// **********************************************************************
//
// Copyright (c) 2003-2011 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.4.2
//
// <auto-generated>
//
// Generated from file `Repositories.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __omero__opt_hudson_workspace_OMERO_5_0_release_src_components_blitz_generated_omero_Repositories_h__
#define __omero__opt_hudson_workspace_OMERO_5_0_release_src_components_blitz_generated_omero_Repositories_h__

#include <Ice/LocalObjectF.h>
#include <Ice/ProxyF.h>
#include <Ice/ObjectF.h>
#include <Ice/Exception.h>
#include <Ice/LocalObject.h>
#include <Ice/Proxy.h>
#include <Ice/Object.h>
#include <Ice/Outgoing.h>
#include <Ice/OutgoingAsync.h>
#include <Ice/Incoming.h>
#include <Ice/IncomingAsync.h>
#include <Ice/Direct.h>
#include <Ice/FactoryTableInit.h>
#include <IceUtil/ScopedArray.h>
#include <Ice/StreamF.h>
#include <omero/ModelF.h>
#include <omero/ServicesF.h>
#include <omero/System.h>
#include <omero/Collections.h>
#include <omero/ServerErrors.h>
#include <omero/cmd/API.h>
#include <Ice/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 304
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 > 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 2
#       error Ice patch level mismatch!
#   endif
#endif

namespace IceProxy
{

namespace omero
{

namespace grid
{

class Repository;

class ImportLocation;

class ImportSettings;

class ImportProcess;

class ImportRequest;

class ImportResponse;

class ManagedRepository;

class RawAccessRequest;

class InternalRepository;

}

}

}

namespace omero
{

namespace grid
{

class Repository;
bool operator==(const Repository&, const Repository&);
bool operator<(const Repository&, const Repository&);

class ImportLocation;
bool operator==(const ImportLocation&, const ImportLocation&);
bool operator<(const ImportLocation&, const ImportLocation&);

class ImportSettings;
bool operator==(const ImportSettings&, const ImportSettings&);
bool operator<(const ImportSettings&, const ImportSettings&);

class ImportProcess;
bool operator==(const ImportProcess&, const ImportProcess&);
bool operator<(const ImportProcess&, const ImportProcess&);

class ImportRequest;
bool operator==(const ImportRequest&, const ImportRequest&);
bool operator<(const ImportRequest&, const ImportRequest&);

class ImportResponse;
bool operator==(const ImportResponse&, const ImportResponse&);
bool operator<(const ImportResponse&, const ImportResponse&);

class ManagedRepository;
bool operator==(const ManagedRepository&, const ManagedRepository&);
bool operator<(const ManagedRepository&, const ManagedRepository&);

class RawAccessRequest;
bool operator==(const RawAccessRequest&, const RawAccessRequest&);
bool operator<(const RawAccessRequest&, const RawAccessRequest&);

class InternalRepository;
bool operator==(const InternalRepository&, const InternalRepository&);
bool operator<(const InternalRepository&, const InternalRepository&);

}

}

namespace IceInternal
{

::Ice::Object* upCast(::omero::grid::Repository*);
::IceProxy::Ice::Object* upCast(::IceProxy::omero::grid::Repository*);

::Ice::Object* upCast(::omero::grid::ImportLocation*);
::IceProxy::Ice::Object* upCast(::IceProxy::omero::grid::ImportLocation*);

::Ice::Object* upCast(::omero::grid::ImportSettings*);
::IceProxy::Ice::Object* upCast(::IceProxy::omero::grid::ImportSettings*);

::Ice::Object* upCast(::omero::grid::ImportProcess*);
::IceProxy::Ice::Object* upCast(::IceProxy::omero::grid::ImportProcess*);

::Ice::Object* upCast(::omero::grid::ImportRequest*);
::IceProxy::Ice::Object* upCast(::IceProxy::omero::grid::ImportRequest*);

::Ice::Object* upCast(::omero::grid::ImportResponse*);
::IceProxy::Ice::Object* upCast(::IceProxy::omero::grid::ImportResponse*);

::Ice::Object* upCast(::omero::grid::ManagedRepository*);
::IceProxy::Ice::Object* upCast(::IceProxy::omero::grid::ManagedRepository*);

::Ice::Object* upCast(::omero::grid::RawAccessRequest*);
::IceProxy::Ice::Object* upCast(::IceProxy::omero::grid::RawAccessRequest*);

::Ice::Object* upCast(::omero::grid::InternalRepository*);
::IceProxy::Ice::Object* upCast(::IceProxy::omero::grid::InternalRepository*);

}

namespace omero
{

namespace grid
{

typedef ::IceInternal::Handle< ::omero::grid::Repository> RepositoryPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::omero::grid::Repository> RepositoryPrx;

void __read(::IceInternal::BasicStream*, RepositoryPrx&);
void __patch__RepositoryPtr(void*, ::Ice::ObjectPtr&);

typedef ::IceInternal::Handle< ::omero::grid::ImportLocation> ImportLocationPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::omero::grid::ImportLocation> ImportLocationPrx;

void __read(::IceInternal::BasicStream*, ImportLocationPrx&);
void __patch__ImportLocationPtr(void*, ::Ice::ObjectPtr&);

typedef ::IceInternal::Handle< ::omero::grid::ImportSettings> ImportSettingsPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::omero::grid::ImportSettings> ImportSettingsPrx;

void __read(::IceInternal::BasicStream*, ImportSettingsPrx&);
void __patch__ImportSettingsPtr(void*, ::Ice::ObjectPtr&);

typedef ::IceInternal::Handle< ::omero::grid::ImportProcess> ImportProcessPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::omero::grid::ImportProcess> ImportProcessPrx;

void __read(::IceInternal::BasicStream*, ImportProcessPrx&);
void __patch__ImportProcessPtr(void*, ::Ice::ObjectPtr&);

typedef ::IceInternal::Handle< ::omero::grid::ImportRequest> ImportRequestPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::omero::grid::ImportRequest> ImportRequestPrx;

void __read(::IceInternal::BasicStream*, ImportRequestPrx&);
void __patch__ImportRequestPtr(void*, ::Ice::ObjectPtr&);

typedef ::IceInternal::Handle< ::omero::grid::ImportResponse> ImportResponsePtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::omero::grid::ImportResponse> ImportResponsePrx;

void __read(::IceInternal::BasicStream*, ImportResponsePrx&);
void __patch__ImportResponsePtr(void*, ::Ice::ObjectPtr&);

typedef ::IceInternal::Handle< ::omero::grid::ManagedRepository> ManagedRepositoryPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::omero::grid::ManagedRepository> ManagedRepositoryPrx;

void __read(::IceInternal::BasicStream*, ManagedRepositoryPrx&);
void __patch__ManagedRepositoryPtr(void*, ::Ice::ObjectPtr&);

typedef ::IceInternal::Handle< ::omero::grid::RawAccessRequest> RawAccessRequestPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::omero::grid::RawAccessRequest> RawAccessRequestPrx;

void __read(::IceInternal::BasicStream*, RawAccessRequestPrx&);
void __patch__RawAccessRequestPtr(void*, ::Ice::ObjectPtr&);

typedef ::IceInternal::Handle< ::omero::grid::InternalRepository> InternalRepositoryPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::omero::grid::InternalRepository> InternalRepositoryPrx;

void __read(::IceInternal::BasicStream*, InternalRepositoryPrx&);
void __patch__InternalRepositoryPtr(void*, ::Ice::ObjectPtr&);

}

}

namespace omero
{

namespace grid
{

class RepositoryException : public ::omero::ServerError
{
public:

    RepositoryException() {}
    RepositoryException(const ::std::string&, const ::std::string&, const ::std::string&);
    virtual ~RepositoryException() throw();

    virtual ::std::string ice_name() const;
    virtual ::Ice::Exception* ice_clone() const;
    virtual void ice_throw() const;

    static const ::IceInternal::UserExceptionFactoryPtr& ice_factory();

    virtual void __write(::IceInternal::BasicStream*) const;
    virtual void __read(::IceInternal::BasicStream*, bool);
// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
    virtual void __write(const ::Ice::OutputStreamPtr&) const;
    virtual void __read(const ::Ice::InputStreamPtr&, bool);
#endif
};

static RepositoryException __RepositoryException_init;

class FileDeleteException : public ::omero::grid::RepositoryException
{
public:

    FileDeleteException() {}
    FileDeleteException(const ::std::string&, const ::std::string&, const ::std::string&);
    virtual ~FileDeleteException() throw();

    virtual ::std::string ice_name() const;
    virtual ::Ice::Exception* ice_clone() const;
    virtual void ice_throw() const;

    static const ::IceInternal::UserExceptionFactoryPtr& ice_factory();

    virtual void __write(::IceInternal::BasicStream*) const;
    virtual void __read(::IceInternal::BasicStream*, bool);
// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
    virtual void __write(const ::Ice::OutputStreamPtr&) const;
    virtual void __read(const ::Ice::InputStreamPtr&, bool);
#endif
};

class UnregisteredFileException : public ::omero::grid::RepositoryException
{
public:

    UnregisteredFileException() {}
    UnregisteredFileException(const ::std::string&, const ::std::string&, const ::std::string&, const ::omero::model::OriginalFilePtr&);
    virtual ~UnregisteredFileException() throw();

    virtual ::std::string ice_name() const;
    virtual ::Ice::Exception* ice_clone() const;
    virtual void ice_throw() const;

    static const ::IceInternal::UserExceptionFactoryPtr& ice_factory();

    ::omero::model::OriginalFilePtr file;

    virtual void __write(::IceInternal::BasicStream*) const;
    virtual void __read(::IceInternal::BasicStream*, bool);
// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
    virtual void __write(const ::Ice::OutputStreamPtr&) const;
    virtual void __read(const ::Ice::InputStreamPtr&, bool);
#endif
    virtual bool __usesClasses() const;
};

typedef ::std::vector< ::omero::grid::ImportProcessPrx> ImportProcessList;
void __writeImportProcessList(::IceInternal::BasicStream*, const ::omero::grid::ImportProcessPrx*, const ::omero::grid::ImportProcessPrx*);
void __readImportProcessList(::IceInternal::BasicStream*, ImportProcessList&);

typedef ::std::vector< ::omero::grid::RepositoryPrx> RepositoryProxyList;
void __writeRepositoryProxyList(::IceInternal::BasicStream*, const ::omero::grid::RepositoryPrx*, const ::omero::grid::RepositoryPrx*);
void __readRepositoryProxyList(::IceInternal::BasicStream*, RepositoryProxyList&);

struct RepositoryMap
{
    ::omero::api::OriginalFileList descriptions;
    ::omero::grid::RepositoryProxyList proxies;

    bool operator==(const RepositoryMap& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(descriptions != __rhs.descriptions)
        {
            return false;
        }
        if(proxies != __rhs.proxies)
        {
            return false;
        }
        return true;
    }

    bool operator<(const RepositoryMap& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(descriptions < __rhs.descriptions)
        {
            return true;
        }
        else if(__rhs.descriptions < descriptions)
        {
            return false;
        }
        if(proxies < __rhs.proxies)
        {
            return true;
        }
        else if(__rhs.proxies < proxies)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const RepositoryMap& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const RepositoryMap& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const RepositoryMap& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const RepositoryMap& __rhs) const
    {
        return !operator<(__rhs);
    }

    void __write(::IceInternal::BasicStream*) const;
    void __read(::IceInternal::BasicStream*);
};

}

}

namespace omero
{

namespace grid
{

class AMI_Repository_root : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::omero::model::OriginalFilePtr&) = 0;

    void __response(const ::omero::model::OriginalFilePtr& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        AMICallbackBase::__sent(sentSynchronously);
#else
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
#endif
    }
};

typedef ::IceUtil::Handle< ::omero::grid::AMI_Repository_root> AMI_Repository_rootPtr;

class AMI_Repository_mimetype : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::std::string&) = 0;

    void __response(const ::std::string& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        AMICallbackBase::__sent(sentSynchronously);
#else
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
#endif
    }
};

typedef ::IceUtil::Handle< ::omero::grid::AMI_Repository_mimetype> AMI_Repository_mimetypePtr;

class AMI_Repository_list : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::omero::api::StringSet&) = 0;

    void __response(const ::omero::api::StringSet& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        AMICallbackBase::__sent(sentSynchronously);
#else
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
#endif
    }
};

typedef ::IceUtil::Handle< ::omero::grid::AMI_Repository_list> AMI_Repository_listPtr;

class AMI_Repository_listFiles : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::omero::api::OriginalFileList&) = 0;

    void __response(const ::omero::api::OriginalFileList& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        AMICallbackBase::__sent(sentSynchronously);
#else
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
#endif
    }
};

typedef ::IceUtil::Handle< ::omero::grid::AMI_Repository_listFiles> AMI_Repository_listFilesPtr;

class AMI_Repository_register : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::omero::model::OriginalFilePtr&) = 0;

    void __response(const ::omero::model::OriginalFilePtr& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        AMICallbackBase::__sent(sentSynchronously);
#else
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
#endif
    }
};

typedef ::IceUtil::Handle< ::omero::grid::AMI_Repository_register> AMI_Repository_registerPtr;

class AMI_Repository_file : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::omero::api::RawFileStorePrx&) = 0;

    void __response(const ::omero::api::RawFileStorePrx& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        AMICallbackBase::__sent(sentSynchronously);
#else
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
#endif
    }
};

typedef ::IceUtil::Handle< ::omero::grid::AMI_Repository_file> AMI_Repository_filePtr;

class AMI_Repository_pixels : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::omero::api::RawPixelsStorePrx&) = 0;

    void __response(const ::omero::api::RawPixelsStorePrx& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        AMICallbackBase::__sent(sentSynchronously);
#else
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
#endif
    }
};

typedef ::IceUtil::Handle< ::omero::grid::AMI_Repository_pixels> AMI_Repository_pixelsPtr;

class AMI_Repository_fileById : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::omero::api::RawFileStorePrx&) = 0;

    void __response(const ::omero::api::RawFileStorePrx& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        AMICallbackBase::__sent(sentSynchronously);
#else
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
#endif
    }
};

typedef ::IceUtil::Handle< ::omero::grid::AMI_Repository_fileById> AMI_Repository_fileByIdPtr;

class AMI_Repository_fileExists : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(bool) = 0;

    void __response(bool __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        AMICallbackBase::__sent(sentSynchronously);
#else
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
#endif
    }
};

typedef ::IceUtil::Handle< ::omero::grid::AMI_Repository_fileExists> AMI_Repository_fileExistsPtr;

class AMI_Repository_makeDir : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response() = 0;

    void __response()
    {
        ice_response();
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        AMICallbackBase::__sent(sentSynchronously);
#else
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
#endif
    }
};

typedef ::IceUtil::Handle< ::omero::grid::AMI_Repository_makeDir> AMI_Repository_makeDirPtr;

class AMI_Repository_treeList : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::omero::RMapPtr&) = 0;

    void __response(const ::omero::RMapPtr& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        AMICallbackBase::__sent(sentSynchronously);
#else
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
#endif
    }
};

typedef ::IceUtil::Handle< ::omero::grid::AMI_Repository_treeList> AMI_Repository_treeListPtr;

class AMI_Repository_deletePaths : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::omero::cmd::HandlePrx&) = 0;

    void __response(const ::omero::cmd::HandlePrx& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        AMICallbackBase::__sent(sentSynchronously);
#else
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
#endif
    }
};

typedef ::IceUtil::Handle< ::omero::grid::AMI_Repository_deletePaths> AMI_Repository_deletePathsPtr;

class AMI_ManagedRepository_importFileset : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::omero::grid::ImportProcessPrx&) = 0;

    void __response(const ::omero::grid::ImportProcessPrx& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        AMICallbackBase::__sent(sentSynchronously);
#else
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
#endif
    }
};

typedef ::IceUtil::Handle< ::omero::grid::AMI_ManagedRepository_importFileset> AMI_ManagedRepository_importFilesetPtr;

class AMI_ManagedRepository_importPaths : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::omero::grid::ImportProcessPrx&) = 0;

    void __response(const ::omero::grid::ImportProcessPrx& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        AMICallbackBase::__sent(sentSynchronously);
#else
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
#endif
    }
};

typedef ::IceUtil::Handle< ::omero::grid::AMI_ManagedRepository_importPaths> AMI_ManagedRepository_importPathsPtr;

class AMI_ManagedRepository_listImports : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::omero::grid::ImportProcessList&) = 0;

    void __response(const ::omero::grid::ImportProcessList& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        AMICallbackBase::__sent(sentSynchronously);
#else
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
#endif
    }
};

typedef ::IceUtil::Handle< ::omero::grid::AMI_ManagedRepository_listImports> AMI_ManagedRepository_listImportsPtr;

class AMI_ManagedRepository_listChecksumAlgorithms : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::omero::api::ChecksumAlgorithmList&) = 0;

    void __response(const ::omero::api::ChecksumAlgorithmList& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        AMICallbackBase::__sent(sentSynchronously);
#else
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
#endif
    }
};

typedef ::IceUtil::Handle< ::omero::grid::AMI_ManagedRepository_listChecksumAlgorithms> AMI_ManagedRepository_listChecksumAlgorithmsPtr;

class AMI_ManagedRepository_suggestChecksumAlgorithm : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::omero::model::ChecksumAlgorithmPtr&) = 0;

    void __response(const ::omero::model::ChecksumAlgorithmPtr& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        AMICallbackBase::__sent(sentSynchronously);
#else
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
#endif
    }
};

typedef ::IceUtil::Handle< ::omero::grid::AMI_ManagedRepository_suggestChecksumAlgorithm> AMI_ManagedRepository_suggestChecksumAlgorithmPtr;

class AMI_InternalRepository_createRawFileStore : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::omero::api::RawFileStorePrx&) = 0;

    void __response(const ::omero::api::RawFileStorePrx& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        AMICallbackBase::__sent(sentSynchronously);
#else
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
#endif
    }
};

typedef ::IceUtil::Handle< ::omero::grid::AMI_InternalRepository_createRawFileStore> AMI_InternalRepository_createRawFileStorePtr;

class AMI_InternalRepository_createRawPixelsStore : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::omero::api::RawPixelsStorePrx&) = 0;

    void __response(const ::omero::api::RawPixelsStorePrx& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        AMICallbackBase::__sent(sentSynchronously);
#else
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
#endif
    }
};

typedef ::IceUtil::Handle< ::omero::grid::AMI_InternalRepository_createRawPixelsStore> AMI_InternalRepository_createRawPixelsStorePtr;

class AMI_InternalRepository_createRenderingEngine : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::omero::api::RenderingEnginePrx&) = 0;

    void __response(const ::omero::api::RenderingEnginePrx& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        AMICallbackBase::__sent(sentSynchronously);
#else
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
#endif
    }
};

typedef ::IceUtil::Handle< ::omero::grid::AMI_InternalRepository_createRenderingEngine> AMI_InternalRepository_createRenderingEnginePtr;

class AMI_InternalRepository_createThumbnailStore : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::omero::api::ThumbnailStorePrx&) = 0;

    void __response(const ::omero::api::ThumbnailStorePrx& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        AMICallbackBase::__sent(sentSynchronously);
#else
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
#endif
    }
};

typedef ::IceUtil::Handle< ::omero::grid::AMI_InternalRepository_createThumbnailStore> AMI_InternalRepository_createThumbnailStorePtr;

class AMI_InternalRepository_getDescription : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::omero::model::OriginalFilePtr&) = 0;

    void __response(const ::omero::model::OriginalFilePtr& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        AMICallbackBase::__sent(sentSynchronously);
#else
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
#endif
    }
};

typedef ::IceUtil::Handle< ::omero::grid::AMI_InternalRepository_getDescription> AMI_InternalRepository_getDescriptionPtr;

class AMI_InternalRepository_getProxy : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::omero::grid::RepositoryPrx&) = 0;

    void __response(const ::omero::grid::RepositoryPrx& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        AMICallbackBase::__sent(sentSynchronously);
#else
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
#endif
    }
};

typedef ::IceUtil::Handle< ::omero::grid::AMI_InternalRepository_getProxy> AMI_InternalRepository_getProxyPtr;

class AMI_InternalRepository_rawAccess : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::omero::cmd::ResponsePtr&) = 0;

    void __response(const ::omero::cmd::ResponsePtr& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        AMICallbackBase::__sent(sentSynchronously);
#else
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
#endif
    }
};

typedef ::IceUtil::Handle< ::omero::grid::AMI_InternalRepository_rawAccess> AMI_InternalRepository_rawAccessPtr;

class AMI_InternalRepository_getFilePath : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::std::string&) = 0;

    void __response(const ::std::string& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        AMICallbackBase::__sent(sentSynchronously);
#else
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
#endif
    }
};

typedef ::IceUtil::Handle< ::omero::grid::AMI_InternalRepository_getFilePath> AMI_InternalRepository_getFilePathPtr;

}

}

namespace IceAsync
{

}

namespace omero
{

namespace grid
{

class Callback_Repository_root_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Repository_root_Base> Callback_Repository_rootPtr;

class Callback_Repository_mimetype_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Repository_mimetype_Base> Callback_Repository_mimetypePtr;

class Callback_Repository_list_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Repository_list_Base> Callback_Repository_listPtr;

class Callback_Repository_listFiles_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Repository_listFiles_Base> Callback_Repository_listFilesPtr;

class Callback_Repository_register_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Repository_register_Base> Callback_Repository_registerPtr;

class Callback_Repository_file_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Repository_file_Base> Callback_Repository_filePtr;

class Callback_Repository_pixels_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Repository_pixels_Base> Callback_Repository_pixelsPtr;

class Callback_Repository_fileById_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Repository_fileById_Base> Callback_Repository_fileByIdPtr;

class Callback_Repository_fileExists_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Repository_fileExists_Base> Callback_Repository_fileExistsPtr;

class Callback_Repository_makeDir_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Repository_makeDir_Base> Callback_Repository_makeDirPtr;

class Callback_Repository_treeList_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Repository_treeList_Base> Callback_Repository_treeListPtr;

class Callback_Repository_deletePaths_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Repository_deletePaths_Base> Callback_Repository_deletePathsPtr;

class Callback_ImportProcess_getUploader_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ImportProcess_getUploader_Base> Callback_ImportProcess_getUploaderPtr;

class Callback_ImportProcess_verifyUpload_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ImportProcess_verifyUpload_Base> Callback_ImportProcess_verifyUploadPtr;

class Callback_ImportProcess_getUploadOffset_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ImportProcess_getUploadOffset_Base> Callback_ImportProcess_getUploadOffsetPtr;

class Callback_ImportProcess_getHandle_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ImportProcess_getHandle_Base> Callback_ImportProcess_getHandlePtr;

class Callback_ImportProcess_getImportSettings_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ImportProcess_getImportSettings_Base> Callback_ImportProcess_getImportSettingsPtr;

class Callback_ManagedRepository_importFileset_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ManagedRepository_importFileset_Base> Callback_ManagedRepository_importFilesetPtr;

class Callback_ManagedRepository_importPaths_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ManagedRepository_importPaths_Base> Callback_ManagedRepository_importPathsPtr;

class Callback_ManagedRepository_listImports_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ManagedRepository_listImports_Base> Callback_ManagedRepository_listImportsPtr;

class Callback_ManagedRepository_listChecksumAlgorithms_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ManagedRepository_listChecksumAlgorithms_Base> Callback_ManagedRepository_listChecksumAlgorithmsPtr;

class Callback_ManagedRepository_suggestChecksumAlgorithm_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ManagedRepository_suggestChecksumAlgorithm_Base> Callback_ManagedRepository_suggestChecksumAlgorithmPtr;

class Callback_InternalRepository_createRawFileStore_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_InternalRepository_createRawFileStore_Base> Callback_InternalRepository_createRawFileStorePtr;

class Callback_InternalRepository_createRawPixelsStore_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_InternalRepository_createRawPixelsStore_Base> Callback_InternalRepository_createRawPixelsStorePtr;

class Callback_InternalRepository_createRenderingEngine_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_InternalRepository_createRenderingEngine_Base> Callback_InternalRepository_createRenderingEnginePtr;

class Callback_InternalRepository_createThumbnailStore_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_InternalRepository_createThumbnailStore_Base> Callback_InternalRepository_createThumbnailStorePtr;

class Callback_InternalRepository_getDescription_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_InternalRepository_getDescription_Base> Callback_InternalRepository_getDescriptionPtr;

class Callback_InternalRepository_getProxy_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_InternalRepository_getProxy_Base> Callback_InternalRepository_getProxyPtr;

class Callback_InternalRepository_rawAccess_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_InternalRepository_rawAccess_Base> Callback_InternalRepository_rawAccessPtr;

class Callback_InternalRepository_getFilePath_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_InternalRepository_getFilePath_Base> Callback_InternalRepository_getFilePathPtr;

}

}

namespace IceProxy
{

namespace omero
{

namespace grid
{

class Repository : virtual public ::IceProxy::Ice::Object
{
public:

    ::omero::model::OriginalFilePtr root()
    {
        return root(0);
    }
    ::omero::model::OriginalFilePtr root(const ::Ice::Context& __ctx)
    {
        return root(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_root()
    {
        return begin_root(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_root(const ::Ice::Context& __ctx)
    {
        return begin_root(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_root(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_root(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_root(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_root(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_root(const ::omero::grid::Callback_Repository_rootPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_root(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_root(const ::Ice::Context& __ctx, const ::omero::grid::Callback_Repository_rootPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_root(&__ctx, __del, __cookie);
    }

    ::omero::model::OriginalFilePtr end_root(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::model::OriginalFilePtr root(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_root(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool root_async(const ::omero::grid::AMI_Repository_rootPtr&);
    bool root_async(const ::omero::grid::AMI_Repository_rootPtr&, const ::Ice::Context&);

    ::std::string mimetype(const ::std::string& path)
    {
        return mimetype(path, 0);
    }
    ::std::string mimetype(const ::std::string& path, const ::Ice::Context& __ctx)
    {
        return mimetype(path, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_mimetype(const ::std::string& path)
    {
        return begin_mimetype(path, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_mimetype(const ::std::string& path, const ::Ice::Context& __ctx)
    {
        return begin_mimetype(path, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_mimetype(const ::std::string& path, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_mimetype(path, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_mimetype(const ::std::string& path, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_mimetype(path, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_mimetype(const ::std::string& path, const ::omero::grid::Callback_Repository_mimetypePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_mimetype(path, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_mimetype(const ::std::string& path, const ::Ice::Context& __ctx, const ::omero::grid::Callback_Repository_mimetypePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_mimetype(path, &__ctx, __del, __cookie);
    }

    ::std::string end_mimetype(const ::Ice::AsyncResultPtr&);
    
private:

    ::std::string mimetype(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_mimetype(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool mimetype_async(const ::omero::grid::AMI_Repository_mimetypePtr&, const ::std::string&);
    bool mimetype_async(const ::omero::grid::AMI_Repository_mimetypePtr&, const ::std::string&, const ::Ice::Context&);

    ::omero::api::StringSet list(const ::std::string& path)
    {
        return list(path, 0);
    }
    ::omero::api::StringSet list(const ::std::string& path, const ::Ice::Context& __ctx)
    {
        return list(path, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_list(const ::std::string& path)
    {
        return begin_list(path, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_list(const ::std::string& path, const ::Ice::Context& __ctx)
    {
        return begin_list(path, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_list(const ::std::string& path, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_list(path, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_list(const ::std::string& path, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_list(path, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_list(const ::std::string& path, const ::omero::grid::Callback_Repository_listPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_list(path, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_list(const ::std::string& path, const ::Ice::Context& __ctx, const ::omero::grid::Callback_Repository_listPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_list(path, &__ctx, __del, __cookie);
    }

    ::omero::api::StringSet end_list(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::api::StringSet list(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_list(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool list_async(const ::omero::grid::AMI_Repository_listPtr&, const ::std::string&);
    bool list_async(const ::omero::grid::AMI_Repository_listPtr&, const ::std::string&, const ::Ice::Context&);

    ::omero::api::OriginalFileList listFiles(const ::std::string& path)
    {
        return listFiles(path, 0);
    }
    ::omero::api::OriginalFileList listFiles(const ::std::string& path, const ::Ice::Context& __ctx)
    {
        return listFiles(path, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_listFiles(const ::std::string& path)
    {
        return begin_listFiles(path, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_listFiles(const ::std::string& path, const ::Ice::Context& __ctx)
    {
        return begin_listFiles(path, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_listFiles(const ::std::string& path, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_listFiles(path, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_listFiles(const ::std::string& path, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_listFiles(path, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_listFiles(const ::std::string& path, const ::omero::grid::Callback_Repository_listFilesPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_listFiles(path, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_listFiles(const ::std::string& path, const ::Ice::Context& __ctx, const ::omero::grid::Callback_Repository_listFilesPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_listFiles(path, &__ctx, __del, __cookie);
    }

    ::omero::api::OriginalFileList end_listFiles(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::api::OriginalFileList listFiles(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_listFiles(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool listFiles_async(const ::omero::grid::AMI_Repository_listFilesPtr&, const ::std::string&);
    bool listFiles_async(const ::omero::grid::AMI_Repository_listFilesPtr&, const ::std::string&, const ::Ice::Context&);

    ::omero::model::OriginalFilePtr _cpp_register(const ::std::string& path, const ::omero::RStringPtr& mimetype)
    {
        return _cpp_register(path, mimetype, 0);
    }
    ::omero::model::OriginalFilePtr _cpp_register(const ::std::string& path, const ::omero::RStringPtr& mimetype, const ::Ice::Context& __ctx)
    {
        return _cpp_register(path, mimetype, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_register(const ::std::string& path, const ::omero::RStringPtr& mimetype)
    {
        return begin_register(path, mimetype, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_register(const ::std::string& path, const ::omero::RStringPtr& mimetype, const ::Ice::Context& __ctx)
    {
        return begin_register(path, mimetype, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_register(const ::std::string& path, const ::omero::RStringPtr& mimetype, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_register(path, mimetype, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_register(const ::std::string& path, const ::omero::RStringPtr& mimetype, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_register(path, mimetype, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_register(const ::std::string& path, const ::omero::RStringPtr& mimetype, const ::omero::grid::Callback_Repository_registerPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_register(path, mimetype, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_register(const ::std::string& path, const ::omero::RStringPtr& mimetype, const ::Ice::Context& __ctx, const ::omero::grid::Callback_Repository_registerPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_register(path, mimetype, &__ctx, __del, __cookie);
    }

    ::omero::model::OriginalFilePtr end_register(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::model::OriginalFilePtr _cpp_register(const ::std::string&, const ::omero::RStringPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_register(const ::std::string&, const ::omero::RStringPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool register_async(const ::omero::grid::AMI_Repository_registerPtr&, const ::std::string&, const ::omero::RStringPtr&);
    bool register_async(const ::omero::grid::AMI_Repository_registerPtr&, const ::std::string&, const ::omero::RStringPtr&, const ::Ice::Context&);

    ::omero::api::RawFileStorePrx file(const ::std::string& path, const ::std::string& mode)
    {
        return file(path, mode, 0);
    }
    ::omero::api::RawFileStorePrx file(const ::std::string& path, const ::std::string& mode, const ::Ice::Context& __ctx)
    {
        return file(path, mode, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_file(const ::std::string& path, const ::std::string& mode)
    {
        return begin_file(path, mode, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_file(const ::std::string& path, const ::std::string& mode, const ::Ice::Context& __ctx)
    {
        return begin_file(path, mode, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_file(const ::std::string& path, const ::std::string& mode, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_file(path, mode, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_file(const ::std::string& path, const ::std::string& mode, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_file(path, mode, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_file(const ::std::string& path, const ::std::string& mode, const ::omero::grid::Callback_Repository_filePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_file(path, mode, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_file(const ::std::string& path, const ::std::string& mode, const ::Ice::Context& __ctx, const ::omero::grid::Callback_Repository_filePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_file(path, mode, &__ctx, __del, __cookie);
    }

    ::omero::api::RawFileStorePrx end_file(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::api::RawFileStorePrx file(const ::std::string&, const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_file(const ::std::string&, const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool file_async(const ::omero::grid::AMI_Repository_filePtr&, const ::std::string&, const ::std::string&);
    bool file_async(const ::omero::grid::AMI_Repository_filePtr&, const ::std::string&, const ::std::string&, const ::Ice::Context&);

    ::omero::api::RawPixelsStorePrx pixels(const ::std::string& path)
    {
        return pixels(path, 0);
    }
    ::omero::api::RawPixelsStorePrx pixels(const ::std::string& path, const ::Ice::Context& __ctx)
    {
        return pixels(path, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_pixels(const ::std::string& path)
    {
        return begin_pixels(path, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_pixels(const ::std::string& path, const ::Ice::Context& __ctx)
    {
        return begin_pixels(path, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_pixels(const ::std::string& path, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_pixels(path, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_pixels(const ::std::string& path, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_pixels(path, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_pixels(const ::std::string& path, const ::omero::grid::Callback_Repository_pixelsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_pixels(path, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_pixels(const ::std::string& path, const ::Ice::Context& __ctx, const ::omero::grid::Callback_Repository_pixelsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_pixels(path, &__ctx, __del, __cookie);
    }

    ::omero::api::RawPixelsStorePrx end_pixels(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::api::RawPixelsStorePrx pixels(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_pixels(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool pixels_async(const ::omero::grid::AMI_Repository_pixelsPtr&, const ::std::string&);
    bool pixels_async(const ::omero::grid::AMI_Repository_pixelsPtr&, const ::std::string&, const ::Ice::Context&);

    ::omero::api::RawFileStorePrx fileById(::Ice::Long id)
    {
        return fileById(id, 0);
    }
    ::omero::api::RawFileStorePrx fileById(::Ice::Long id, const ::Ice::Context& __ctx)
    {
        return fileById(id, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_fileById(::Ice::Long id)
    {
        return begin_fileById(id, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_fileById(::Ice::Long id, const ::Ice::Context& __ctx)
    {
        return begin_fileById(id, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_fileById(::Ice::Long id, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_fileById(id, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_fileById(::Ice::Long id, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_fileById(id, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_fileById(::Ice::Long id, const ::omero::grid::Callback_Repository_fileByIdPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_fileById(id, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_fileById(::Ice::Long id, const ::Ice::Context& __ctx, const ::omero::grid::Callback_Repository_fileByIdPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_fileById(id, &__ctx, __del, __cookie);
    }

    ::omero::api::RawFileStorePrx end_fileById(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::api::RawFileStorePrx fileById(::Ice::Long, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_fileById(::Ice::Long, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool fileById_async(const ::omero::grid::AMI_Repository_fileByIdPtr&, ::Ice::Long);
    bool fileById_async(const ::omero::grid::AMI_Repository_fileByIdPtr&, ::Ice::Long, const ::Ice::Context&);

    bool fileExists(const ::std::string& path)
    {
        return fileExists(path, 0);
    }
    bool fileExists(const ::std::string& path, const ::Ice::Context& __ctx)
    {
        return fileExists(path, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_fileExists(const ::std::string& path)
    {
        return begin_fileExists(path, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_fileExists(const ::std::string& path, const ::Ice::Context& __ctx)
    {
        return begin_fileExists(path, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_fileExists(const ::std::string& path, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_fileExists(path, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_fileExists(const ::std::string& path, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_fileExists(path, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_fileExists(const ::std::string& path, const ::omero::grid::Callback_Repository_fileExistsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_fileExists(path, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_fileExists(const ::std::string& path, const ::Ice::Context& __ctx, const ::omero::grid::Callback_Repository_fileExistsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_fileExists(path, &__ctx, __del, __cookie);
    }

    bool end_fileExists(const ::Ice::AsyncResultPtr&);
    
private:

    bool fileExists(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_fileExists(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool fileExists_async(const ::omero::grid::AMI_Repository_fileExistsPtr&, const ::std::string&);
    bool fileExists_async(const ::omero::grid::AMI_Repository_fileExistsPtr&, const ::std::string&, const ::Ice::Context&);

    void makeDir(const ::std::string& path, bool parents)
    {
        makeDir(path, parents, 0);
    }
    void makeDir(const ::std::string& path, bool parents, const ::Ice::Context& __ctx)
    {
        makeDir(path, parents, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_makeDir(const ::std::string& path, bool parents)
    {
        return begin_makeDir(path, parents, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_makeDir(const ::std::string& path, bool parents, const ::Ice::Context& __ctx)
    {
        return begin_makeDir(path, parents, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_makeDir(const ::std::string& path, bool parents, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_makeDir(path, parents, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_makeDir(const ::std::string& path, bool parents, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_makeDir(path, parents, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_makeDir(const ::std::string& path, bool parents, const ::omero::grid::Callback_Repository_makeDirPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_makeDir(path, parents, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_makeDir(const ::std::string& path, bool parents, const ::Ice::Context& __ctx, const ::omero::grid::Callback_Repository_makeDirPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_makeDir(path, parents, &__ctx, __del, __cookie);
    }

    void end_makeDir(const ::Ice::AsyncResultPtr&);
    
private:

    void makeDir(const ::std::string&, bool, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_makeDir(const ::std::string&, bool, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool makeDir_async(const ::omero::grid::AMI_Repository_makeDirPtr&, const ::std::string&, bool);
    bool makeDir_async(const ::omero::grid::AMI_Repository_makeDirPtr&, const ::std::string&, bool, const ::Ice::Context&);

    ::omero::RMapPtr treeList(const ::std::string& path)
    {
        return treeList(path, 0);
    }
    ::omero::RMapPtr treeList(const ::std::string& path, const ::Ice::Context& __ctx)
    {
        return treeList(path, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_treeList(const ::std::string& path)
    {
        return begin_treeList(path, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_treeList(const ::std::string& path, const ::Ice::Context& __ctx)
    {
        return begin_treeList(path, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_treeList(const ::std::string& path, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_treeList(path, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_treeList(const ::std::string& path, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_treeList(path, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_treeList(const ::std::string& path, const ::omero::grid::Callback_Repository_treeListPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_treeList(path, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_treeList(const ::std::string& path, const ::Ice::Context& __ctx, const ::omero::grid::Callback_Repository_treeListPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_treeList(path, &__ctx, __del, __cookie);
    }

    ::omero::RMapPtr end_treeList(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::RMapPtr treeList(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_treeList(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool treeList_async(const ::omero::grid::AMI_Repository_treeListPtr&, const ::std::string&);
    bool treeList_async(const ::omero::grid::AMI_Repository_treeListPtr&, const ::std::string&, const ::Ice::Context&);

    ::omero::cmd::HandlePrx deletePaths(const ::omero::api::StringArray& paths, bool recursively, bool force)
    {
        return deletePaths(paths, recursively, force, 0);
    }
    ::omero::cmd::HandlePrx deletePaths(const ::omero::api::StringArray& paths, bool recursively, bool force, const ::Ice::Context& __ctx)
    {
        return deletePaths(paths, recursively, force, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_deletePaths(const ::omero::api::StringArray& paths, bool recursively, bool force)
    {
        return begin_deletePaths(paths, recursively, force, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_deletePaths(const ::omero::api::StringArray& paths, bool recursively, bool force, const ::Ice::Context& __ctx)
    {
        return begin_deletePaths(paths, recursively, force, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_deletePaths(const ::omero::api::StringArray& paths, bool recursively, bool force, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_deletePaths(paths, recursively, force, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_deletePaths(const ::omero::api::StringArray& paths, bool recursively, bool force, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_deletePaths(paths, recursively, force, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_deletePaths(const ::omero::api::StringArray& paths, bool recursively, bool force, const ::omero::grid::Callback_Repository_deletePathsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_deletePaths(paths, recursively, force, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_deletePaths(const ::omero::api::StringArray& paths, bool recursively, bool force, const ::Ice::Context& __ctx, const ::omero::grid::Callback_Repository_deletePathsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_deletePaths(paths, recursively, force, &__ctx, __del, __cookie);
    }

    ::omero::cmd::HandlePrx end_deletePaths(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::cmd::HandlePrx deletePaths(const ::omero::api::StringArray&, bool, bool, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_deletePaths(const ::omero::api::StringArray&, bool, bool, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool deletePaths_async(const ::omero::grid::AMI_Repository_deletePathsPtr&, const ::omero::api::StringArray&, bool, bool);
    bool deletePaths_async(const ::omero::grid::AMI_Repository_deletePathsPtr&, const ::omero::api::StringArray&, bool, bool, const ::Ice::Context&);
    
    ::IceInternal::ProxyHandle<Repository> ice_context(const ::Ice::Context& __context) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Repository*>(_Base::ice_context(__context).get());
    #else
        return dynamic_cast<Repository*>(::IceProxy::Ice::Object::ice_context(__context).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Repository> ice_adapterId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Repository*>(_Base::ice_adapterId(__id).get());
    #else
        return dynamic_cast<Repository*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Repository> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Repository*>(_Base::ice_endpoints(__endpoints).get());
    #else
        return dynamic_cast<Repository*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Repository> ice_locatorCacheTimeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Repository*>(_Base::ice_locatorCacheTimeout(__timeout).get());
    #else
        return dynamic_cast<Repository*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Repository> ice_connectionCached(bool __cached) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Repository*>(_Base::ice_connectionCached(__cached).get());
    #else
        return dynamic_cast<Repository*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Repository> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Repository*>(_Base::ice_endpointSelection(__est).get());
    #else
        return dynamic_cast<Repository*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Repository> ice_secure(bool __secure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Repository*>(_Base::ice_secure(__secure).get());
    #else
        return dynamic_cast<Repository*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Repository> ice_preferSecure(bool __preferSecure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Repository*>(_Base::ice_preferSecure(__preferSecure).get());
    #else
        return dynamic_cast<Repository*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Repository> ice_router(const ::Ice::RouterPrx& __router) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Repository*>(_Base::ice_router(__router).get());
    #else
        return dynamic_cast<Repository*>(::IceProxy::Ice::Object::ice_router(__router).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Repository> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Repository*>(_Base::ice_locator(__locator).get());
    #else
        return dynamic_cast<Repository*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Repository> ice_collocationOptimized(bool __co) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Repository*>(_Base::ice_collocationOptimized(__co).get());
    #else
        return dynamic_cast<Repository*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Repository> ice_twoway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Repository*>(_Base::ice_twoway().get());
    #else
        return dynamic_cast<Repository*>(::IceProxy::Ice::Object::ice_twoway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Repository> ice_oneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Repository*>(_Base::ice_oneway().get());
    #else
        return dynamic_cast<Repository*>(::IceProxy::Ice::Object::ice_oneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Repository> ice_batchOneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Repository*>(_Base::ice_batchOneway().get());
    #else
        return dynamic_cast<Repository*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Repository> ice_datagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Repository*>(_Base::ice_datagram().get());
    #else
        return dynamic_cast<Repository*>(::IceProxy::Ice::Object::ice_datagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Repository> ice_batchDatagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Repository*>(_Base::ice_batchDatagram().get());
    #else
        return dynamic_cast<Repository*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Repository> ice_compress(bool __compress) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Repository*>(_Base::ice_compress(__compress).get());
    #else
        return dynamic_cast<Repository*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Repository> ice_timeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Repository*>(_Base::ice_timeout(__timeout).get());
    #else
        return dynamic_cast<Repository*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Repository> ice_connectionId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Repository*>(_Base::ice_connectionId(__id).get());
    #else
        return dynamic_cast<Repository*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    #endif
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class ImportLocation : virtual public ::IceProxy::Ice::Object
{
public:
    
    ::IceInternal::ProxyHandle<ImportLocation> ice_context(const ::Ice::Context& __context) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ImportLocation*>(_Base::ice_context(__context).get());
    #else
        return dynamic_cast<ImportLocation*>(::IceProxy::Ice::Object::ice_context(__context).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ImportLocation> ice_adapterId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ImportLocation*>(_Base::ice_adapterId(__id).get());
    #else
        return dynamic_cast<ImportLocation*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ImportLocation> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ImportLocation*>(_Base::ice_endpoints(__endpoints).get());
    #else
        return dynamic_cast<ImportLocation*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ImportLocation> ice_locatorCacheTimeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ImportLocation*>(_Base::ice_locatorCacheTimeout(__timeout).get());
    #else
        return dynamic_cast<ImportLocation*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ImportLocation> ice_connectionCached(bool __cached) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ImportLocation*>(_Base::ice_connectionCached(__cached).get());
    #else
        return dynamic_cast<ImportLocation*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ImportLocation> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ImportLocation*>(_Base::ice_endpointSelection(__est).get());
    #else
        return dynamic_cast<ImportLocation*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ImportLocation> ice_secure(bool __secure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ImportLocation*>(_Base::ice_secure(__secure).get());
    #else
        return dynamic_cast<ImportLocation*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ImportLocation> ice_preferSecure(bool __preferSecure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ImportLocation*>(_Base::ice_preferSecure(__preferSecure).get());
    #else
        return dynamic_cast<ImportLocation*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ImportLocation> ice_router(const ::Ice::RouterPrx& __router) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ImportLocation*>(_Base::ice_router(__router).get());
    #else
        return dynamic_cast<ImportLocation*>(::IceProxy::Ice::Object::ice_router(__router).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ImportLocation> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ImportLocation*>(_Base::ice_locator(__locator).get());
    #else
        return dynamic_cast<ImportLocation*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ImportLocation> ice_collocationOptimized(bool __co) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ImportLocation*>(_Base::ice_collocationOptimized(__co).get());
    #else
        return dynamic_cast<ImportLocation*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ImportLocation> ice_twoway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ImportLocation*>(_Base::ice_twoway().get());
    #else
        return dynamic_cast<ImportLocation*>(::IceProxy::Ice::Object::ice_twoway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ImportLocation> ice_oneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ImportLocation*>(_Base::ice_oneway().get());
    #else
        return dynamic_cast<ImportLocation*>(::IceProxy::Ice::Object::ice_oneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ImportLocation> ice_batchOneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ImportLocation*>(_Base::ice_batchOneway().get());
    #else
        return dynamic_cast<ImportLocation*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ImportLocation> ice_datagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ImportLocation*>(_Base::ice_datagram().get());
    #else
        return dynamic_cast<ImportLocation*>(::IceProxy::Ice::Object::ice_datagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ImportLocation> ice_batchDatagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ImportLocation*>(_Base::ice_batchDatagram().get());
    #else
        return dynamic_cast<ImportLocation*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ImportLocation> ice_compress(bool __compress) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ImportLocation*>(_Base::ice_compress(__compress).get());
    #else
        return dynamic_cast<ImportLocation*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ImportLocation> ice_timeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ImportLocation*>(_Base::ice_timeout(__timeout).get());
    #else
        return dynamic_cast<ImportLocation*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ImportLocation> ice_connectionId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ImportLocation*>(_Base::ice_connectionId(__id).get());
    #else
        return dynamic_cast<ImportLocation*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    #endif
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class ImportSettings : virtual public ::IceProxy::Ice::Object
{
public:
    
    ::IceInternal::ProxyHandle<ImportSettings> ice_context(const ::Ice::Context& __context) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ImportSettings*>(_Base::ice_context(__context).get());
    #else
        return dynamic_cast<ImportSettings*>(::IceProxy::Ice::Object::ice_context(__context).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ImportSettings> ice_adapterId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ImportSettings*>(_Base::ice_adapterId(__id).get());
    #else
        return dynamic_cast<ImportSettings*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ImportSettings> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ImportSettings*>(_Base::ice_endpoints(__endpoints).get());
    #else
        return dynamic_cast<ImportSettings*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ImportSettings> ice_locatorCacheTimeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ImportSettings*>(_Base::ice_locatorCacheTimeout(__timeout).get());
    #else
        return dynamic_cast<ImportSettings*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ImportSettings> ice_connectionCached(bool __cached) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ImportSettings*>(_Base::ice_connectionCached(__cached).get());
    #else
        return dynamic_cast<ImportSettings*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ImportSettings> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ImportSettings*>(_Base::ice_endpointSelection(__est).get());
    #else
        return dynamic_cast<ImportSettings*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ImportSettings> ice_secure(bool __secure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ImportSettings*>(_Base::ice_secure(__secure).get());
    #else
        return dynamic_cast<ImportSettings*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ImportSettings> ice_preferSecure(bool __preferSecure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ImportSettings*>(_Base::ice_preferSecure(__preferSecure).get());
    #else
        return dynamic_cast<ImportSettings*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ImportSettings> ice_router(const ::Ice::RouterPrx& __router) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ImportSettings*>(_Base::ice_router(__router).get());
    #else
        return dynamic_cast<ImportSettings*>(::IceProxy::Ice::Object::ice_router(__router).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ImportSettings> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ImportSettings*>(_Base::ice_locator(__locator).get());
    #else
        return dynamic_cast<ImportSettings*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ImportSettings> ice_collocationOptimized(bool __co) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ImportSettings*>(_Base::ice_collocationOptimized(__co).get());
    #else
        return dynamic_cast<ImportSettings*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ImportSettings> ice_twoway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ImportSettings*>(_Base::ice_twoway().get());
    #else
        return dynamic_cast<ImportSettings*>(::IceProxy::Ice::Object::ice_twoway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ImportSettings> ice_oneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ImportSettings*>(_Base::ice_oneway().get());
    #else
        return dynamic_cast<ImportSettings*>(::IceProxy::Ice::Object::ice_oneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ImportSettings> ice_batchOneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ImportSettings*>(_Base::ice_batchOneway().get());
    #else
        return dynamic_cast<ImportSettings*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ImportSettings> ice_datagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ImportSettings*>(_Base::ice_datagram().get());
    #else
        return dynamic_cast<ImportSettings*>(::IceProxy::Ice::Object::ice_datagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ImportSettings> ice_batchDatagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ImportSettings*>(_Base::ice_batchDatagram().get());
    #else
        return dynamic_cast<ImportSettings*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ImportSettings> ice_compress(bool __compress) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ImportSettings*>(_Base::ice_compress(__compress).get());
    #else
        return dynamic_cast<ImportSettings*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ImportSettings> ice_timeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ImportSettings*>(_Base::ice_timeout(__timeout).get());
    #else
        return dynamic_cast<ImportSettings*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ImportSettings> ice_connectionId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ImportSettings*>(_Base::ice_connectionId(__id).get());
    #else
        return dynamic_cast<ImportSettings*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    #endif
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class ImportProcess : virtual public ::IceProxy::omero::api::StatefulServiceInterface
{
public:

    ::omero::api::RawFileStorePrx getUploader(::Ice::Int i)
    {
        return getUploader(i, 0);
    }
    ::omero::api::RawFileStorePrx getUploader(::Ice::Int i, const ::Ice::Context& __ctx)
    {
        return getUploader(i, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_getUploader(::Ice::Int i)
    {
        return begin_getUploader(i, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getUploader(::Ice::Int i, const ::Ice::Context& __ctx)
    {
        return begin_getUploader(i, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getUploader(::Ice::Int i, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getUploader(i, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getUploader(::Ice::Int i, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getUploader(i, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getUploader(::Ice::Int i, const ::omero::grid::Callback_ImportProcess_getUploaderPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getUploader(i, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getUploader(::Ice::Int i, const ::Ice::Context& __ctx, const ::omero::grid::Callback_ImportProcess_getUploaderPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getUploader(i, &__ctx, __del, __cookie);
    }

    ::omero::api::RawFileStorePrx end_getUploader(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::api::RawFileStorePrx getUploader(::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getUploader(::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::cmd::HandlePrx verifyUpload(const ::omero::api::StringSet& hash)
    {
        return verifyUpload(hash, 0);
    }
    ::omero::cmd::HandlePrx verifyUpload(const ::omero::api::StringSet& hash, const ::Ice::Context& __ctx)
    {
        return verifyUpload(hash, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_verifyUpload(const ::omero::api::StringSet& hash)
    {
        return begin_verifyUpload(hash, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_verifyUpload(const ::omero::api::StringSet& hash, const ::Ice::Context& __ctx)
    {
        return begin_verifyUpload(hash, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_verifyUpload(const ::omero::api::StringSet& hash, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_verifyUpload(hash, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_verifyUpload(const ::omero::api::StringSet& hash, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_verifyUpload(hash, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_verifyUpload(const ::omero::api::StringSet& hash, const ::omero::grid::Callback_ImportProcess_verifyUploadPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_verifyUpload(hash, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_verifyUpload(const ::omero::api::StringSet& hash, const ::Ice::Context& __ctx, const ::omero::grid::Callback_ImportProcess_verifyUploadPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_verifyUpload(hash, &__ctx, __del, __cookie);
    }

    ::omero::cmd::HandlePrx end_verifyUpload(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::cmd::HandlePrx verifyUpload(const ::omero::api::StringSet&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_verifyUpload(const ::omero::api::StringSet&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Long getUploadOffset(::Ice::Int i)
    {
        return getUploadOffset(i, 0);
    }
    ::Ice::Long getUploadOffset(::Ice::Int i, const ::Ice::Context& __ctx)
    {
        return getUploadOffset(i, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_getUploadOffset(::Ice::Int i)
    {
        return begin_getUploadOffset(i, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getUploadOffset(::Ice::Int i, const ::Ice::Context& __ctx)
    {
        return begin_getUploadOffset(i, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getUploadOffset(::Ice::Int i, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getUploadOffset(i, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getUploadOffset(::Ice::Int i, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getUploadOffset(i, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getUploadOffset(::Ice::Int i, const ::omero::grid::Callback_ImportProcess_getUploadOffsetPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getUploadOffset(i, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getUploadOffset(::Ice::Int i, const ::Ice::Context& __ctx, const ::omero::grid::Callback_ImportProcess_getUploadOffsetPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getUploadOffset(i, &__ctx, __del, __cookie);
    }

    ::Ice::Long end_getUploadOffset(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Long getUploadOffset(::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getUploadOffset(::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::cmd::HandlePrx getHandle()
    {
        return getHandle(0);
    }
    ::omero::cmd::HandlePrx getHandle(const ::Ice::Context& __ctx)
    {
        return getHandle(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getHandle()
    {
        return begin_getHandle(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getHandle(const ::Ice::Context& __ctx)
    {
        return begin_getHandle(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getHandle(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getHandle(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getHandle(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getHandle(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getHandle(const ::omero::grid::Callback_ImportProcess_getHandlePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getHandle(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getHandle(const ::Ice::Context& __ctx, const ::omero::grid::Callback_ImportProcess_getHandlePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getHandle(&__ctx, __del, __cookie);
    }

    ::omero::cmd::HandlePrx end_getHandle(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::cmd::HandlePrx getHandle(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getHandle(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::grid::ImportSettingsPtr getImportSettings()
    {
        return getImportSettings(0);
    }
    ::omero::grid::ImportSettingsPtr getImportSettings(const ::Ice::Context& __ctx)
    {
        return getImportSettings(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getImportSettings()
    {
        return begin_getImportSettings(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getImportSettings(const ::Ice::Context& __ctx)
    {
        return begin_getImportSettings(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getImportSettings(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getImportSettings(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getImportSettings(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getImportSettings(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getImportSettings(const ::omero::grid::Callback_ImportProcess_getImportSettingsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getImportSettings(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getImportSettings(const ::Ice::Context& __ctx, const ::omero::grid::Callback_ImportProcess_getImportSettingsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getImportSettings(&__ctx, __del, __cookie);
    }

    ::omero::grid::ImportSettingsPtr end_getImportSettings(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::grid::ImportSettingsPtr getImportSettings(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getImportSettings(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    
    ::IceInternal::ProxyHandle<ImportProcess> ice_context(const ::Ice::Context& __context) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ImportProcess*>(_Base::ice_context(__context).get());
    #else
        return dynamic_cast<ImportProcess*>(::IceProxy::Ice::Object::ice_context(__context).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ImportProcess> ice_adapterId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ImportProcess*>(_Base::ice_adapterId(__id).get());
    #else
        return dynamic_cast<ImportProcess*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ImportProcess> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ImportProcess*>(_Base::ice_endpoints(__endpoints).get());
    #else
        return dynamic_cast<ImportProcess*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ImportProcess> ice_locatorCacheTimeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ImportProcess*>(_Base::ice_locatorCacheTimeout(__timeout).get());
    #else
        return dynamic_cast<ImportProcess*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ImportProcess> ice_connectionCached(bool __cached) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ImportProcess*>(_Base::ice_connectionCached(__cached).get());
    #else
        return dynamic_cast<ImportProcess*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ImportProcess> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ImportProcess*>(_Base::ice_endpointSelection(__est).get());
    #else
        return dynamic_cast<ImportProcess*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ImportProcess> ice_secure(bool __secure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ImportProcess*>(_Base::ice_secure(__secure).get());
    #else
        return dynamic_cast<ImportProcess*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ImportProcess> ice_preferSecure(bool __preferSecure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ImportProcess*>(_Base::ice_preferSecure(__preferSecure).get());
    #else
        return dynamic_cast<ImportProcess*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ImportProcess> ice_router(const ::Ice::RouterPrx& __router) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ImportProcess*>(_Base::ice_router(__router).get());
    #else
        return dynamic_cast<ImportProcess*>(::IceProxy::Ice::Object::ice_router(__router).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ImportProcess> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ImportProcess*>(_Base::ice_locator(__locator).get());
    #else
        return dynamic_cast<ImportProcess*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ImportProcess> ice_collocationOptimized(bool __co) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ImportProcess*>(_Base::ice_collocationOptimized(__co).get());
    #else
        return dynamic_cast<ImportProcess*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ImportProcess> ice_twoway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ImportProcess*>(_Base::ice_twoway().get());
    #else
        return dynamic_cast<ImportProcess*>(::IceProxy::Ice::Object::ice_twoway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ImportProcess> ice_oneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ImportProcess*>(_Base::ice_oneway().get());
    #else
        return dynamic_cast<ImportProcess*>(::IceProxy::Ice::Object::ice_oneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ImportProcess> ice_batchOneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ImportProcess*>(_Base::ice_batchOneway().get());
    #else
        return dynamic_cast<ImportProcess*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ImportProcess> ice_datagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ImportProcess*>(_Base::ice_datagram().get());
    #else
        return dynamic_cast<ImportProcess*>(::IceProxy::Ice::Object::ice_datagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ImportProcess> ice_batchDatagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ImportProcess*>(_Base::ice_batchDatagram().get());
    #else
        return dynamic_cast<ImportProcess*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ImportProcess> ice_compress(bool __compress) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ImportProcess*>(_Base::ice_compress(__compress).get());
    #else
        return dynamic_cast<ImportProcess*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ImportProcess> ice_timeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ImportProcess*>(_Base::ice_timeout(__timeout).get());
    #else
        return dynamic_cast<ImportProcess*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ImportProcess> ice_connectionId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ImportProcess*>(_Base::ice_connectionId(__id).get());
    #else
        return dynamic_cast<ImportProcess*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    #endif
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class ImportRequest : virtual public ::IceProxy::omero::cmd::Request
{
public:
    
    ::IceInternal::ProxyHandle<ImportRequest> ice_context(const ::Ice::Context& __context) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ImportRequest*>(_Base::ice_context(__context).get());
    #else
        return dynamic_cast<ImportRequest*>(::IceProxy::Ice::Object::ice_context(__context).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ImportRequest> ice_adapterId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ImportRequest*>(_Base::ice_adapterId(__id).get());
    #else
        return dynamic_cast<ImportRequest*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ImportRequest> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ImportRequest*>(_Base::ice_endpoints(__endpoints).get());
    #else
        return dynamic_cast<ImportRequest*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ImportRequest> ice_locatorCacheTimeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ImportRequest*>(_Base::ice_locatorCacheTimeout(__timeout).get());
    #else
        return dynamic_cast<ImportRequest*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ImportRequest> ice_connectionCached(bool __cached) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ImportRequest*>(_Base::ice_connectionCached(__cached).get());
    #else
        return dynamic_cast<ImportRequest*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ImportRequest> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ImportRequest*>(_Base::ice_endpointSelection(__est).get());
    #else
        return dynamic_cast<ImportRequest*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ImportRequest> ice_secure(bool __secure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ImportRequest*>(_Base::ice_secure(__secure).get());
    #else
        return dynamic_cast<ImportRequest*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ImportRequest> ice_preferSecure(bool __preferSecure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ImportRequest*>(_Base::ice_preferSecure(__preferSecure).get());
    #else
        return dynamic_cast<ImportRequest*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ImportRequest> ice_router(const ::Ice::RouterPrx& __router) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ImportRequest*>(_Base::ice_router(__router).get());
    #else
        return dynamic_cast<ImportRequest*>(::IceProxy::Ice::Object::ice_router(__router).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ImportRequest> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ImportRequest*>(_Base::ice_locator(__locator).get());
    #else
        return dynamic_cast<ImportRequest*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ImportRequest> ice_collocationOptimized(bool __co) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ImportRequest*>(_Base::ice_collocationOptimized(__co).get());
    #else
        return dynamic_cast<ImportRequest*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ImportRequest> ice_twoway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ImportRequest*>(_Base::ice_twoway().get());
    #else
        return dynamic_cast<ImportRequest*>(::IceProxy::Ice::Object::ice_twoway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ImportRequest> ice_oneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ImportRequest*>(_Base::ice_oneway().get());
    #else
        return dynamic_cast<ImportRequest*>(::IceProxy::Ice::Object::ice_oneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ImportRequest> ice_batchOneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ImportRequest*>(_Base::ice_batchOneway().get());
    #else
        return dynamic_cast<ImportRequest*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ImportRequest> ice_datagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ImportRequest*>(_Base::ice_datagram().get());
    #else
        return dynamic_cast<ImportRequest*>(::IceProxy::Ice::Object::ice_datagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ImportRequest> ice_batchDatagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ImportRequest*>(_Base::ice_batchDatagram().get());
    #else
        return dynamic_cast<ImportRequest*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ImportRequest> ice_compress(bool __compress) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ImportRequest*>(_Base::ice_compress(__compress).get());
    #else
        return dynamic_cast<ImportRequest*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ImportRequest> ice_timeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ImportRequest*>(_Base::ice_timeout(__timeout).get());
    #else
        return dynamic_cast<ImportRequest*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ImportRequest> ice_connectionId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ImportRequest*>(_Base::ice_connectionId(__id).get());
    #else
        return dynamic_cast<ImportRequest*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    #endif
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class ImportResponse : virtual public ::IceProxy::omero::cmd::Response
{
public:
    
    ::IceInternal::ProxyHandle<ImportResponse> ice_context(const ::Ice::Context& __context) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ImportResponse*>(_Base::ice_context(__context).get());
    #else
        return dynamic_cast<ImportResponse*>(::IceProxy::Ice::Object::ice_context(__context).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ImportResponse> ice_adapterId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ImportResponse*>(_Base::ice_adapterId(__id).get());
    #else
        return dynamic_cast<ImportResponse*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ImportResponse> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ImportResponse*>(_Base::ice_endpoints(__endpoints).get());
    #else
        return dynamic_cast<ImportResponse*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ImportResponse> ice_locatorCacheTimeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ImportResponse*>(_Base::ice_locatorCacheTimeout(__timeout).get());
    #else
        return dynamic_cast<ImportResponse*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ImportResponse> ice_connectionCached(bool __cached) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ImportResponse*>(_Base::ice_connectionCached(__cached).get());
    #else
        return dynamic_cast<ImportResponse*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ImportResponse> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ImportResponse*>(_Base::ice_endpointSelection(__est).get());
    #else
        return dynamic_cast<ImportResponse*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ImportResponse> ice_secure(bool __secure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ImportResponse*>(_Base::ice_secure(__secure).get());
    #else
        return dynamic_cast<ImportResponse*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ImportResponse> ice_preferSecure(bool __preferSecure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ImportResponse*>(_Base::ice_preferSecure(__preferSecure).get());
    #else
        return dynamic_cast<ImportResponse*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ImportResponse> ice_router(const ::Ice::RouterPrx& __router) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ImportResponse*>(_Base::ice_router(__router).get());
    #else
        return dynamic_cast<ImportResponse*>(::IceProxy::Ice::Object::ice_router(__router).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ImportResponse> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ImportResponse*>(_Base::ice_locator(__locator).get());
    #else
        return dynamic_cast<ImportResponse*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ImportResponse> ice_collocationOptimized(bool __co) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ImportResponse*>(_Base::ice_collocationOptimized(__co).get());
    #else
        return dynamic_cast<ImportResponse*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ImportResponse> ice_twoway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ImportResponse*>(_Base::ice_twoway().get());
    #else
        return dynamic_cast<ImportResponse*>(::IceProxy::Ice::Object::ice_twoway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ImportResponse> ice_oneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ImportResponse*>(_Base::ice_oneway().get());
    #else
        return dynamic_cast<ImportResponse*>(::IceProxy::Ice::Object::ice_oneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ImportResponse> ice_batchOneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ImportResponse*>(_Base::ice_batchOneway().get());
    #else
        return dynamic_cast<ImportResponse*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ImportResponse> ice_datagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ImportResponse*>(_Base::ice_datagram().get());
    #else
        return dynamic_cast<ImportResponse*>(::IceProxy::Ice::Object::ice_datagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ImportResponse> ice_batchDatagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ImportResponse*>(_Base::ice_batchDatagram().get());
    #else
        return dynamic_cast<ImportResponse*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ImportResponse> ice_compress(bool __compress) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ImportResponse*>(_Base::ice_compress(__compress).get());
    #else
        return dynamic_cast<ImportResponse*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ImportResponse> ice_timeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ImportResponse*>(_Base::ice_timeout(__timeout).get());
    #else
        return dynamic_cast<ImportResponse*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ImportResponse> ice_connectionId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ImportResponse*>(_Base::ice_connectionId(__id).get());
    #else
        return dynamic_cast<ImportResponse*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    #endif
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class ManagedRepository : virtual public ::IceProxy::omero::grid::Repository
{
public:

    ::omero::grid::ImportProcessPrx importFileset(const ::omero::model::FilesetPtr& fs, const ::omero::grid::ImportSettingsPtr& settings)
    {
        return importFileset(fs, settings, 0);
    }
    ::omero::grid::ImportProcessPrx importFileset(const ::omero::model::FilesetPtr& fs, const ::omero::grid::ImportSettingsPtr& settings, const ::Ice::Context& __ctx)
    {
        return importFileset(fs, settings, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_importFileset(const ::omero::model::FilesetPtr& fs, const ::omero::grid::ImportSettingsPtr& settings)
    {
        return begin_importFileset(fs, settings, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_importFileset(const ::omero::model::FilesetPtr& fs, const ::omero::grid::ImportSettingsPtr& settings, const ::Ice::Context& __ctx)
    {
        return begin_importFileset(fs, settings, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_importFileset(const ::omero::model::FilesetPtr& fs, const ::omero::grid::ImportSettingsPtr& settings, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_importFileset(fs, settings, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_importFileset(const ::omero::model::FilesetPtr& fs, const ::omero::grid::ImportSettingsPtr& settings, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_importFileset(fs, settings, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_importFileset(const ::omero::model::FilesetPtr& fs, const ::omero::grid::ImportSettingsPtr& settings, const ::omero::grid::Callback_ManagedRepository_importFilesetPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_importFileset(fs, settings, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_importFileset(const ::omero::model::FilesetPtr& fs, const ::omero::grid::ImportSettingsPtr& settings, const ::Ice::Context& __ctx, const ::omero::grid::Callback_ManagedRepository_importFilesetPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_importFileset(fs, settings, &__ctx, __del, __cookie);
    }

    ::omero::grid::ImportProcessPrx end_importFileset(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::grid::ImportProcessPrx importFileset(const ::omero::model::FilesetPtr&, const ::omero::grid::ImportSettingsPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_importFileset(const ::omero::model::FilesetPtr&, const ::omero::grid::ImportSettingsPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool importFileset_async(const ::omero::grid::AMI_ManagedRepository_importFilesetPtr&, const ::omero::model::FilesetPtr&, const ::omero::grid::ImportSettingsPtr&);
    bool importFileset_async(const ::omero::grid::AMI_ManagedRepository_importFilesetPtr&, const ::omero::model::FilesetPtr&, const ::omero::grid::ImportSettingsPtr&, const ::Ice::Context&);

    ::omero::grid::ImportProcessPrx importPaths(const ::omero::api::StringSet& filePaths)
    {
        return importPaths(filePaths, 0);
    }
    ::omero::grid::ImportProcessPrx importPaths(const ::omero::api::StringSet& filePaths, const ::Ice::Context& __ctx)
    {
        return importPaths(filePaths, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_importPaths(const ::omero::api::StringSet& filePaths)
    {
        return begin_importPaths(filePaths, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_importPaths(const ::omero::api::StringSet& filePaths, const ::Ice::Context& __ctx)
    {
        return begin_importPaths(filePaths, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_importPaths(const ::omero::api::StringSet& filePaths, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_importPaths(filePaths, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_importPaths(const ::omero::api::StringSet& filePaths, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_importPaths(filePaths, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_importPaths(const ::omero::api::StringSet& filePaths, const ::omero::grid::Callback_ManagedRepository_importPathsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_importPaths(filePaths, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_importPaths(const ::omero::api::StringSet& filePaths, const ::Ice::Context& __ctx, const ::omero::grid::Callback_ManagedRepository_importPathsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_importPaths(filePaths, &__ctx, __del, __cookie);
    }

    ::omero::grid::ImportProcessPrx end_importPaths(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::grid::ImportProcessPrx importPaths(const ::omero::api::StringSet&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_importPaths(const ::omero::api::StringSet&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool importPaths_async(const ::omero::grid::AMI_ManagedRepository_importPathsPtr&, const ::omero::api::StringSet&);
    bool importPaths_async(const ::omero::grid::AMI_ManagedRepository_importPathsPtr&, const ::omero::api::StringSet&, const ::Ice::Context&);

    ::omero::grid::ImportProcessList listImports()
    {
        return listImports(0);
    }
    ::omero::grid::ImportProcessList listImports(const ::Ice::Context& __ctx)
    {
        return listImports(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_listImports()
    {
        return begin_listImports(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_listImports(const ::Ice::Context& __ctx)
    {
        return begin_listImports(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_listImports(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_listImports(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_listImports(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_listImports(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_listImports(const ::omero::grid::Callback_ManagedRepository_listImportsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_listImports(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_listImports(const ::Ice::Context& __ctx, const ::omero::grid::Callback_ManagedRepository_listImportsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_listImports(&__ctx, __del, __cookie);
    }

    ::omero::grid::ImportProcessList end_listImports(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::grid::ImportProcessList listImports(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_listImports(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool listImports_async(const ::omero::grid::AMI_ManagedRepository_listImportsPtr&);
    bool listImports_async(const ::omero::grid::AMI_ManagedRepository_listImportsPtr&, const ::Ice::Context&);

    ::omero::api::ChecksumAlgorithmList listChecksumAlgorithms()
    {
        return listChecksumAlgorithms(0);
    }
    ::omero::api::ChecksumAlgorithmList listChecksumAlgorithms(const ::Ice::Context& __ctx)
    {
        return listChecksumAlgorithms(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_listChecksumAlgorithms()
    {
        return begin_listChecksumAlgorithms(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_listChecksumAlgorithms(const ::Ice::Context& __ctx)
    {
        return begin_listChecksumAlgorithms(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_listChecksumAlgorithms(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_listChecksumAlgorithms(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_listChecksumAlgorithms(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_listChecksumAlgorithms(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_listChecksumAlgorithms(const ::omero::grid::Callback_ManagedRepository_listChecksumAlgorithmsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_listChecksumAlgorithms(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_listChecksumAlgorithms(const ::Ice::Context& __ctx, const ::omero::grid::Callback_ManagedRepository_listChecksumAlgorithmsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_listChecksumAlgorithms(&__ctx, __del, __cookie);
    }

    ::omero::api::ChecksumAlgorithmList end_listChecksumAlgorithms(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::api::ChecksumAlgorithmList listChecksumAlgorithms(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_listChecksumAlgorithms(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool listChecksumAlgorithms_async(const ::omero::grid::AMI_ManagedRepository_listChecksumAlgorithmsPtr&);
    bool listChecksumAlgorithms_async(const ::omero::grid::AMI_ManagedRepository_listChecksumAlgorithmsPtr&, const ::Ice::Context&);

    ::omero::model::ChecksumAlgorithmPtr suggestChecksumAlgorithm(const ::omero::api::ChecksumAlgorithmList& supported)
    {
        return suggestChecksumAlgorithm(supported, 0);
    }
    ::omero::model::ChecksumAlgorithmPtr suggestChecksumAlgorithm(const ::omero::api::ChecksumAlgorithmList& supported, const ::Ice::Context& __ctx)
    {
        return suggestChecksumAlgorithm(supported, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_suggestChecksumAlgorithm(const ::omero::api::ChecksumAlgorithmList& supported)
    {
        return begin_suggestChecksumAlgorithm(supported, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_suggestChecksumAlgorithm(const ::omero::api::ChecksumAlgorithmList& supported, const ::Ice::Context& __ctx)
    {
        return begin_suggestChecksumAlgorithm(supported, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_suggestChecksumAlgorithm(const ::omero::api::ChecksumAlgorithmList& supported, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_suggestChecksumAlgorithm(supported, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_suggestChecksumAlgorithm(const ::omero::api::ChecksumAlgorithmList& supported, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_suggestChecksumAlgorithm(supported, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_suggestChecksumAlgorithm(const ::omero::api::ChecksumAlgorithmList& supported, const ::omero::grid::Callback_ManagedRepository_suggestChecksumAlgorithmPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_suggestChecksumAlgorithm(supported, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_suggestChecksumAlgorithm(const ::omero::api::ChecksumAlgorithmList& supported, const ::Ice::Context& __ctx, const ::omero::grid::Callback_ManagedRepository_suggestChecksumAlgorithmPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_suggestChecksumAlgorithm(supported, &__ctx, __del, __cookie);
    }

    ::omero::model::ChecksumAlgorithmPtr end_suggestChecksumAlgorithm(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::model::ChecksumAlgorithmPtr suggestChecksumAlgorithm(const ::omero::api::ChecksumAlgorithmList&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_suggestChecksumAlgorithm(const ::omero::api::ChecksumAlgorithmList&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool suggestChecksumAlgorithm_async(const ::omero::grid::AMI_ManagedRepository_suggestChecksumAlgorithmPtr&, const ::omero::api::ChecksumAlgorithmList&);
    bool suggestChecksumAlgorithm_async(const ::omero::grid::AMI_ManagedRepository_suggestChecksumAlgorithmPtr&, const ::omero::api::ChecksumAlgorithmList&, const ::Ice::Context&);
    
    ::IceInternal::ProxyHandle<ManagedRepository> ice_context(const ::Ice::Context& __context) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ManagedRepository*>(_Base::ice_context(__context).get());
    #else
        return dynamic_cast<ManagedRepository*>(::IceProxy::Ice::Object::ice_context(__context).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ManagedRepository> ice_adapterId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ManagedRepository*>(_Base::ice_adapterId(__id).get());
    #else
        return dynamic_cast<ManagedRepository*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ManagedRepository> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ManagedRepository*>(_Base::ice_endpoints(__endpoints).get());
    #else
        return dynamic_cast<ManagedRepository*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ManagedRepository> ice_locatorCacheTimeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ManagedRepository*>(_Base::ice_locatorCacheTimeout(__timeout).get());
    #else
        return dynamic_cast<ManagedRepository*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ManagedRepository> ice_connectionCached(bool __cached) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ManagedRepository*>(_Base::ice_connectionCached(__cached).get());
    #else
        return dynamic_cast<ManagedRepository*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ManagedRepository> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ManagedRepository*>(_Base::ice_endpointSelection(__est).get());
    #else
        return dynamic_cast<ManagedRepository*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ManagedRepository> ice_secure(bool __secure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ManagedRepository*>(_Base::ice_secure(__secure).get());
    #else
        return dynamic_cast<ManagedRepository*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ManagedRepository> ice_preferSecure(bool __preferSecure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ManagedRepository*>(_Base::ice_preferSecure(__preferSecure).get());
    #else
        return dynamic_cast<ManagedRepository*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ManagedRepository> ice_router(const ::Ice::RouterPrx& __router) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ManagedRepository*>(_Base::ice_router(__router).get());
    #else
        return dynamic_cast<ManagedRepository*>(::IceProxy::Ice::Object::ice_router(__router).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ManagedRepository> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ManagedRepository*>(_Base::ice_locator(__locator).get());
    #else
        return dynamic_cast<ManagedRepository*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ManagedRepository> ice_collocationOptimized(bool __co) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ManagedRepository*>(_Base::ice_collocationOptimized(__co).get());
    #else
        return dynamic_cast<ManagedRepository*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ManagedRepository> ice_twoway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ManagedRepository*>(_Base::ice_twoway().get());
    #else
        return dynamic_cast<ManagedRepository*>(::IceProxy::Ice::Object::ice_twoway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ManagedRepository> ice_oneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ManagedRepository*>(_Base::ice_oneway().get());
    #else
        return dynamic_cast<ManagedRepository*>(::IceProxy::Ice::Object::ice_oneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ManagedRepository> ice_batchOneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ManagedRepository*>(_Base::ice_batchOneway().get());
    #else
        return dynamic_cast<ManagedRepository*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ManagedRepository> ice_datagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ManagedRepository*>(_Base::ice_datagram().get());
    #else
        return dynamic_cast<ManagedRepository*>(::IceProxy::Ice::Object::ice_datagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ManagedRepository> ice_batchDatagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ManagedRepository*>(_Base::ice_batchDatagram().get());
    #else
        return dynamic_cast<ManagedRepository*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ManagedRepository> ice_compress(bool __compress) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ManagedRepository*>(_Base::ice_compress(__compress).get());
    #else
        return dynamic_cast<ManagedRepository*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ManagedRepository> ice_timeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ManagedRepository*>(_Base::ice_timeout(__timeout).get());
    #else
        return dynamic_cast<ManagedRepository*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ManagedRepository> ice_connectionId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ManagedRepository*>(_Base::ice_connectionId(__id).get());
    #else
        return dynamic_cast<ManagedRepository*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    #endif
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class RawAccessRequest : virtual public ::IceProxy::omero::cmd::Request
{
public:
    
    ::IceInternal::ProxyHandle<RawAccessRequest> ice_context(const ::Ice::Context& __context) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<RawAccessRequest*>(_Base::ice_context(__context).get());
    #else
        return dynamic_cast<RawAccessRequest*>(::IceProxy::Ice::Object::ice_context(__context).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<RawAccessRequest> ice_adapterId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<RawAccessRequest*>(_Base::ice_adapterId(__id).get());
    #else
        return dynamic_cast<RawAccessRequest*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<RawAccessRequest> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<RawAccessRequest*>(_Base::ice_endpoints(__endpoints).get());
    #else
        return dynamic_cast<RawAccessRequest*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<RawAccessRequest> ice_locatorCacheTimeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<RawAccessRequest*>(_Base::ice_locatorCacheTimeout(__timeout).get());
    #else
        return dynamic_cast<RawAccessRequest*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<RawAccessRequest> ice_connectionCached(bool __cached) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<RawAccessRequest*>(_Base::ice_connectionCached(__cached).get());
    #else
        return dynamic_cast<RawAccessRequest*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<RawAccessRequest> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<RawAccessRequest*>(_Base::ice_endpointSelection(__est).get());
    #else
        return dynamic_cast<RawAccessRequest*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<RawAccessRequest> ice_secure(bool __secure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<RawAccessRequest*>(_Base::ice_secure(__secure).get());
    #else
        return dynamic_cast<RawAccessRequest*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<RawAccessRequest> ice_preferSecure(bool __preferSecure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<RawAccessRequest*>(_Base::ice_preferSecure(__preferSecure).get());
    #else
        return dynamic_cast<RawAccessRequest*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<RawAccessRequest> ice_router(const ::Ice::RouterPrx& __router) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<RawAccessRequest*>(_Base::ice_router(__router).get());
    #else
        return dynamic_cast<RawAccessRequest*>(::IceProxy::Ice::Object::ice_router(__router).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<RawAccessRequest> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<RawAccessRequest*>(_Base::ice_locator(__locator).get());
    #else
        return dynamic_cast<RawAccessRequest*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<RawAccessRequest> ice_collocationOptimized(bool __co) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<RawAccessRequest*>(_Base::ice_collocationOptimized(__co).get());
    #else
        return dynamic_cast<RawAccessRequest*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<RawAccessRequest> ice_twoway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<RawAccessRequest*>(_Base::ice_twoway().get());
    #else
        return dynamic_cast<RawAccessRequest*>(::IceProxy::Ice::Object::ice_twoway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<RawAccessRequest> ice_oneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<RawAccessRequest*>(_Base::ice_oneway().get());
    #else
        return dynamic_cast<RawAccessRequest*>(::IceProxy::Ice::Object::ice_oneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<RawAccessRequest> ice_batchOneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<RawAccessRequest*>(_Base::ice_batchOneway().get());
    #else
        return dynamic_cast<RawAccessRequest*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<RawAccessRequest> ice_datagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<RawAccessRequest*>(_Base::ice_datagram().get());
    #else
        return dynamic_cast<RawAccessRequest*>(::IceProxy::Ice::Object::ice_datagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<RawAccessRequest> ice_batchDatagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<RawAccessRequest*>(_Base::ice_batchDatagram().get());
    #else
        return dynamic_cast<RawAccessRequest*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<RawAccessRequest> ice_compress(bool __compress) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<RawAccessRequest*>(_Base::ice_compress(__compress).get());
    #else
        return dynamic_cast<RawAccessRequest*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<RawAccessRequest> ice_timeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<RawAccessRequest*>(_Base::ice_timeout(__timeout).get());
    #else
        return dynamic_cast<RawAccessRequest*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<RawAccessRequest> ice_connectionId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<RawAccessRequest*>(_Base::ice_connectionId(__id).get());
    #else
        return dynamic_cast<RawAccessRequest*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    #endif
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class InternalRepository : virtual public ::IceProxy::Ice::Object
{
public:

    ::omero::api::RawFileStorePrx createRawFileStore(const ::omero::model::OriginalFilePtr& file)
    {
        return createRawFileStore(file, 0);
    }
    ::omero::api::RawFileStorePrx createRawFileStore(const ::omero::model::OriginalFilePtr& file, const ::Ice::Context& __ctx)
    {
        return createRawFileStore(file, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_createRawFileStore(const ::omero::model::OriginalFilePtr& file)
    {
        return begin_createRawFileStore(file, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_createRawFileStore(const ::omero::model::OriginalFilePtr& file, const ::Ice::Context& __ctx)
    {
        return begin_createRawFileStore(file, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_createRawFileStore(const ::omero::model::OriginalFilePtr& file, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createRawFileStore(file, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_createRawFileStore(const ::omero::model::OriginalFilePtr& file, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createRawFileStore(file, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_createRawFileStore(const ::omero::model::OriginalFilePtr& file, const ::omero::grid::Callback_InternalRepository_createRawFileStorePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createRawFileStore(file, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_createRawFileStore(const ::omero::model::OriginalFilePtr& file, const ::Ice::Context& __ctx, const ::omero::grid::Callback_InternalRepository_createRawFileStorePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createRawFileStore(file, &__ctx, __del, __cookie);
    }

    ::omero::api::RawFileStorePrx end_createRawFileStore(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::api::RawFileStorePrx createRawFileStore(const ::omero::model::OriginalFilePtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_createRawFileStore(const ::omero::model::OriginalFilePtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool createRawFileStore_async(const ::omero::grid::AMI_InternalRepository_createRawFileStorePtr&, const ::omero::model::OriginalFilePtr&);
    bool createRawFileStore_async(const ::omero::grid::AMI_InternalRepository_createRawFileStorePtr&, const ::omero::model::OriginalFilePtr&, const ::Ice::Context&);

    ::omero::api::RawPixelsStorePrx createRawPixelsStore(const ::omero::model::OriginalFilePtr& file)
    {
        return createRawPixelsStore(file, 0);
    }
    ::omero::api::RawPixelsStorePrx createRawPixelsStore(const ::omero::model::OriginalFilePtr& file, const ::Ice::Context& __ctx)
    {
        return createRawPixelsStore(file, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_createRawPixelsStore(const ::omero::model::OriginalFilePtr& file)
    {
        return begin_createRawPixelsStore(file, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_createRawPixelsStore(const ::omero::model::OriginalFilePtr& file, const ::Ice::Context& __ctx)
    {
        return begin_createRawPixelsStore(file, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_createRawPixelsStore(const ::omero::model::OriginalFilePtr& file, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createRawPixelsStore(file, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_createRawPixelsStore(const ::omero::model::OriginalFilePtr& file, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createRawPixelsStore(file, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_createRawPixelsStore(const ::omero::model::OriginalFilePtr& file, const ::omero::grid::Callback_InternalRepository_createRawPixelsStorePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createRawPixelsStore(file, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_createRawPixelsStore(const ::omero::model::OriginalFilePtr& file, const ::Ice::Context& __ctx, const ::omero::grid::Callback_InternalRepository_createRawPixelsStorePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createRawPixelsStore(file, &__ctx, __del, __cookie);
    }

    ::omero::api::RawPixelsStorePrx end_createRawPixelsStore(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::api::RawPixelsStorePrx createRawPixelsStore(const ::omero::model::OriginalFilePtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_createRawPixelsStore(const ::omero::model::OriginalFilePtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool createRawPixelsStore_async(const ::omero::grid::AMI_InternalRepository_createRawPixelsStorePtr&, const ::omero::model::OriginalFilePtr&);
    bool createRawPixelsStore_async(const ::omero::grid::AMI_InternalRepository_createRawPixelsStorePtr&, const ::omero::model::OriginalFilePtr&, const ::Ice::Context&);

    ::omero::api::RenderingEnginePrx createRenderingEngine(const ::omero::model::OriginalFilePtr& file)
    {
        return createRenderingEngine(file, 0);
    }
    ::omero::api::RenderingEnginePrx createRenderingEngine(const ::omero::model::OriginalFilePtr& file, const ::Ice::Context& __ctx)
    {
        return createRenderingEngine(file, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_createRenderingEngine(const ::omero::model::OriginalFilePtr& file)
    {
        return begin_createRenderingEngine(file, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_createRenderingEngine(const ::omero::model::OriginalFilePtr& file, const ::Ice::Context& __ctx)
    {
        return begin_createRenderingEngine(file, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_createRenderingEngine(const ::omero::model::OriginalFilePtr& file, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createRenderingEngine(file, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_createRenderingEngine(const ::omero::model::OriginalFilePtr& file, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createRenderingEngine(file, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_createRenderingEngine(const ::omero::model::OriginalFilePtr& file, const ::omero::grid::Callback_InternalRepository_createRenderingEnginePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createRenderingEngine(file, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_createRenderingEngine(const ::omero::model::OriginalFilePtr& file, const ::Ice::Context& __ctx, const ::omero::grid::Callback_InternalRepository_createRenderingEnginePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createRenderingEngine(file, &__ctx, __del, __cookie);
    }

    ::omero::api::RenderingEnginePrx end_createRenderingEngine(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::api::RenderingEnginePrx createRenderingEngine(const ::omero::model::OriginalFilePtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_createRenderingEngine(const ::omero::model::OriginalFilePtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool createRenderingEngine_async(const ::omero::grid::AMI_InternalRepository_createRenderingEnginePtr&, const ::omero::model::OriginalFilePtr&);
    bool createRenderingEngine_async(const ::omero::grid::AMI_InternalRepository_createRenderingEnginePtr&, const ::omero::model::OriginalFilePtr&, const ::Ice::Context&);

    ::omero::api::ThumbnailStorePrx createThumbnailStore(const ::omero::model::OriginalFilePtr& file)
    {
        return createThumbnailStore(file, 0);
    }
    ::omero::api::ThumbnailStorePrx createThumbnailStore(const ::omero::model::OriginalFilePtr& file, const ::Ice::Context& __ctx)
    {
        return createThumbnailStore(file, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_createThumbnailStore(const ::omero::model::OriginalFilePtr& file)
    {
        return begin_createThumbnailStore(file, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_createThumbnailStore(const ::omero::model::OriginalFilePtr& file, const ::Ice::Context& __ctx)
    {
        return begin_createThumbnailStore(file, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_createThumbnailStore(const ::omero::model::OriginalFilePtr& file, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createThumbnailStore(file, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_createThumbnailStore(const ::omero::model::OriginalFilePtr& file, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createThumbnailStore(file, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_createThumbnailStore(const ::omero::model::OriginalFilePtr& file, const ::omero::grid::Callback_InternalRepository_createThumbnailStorePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createThumbnailStore(file, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_createThumbnailStore(const ::omero::model::OriginalFilePtr& file, const ::Ice::Context& __ctx, const ::omero::grid::Callback_InternalRepository_createThumbnailStorePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createThumbnailStore(file, &__ctx, __del, __cookie);
    }

    ::omero::api::ThumbnailStorePrx end_createThumbnailStore(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::api::ThumbnailStorePrx createThumbnailStore(const ::omero::model::OriginalFilePtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_createThumbnailStore(const ::omero::model::OriginalFilePtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool createThumbnailStore_async(const ::omero::grid::AMI_InternalRepository_createThumbnailStorePtr&, const ::omero::model::OriginalFilePtr&);
    bool createThumbnailStore_async(const ::omero::grid::AMI_InternalRepository_createThumbnailStorePtr&, const ::omero::model::OriginalFilePtr&, const ::Ice::Context&);

    ::omero::model::OriginalFilePtr getDescription()
    {
        return getDescription(0);
    }
    ::omero::model::OriginalFilePtr getDescription(const ::Ice::Context& __ctx)
    {
        return getDescription(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getDescription()
    {
        return begin_getDescription(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getDescription(const ::Ice::Context& __ctx)
    {
        return begin_getDescription(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getDescription(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getDescription(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getDescription(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getDescription(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getDescription(const ::omero::grid::Callback_InternalRepository_getDescriptionPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getDescription(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getDescription(const ::Ice::Context& __ctx, const ::omero::grid::Callback_InternalRepository_getDescriptionPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getDescription(&__ctx, __del, __cookie);
    }

    ::omero::model::OriginalFilePtr end_getDescription(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::model::OriginalFilePtr getDescription(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getDescription(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool getDescription_async(const ::omero::grid::AMI_InternalRepository_getDescriptionPtr&);
    bool getDescription_async(const ::omero::grid::AMI_InternalRepository_getDescriptionPtr&, const ::Ice::Context&);

    ::omero::grid::RepositoryPrx getProxy()
    {
        return getProxy(0);
    }
    ::omero::grid::RepositoryPrx getProxy(const ::Ice::Context& __ctx)
    {
        return getProxy(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getProxy()
    {
        return begin_getProxy(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getProxy(const ::Ice::Context& __ctx)
    {
        return begin_getProxy(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getProxy(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getProxy(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getProxy(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getProxy(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getProxy(const ::omero::grid::Callback_InternalRepository_getProxyPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getProxy(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getProxy(const ::Ice::Context& __ctx, const ::omero::grid::Callback_InternalRepository_getProxyPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getProxy(&__ctx, __del, __cookie);
    }

    ::omero::grid::RepositoryPrx end_getProxy(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::grid::RepositoryPrx getProxy(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getProxy(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool getProxy_async(const ::omero::grid::AMI_InternalRepository_getProxyPtr&);
    bool getProxy_async(const ::omero::grid::AMI_InternalRepository_getProxyPtr&, const ::Ice::Context&);

    ::omero::cmd::ResponsePtr rawAccess(const ::omero::grid::RawAccessRequestPtr& raw)
    {
        return rawAccess(raw, 0);
    }
    ::omero::cmd::ResponsePtr rawAccess(const ::omero::grid::RawAccessRequestPtr& raw, const ::Ice::Context& __ctx)
    {
        return rawAccess(raw, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_rawAccess(const ::omero::grid::RawAccessRequestPtr& raw)
    {
        return begin_rawAccess(raw, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_rawAccess(const ::omero::grid::RawAccessRequestPtr& raw, const ::Ice::Context& __ctx)
    {
        return begin_rawAccess(raw, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_rawAccess(const ::omero::grid::RawAccessRequestPtr& raw, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_rawAccess(raw, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_rawAccess(const ::omero::grid::RawAccessRequestPtr& raw, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_rawAccess(raw, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_rawAccess(const ::omero::grid::RawAccessRequestPtr& raw, const ::omero::grid::Callback_InternalRepository_rawAccessPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_rawAccess(raw, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_rawAccess(const ::omero::grid::RawAccessRequestPtr& raw, const ::Ice::Context& __ctx, const ::omero::grid::Callback_InternalRepository_rawAccessPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_rawAccess(raw, &__ctx, __del, __cookie);
    }

    ::omero::cmd::ResponsePtr end_rawAccess(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::cmd::ResponsePtr rawAccess(const ::omero::grid::RawAccessRequestPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_rawAccess(const ::omero::grid::RawAccessRequestPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool rawAccess_async(const ::omero::grid::AMI_InternalRepository_rawAccessPtr&, const ::omero::grid::RawAccessRequestPtr&);
    bool rawAccess_async(const ::omero::grid::AMI_InternalRepository_rawAccessPtr&, const ::omero::grid::RawAccessRequestPtr&, const ::Ice::Context&);

    ::std::string getFilePath(const ::omero::model::OriginalFilePtr& file)
    {
        return getFilePath(file, 0);
    }
    ::std::string getFilePath(const ::omero::model::OriginalFilePtr& file, const ::Ice::Context& __ctx)
    {
        return getFilePath(file, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_getFilePath(const ::omero::model::OriginalFilePtr& file)
    {
        return begin_getFilePath(file, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getFilePath(const ::omero::model::OriginalFilePtr& file, const ::Ice::Context& __ctx)
    {
        return begin_getFilePath(file, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getFilePath(const ::omero::model::OriginalFilePtr& file, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getFilePath(file, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getFilePath(const ::omero::model::OriginalFilePtr& file, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getFilePath(file, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getFilePath(const ::omero::model::OriginalFilePtr& file, const ::omero::grid::Callback_InternalRepository_getFilePathPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getFilePath(file, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getFilePath(const ::omero::model::OriginalFilePtr& file, const ::Ice::Context& __ctx, const ::omero::grid::Callback_InternalRepository_getFilePathPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getFilePath(file, &__ctx, __del, __cookie);
    }

    ::std::string end_getFilePath(const ::Ice::AsyncResultPtr&);
    
private:

    ::std::string getFilePath(const ::omero::model::OriginalFilePtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getFilePath(const ::omero::model::OriginalFilePtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool getFilePath_async(const ::omero::grid::AMI_InternalRepository_getFilePathPtr&, const ::omero::model::OriginalFilePtr&);
    bool getFilePath_async(const ::omero::grid::AMI_InternalRepository_getFilePathPtr&, const ::omero::model::OriginalFilePtr&, const ::Ice::Context&);
    
    ::IceInternal::ProxyHandle<InternalRepository> ice_context(const ::Ice::Context& __context) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<InternalRepository*>(_Base::ice_context(__context).get());
    #else
        return dynamic_cast<InternalRepository*>(::IceProxy::Ice::Object::ice_context(__context).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<InternalRepository> ice_adapterId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<InternalRepository*>(_Base::ice_adapterId(__id).get());
    #else
        return dynamic_cast<InternalRepository*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<InternalRepository> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<InternalRepository*>(_Base::ice_endpoints(__endpoints).get());
    #else
        return dynamic_cast<InternalRepository*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<InternalRepository> ice_locatorCacheTimeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<InternalRepository*>(_Base::ice_locatorCacheTimeout(__timeout).get());
    #else
        return dynamic_cast<InternalRepository*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<InternalRepository> ice_connectionCached(bool __cached) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<InternalRepository*>(_Base::ice_connectionCached(__cached).get());
    #else
        return dynamic_cast<InternalRepository*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<InternalRepository> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<InternalRepository*>(_Base::ice_endpointSelection(__est).get());
    #else
        return dynamic_cast<InternalRepository*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<InternalRepository> ice_secure(bool __secure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<InternalRepository*>(_Base::ice_secure(__secure).get());
    #else
        return dynamic_cast<InternalRepository*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<InternalRepository> ice_preferSecure(bool __preferSecure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<InternalRepository*>(_Base::ice_preferSecure(__preferSecure).get());
    #else
        return dynamic_cast<InternalRepository*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<InternalRepository> ice_router(const ::Ice::RouterPrx& __router) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<InternalRepository*>(_Base::ice_router(__router).get());
    #else
        return dynamic_cast<InternalRepository*>(::IceProxy::Ice::Object::ice_router(__router).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<InternalRepository> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<InternalRepository*>(_Base::ice_locator(__locator).get());
    #else
        return dynamic_cast<InternalRepository*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<InternalRepository> ice_collocationOptimized(bool __co) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<InternalRepository*>(_Base::ice_collocationOptimized(__co).get());
    #else
        return dynamic_cast<InternalRepository*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<InternalRepository> ice_twoway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<InternalRepository*>(_Base::ice_twoway().get());
    #else
        return dynamic_cast<InternalRepository*>(::IceProxy::Ice::Object::ice_twoway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<InternalRepository> ice_oneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<InternalRepository*>(_Base::ice_oneway().get());
    #else
        return dynamic_cast<InternalRepository*>(::IceProxy::Ice::Object::ice_oneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<InternalRepository> ice_batchOneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<InternalRepository*>(_Base::ice_batchOneway().get());
    #else
        return dynamic_cast<InternalRepository*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<InternalRepository> ice_datagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<InternalRepository*>(_Base::ice_datagram().get());
    #else
        return dynamic_cast<InternalRepository*>(::IceProxy::Ice::Object::ice_datagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<InternalRepository> ice_batchDatagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<InternalRepository*>(_Base::ice_batchDatagram().get());
    #else
        return dynamic_cast<InternalRepository*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<InternalRepository> ice_compress(bool __compress) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<InternalRepository*>(_Base::ice_compress(__compress).get());
    #else
        return dynamic_cast<InternalRepository*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<InternalRepository> ice_timeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<InternalRepository*>(_Base::ice_timeout(__timeout).get());
    #else
        return dynamic_cast<InternalRepository*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<InternalRepository> ice_connectionId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<InternalRepository*>(_Base::ice_connectionId(__id).get());
    #else
        return dynamic_cast<InternalRepository*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    #endif
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

}

}

}

namespace IceDelegate
{

namespace omero
{

namespace grid
{

class Repository : virtual public ::IceDelegate::Ice::Object
{
public:

    virtual ::omero::model::OriginalFilePtr root(const ::Ice::Context*) = 0;

    virtual ::std::string mimetype(const ::std::string&, const ::Ice::Context*) = 0;

    virtual ::omero::api::StringSet list(const ::std::string&, const ::Ice::Context*) = 0;

    virtual ::omero::api::OriginalFileList listFiles(const ::std::string&, const ::Ice::Context*) = 0;

    virtual ::omero::model::OriginalFilePtr _cpp_register(const ::std::string&, const ::omero::RStringPtr&, const ::Ice::Context*) = 0;

    virtual ::omero::api::RawFileStorePrx file(const ::std::string&, const ::std::string&, const ::Ice::Context*) = 0;

    virtual ::omero::api::RawPixelsStorePrx pixels(const ::std::string&, const ::Ice::Context*) = 0;

    virtual ::omero::api::RawFileStorePrx fileById(::Ice::Long, const ::Ice::Context*) = 0;

    virtual bool fileExists(const ::std::string&, const ::Ice::Context*) = 0;

    virtual void makeDir(const ::std::string&, bool, const ::Ice::Context*) = 0;

    virtual ::omero::RMapPtr treeList(const ::std::string&, const ::Ice::Context*) = 0;

    virtual ::omero::cmd::HandlePrx deletePaths(const ::omero::api::StringArray&, bool, bool, const ::Ice::Context*) = 0;
};

class ImportLocation : virtual public ::IceDelegate::Ice::Object
{
public:
};

class ImportSettings : virtual public ::IceDelegate::Ice::Object
{
public:
};

class ImportProcess : virtual public ::IceDelegate::omero::api::StatefulServiceInterface
{
public:

    virtual ::omero::api::RawFileStorePrx getUploader(::Ice::Int, const ::Ice::Context*) = 0;

    virtual ::omero::cmd::HandlePrx verifyUpload(const ::omero::api::StringSet&, const ::Ice::Context*) = 0;

    virtual ::Ice::Long getUploadOffset(::Ice::Int, const ::Ice::Context*) = 0;

    virtual ::omero::cmd::HandlePrx getHandle(const ::Ice::Context*) = 0;

    virtual ::omero::grid::ImportSettingsPtr getImportSettings(const ::Ice::Context*) = 0;
};

class ImportRequest : virtual public ::IceDelegate::omero::cmd::Request
{
public:
};

class ImportResponse : virtual public ::IceDelegate::omero::cmd::Response
{
public:
};

class ManagedRepository : virtual public ::IceDelegate::omero::grid::Repository
{
public:

    virtual ::omero::grid::ImportProcessPrx importFileset(const ::omero::model::FilesetPtr&, const ::omero::grid::ImportSettingsPtr&, const ::Ice::Context*) = 0;

    virtual ::omero::grid::ImportProcessPrx importPaths(const ::omero::api::StringSet&, const ::Ice::Context*) = 0;

    virtual ::omero::grid::ImportProcessList listImports(const ::Ice::Context*) = 0;

    virtual ::omero::api::ChecksumAlgorithmList listChecksumAlgorithms(const ::Ice::Context*) = 0;

    virtual ::omero::model::ChecksumAlgorithmPtr suggestChecksumAlgorithm(const ::omero::api::ChecksumAlgorithmList&, const ::Ice::Context*) = 0;
};

class RawAccessRequest : virtual public ::IceDelegate::omero::cmd::Request
{
public:
};

class InternalRepository : virtual public ::IceDelegate::Ice::Object
{
public:

    virtual ::omero::api::RawFileStorePrx createRawFileStore(const ::omero::model::OriginalFilePtr&, const ::Ice::Context*) = 0;

    virtual ::omero::api::RawPixelsStorePrx createRawPixelsStore(const ::omero::model::OriginalFilePtr&, const ::Ice::Context*) = 0;

    virtual ::omero::api::RenderingEnginePrx createRenderingEngine(const ::omero::model::OriginalFilePtr&, const ::Ice::Context*) = 0;

    virtual ::omero::api::ThumbnailStorePrx createThumbnailStore(const ::omero::model::OriginalFilePtr&, const ::Ice::Context*) = 0;

    virtual ::omero::model::OriginalFilePtr getDescription(const ::Ice::Context*) = 0;

    virtual ::omero::grid::RepositoryPrx getProxy(const ::Ice::Context*) = 0;

    virtual ::omero::cmd::ResponsePtr rawAccess(const ::omero::grid::RawAccessRequestPtr&, const ::Ice::Context*) = 0;

    virtual ::std::string getFilePath(const ::omero::model::OriginalFilePtr&, const ::Ice::Context*) = 0;
};

}

}

}

namespace IceDelegateM
{

namespace omero
{

namespace grid
{

class Repository : virtual public ::IceDelegate::omero::grid::Repository,
                   virtual public ::IceDelegateM::Ice::Object
{
public:

    virtual ::omero::model::OriginalFilePtr root(const ::Ice::Context*);

    virtual ::std::string mimetype(const ::std::string&, const ::Ice::Context*);

    virtual ::omero::api::StringSet list(const ::std::string&, const ::Ice::Context*);

    virtual ::omero::api::OriginalFileList listFiles(const ::std::string&, const ::Ice::Context*);

    virtual ::omero::model::OriginalFilePtr _cpp_register(const ::std::string&, const ::omero::RStringPtr&, const ::Ice::Context*);

    virtual ::omero::api::RawFileStorePrx file(const ::std::string&, const ::std::string&, const ::Ice::Context*);

    virtual ::omero::api::RawPixelsStorePrx pixels(const ::std::string&, const ::Ice::Context*);

    virtual ::omero::api::RawFileStorePrx fileById(::Ice::Long, const ::Ice::Context*);

    virtual bool fileExists(const ::std::string&, const ::Ice::Context*);

    virtual void makeDir(const ::std::string&, bool, const ::Ice::Context*);

    virtual ::omero::RMapPtr treeList(const ::std::string&, const ::Ice::Context*);

    virtual ::omero::cmd::HandlePrx deletePaths(const ::omero::api::StringArray&, bool, bool, const ::Ice::Context*);
};

class ImportLocation : virtual public ::IceDelegate::omero::grid::ImportLocation,
                       virtual public ::IceDelegateM::Ice::Object
{
public:
};

class ImportSettings : virtual public ::IceDelegate::omero::grid::ImportSettings,
                       virtual public ::IceDelegateM::Ice::Object
{
public:
};

class ImportProcess : virtual public ::IceDelegate::omero::grid::ImportProcess,
                      virtual public ::IceDelegateM::omero::api::StatefulServiceInterface
{
public:

    virtual ::omero::api::RawFileStorePrx getUploader(::Ice::Int, const ::Ice::Context*);

    virtual ::omero::cmd::HandlePrx verifyUpload(const ::omero::api::StringSet&, const ::Ice::Context*);

    virtual ::Ice::Long getUploadOffset(::Ice::Int, const ::Ice::Context*);

    virtual ::omero::cmd::HandlePrx getHandle(const ::Ice::Context*);

    virtual ::omero::grid::ImportSettingsPtr getImportSettings(const ::Ice::Context*);
};

class ImportRequest : virtual public ::IceDelegate::omero::grid::ImportRequest,
                      virtual public ::IceDelegateM::omero::cmd::Request
{
public:
};

class ImportResponse : virtual public ::IceDelegate::omero::grid::ImportResponse,
                       virtual public ::IceDelegateM::omero::cmd::Response
{
public:
};

class ManagedRepository : virtual public ::IceDelegate::omero::grid::ManagedRepository,
                          virtual public ::IceDelegateM::omero::grid::Repository
{
public:

    virtual ::omero::grid::ImportProcessPrx importFileset(const ::omero::model::FilesetPtr&, const ::omero::grid::ImportSettingsPtr&, const ::Ice::Context*);

    virtual ::omero::grid::ImportProcessPrx importPaths(const ::omero::api::StringSet&, const ::Ice::Context*);

    virtual ::omero::grid::ImportProcessList listImports(const ::Ice::Context*);

    virtual ::omero::api::ChecksumAlgorithmList listChecksumAlgorithms(const ::Ice::Context*);

    virtual ::omero::model::ChecksumAlgorithmPtr suggestChecksumAlgorithm(const ::omero::api::ChecksumAlgorithmList&, const ::Ice::Context*);
};

class RawAccessRequest : virtual public ::IceDelegate::omero::grid::RawAccessRequest,
                         virtual public ::IceDelegateM::omero::cmd::Request
{
public:
};

class InternalRepository : virtual public ::IceDelegate::omero::grid::InternalRepository,
                           virtual public ::IceDelegateM::Ice::Object
{
public:

    virtual ::omero::api::RawFileStorePrx createRawFileStore(const ::omero::model::OriginalFilePtr&, const ::Ice::Context*);

    virtual ::omero::api::RawPixelsStorePrx createRawPixelsStore(const ::omero::model::OriginalFilePtr&, const ::Ice::Context*);

    virtual ::omero::api::RenderingEnginePrx createRenderingEngine(const ::omero::model::OriginalFilePtr&, const ::Ice::Context*);

    virtual ::omero::api::ThumbnailStorePrx createThumbnailStore(const ::omero::model::OriginalFilePtr&, const ::Ice::Context*);

    virtual ::omero::model::OriginalFilePtr getDescription(const ::Ice::Context*);

    virtual ::omero::grid::RepositoryPrx getProxy(const ::Ice::Context*);

    virtual ::omero::cmd::ResponsePtr rawAccess(const ::omero::grid::RawAccessRequestPtr&, const ::Ice::Context*);

    virtual ::std::string getFilePath(const ::omero::model::OriginalFilePtr&, const ::Ice::Context*);
};

}

}

}

namespace IceDelegateD
{

namespace omero
{

namespace grid
{

class Repository : virtual public ::IceDelegate::omero::grid::Repository,
                   virtual public ::IceDelegateD::Ice::Object
{
public:

    virtual ::omero::model::OriginalFilePtr root(const ::Ice::Context*);

    virtual ::std::string mimetype(const ::std::string&, const ::Ice::Context*);

    virtual ::omero::api::StringSet list(const ::std::string&, const ::Ice::Context*);

    virtual ::omero::api::OriginalFileList listFiles(const ::std::string&, const ::Ice::Context*);

    virtual ::omero::model::OriginalFilePtr _cpp_register(const ::std::string&, const ::omero::RStringPtr&, const ::Ice::Context*);

    virtual ::omero::api::RawFileStorePrx file(const ::std::string&, const ::std::string&, const ::Ice::Context*);

    virtual ::omero::api::RawPixelsStorePrx pixels(const ::std::string&, const ::Ice::Context*);

    virtual ::omero::api::RawFileStorePrx fileById(::Ice::Long, const ::Ice::Context*);

    virtual bool fileExists(const ::std::string&, const ::Ice::Context*);

    virtual void makeDir(const ::std::string&, bool, const ::Ice::Context*);

    virtual ::omero::RMapPtr treeList(const ::std::string&, const ::Ice::Context*);

    virtual ::omero::cmd::HandlePrx deletePaths(const ::omero::api::StringArray&, bool, bool, const ::Ice::Context*);
};

class ImportLocation : virtual public ::IceDelegate::omero::grid::ImportLocation,
                       virtual public ::IceDelegateD::Ice::Object
{
public:
};

class ImportSettings : virtual public ::IceDelegate::omero::grid::ImportSettings,
                       virtual public ::IceDelegateD::Ice::Object
{
public:
};

class ImportProcess : virtual public ::IceDelegate::omero::grid::ImportProcess,
                      virtual public ::IceDelegateD::omero::api::StatefulServiceInterface
{
public:

    virtual ::omero::api::RawFileStorePrx getUploader(::Ice::Int, const ::Ice::Context*);

    virtual ::omero::cmd::HandlePrx verifyUpload(const ::omero::api::StringSet&, const ::Ice::Context*);

    virtual ::Ice::Long getUploadOffset(::Ice::Int, const ::Ice::Context*);

    virtual ::omero::cmd::HandlePrx getHandle(const ::Ice::Context*);

    virtual ::omero::grid::ImportSettingsPtr getImportSettings(const ::Ice::Context*);
};

class ImportRequest : virtual public ::IceDelegate::omero::grid::ImportRequest,
                      virtual public ::IceDelegateD::omero::cmd::Request
{
public:
};

class ImportResponse : virtual public ::IceDelegate::omero::grid::ImportResponse,
                       virtual public ::IceDelegateD::omero::cmd::Response
{
public:
};

class ManagedRepository : virtual public ::IceDelegate::omero::grid::ManagedRepository,
                          virtual public ::IceDelegateD::omero::grid::Repository
{
public:

    virtual ::omero::grid::ImportProcessPrx importFileset(const ::omero::model::FilesetPtr&, const ::omero::grid::ImportSettingsPtr&, const ::Ice::Context*);

    virtual ::omero::grid::ImportProcessPrx importPaths(const ::omero::api::StringSet&, const ::Ice::Context*);

    virtual ::omero::grid::ImportProcessList listImports(const ::Ice::Context*);

    virtual ::omero::api::ChecksumAlgorithmList listChecksumAlgorithms(const ::Ice::Context*);

    virtual ::omero::model::ChecksumAlgorithmPtr suggestChecksumAlgorithm(const ::omero::api::ChecksumAlgorithmList&, const ::Ice::Context*);
};

class RawAccessRequest : virtual public ::IceDelegate::omero::grid::RawAccessRequest,
                         virtual public ::IceDelegateD::omero::cmd::Request
{
public:
};

class InternalRepository : virtual public ::IceDelegate::omero::grid::InternalRepository,
                           virtual public ::IceDelegateD::Ice::Object
{
public:

    virtual ::omero::api::RawFileStorePrx createRawFileStore(const ::omero::model::OriginalFilePtr&, const ::Ice::Context*);

    virtual ::omero::api::RawPixelsStorePrx createRawPixelsStore(const ::omero::model::OriginalFilePtr&, const ::Ice::Context*);

    virtual ::omero::api::RenderingEnginePrx createRenderingEngine(const ::omero::model::OriginalFilePtr&, const ::Ice::Context*);

    virtual ::omero::api::ThumbnailStorePrx createThumbnailStore(const ::omero::model::OriginalFilePtr&, const ::Ice::Context*);

    virtual ::omero::model::OriginalFilePtr getDescription(const ::Ice::Context*);

    virtual ::omero::grid::RepositoryPrx getProxy(const ::Ice::Context*);

    virtual ::omero::cmd::ResponsePtr rawAccess(const ::omero::grid::RawAccessRequestPtr&, const ::Ice::Context*);

    virtual ::std::string getFilePath(const ::omero::model::OriginalFilePtr&, const ::Ice::Context*);
};

}

}

}

namespace omero
{

namespace grid
{

class Repository : virtual public ::Ice::Object
{
public:

    typedef RepositoryPrx ProxyType;
    typedef RepositoryPtr PointerType;
    
    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual ::omero::model::OriginalFilePtr root(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___root(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::std::string mimetype(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___mimetype(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::api::StringSet list(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___list(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::api::OriginalFileList listFiles(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___listFiles(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::model::OriginalFilePtr _cpp_register(const ::std::string&, const ::omero::RStringPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___register(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::api::RawFileStorePrx file(const ::std::string&, const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___file(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::api::RawPixelsStorePrx pixels(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___pixels(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::api::RawFileStorePrx fileById(::Ice::Long, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___fileById(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual bool fileExists(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___fileExists(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void makeDir(const ::std::string&, bool, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___makeDir(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::RMapPtr treeList(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___treeList(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::cmd::HandlePrx deletePaths(const ::omero::api::StringArray&, bool, bool, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___deletePaths(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void __write(::IceInternal::BasicStream*) const;
    virtual void __read(::IceInternal::BasicStream*, bool);
// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
    virtual void __write(const ::Ice::OutputStreamPtr&) const;
    virtual void __read(const ::Ice::InputStreamPtr&, bool);
#endif
};

inline bool operator==(const Repository& l, const Repository& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const Repository& l, const Repository& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class ImportLocation : virtual public ::Ice::Object, private IceInternal::GCShared
{
public:

    typedef ImportLocationPrx ProxyType;
    typedef ImportLocationPtr PointerType;
    
    ImportLocation() {}
    ImportLocation(const ::std::string&, ::Ice::Int, const ::omero::api::StringSet&, const ::omero::model::OriginalFilePtr&);
    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void __addObject(::IceInternal::GCCountMap&);
    virtual bool __usesClasses();
    virtual void __gcReachable(::IceInternal::GCCountMap&) const;
    virtual void __gcClear();

    virtual void __write(::IceInternal::BasicStream*) const;
    virtual void __read(::IceInternal::BasicStream*, bool);
// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
    virtual void __write(const ::Ice::OutputStreamPtr&) const;
    virtual void __read(const ::Ice::InputStreamPtr&, bool);
#endif

    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:

    virtual ~ImportLocation() {}

    friend class ImportLocation__staticInit;

public:

    ::std::string sharedPath;

    ::Ice::Int omittedLevels;

    ::omero::api::StringSet usedFiles;

    ::omero::model::OriginalFilePtr directory;
};

class ImportLocation__staticInit
{
public:

    ::omero::grid::ImportLocation _init;
};

static ImportLocation__staticInit _ImportLocation_init;

inline bool operator==(const ImportLocation& l, const ImportLocation& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const ImportLocation& l, const ImportLocation& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class ImportSettings : virtual public ::Ice::Object, private IceInternal::GCShared
{
public:

    typedef ImportSettingsPrx ProxyType;
    typedef ImportSettingsPtr PointerType;
    
    ImportSettings() {}
    ImportSettings(const ::omero::model::IObjectPtr&, const ::omero::RStringPtr&, const ::omero::RStringPtr&, const ::omero::api::DoubleArray&, const ::omero::api::AnnotationList&, const ::omero::RBoolPtr&, const ::omero::model::ChecksumAlgorithmPtr&);
    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void __addObject(::IceInternal::GCCountMap&);
    virtual bool __usesClasses();
    virtual void __gcReachable(::IceInternal::GCCountMap&) const;
    virtual void __gcClear();

    virtual void __write(::IceInternal::BasicStream*) const;
    virtual void __read(::IceInternal::BasicStream*, bool);
// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
    virtual void __write(const ::Ice::OutputStreamPtr&) const;
    virtual void __read(const ::Ice::InputStreamPtr&, bool);
#endif

    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:

    virtual ~ImportSettings() {}

public:

    ::omero::model::IObjectPtr userSpecifiedTarget;

    ::omero::RStringPtr userSpecifiedName;

    ::omero::RStringPtr userSpecifiedDescription;

    ::omero::api::DoubleArray userSpecifiedPixels;

    ::omero::api::AnnotationList userSpecifiedAnnotationList;

    ::omero::RBoolPtr doThumbnails;

    ::omero::model::ChecksumAlgorithmPtr checksumAlgorithm;
};

inline bool operator==(const ImportSettings& l, const ImportSettings& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const ImportSettings& l, const ImportSettings& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class ImportProcess : virtual public ::omero::api::StatefulServiceInterface
{
public:

    typedef ImportProcessPrx ProxyType;
    typedef ImportProcessPtr PointerType;
    
    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual ::omero::api::RawFileStorePrx getUploader(::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getUploader(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::cmd::HandlePrx verifyUpload(const ::omero::api::StringSet&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___verifyUpload(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Long getUploadOffset(::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getUploadOffset(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::cmd::HandlePrx getHandle(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getHandle(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::grid::ImportSettingsPtr getImportSettings(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getImportSettings(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void __write(::IceInternal::BasicStream*) const;
    virtual void __read(::IceInternal::BasicStream*, bool);
// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
    virtual void __write(const ::Ice::OutputStreamPtr&) const;
    virtual void __read(const ::Ice::InputStreamPtr&, bool);
#endif
};

inline bool operator==(const ImportProcess& l, const ImportProcess& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const ImportProcess& l, const ImportProcess& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class ImportRequest : public ::omero::cmd::Request, private IceInternal::GCShared
{
public:

    typedef ImportRequestPrx ProxyType;
    typedef ImportRequestPtr PointerType;
    
    ImportRequest() {}
    ImportRequest(const ::std::string&, const ::std::string&, const ::omero::grid::ImportProcessPrx&, const ::omero::model::FilesetJobLinkPtr&, const ::omero::grid::ImportSettingsPtr&, const ::omero::grid::ImportLocationPtr&, const ::omero::model::OriginalFilePtr&);
    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void __addObject(::IceInternal::GCCountMap&);
    virtual bool __usesClasses();
    virtual void __gcReachable(::IceInternal::GCCountMap&) const;
    virtual void __gcClear();

    virtual void __write(::IceInternal::BasicStream*) const;
    virtual void __read(::IceInternal::BasicStream*, bool);
// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
    virtual void __write(const ::Ice::OutputStreamPtr&) const;
    virtual void __read(const ::Ice::InputStreamPtr&, bool);
#endif

    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:

    virtual ~ImportRequest() {}

public:

    ::std::string clientUuid;

    ::std::string repoUuid;

    ::omero::grid::ImportProcessPrx process;

    ::omero::model::FilesetJobLinkPtr activity;

    ::omero::grid::ImportSettingsPtr settings;

    ::omero::grid::ImportLocationPtr location;

    ::omero::model::OriginalFilePtr logFile;
};

inline bool operator==(const ImportRequest& l, const ImportRequest& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const ImportRequest& l, const ImportRequest& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class ImportResponse : public ::omero::cmd::Response, private IceInternal::GCShared
{
public:

    typedef ImportResponsePrx ProxyType;
    typedef ImportResponsePtr PointerType;
    
    ImportResponse() {}
    ImportResponse(const ::omero::api::PixelsList&, const ::omero::api::IObjectList&);
    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void __addObject(::IceInternal::GCCountMap&);
    virtual bool __usesClasses();
    virtual void __gcReachable(::IceInternal::GCCountMap&) const;
    virtual void __gcClear();

    virtual void __write(::IceInternal::BasicStream*) const;
    virtual void __read(::IceInternal::BasicStream*, bool);
// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
    virtual void __write(const ::Ice::OutputStreamPtr&) const;
    virtual void __read(const ::Ice::InputStreamPtr&, bool);
#endif

    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:

    virtual ~ImportResponse() {}

public:

    ::omero::api::PixelsList pixels;

    ::omero::api::IObjectList objects;
};

inline bool operator==(const ImportResponse& l, const ImportResponse& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const ImportResponse& l, const ImportResponse& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class ManagedRepository : virtual public ::omero::grid::Repository
{
public:

    typedef ManagedRepositoryPrx ProxyType;
    typedef ManagedRepositoryPtr PointerType;
    
    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual ::omero::grid::ImportProcessPrx importFileset(const ::omero::model::FilesetPtr&, const ::omero::grid::ImportSettingsPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___importFileset(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::grid::ImportProcessPrx importPaths(const ::omero::api::StringSet&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___importPaths(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::grid::ImportProcessList listImports(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___listImports(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::api::ChecksumAlgorithmList listChecksumAlgorithms(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___listChecksumAlgorithms(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::model::ChecksumAlgorithmPtr suggestChecksumAlgorithm(const ::omero::api::ChecksumAlgorithmList&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___suggestChecksumAlgorithm(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void __write(::IceInternal::BasicStream*) const;
    virtual void __read(::IceInternal::BasicStream*, bool);
// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
    virtual void __write(const ::Ice::OutputStreamPtr&) const;
    virtual void __read(const ::Ice::InputStreamPtr&, bool);
#endif
};

inline bool operator==(const ManagedRepository& l, const ManagedRepository& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const ManagedRepository& l, const ManagedRepository& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class RawAccessRequest : public ::omero::cmd::Request
{
public:

    typedef RawAccessRequestPrx ProxyType;
    typedef RawAccessRequestPtr PointerType;
    
    RawAccessRequest() {}
    RawAccessRequest(const ::std::string&, const ::std::string&, const ::omero::api::StringSet&, const ::std::string&);
    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();


    virtual void __write(::IceInternal::BasicStream*) const;
    virtual void __read(::IceInternal::BasicStream*, bool);
// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
    virtual void __write(const ::Ice::OutputStreamPtr&) const;
    virtual void __read(const ::Ice::InputStreamPtr&, bool);
#endif

    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:

    virtual ~RawAccessRequest() {}

public:

    ::std::string repoUuid;

    ::std::string command;

    ::omero::api::StringSet args;

    ::std::string path;
};

inline bool operator==(const RawAccessRequest& l, const RawAccessRequest& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const RawAccessRequest& l, const RawAccessRequest& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class InternalRepository : virtual public ::Ice::Object
{
public:

    typedef InternalRepositoryPrx ProxyType;
    typedef InternalRepositoryPtr PointerType;
    
    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual ::omero::api::RawFileStorePrx createRawFileStore(const ::omero::model::OriginalFilePtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___createRawFileStore(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::api::RawPixelsStorePrx createRawPixelsStore(const ::omero::model::OriginalFilePtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___createRawPixelsStore(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::api::RenderingEnginePrx createRenderingEngine(const ::omero::model::OriginalFilePtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___createRenderingEngine(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::api::ThumbnailStorePrx createThumbnailStore(const ::omero::model::OriginalFilePtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___createThumbnailStore(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::model::OriginalFilePtr getDescription(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getDescription(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::grid::RepositoryPrx getProxy(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getProxy(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::cmd::ResponsePtr rawAccess(const ::omero::grid::RawAccessRequestPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___rawAccess(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::std::string getFilePath(const ::omero::model::OriginalFilePtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getFilePath(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void __write(::IceInternal::BasicStream*) const;
    virtual void __read(::IceInternal::BasicStream*, bool);
// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
    virtual void __write(const ::Ice::OutputStreamPtr&) const;
    virtual void __read(const ::Ice::InputStreamPtr&, bool);
#endif
};

inline bool operator==(const InternalRepository& l, const InternalRepository& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const InternalRepository& l, const InternalRepository& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

}

}

namespace omero
{

namespace grid
{

template<class T>
class CallbackNC_Repository_root : public Callback_Repository_root_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::model::OriginalFilePtr&);

    CallbackNC_Repository_root(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::RepositoryPrx __proxy = ::omero::grid::RepositoryPrx::uncheckedCast(__result->getProxy());
        ::omero::model::OriginalFilePtr __ret;
        try
        {
            __ret = __proxy->end_root(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_Repository_rootPtr
newCallback_Repository_root(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::OriginalFilePtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Repository_root<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Repository_rootPtr
newCallback_Repository_root(T* instance, void (T::*cb)(const ::omero::model::OriginalFilePtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Repository_root<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Repository_root : public Callback_Repository_root_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::model::OriginalFilePtr&, const CT&);

    Callback_Repository_root(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::RepositoryPrx __proxy = ::omero::grid::RepositoryPrx::uncheckedCast(__result->getProxy());
        ::omero::model::OriginalFilePtr __ret;
        try
        {
            __ret = __proxy->end_root(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Repository_rootPtr
newCallback_Repository_root(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::OriginalFilePtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Repository_root<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Repository_rootPtr
newCallback_Repository_root(T* instance, void (T::*cb)(const ::omero::model::OriginalFilePtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Repository_root<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Repository_mimetype : public Callback_Repository_mimetype_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_Repository_mimetype(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::RepositoryPrx __proxy = ::omero::grid::RepositoryPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_mimetype(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_Repository_mimetypePtr
newCallback_Repository_mimetype(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Repository_mimetype<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Repository_mimetypePtr
newCallback_Repository_mimetype(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Repository_mimetype<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Repository_mimetype : public Callback_Repository_mimetype_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_Repository_mimetype(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::RepositoryPrx __proxy = ::omero::grid::RepositoryPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_mimetype(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Repository_mimetypePtr
newCallback_Repository_mimetype(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Repository_mimetype<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Repository_mimetypePtr
newCallback_Repository_mimetype(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Repository_mimetype<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Repository_list : public Callback_Repository_list_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::api::StringSet&);

    CallbackNC_Repository_list(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::RepositoryPrx __proxy = ::omero::grid::RepositoryPrx::uncheckedCast(__result->getProxy());
        ::omero::api::StringSet __ret;
        try
        {
            __ret = __proxy->end_list(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_Repository_listPtr
newCallback_Repository_list(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::StringSet&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Repository_list<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Repository_listPtr
newCallback_Repository_list(T* instance, void (T::*cb)(const ::omero::api::StringSet&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Repository_list<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Repository_list : public Callback_Repository_list_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::api::StringSet&, const CT&);

    Callback_Repository_list(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::RepositoryPrx __proxy = ::omero::grid::RepositoryPrx::uncheckedCast(__result->getProxy());
        ::omero::api::StringSet __ret;
        try
        {
            __ret = __proxy->end_list(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Repository_listPtr
newCallback_Repository_list(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::StringSet&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Repository_list<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Repository_listPtr
newCallback_Repository_list(T* instance, void (T::*cb)(const ::omero::api::StringSet&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Repository_list<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Repository_listFiles : public Callback_Repository_listFiles_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::api::OriginalFileList&);

    CallbackNC_Repository_listFiles(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::RepositoryPrx __proxy = ::omero::grid::RepositoryPrx::uncheckedCast(__result->getProxy());
        ::omero::api::OriginalFileList __ret;
        try
        {
            __ret = __proxy->end_listFiles(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_Repository_listFilesPtr
newCallback_Repository_listFiles(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::OriginalFileList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Repository_listFiles<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Repository_listFilesPtr
newCallback_Repository_listFiles(T* instance, void (T::*cb)(const ::omero::api::OriginalFileList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Repository_listFiles<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Repository_listFiles : public Callback_Repository_listFiles_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::api::OriginalFileList&, const CT&);

    Callback_Repository_listFiles(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::RepositoryPrx __proxy = ::omero::grid::RepositoryPrx::uncheckedCast(__result->getProxy());
        ::omero::api::OriginalFileList __ret;
        try
        {
            __ret = __proxy->end_listFiles(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Repository_listFilesPtr
newCallback_Repository_listFiles(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::OriginalFileList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Repository_listFiles<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Repository_listFilesPtr
newCallback_Repository_listFiles(T* instance, void (T::*cb)(const ::omero::api::OriginalFileList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Repository_listFiles<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Repository_register : public Callback_Repository_register_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::model::OriginalFilePtr&);

    CallbackNC_Repository_register(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::RepositoryPrx __proxy = ::omero::grid::RepositoryPrx::uncheckedCast(__result->getProxy());
        ::omero::model::OriginalFilePtr __ret;
        try
        {
            __ret = __proxy->end_register(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_Repository_registerPtr
newCallback_Repository_register(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::OriginalFilePtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Repository_register<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Repository_registerPtr
newCallback_Repository_register(T* instance, void (T::*cb)(const ::omero::model::OriginalFilePtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Repository_register<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Repository_register : public Callback_Repository_register_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::model::OriginalFilePtr&, const CT&);

    Callback_Repository_register(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::RepositoryPrx __proxy = ::omero::grid::RepositoryPrx::uncheckedCast(__result->getProxy());
        ::omero::model::OriginalFilePtr __ret;
        try
        {
            __ret = __proxy->end_register(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Repository_registerPtr
newCallback_Repository_register(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::OriginalFilePtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Repository_register<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Repository_registerPtr
newCallback_Repository_register(T* instance, void (T::*cb)(const ::omero::model::OriginalFilePtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Repository_register<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Repository_file : public Callback_Repository_file_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::api::RawFileStorePrx&);

    CallbackNC_Repository_file(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::RepositoryPrx __proxy = ::omero::grid::RepositoryPrx::uncheckedCast(__result->getProxy());
        ::omero::api::RawFileStorePrx __ret;
        try
        {
            __ret = __proxy->end_file(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_Repository_filePtr
newCallback_Repository_file(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::RawFileStorePrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Repository_file<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Repository_filePtr
newCallback_Repository_file(T* instance, void (T::*cb)(const ::omero::api::RawFileStorePrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Repository_file<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Repository_file : public Callback_Repository_file_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::api::RawFileStorePrx&, const CT&);

    Callback_Repository_file(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::RepositoryPrx __proxy = ::omero::grid::RepositoryPrx::uncheckedCast(__result->getProxy());
        ::omero::api::RawFileStorePrx __ret;
        try
        {
            __ret = __proxy->end_file(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Repository_filePtr
newCallback_Repository_file(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::RawFileStorePrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Repository_file<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Repository_filePtr
newCallback_Repository_file(T* instance, void (T::*cb)(const ::omero::api::RawFileStorePrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Repository_file<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Repository_pixels : public Callback_Repository_pixels_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::api::RawPixelsStorePrx&);

    CallbackNC_Repository_pixels(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::RepositoryPrx __proxy = ::omero::grid::RepositoryPrx::uncheckedCast(__result->getProxy());
        ::omero::api::RawPixelsStorePrx __ret;
        try
        {
            __ret = __proxy->end_pixels(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_Repository_pixelsPtr
newCallback_Repository_pixels(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::RawPixelsStorePrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Repository_pixels<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Repository_pixelsPtr
newCallback_Repository_pixels(T* instance, void (T::*cb)(const ::omero::api::RawPixelsStorePrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Repository_pixels<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Repository_pixels : public Callback_Repository_pixels_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::api::RawPixelsStorePrx&, const CT&);

    Callback_Repository_pixels(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::RepositoryPrx __proxy = ::omero::grid::RepositoryPrx::uncheckedCast(__result->getProxy());
        ::omero::api::RawPixelsStorePrx __ret;
        try
        {
            __ret = __proxy->end_pixels(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Repository_pixelsPtr
newCallback_Repository_pixels(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::RawPixelsStorePrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Repository_pixels<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Repository_pixelsPtr
newCallback_Repository_pixels(T* instance, void (T::*cb)(const ::omero::api::RawPixelsStorePrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Repository_pixels<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Repository_fileById : public Callback_Repository_fileById_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::api::RawFileStorePrx&);

    CallbackNC_Repository_fileById(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::RepositoryPrx __proxy = ::omero::grid::RepositoryPrx::uncheckedCast(__result->getProxy());
        ::omero::api::RawFileStorePrx __ret;
        try
        {
            __ret = __proxy->end_fileById(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_Repository_fileByIdPtr
newCallback_Repository_fileById(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::RawFileStorePrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Repository_fileById<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Repository_fileByIdPtr
newCallback_Repository_fileById(T* instance, void (T::*cb)(const ::omero::api::RawFileStorePrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Repository_fileById<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Repository_fileById : public Callback_Repository_fileById_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::api::RawFileStorePrx&, const CT&);

    Callback_Repository_fileById(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::RepositoryPrx __proxy = ::omero::grid::RepositoryPrx::uncheckedCast(__result->getProxy());
        ::omero::api::RawFileStorePrx __ret;
        try
        {
            __ret = __proxy->end_fileById(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Repository_fileByIdPtr
newCallback_Repository_fileById(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::RawFileStorePrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Repository_fileById<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Repository_fileByIdPtr
newCallback_Repository_fileById(T* instance, void (T::*cb)(const ::omero::api::RawFileStorePrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Repository_fileById<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Repository_fileExists : public Callback_Repository_fileExists_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_Repository_fileExists(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::RepositoryPrx __proxy = ::omero::grid::RepositoryPrx::uncheckedCast(__result->getProxy());
        bool __ret;
        try
        {
            __ret = __proxy->end_fileExists(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_Repository_fileExistsPtr
newCallback_Repository_fileExists(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Repository_fileExists<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Repository_fileExistsPtr
newCallback_Repository_fileExists(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Repository_fileExists<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Repository_fileExists : public Callback_Repository_fileExists_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_Repository_fileExists(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::RepositoryPrx __proxy = ::omero::grid::RepositoryPrx::uncheckedCast(__result->getProxy());
        bool __ret;
        try
        {
            __ret = __proxy->end_fileExists(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Repository_fileExistsPtr
newCallback_Repository_fileExists(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Repository_fileExists<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Repository_fileExistsPtr
newCallback_Repository_fileExists(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Repository_fileExists<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Repository_makeDir : public Callback_Repository_makeDir_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Repository_makeDir(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::RepositoryPrx __proxy = ::omero::grid::RepositoryPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_makeDir(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)();
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
#endif
        }
    }

    Response response;
};

template<class T> Callback_Repository_makeDirPtr
newCallback_Repository_makeDir(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Repository_makeDir<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Repository_makeDirPtr
newCallback_Repository_makeDir(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Repository_makeDir<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Repository_makeDirPtr
newCallback_Repository_makeDir(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Repository_makeDir<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Repository_makeDirPtr
newCallback_Repository_makeDir(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Repository_makeDir<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Repository_makeDir : public Callback_Repository_makeDir_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Repository_makeDir(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::RepositoryPrx __proxy = ::omero::grid::RepositoryPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_makeDir(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Repository_makeDirPtr
newCallback_Repository_makeDir(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Repository_makeDir<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Repository_makeDirPtr
newCallback_Repository_makeDir(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Repository_makeDir<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Repository_makeDirPtr
newCallback_Repository_makeDir(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Repository_makeDir<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Repository_makeDirPtr
newCallback_Repository_makeDir(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Repository_makeDir<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Repository_treeList : public Callback_Repository_treeList_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::RMapPtr&);

    CallbackNC_Repository_treeList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::RepositoryPrx __proxy = ::omero::grid::RepositoryPrx::uncheckedCast(__result->getProxy());
        ::omero::RMapPtr __ret;
        try
        {
            __ret = __proxy->end_treeList(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_Repository_treeListPtr
newCallback_Repository_treeList(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RMapPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Repository_treeList<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Repository_treeListPtr
newCallback_Repository_treeList(T* instance, void (T::*cb)(const ::omero::RMapPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Repository_treeList<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Repository_treeList : public Callback_Repository_treeList_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::RMapPtr&, const CT&);

    Callback_Repository_treeList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::RepositoryPrx __proxy = ::omero::grid::RepositoryPrx::uncheckedCast(__result->getProxy());
        ::omero::RMapPtr __ret;
        try
        {
            __ret = __proxy->end_treeList(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Repository_treeListPtr
newCallback_Repository_treeList(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RMapPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Repository_treeList<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Repository_treeListPtr
newCallback_Repository_treeList(T* instance, void (T::*cb)(const ::omero::RMapPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Repository_treeList<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Repository_deletePaths : public Callback_Repository_deletePaths_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::cmd::HandlePrx&);

    CallbackNC_Repository_deletePaths(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::RepositoryPrx __proxy = ::omero::grid::RepositoryPrx::uncheckedCast(__result->getProxy());
        ::omero::cmd::HandlePrx __ret;
        try
        {
            __ret = __proxy->end_deletePaths(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_Repository_deletePathsPtr
newCallback_Repository_deletePaths(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::cmd::HandlePrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Repository_deletePaths<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Repository_deletePathsPtr
newCallback_Repository_deletePaths(T* instance, void (T::*cb)(const ::omero::cmd::HandlePrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Repository_deletePaths<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Repository_deletePaths : public Callback_Repository_deletePaths_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::cmd::HandlePrx&, const CT&);

    Callback_Repository_deletePaths(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::RepositoryPrx __proxy = ::omero::grid::RepositoryPrx::uncheckedCast(__result->getProxy());
        ::omero::cmd::HandlePrx __ret;
        try
        {
            __ret = __proxy->end_deletePaths(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Repository_deletePathsPtr
newCallback_Repository_deletePaths(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::cmd::HandlePrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Repository_deletePaths<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Repository_deletePathsPtr
newCallback_Repository_deletePaths(T* instance, void (T::*cb)(const ::omero::cmd::HandlePrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Repository_deletePaths<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_ImportProcess_getUploader : public Callback_ImportProcess_getUploader_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::api::RawFileStorePrx&);

    CallbackNC_ImportProcess_getUploader(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::ImportProcessPrx __proxy = ::omero::grid::ImportProcessPrx::uncheckedCast(__result->getProxy());
        ::omero::api::RawFileStorePrx __ret;
        try
        {
            __ret = __proxy->end_getUploader(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_ImportProcess_getUploaderPtr
newCallback_ImportProcess_getUploader(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::RawFileStorePrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ImportProcess_getUploader<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ImportProcess_getUploaderPtr
newCallback_ImportProcess_getUploader(T* instance, void (T::*cb)(const ::omero::api::RawFileStorePrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ImportProcess_getUploader<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_ImportProcess_getUploader : public Callback_ImportProcess_getUploader_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::api::RawFileStorePrx&, const CT&);

    Callback_ImportProcess_getUploader(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::ImportProcessPrx __proxy = ::omero::grid::ImportProcessPrx::uncheckedCast(__result->getProxy());
        ::omero::api::RawFileStorePrx __ret;
        try
        {
            __ret = __proxy->end_getUploader(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ImportProcess_getUploaderPtr
newCallback_ImportProcess_getUploader(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::RawFileStorePrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ImportProcess_getUploader<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ImportProcess_getUploaderPtr
newCallback_ImportProcess_getUploader(T* instance, void (T::*cb)(const ::omero::api::RawFileStorePrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ImportProcess_getUploader<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_ImportProcess_verifyUpload : public Callback_ImportProcess_verifyUpload_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::cmd::HandlePrx&);

    CallbackNC_ImportProcess_verifyUpload(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::ImportProcessPrx __proxy = ::omero::grid::ImportProcessPrx::uncheckedCast(__result->getProxy());
        ::omero::cmd::HandlePrx __ret;
        try
        {
            __ret = __proxy->end_verifyUpload(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_ImportProcess_verifyUploadPtr
newCallback_ImportProcess_verifyUpload(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::cmd::HandlePrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ImportProcess_verifyUpload<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ImportProcess_verifyUploadPtr
newCallback_ImportProcess_verifyUpload(T* instance, void (T::*cb)(const ::omero::cmd::HandlePrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ImportProcess_verifyUpload<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_ImportProcess_verifyUpload : public Callback_ImportProcess_verifyUpload_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::cmd::HandlePrx&, const CT&);

    Callback_ImportProcess_verifyUpload(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::ImportProcessPrx __proxy = ::omero::grid::ImportProcessPrx::uncheckedCast(__result->getProxy());
        ::omero::cmd::HandlePrx __ret;
        try
        {
            __ret = __proxy->end_verifyUpload(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ImportProcess_verifyUploadPtr
newCallback_ImportProcess_verifyUpload(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::cmd::HandlePrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ImportProcess_verifyUpload<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ImportProcess_verifyUploadPtr
newCallback_ImportProcess_verifyUpload(T* instance, void (T::*cb)(const ::omero::cmd::HandlePrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ImportProcess_verifyUpload<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_ImportProcess_getUploadOffset : public Callback_ImportProcess_getUploadOffset_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Long);

    CallbackNC_ImportProcess_getUploadOffset(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::ImportProcessPrx __proxy = ::omero::grid::ImportProcessPrx::uncheckedCast(__result->getProxy());
        ::Ice::Long __ret;
        try
        {
            __ret = __proxy->end_getUploadOffset(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_ImportProcess_getUploadOffsetPtr
newCallback_ImportProcess_getUploadOffset(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Long), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ImportProcess_getUploadOffset<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ImportProcess_getUploadOffsetPtr
newCallback_ImportProcess_getUploadOffset(T* instance, void (T::*cb)(::Ice::Long), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ImportProcess_getUploadOffset<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_ImportProcess_getUploadOffset : public Callback_ImportProcess_getUploadOffset_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Long, const CT&);

    Callback_ImportProcess_getUploadOffset(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::ImportProcessPrx __proxy = ::omero::grid::ImportProcessPrx::uncheckedCast(__result->getProxy());
        ::Ice::Long __ret;
        try
        {
            __ret = __proxy->end_getUploadOffset(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ImportProcess_getUploadOffsetPtr
newCallback_ImportProcess_getUploadOffset(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Long, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ImportProcess_getUploadOffset<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ImportProcess_getUploadOffsetPtr
newCallback_ImportProcess_getUploadOffset(T* instance, void (T::*cb)(::Ice::Long, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ImportProcess_getUploadOffset<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_ImportProcess_getHandle : public Callback_ImportProcess_getHandle_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::cmd::HandlePrx&);

    CallbackNC_ImportProcess_getHandle(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::ImportProcessPrx __proxy = ::omero::grid::ImportProcessPrx::uncheckedCast(__result->getProxy());
        ::omero::cmd::HandlePrx __ret;
        try
        {
            __ret = __proxy->end_getHandle(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_ImportProcess_getHandlePtr
newCallback_ImportProcess_getHandle(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::cmd::HandlePrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ImportProcess_getHandle<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ImportProcess_getHandlePtr
newCallback_ImportProcess_getHandle(T* instance, void (T::*cb)(const ::omero::cmd::HandlePrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ImportProcess_getHandle<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_ImportProcess_getHandle : public Callback_ImportProcess_getHandle_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::cmd::HandlePrx&, const CT&);

    Callback_ImportProcess_getHandle(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::ImportProcessPrx __proxy = ::omero::grid::ImportProcessPrx::uncheckedCast(__result->getProxy());
        ::omero::cmd::HandlePrx __ret;
        try
        {
            __ret = __proxy->end_getHandle(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ImportProcess_getHandlePtr
newCallback_ImportProcess_getHandle(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::cmd::HandlePrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ImportProcess_getHandle<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ImportProcess_getHandlePtr
newCallback_ImportProcess_getHandle(T* instance, void (T::*cb)(const ::omero::cmd::HandlePrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ImportProcess_getHandle<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_ImportProcess_getImportSettings : public Callback_ImportProcess_getImportSettings_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::grid::ImportSettingsPtr&);

    CallbackNC_ImportProcess_getImportSettings(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::ImportProcessPrx __proxy = ::omero::grid::ImportProcessPrx::uncheckedCast(__result->getProxy());
        ::omero::grid::ImportSettingsPtr __ret;
        try
        {
            __ret = __proxy->end_getImportSettings(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_ImportProcess_getImportSettingsPtr
newCallback_ImportProcess_getImportSettings(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::grid::ImportSettingsPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ImportProcess_getImportSettings<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ImportProcess_getImportSettingsPtr
newCallback_ImportProcess_getImportSettings(T* instance, void (T::*cb)(const ::omero::grid::ImportSettingsPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ImportProcess_getImportSettings<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_ImportProcess_getImportSettings : public Callback_ImportProcess_getImportSettings_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::grid::ImportSettingsPtr&, const CT&);

    Callback_ImportProcess_getImportSettings(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::ImportProcessPrx __proxy = ::omero::grid::ImportProcessPrx::uncheckedCast(__result->getProxy());
        ::omero::grid::ImportSettingsPtr __ret;
        try
        {
            __ret = __proxy->end_getImportSettings(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ImportProcess_getImportSettingsPtr
newCallback_ImportProcess_getImportSettings(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::grid::ImportSettingsPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ImportProcess_getImportSettings<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ImportProcess_getImportSettingsPtr
newCallback_ImportProcess_getImportSettings(T* instance, void (T::*cb)(const ::omero::grid::ImportSettingsPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ImportProcess_getImportSettings<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_ManagedRepository_importFileset : public Callback_ManagedRepository_importFileset_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::grid::ImportProcessPrx&);

    CallbackNC_ManagedRepository_importFileset(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::ManagedRepositoryPrx __proxy = ::omero::grid::ManagedRepositoryPrx::uncheckedCast(__result->getProxy());
        ::omero::grid::ImportProcessPrx __ret;
        try
        {
            __ret = __proxy->end_importFileset(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_ManagedRepository_importFilesetPtr
newCallback_ManagedRepository_importFileset(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::grid::ImportProcessPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ManagedRepository_importFileset<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ManagedRepository_importFilesetPtr
newCallback_ManagedRepository_importFileset(T* instance, void (T::*cb)(const ::omero::grid::ImportProcessPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ManagedRepository_importFileset<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_ManagedRepository_importFileset : public Callback_ManagedRepository_importFileset_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::grid::ImportProcessPrx&, const CT&);

    Callback_ManagedRepository_importFileset(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::ManagedRepositoryPrx __proxy = ::omero::grid::ManagedRepositoryPrx::uncheckedCast(__result->getProxy());
        ::omero::grid::ImportProcessPrx __ret;
        try
        {
            __ret = __proxy->end_importFileset(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ManagedRepository_importFilesetPtr
newCallback_ManagedRepository_importFileset(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::grid::ImportProcessPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ManagedRepository_importFileset<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ManagedRepository_importFilesetPtr
newCallback_ManagedRepository_importFileset(T* instance, void (T::*cb)(const ::omero::grid::ImportProcessPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ManagedRepository_importFileset<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_ManagedRepository_importPaths : public Callback_ManagedRepository_importPaths_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::grid::ImportProcessPrx&);

    CallbackNC_ManagedRepository_importPaths(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::ManagedRepositoryPrx __proxy = ::omero::grid::ManagedRepositoryPrx::uncheckedCast(__result->getProxy());
        ::omero::grid::ImportProcessPrx __ret;
        try
        {
            __ret = __proxy->end_importPaths(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_ManagedRepository_importPathsPtr
newCallback_ManagedRepository_importPaths(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::grid::ImportProcessPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ManagedRepository_importPaths<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ManagedRepository_importPathsPtr
newCallback_ManagedRepository_importPaths(T* instance, void (T::*cb)(const ::omero::grid::ImportProcessPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ManagedRepository_importPaths<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_ManagedRepository_importPaths : public Callback_ManagedRepository_importPaths_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::grid::ImportProcessPrx&, const CT&);

    Callback_ManagedRepository_importPaths(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::ManagedRepositoryPrx __proxy = ::omero::grid::ManagedRepositoryPrx::uncheckedCast(__result->getProxy());
        ::omero::grid::ImportProcessPrx __ret;
        try
        {
            __ret = __proxy->end_importPaths(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ManagedRepository_importPathsPtr
newCallback_ManagedRepository_importPaths(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::grid::ImportProcessPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ManagedRepository_importPaths<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ManagedRepository_importPathsPtr
newCallback_ManagedRepository_importPaths(T* instance, void (T::*cb)(const ::omero::grid::ImportProcessPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ManagedRepository_importPaths<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_ManagedRepository_listImports : public Callback_ManagedRepository_listImports_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::grid::ImportProcessList&);

    CallbackNC_ManagedRepository_listImports(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::ManagedRepositoryPrx __proxy = ::omero::grid::ManagedRepositoryPrx::uncheckedCast(__result->getProxy());
        ::omero::grid::ImportProcessList __ret;
        try
        {
            __ret = __proxy->end_listImports(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_ManagedRepository_listImportsPtr
newCallback_ManagedRepository_listImports(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::grid::ImportProcessList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ManagedRepository_listImports<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ManagedRepository_listImportsPtr
newCallback_ManagedRepository_listImports(T* instance, void (T::*cb)(const ::omero::grid::ImportProcessList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ManagedRepository_listImports<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_ManagedRepository_listImports : public Callback_ManagedRepository_listImports_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::grid::ImportProcessList&, const CT&);

    Callback_ManagedRepository_listImports(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::ManagedRepositoryPrx __proxy = ::omero::grid::ManagedRepositoryPrx::uncheckedCast(__result->getProxy());
        ::omero::grid::ImportProcessList __ret;
        try
        {
            __ret = __proxy->end_listImports(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ManagedRepository_listImportsPtr
newCallback_ManagedRepository_listImports(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::grid::ImportProcessList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ManagedRepository_listImports<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ManagedRepository_listImportsPtr
newCallback_ManagedRepository_listImports(T* instance, void (T::*cb)(const ::omero::grid::ImportProcessList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ManagedRepository_listImports<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_ManagedRepository_listChecksumAlgorithms : public Callback_ManagedRepository_listChecksumAlgorithms_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::api::ChecksumAlgorithmList&);

    CallbackNC_ManagedRepository_listChecksumAlgorithms(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::ManagedRepositoryPrx __proxy = ::omero::grid::ManagedRepositoryPrx::uncheckedCast(__result->getProxy());
        ::omero::api::ChecksumAlgorithmList __ret;
        try
        {
            __ret = __proxy->end_listChecksumAlgorithms(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_ManagedRepository_listChecksumAlgorithmsPtr
newCallback_ManagedRepository_listChecksumAlgorithms(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::ChecksumAlgorithmList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ManagedRepository_listChecksumAlgorithms<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ManagedRepository_listChecksumAlgorithmsPtr
newCallback_ManagedRepository_listChecksumAlgorithms(T* instance, void (T::*cb)(const ::omero::api::ChecksumAlgorithmList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ManagedRepository_listChecksumAlgorithms<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_ManagedRepository_listChecksumAlgorithms : public Callback_ManagedRepository_listChecksumAlgorithms_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::api::ChecksumAlgorithmList&, const CT&);

    Callback_ManagedRepository_listChecksumAlgorithms(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::ManagedRepositoryPrx __proxy = ::omero::grid::ManagedRepositoryPrx::uncheckedCast(__result->getProxy());
        ::omero::api::ChecksumAlgorithmList __ret;
        try
        {
            __ret = __proxy->end_listChecksumAlgorithms(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ManagedRepository_listChecksumAlgorithmsPtr
newCallback_ManagedRepository_listChecksumAlgorithms(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::ChecksumAlgorithmList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ManagedRepository_listChecksumAlgorithms<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ManagedRepository_listChecksumAlgorithmsPtr
newCallback_ManagedRepository_listChecksumAlgorithms(T* instance, void (T::*cb)(const ::omero::api::ChecksumAlgorithmList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ManagedRepository_listChecksumAlgorithms<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_ManagedRepository_suggestChecksumAlgorithm : public Callback_ManagedRepository_suggestChecksumAlgorithm_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::model::ChecksumAlgorithmPtr&);

    CallbackNC_ManagedRepository_suggestChecksumAlgorithm(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::ManagedRepositoryPrx __proxy = ::omero::grid::ManagedRepositoryPrx::uncheckedCast(__result->getProxy());
        ::omero::model::ChecksumAlgorithmPtr __ret;
        try
        {
            __ret = __proxy->end_suggestChecksumAlgorithm(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_ManagedRepository_suggestChecksumAlgorithmPtr
newCallback_ManagedRepository_suggestChecksumAlgorithm(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::ChecksumAlgorithmPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ManagedRepository_suggestChecksumAlgorithm<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ManagedRepository_suggestChecksumAlgorithmPtr
newCallback_ManagedRepository_suggestChecksumAlgorithm(T* instance, void (T::*cb)(const ::omero::model::ChecksumAlgorithmPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ManagedRepository_suggestChecksumAlgorithm<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_ManagedRepository_suggestChecksumAlgorithm : public Callback_ManagedRepository_suggestChecksumAlgorithm_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::model::ChecksumAlgorithmPtr&, const CT&);

    Callback_ManagedRepository_suggestChecksumAlgorithm(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::ManagedRepositoryPrx __proxy = ::omero::grid::ManagedRepositoryPrx::uncheckedCast(__result->getProxy());
        ::omero::model::ChecksumAlgorithmPtr __ret;
        try
        {
            __ret = __proxy->end_suggestChecksumAlgorithm(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ManagedRepository_suggestChecksumAlgorithmPtr
newCallback_ManagedRepository_suggestChecksumAlgorithm(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::ChecksumAlgorithmPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ManagedRepository_suggestChecksumAlgorithm<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ManagedRepository_suggestChecksumAlgorithmPtr
newCallback_ManagedRepository_suggestChecksumAlgorithm(T* instance, void (T::*cb)(const ::omero::model::ChecksumAlgorithmPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ManagedRepository_suggestChecksumAlgorithm<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_InternalRepository_createRawFileStore : public Callback_InternalRepository_createRawFileStore_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::api::RawFileStorePrx&);

    CallbackNC_InternalRepository_createRawFileStore(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::InternalRepositoryPrx __proxy = ::omero::grid::InternalRepositoryPrx::uncheckedCast(__result->getProxy());
        ::omero::api::RawFileStorePrx __ret;
        try
        {
            __ret = __proxy->end_createRawFileStore(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_InternalRepository_createRawFileStorePtr
newCallback_InternalRepository_createRawFileStore(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::RawFileStorePrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InternalRepository_createRawFileStore<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_InternalRepository_createRawFileStorePtr
newCallback_InternalRepository_createRawFileStore(T* instance, void (T::*cb)(const ::omero::api::RawFileStorePrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InternalRepository_createRawFileStore<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_InternalRepository_createRawFileStore : public Callback_InternalRepository_createRawFileStore_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::api::RawFileStorePrx&, const CT&);

    Callback_InternalRepository_createRawFileStore(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::InternalRepositoryPrx __proxy = ::omero::grid::InternalRepositoryPrx::uncheckedCast(__result->getProxy());
        ::omero::api::RawFileStorePrx __ret;
        try
        {
            __ret = __proxy->end_createRawFileStore(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_InternalRepository_createRawFileStorePtr
newCallback_InternalRepository_createRawFileStore(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::RawFileStorePrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InternalRepository_createRawFileStore<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_InternalRepository_createRawFileStorePtr
newCallback_InternalRepository_createRawFileStore(T* instance, void (T::*cb)(const ::omero::api::RawFileStorePrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InternalRepository_createRawFileStore<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_InternalRepository_createRawPixelsStore : public Callback_InternalRepository_createRawPixelsStore_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::api::RawPixelsStorePrx&);

    CallbackNC_InternalRepository_createRawPixelsStore(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::InternalRepositoryPrx __proxy = ::omero::grid::InternalRepositoryPrx::uncheckedCast(__result->getProxy());
        ::omero::api::RawPixelsStorePrx __ret;
        try
        {
            __ret = __proxy->end_createRawPixelsStore(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_InternalRepository_createRawPixelsStorePtr
newCallback_InternalRepository_createRawPixelsStore(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::RawPixelsStorePrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InternalRepository_createRawPixelsStore<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_InternalRepository_createRawPixelsStorePtr
newCallback_InternalRepository_createRawPixelsStore(T* instance, void (T::*cb)(const ::omero::api::RawPixelsStorePrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InternalRepository_createRawPixelsStore<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_InternalRepository_createRawPixelsStore : public Callback_InternalRepository_createRawPixelsStore_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::api::RawPixelsStorePrx&, const CT&);

    Callback_InternalRepository_createRawPixelsStore(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::InternalRepositoryPrx __proxy = ::omero::grid::InternalRepositoryPrx::uncheckedCast(__result->getProxy());
        ::omero::api::RawPixelsStorePrx __ret;
        try
        {
            __ret = __proxy->end_createRawPixelsStore(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_InternalRepository_createRawPixelsStorePtr
newCallback_InternalRepository_createRawPixelsStore(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::RawPixelsStorePrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InternalRepository_createRawPixelsStore<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_InternalRepository_createRawPixelsStorePtr
newCallback_InternalRepository_createRawPixelsStore(T* instance, void (T::*cb)(const ::omero::api::RawPixelsStorePrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InternalRepository_createRawPixelsStore<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_InternalRepository_createRenderingEngine : public Callback_InternalRepository_createRenderingEngine_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::api::RenderingEnginePrx&);

    CallbackNC_InternalRepository_createRenderingEngine(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::InternalRepositoryPrx __proxy = ::omero::grid::InternalRepositoryPrx::uncheckedCast(__result->getProxy());
        ::omero::api::RenderingEnginePrx __ret;
        try
        {
            __ret = __proxy->end_createRenderingEngine(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_InternalRepository_createRenderingEnginePtr
newCallback_InternalRepository_createRenderingEngine(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::RenderingEnginePrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InternalRepository_createRenderingEngine<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_InternalRepository_createRenderingEnginePtr
newCallback_InternalRepository_createRenderingEngine(T* instance, void (T::*cb)(const ::omero::api::RenderingEnginePrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InternalRepository_createRenderingEngine<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_InternalRepository_createRenderingEngine : public Callback_InternalRepository_createRenderingEngine_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::api::RenderingEnginePrx&, const CT&);

    Callback_InternalRepository_createRenderingEngine(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::InternalRepositoryPrx __proxy = ::omero::grid::InternalRepositoryPrx::uncheckedCast(__result->getProxy());
        ::omero::api::RenderingEnginePrx __ret;
        try
        {
            __ret = __proxy->end_createRenderingEngine(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_InternalRepository_createRenderingEnginePtr
newCallback_InternalRepository_createRenderingEngine(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::RenderingEnginePrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InternalRepository_createRenderingEngine<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_InternalRepository_createRenderingEnginePtr
newCallback_InternalRepository_createRenderingEngine(T* instance, void (T::*cb)(const ::omero::api::RenderingEnginePrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InternalRepository_createRenderingEngine<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_InternalRepository_createThumbnailStore : public Callback_InternalRepository_createThumbnailStore_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::api::ThumbnailStorePrx&);

    CallbackNC_InternalRepository_createThumbnailStore(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::InternalRepositoryPrx __proxy = ::omero::grid::InternalRepositoryPrx::uncheckedCast(__result->getProxy());
        ::omero::api::ThumbnailStorePrx __ret;
        try
        {
            __ret = __proxy->end_createThumbnailStore(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_InternalRepository_createThumbnailStorePtr
newCallback_InternalRepository_createThumbnailStore(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::ThumbnailStorePrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InternalRepository_createThumbnailStore<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_InternalRepository_createThumbnailStorePtr
newCallback_InternalRepository_createThumbnailStore(T* instance, void (T::*cb)(const ::omero::api::ThumbnailStorePrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InternalRepository_createThumbnailStore<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_InternalRepository_createThumbnailStore : public Callback_InternalRepository_createThumbnailStore_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::api::ThumbnailStorePrx&, const CT&);

    Callback_InternalRepository_createThumbnailStore(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::InternalRepositoryPrx __proxy = ::omero::grid::InternalRepositoryPrx::uncheckedCast(__result->getProxy());
        ::omero::api::ThumbnailStorePrx __ret;
        try
        {
            __ret = __proxy->end_createThumbnailStore(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_InternalRepository_createThumbnailStorePtr
newCallback_InternalRepository_createThumbnailStore(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::ThumbnailStorePrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InternalRepository_createThumbnailStore<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_InternalRepository_createThumbnailStorePtr
newCallback_InternalRepository_createThumbnailStore(T* instance, void (T::*cb)(const ::omero::api::ThumbnailStorePrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InternalRepository_createThumbnailStore<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_InternalRepository_getDescription : public Callback_InternalRepository_getDescription_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::model::OriginalFilePtr&);

    CallbackNC_InternalRepository_getDescription(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::InternalRepositoryPrx __proxy = ::omero::grid::InternalRepositoryPrx::uncheckedCast(__result->getProxy());
        ::omero::model::OriginalFilePtr __ret;
        try
        {
            __ret = __proxy->end_getDescription(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_InternalRepository_getDescriptionPtr
newCallback_InternalRepository_getDescription(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::OriginalFilePtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InternalRepository_getDescription<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_InternalRepository_getDescriptionPtr
newCallback_InternalRepository_getDescription(T* instance, void (T::*cb)(const ::omero::model::OriginalFilePtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InternalRepository_getDescription<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_InternalRepository_getDescription : public Callback_InternalRepository_getDescription_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::model::OriginalFilePtr&, const CT&);

    Callback_InternalRepository_getDescription(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::InternalRepositoryPrx __proxy = ::omero::grid::InternalRepositoryPrx::uncheckedCast(__result->getProxy());
        ::omero::model::OriginalFilePtr __ret;
        try
        {
            __ret = __proxy->end_getDescription(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_InternalRepository_getDescriptionPtr
newCallback_InternalRepository_getDescription(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::OriginalFilePtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InternalRepository_getDescription<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_InternalRepository_getDescriptionPtr
newCallback_InternalRepository_getDescription(T* instance, void (T::*cb)(const ::omero::model::OriginalFilePtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InternalRepository_getDescription<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_InternalRepository_getProxy : public Callback_InternalRepository_getProxy_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::grid::RepositoryPrx&);

    CallbackNC_InternalRepository_getProxy(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::InternalRepositoryPrx __proxy = ::omero::grid::InternalRepositoryPrx::uncheckedCast(__result->getProxy());
        ::omero::grid::RepositoryPrx __ret;
        try
        {
            __ret = __proxy->end_getProxy(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_InternalRepository_getProxyPtr
newCallback_InternalRepository_getProxy(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::grid::RepositoryPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InternalRepository_getProxy<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_InternalRepository_getProxyPtr
newCallback_InternalRepository_getProxy(T* instance, void (T::*cb)(const ::omero::grid::RepositoryPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InternalRepository_getProxy<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_InternalRepository_getProxy : public Callback_InternalRepository_getProxy_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::grid::RepositoryPrx&, const CT&);

    Callback_InternalRepository_getProxy(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::InternalRepositoryPrx __proxy = ::omero::grid::InternalRepositoryPrx::uncheckedCast(__result->getProxy());
        ::omero::grid::RepositoryPrx __ret;
        try
        {
            __ret = __proxy->end_getProxy(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_InternalRepository_getProxyPtr
newCallback_InternalRepository_getProxy(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::grid::RepositoryPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InternalRepository_getProxy<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_InternalRepository_getProxyPtr
newCallback_InternalRepository_getProxy(T* instance, void (T::*cb)(const ::omero::grid::RepositoryPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InternalRepository_getProxy<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_InternalRepository_rawAccess : public Callback_InternalRepository_rawAccess_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::cmd::ResponsePtr&);

    CallbackNC_InternalRepository_rawAccess(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::InternalRepositoryPrx __proxy = ::omero::grid::InternalRepositoryPrx::uncheckedCast(__result->getProxy());
        ::omero::cmd::ResponsePtr __ret;
        try
        {
            __ret = __proxy->end_rawAccess(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_InternalRepository_rawAccessPtr
newCallback_InternalRepository_rawAccess(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::cmd::ResponsePtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InternalRepository_rawAccess<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_InternalRepository_rawAccessPtr
newCallback_InternalRepository_rawAccess(T* instance, void (T::*cb)(const ::omero::cmd::ResponsePtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InternalRepository_rawAccess<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_InternalRepository_rawAccess : public Callback_InternalRepository_rawAccess_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::cmd::ResponsePtr&, const CT&);

    Callback_InternalRepository_rawAccess(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::InternalRepositoryPrx __proxy = ::omero::grid::InternalRepositoryPrx::uncheckedCast(__result->getProxy());
        ::omero::cmd::ResponsePtr __ret;
        try
        {
            __ret = __proxy->end_rawAccess(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_InternalRepository_rawAccessPtr
newCallback_InternalRepository_rawAccess(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::cmd::ResponsePtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InternalRepository_rawAccess<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_InternalRepository_rawAccessPtr
newCallback_InternalRepository_rawAccess(T* instance, void (T::*cb)(const ::omero::cmd::ResponsePtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InternalRepository_rawAccess<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_InternalRepository_getFilePath : public Callback_InternalRepository_getFilePath_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_InternalRepository_getFilePath(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::InternalRepositoryPrx __proxy = ::omero::grid::InternalRepositoryPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_getFilePath(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_InternalRepository_getFilePathPtr
newCallback_InternalRepository_getFilePath(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InternalRepository_getFilePath<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_InternalRepository_getFilePathPtr
newCallback_InternalRepository_getFilePath(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InternalRepository_getFilePath<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_InternalRepository_getFilePath : public Callback_InternalRepository_getFilePath_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_InternalRepository_getFilePath(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::InternalRepositoryPrx __proxy = ::omero::grid::InternalRepositoryPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_getFilePath(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_InternalRepository_getFilePathPtr
newCallback_InternalRepository_getFilePath(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InternalRepository_getFilePath<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_InternalRepository_getFilePathPtr
newCallback_InternalRepository_getFilePath(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InternalRepository_getFilePath<T, CT>(instance, cb, excb, sentcb);
}

}

}

#endif
