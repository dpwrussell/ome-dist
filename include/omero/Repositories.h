// **********************************************************************
//
// Copyright (c) 2003-2013 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.5.1
//
// <auto-generated>
//
// Generated from file `Repositories.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __omero__opt_hudson_workspace_OMERO_5_0_release_src_components_blitz_generated_omero_Repositories_h__
#define __omero__opt_hudson_workspace_OMERO_5_0_release_src_components_blitz_generated_omero_Repositories_h__

#include <Ice/ProxyF.h>
#include <Ice/ObjectF.h>
#include <Ice/Exception.h>
#include <Ice/LocalObject.h>
#include <Ice/StreamHelpers.h>
#include <Ice/Proxy.h>
#include <Ice/Object.h>
#include <Ice/Outgoing.h>
#include <Ice/OutgoingAsync.h>
#include <Ice/Incoming.h>
#include <Ice/IncomingAsync.h>
#include <Ice/Direct.h>
#include <Ice/FactoryTableInit.h>
#include <IceUtil/ScopedArray.h>
#include <IceUtil/Optional.h>
#include <Ice/StreamF.h>
#include <Ice/SlicedDataF.h>
#include <omero/ModelF.h>
#include <omero/ServicesF.h>
#include <omero/System.h>
#include <omero/Collections.h>
#include <omero/ServerErrors.h>
#include <omero/cmd/API.h>
#include <Ice/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 305
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 > 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 1
#       error Ice patch level mismatch!
#   endif
#endif

namespace IceProxy
{

namespace omero
{

namespace grid
{

class Repository;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::omero::grid::Repository>&);
::IceProxy::Ice::Object* upCast(::IceProxy::omero::grid::Repository*);

class ImportLocation;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::omero::grid::ImportLocation>&);
::IceProxy::Ice::Object* upCast(::IceProxy::omero::grid::ImportLocation*);

class ImportSettings;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::omero::grid::ImportSettings>&);
::IceProxy::Ice::Object* upCast(::IceProxy::omero::grid::ImportSettings*);

class ImportProcess;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::omero::grid::ImportProcess>&);
::IceProxy::Ice::Object* upCast(::IceProxy::omero::grid::ImportProcess*);

class ImportRequest;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::omero::grid::ImportRequest>&);
::IceProxy::Ice::Object* upCast(::IceProxy::omero::grid::ImportRequest*);

class ImportResponse;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::omero::grid::ImportResponse>&);
::IceProxy::Ice::Object* upCast(::IceProxy::omero::grid::ImportResponse*);

class ManagedRepository;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::omero::grid::ManagedRepository>&);
::IceProxy::Ice::Object* upCast(::IceProxy::omero::grid::ManagedRepository*);

class RawAccessRequest;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::omero::grid::RawAccessRequest>&);
::IceProxy::Ice::Object* upCast(::IceProxy::omero::grid::RawAccessRequest*);

class InternalRepository;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::omero::grid::InternalRepository>&);
::IceProxy::Ice::Object* upCast(::IceProxy::omero::grid::InternalRepository*);

}

}

}

namespace omero
{

namespace grid
{

class Repository;
bool operator==(const Repository&, const Repository&);
bool operator<(const Repository&, const Repository&);
::Ice::Object* upCast(::omero::grid::Repository*);
typedef ::IceInternal::Handle< ::omero::grid::Repository> RepositoryPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::omero::grid::Repository> RepositoryPrx;
void __patch(RepositoryPtr&, const ::Ice::ObjectPtr&);

class ImportLocation;
bool operator==(const ImportLocation&, const ImportLocation&);
bool operator<(const ImportLocation&, const ImportLocation&);
::Ice::Object* upCast(::omero::grid::ImportLocation*);
typedef ::IceInternal::Handle< ::omero::grid::ImportLocation> ImportLocationPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::omero::grid::ImportLocation> ImportLocationPrx;
void __patch(ImportLocationPtr&, const ::Ice::ObjectPtr&);

class ImportSettings;
bool operator==(const ImportSettings&, const ImportSettings&);
bool operator<(const ImportSettings&, const ImportSettings&);
::Ice::Object* upCast(::omero::grid::ImportSettings*);
typedef ::IceInternal::Handle< ::omero::grid::ImportSettings> ImportSettingsPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::omero::grid::ImportSettings> ImportSettingsPrx;
void __patch(ImportSettingsPtr&, const ::Ice::ObjectPtr&);

class ImportProcess;
bool operator==(const ImportProcess&, const ImportProcess&);
bool operator<(const ImportProcess&, const ImportProcess&);
::Ice::Object* upCast(::omero::grid::ImportProcess*);
typedef ::IceInternal::Handle< ::omero::grid::ImportProcess> ImportProcessPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::omero::grid::ImportProcess> ImportProcessPrx;
void __patch(ImportProcessPtr&, const ::Ice::ObjectPtr&);

class ImportRequest;
bool operator==(const ImportRequest&, const ImportRequest&);
bool operator<(const ImportRequest&, const ImportRequest&);
::Ice::Object* upCast(::omero::grid::ImportRequest*);
typedef ::IceInternal::Handle< ::omero::grid::ImportRequest> ImportRequestPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::omero::grid::ImportRequest> ImportRequestPrx;
void __patch(ImportRequestPtr&, const ::Ice::ObjectPtr&);

class ImportResponse;
bool operator==(const ImportResponse&, const ImportResponse&);
bool operator<(const ImportResponse&, const ImportResponse&);
::Ice::Object* upCast(::omero::grid::ImportResponse*);
typedef ::IceInternal::Handle< ::omero::grid::ImportResponse> ImportResponsePtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::omero::grid::ImportResponse> ImportResponsePrx;
void __patch(ImportResponsePtr&, const ::Ice::ObjectPtr&);

class ManagedRepository;
bool operator==(const ManagedRepository&, const ManagedRepository&);
bool operator<(const ManagedRepository&, const ManagedRepository&);
::Ice::Object* upCast(::omero::grid::ManagedRepository*);
typedef ::IceInternal::Handle< ::omero::grid::ManagedRepository> ManagedRepositoryPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::omero::grid::ManagedRepository> ManagedRepositoryPrx;
void __patch(ManagedRepositoryPtr&, const ::Ice::ObjectPtr&);

class RawAccessRequest;
bool operator==(const RawAccessRequest&, const RawAccessRequest&);
bool operator<(const RawAccessRequest&, const RawAccessRequest&);
::Ice::Object* upCast(::omero::grid::RawAccessRequest*);
typedef ::IceInternal::Handle< ::omero::grid::RawAccessRequest> RawAccessRequestPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::omero::grid::RawAccessRequest> RawAccessRequestPrx;
void __patch(RawAccessRequestPtr&, const ::Ice::ObjectPtr&);

class InternalRepository;
bool operator==(const InternalRepository&, const InternalRepository&);
bool operator<(const InternalRepository&, const InternalRepository&);
::Ice::Object* upCast(::omero::grid::InternalRepository*);
typedef ::IceInternal::Handle< ::omero::grid::InternalRepository> InternalRepositoryPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::omero::grid::InternalRepository> InternalRepositoryPrx;
void __patch(InternalRepositoryPtr&, const ::Ice::ObjectPtr&);

}

}

namespace omero
{

namespace grid
{

class RepositoryException : public ::omero::ServerError
{
public:

    RepositoryException() {}
    RepositoryException(const ::std::string&, const ::std::string&, const ::std::string&);
    virtual ~RepositoryException() throw();

    virtual ::std::string ice_name() const;
    virtual RepositoryException* ice_clone() const;
    virtual void ice_throw() const;

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::omero::ServerError::__writeImpl;
    using ::omero::ServerError::__readImpl;
    #endif
};

static RepositoryException __RepositoryException_init;

class FileDeleteException : public ::omero::grid::RepositoryException
{
public:

    FileDeleteException() {}
    FileDeleteException(const ::std::string&, const ::std::string&, const ::std::string&);
    virtual ~FileDeleteException() throw();

    virtual ::std::string ice_name() const;
    virtual FileDeleteException* ice_clone() const;
    virtual void ice_throw() const;

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::omero::grid::RepositoryException::__writeImpl;
    using ::omero::grid::RepositoryException::__readImpl;
    #endif
};

class UnregisteredFileException : public ::omero::grid::RepositoryException
{
public:

    UnregisteredFileException() {}
    UnregisteredFileException(const ::std::string&, const ::std::string&, const ::std::string&, const ::omero::model::OriginalFilePtr&);
    virtual ~UnregisteredFileException() throw();

    virtual ::std::string ice_name() const;
    virtual UnregisteredFileException* ice_clone() const;
    virtual void ice_throw() const;

    virtual bool __usesClasses() const;

    ::omero::model::OriginalFilePtr file;

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::omero::grid::RepositoryException::__writeImpl;
    using ::omero::grid::RepositoryException::__readImpl;
    #endif
};

typedef ::std::vector< ::omero::grid::ImportProcessPrx> ImportProcessList;

typedef ::std::vector< ::omero::grid::RepositoryPrx> RepositoryProxyList;

struct RepositoryMap
{
    ::omero::api::OriginalFileList descriptions;
    ::omero::grid::RepositoryProxyList proxies;
};

}

}

namespace Ice
{
template<>
struct StreamableTraits< ::omero::grid::RepositoryException>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

template<>
struct StreamableTraits< ::omero::grid::FileDeleteException>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

template<>
struct StreamableTraits< ::omero::grid::UnregisteredFileException>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

template<>
struct StreamableTraits< ::omero::grid::RepositoryMap>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 2;
    static const bool fixedLength = false;
};

template<class S>
struct StreamWriter< ::omero::grid::RepositoryMap, S>
{
    static void write(S* __os, const ::omero::grid::RepositoryMap& v)
    {
        __os->write(v.descriptions);
        __os->write(v.proxies);
    }
};

template<class S>
struct StreamReader< ::omero::grid::RepositoryMap, S>
{
    static void read(S* __is, ::omero::grid::RepositoryMap& v)
    {
        __is->read(v.descriptions);
        __is->read(v.proxies);
    }
};

}

namespace omero
{

namespace grid
{

class AMI_Repository_root : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::omero::model::OriginalFilePtr&) = 0;

    void __response(const ::omero::model::OriginalFilePtr& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::grid::AMI_Repository_root> AMI_Repository_rootPtr;

class AMI_Repository_mimetype : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::std::string&) = 0;

    void __response(const ::std::string& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::grid::AMI_Repository_mimetype> AMI_Repository_mimetypePtr;

class AMI_Repository_list : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::omero::api::StringSet&) = 0;

    void __response(const ::omero::api::StringSet& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::grid::AMI_Repository_list> AMI_Repository_listPtr;

class AMI_Repository_listFiles : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::omero::api::OriginalFileList&) = 0;

    void __response(const ::omero::api::OriginalFileList& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::grid::AMI_Repository_listFiles> AMI_Repository_listFilesPtr;

class AMI_Repository_register : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::omero::model::OriginalFilePtr&) = 0;

    void __response(const ::omero::model::OriginalFilePtr& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::grid::AMI_Repository_register> AMI_Repository_registerPtr;

class AMI_Repository_file : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::omero::api::RawFileStorePrx&) = 0;

    void __response(const ::omero::api::RawFileStorePrx& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::grid::AMI_Repository_file> AMI_Repository_filePtr;

class AMI_Repository_pixels : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::omero::api::RawPixelsStorePrx&) = 0;

    void __response(const ::omero::api::RawPixelsStorePrx& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::grid::AMI_Repository_pixels> AMI_Repository_pixelsPtr;

class AMI_Repository_fileById : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::omero::api::RawFileStorePrx&) = 0;

    void __response(const ::omero::api::RawFileStorePrx& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::grid::AMI_Repository_fileById> AMI_Repository_fileByIdPtr;

class AMI_Repository_fileExists : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(bool) = 0;

    void __response(bool __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::grid::AMI_Repository_fileExists> AMI_Repository_fileExistsPtr;

class AMI_Repository_makeDir : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response() = 0;

    void __response()
    {
        ice_response();
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::grid::AMI_Repository_makeDir> AMI_Repository_makeDirPtr;

class AMI_Repository_treeList : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::omero::RMapPtr&) = 0;

    void __response(const ::omero::RMapPtr& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::grid::AMI_Repository_treeList> AMI_Repository_treeListPtr;

class AMI_Repository_deletePaths : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::omero::cmd::HandlePrx&) = 0;

    void __response(const ::omero::cmd::HandlePrx& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::grid::AMI_Repository_deletePaths> AMI_Repository_deletePathsPtr;

class AMI_ManagedRepository_importFileset : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::omero::grid::ImportProcessPrx&) = 0;

    void __response(const ::omero::grid::ImportProcessPrx& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::grid::AMI_ManagedRepository_importFileset> AMI_ManagedRepository_importFilesetPtr;

class AMI_ManagedRepository_importPaths : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::omero::grid::ImportProcessPrx&) = 0;

    void __response(const ::omero::grid::ImportProcessPrx& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::grid::AMI_ManagedRepository_importPaths> AMI_ManagedRepository_importPathsPtr;

class AMI_ManagedRepository_listImports : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::omero::grid::ImportProcessList&) = 0;

    void __response(const ::omero::grid::ImportProcessList& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::grid::AMI_ManagedRepository_listImports> AMI_ManagedRepository_listImportsPtr;

class AMI_ManagedRepository_listChecksumAlgorithms : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::omero::api::ChecksumAlgorithmList&) = 0;

    void __response(const ::omero::api::ChecksumAlgorithmList& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::grid::AMI_ManagedRepository_listChecksumAlgorithms> AMI_ManagedRepository_listChecksumAlgorithmsPtr;

class AMI_ManagedRepository_suggestChecksumAlgorithm : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::omero::model::ChecksumAlgorithmPtr&) = 0;

    void __response(const ::omero::model::ChecksumAlgorithmPtr& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::grid::AMI_ManagedRepository_suggestChecksumAlgorithm> AMI_ManagedRepository_suggestChecksumAlgorithmPtr;

class AMI_InternalRepository_createRawFileStore : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::omero::api::RawFileStorePrx&) = 0;

    void __response(const ::omero::api::RawFileStorePrx& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::grid::AMI_InternalRepository_createRawFileStore> AMI_InternalRepository_createRawFileStorePtr;

class AMI_InternalRepository_createRawPixelsStore : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::omero::api::RawPixelsStorePrx&) = 0;

    void __response(const ::omero::api::RawPixelsStorePrx& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::grid::AMI_InternalRepository_createRawPixelsStore> AMI_InternalRepository_createRawPixelsStorePtr;

class AMI_InternalRepository_createRenderingEngine : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::omero::api::RenderingEnginePrx&) = 0;

    void __response(const ::omero::api::RenderingEnginePrx& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::grid::AMI_InternalRepository_createRenderingEngine> AMI_InternalRepository_createRenderingEnginePtr;

class AMI_InternalRepository_createThumbnailStore : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::omero::api::ThumbnailStorePrx&) = 0;

    void __response(const ::omero::api::ThumbnailStorePrx& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::grid::AMI_InternalRepository_createThumbnailStore> AMI_InternalRepository_createThumbnailStorePtr;

class AMI_InternalRepository_getDescription : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::omero::model::OriginalFilePtr&) = 0;

    void __response(const ::omero::model::OriginalFilePtr& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::grid::AMI_InternalRepository_getDescription> AMI_InternalRepository_getDescriptionPtr;

class AMI_InternalRepository_getProxy : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::omero::grid::RepositoryPrx&) = 0;

    void __response(const ::omero::grid::RepositoryPrx& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::grid::AMI_InternalRepository_getProxy> AMI_InternalRepository_getProxyPtr;

class AMI_InternalRepository_rawAccess : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::omero::cmd::ResponsePtr&) = 0;

    void __response(const ::omero::cmd::ResponsePtr& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::grid::AMI_InternalRepository_rawAccess> AMI_InternalRepository_rawAccessPtr;

class AMI_InternalRepository_getFilePath : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::std::string&) = 0;

    void __response(const ::std::string& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::grid::AMI_InternalRepository_getFilePath> AMI_InternalRepository_getFilePathPtr;

}

}

namespace IceAsync
{

}

namespace omero
{

namespace grid
{

class Callback_Repository_root_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Repository_root_Base> Callback_Repository_rootPtr;

class Callback_Repository_mimetype_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Repository_mimetype_Base> Callback_Repository_mimetypePtr;

class Callback_Repository_list_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Repository_list_Base> Callback_Repository_listPtr;

class Callback_Repository_listFiles_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Repository_listFiles_Base> Callback_Repository_listFilesPtr;

class Callback_Repository_register_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Repository_register_Base> Callback_Repository_registerPtr;

class Callback_Repository_file_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Repository_file_Base> Callback_Repository_filePtr;

class Callback_Repository_pixels_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Repository_pixels_Base> Callback_Repository_pixelsPtr;

class Callback_Repository_fileById_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Repository_fileById_Base> Callback_Repository_fileByIdPtr;

class Callback_Repository_fileExists_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Repository_fileExists_Base> Callback_Repository_fileExistsPtr;

class Callback_Repository_makeDir_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Repository_makeDir_Base> Callback_Repository_makeDirPtr;

class Callback_Repository_treeList_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Repository_treeList_Base> Callback_Repository_treeListPtr;

class Callback_Repository_deletePaths_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Repository_deletePaths_Base> Callback_Repository_deletePathsPtr;

class Callback_ImportProcess_getUploader_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ImportProcess_getUploader_Base> Callback_ImportProcess_getUploaderPtr;

class Callback_ImportProcess_verifyUpload_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ImportProcess_verifyUpload_Base> Callback_ImportProcess_verifyUploadPtr;

class Callback_ImportProcess_getUploadOffset_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ImportProcess_getUploadOffset_Base> Callback_ImportProcess_getUploadOffsetPtr;

class Callback_ImportProcess_getHandle_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ImportProcess_getHandle_Base> Callback_ImportProcess_getHandlePtr;

class Callback_ImportProcess_getImportSettings_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ImportProcess_getImportSettings_Base> Callback_ImportProcess_getImportSettingsPtr;

class Callback_ManagedRepository_importFileset_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ManagedRepository_importFileset_Base> Callback_ManagedRepository_importFilesetPtr;

class Callback_ManagedRepository_importPaths_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ManagedRepository_importPaths_Base> Callback_ManagedRepository_importPathsPtr;

class Callback_ManagedRepository_listImports_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ManagedRepository_listImports_Base> Callback_ManagedRepository_listImportsPtr;

class Callback_ManagedRepository_listChecksumAlgorithms_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ManagedRepository_listChecksumAlgorithms_Base> Callback_ManagedRepository_listChecksumAlgorithmsPtr;

class Callback_ManagedRepository_suggestChecksumAlgorithm_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ManagedRepository_suggestChecksumAlgorithm_Base> Callback_ManagedRepository_suggestChecksumAlgorithmPtr;

class Callback_InternalRepository_createRawFileStore_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_InternalRepository_createRawFileStore_Base> Callback_InternalRepository_createRawFileStorePtr;

class Callback_InternalRepository_createRawPixelsStore_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_InternalRepository_createRawPixelsStore_Base> Callback_InternalRepository_createRawPixelsStorePtr;

class Callback_InternalRepository_createRenderingEngine_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_InternalRepository_createRenderingEngine_Base> Callback_InternalRepository_createRenderingEnginePtr;

class Callback_InternalRepository_createThumbnailStore_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_InternalRepository_createThumbnailStore_Base> Callback_InternalRepository_createThumbnailStorePtr;

class Callback_InternalRepository_getDescription_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_InternalRepository_getDescription_Base> Callback_InternalRepository_getDescriptionPtr;

class Callback_InternalRepository_getProxy_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_InternalRepository_getProxy_Base> Callback_InternalRepository_getProxyPtr;

class Callback_InternalRepository_rawAccess_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_InternalRepository_rawAccess_Base> Callback_InternalRepository_rawAccessPtr;

class Callback_InternalRepository_getFilePath_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_InternalRepository_getFilePath_Base> Callback_InternalRepository_getFilePathPtr;

}

}

namespace IceProxy
{

namespace omero
{

namespace grid
{

class Repository : virtual public ::IceProxy::Ice::Object
{
public:

    ::omero::model::OriginalFilePtr root()
    {
        return root(0);
    }
    ::omero::model::OriginalFilePtr root(const ::Ice::Context& __ctx)
    {
        return root(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_root(const ::IceInternal::Function<void (const ::omero::model::OriginalFilePtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_root(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_root(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_root(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_root(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::omero::model::OriginalFilePtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_root(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_root(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_root(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_root(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::omero::model::OriginalFilePtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::omero::model::OriginalFilePtr&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::grid::RepositoryPrx __proxy = ::omero::grid::RepositoryPrx::uncheckedCast(__result->getProxy());
                ::omero::model::OriginalFilePtr __ret;
                try
                {
                    __ret = __proxy->end_root(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::omero::model::OriginalFilePtr&)> _response;
        };
        return begin_root(__ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_root()
    {
        return begin_root(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_root(const ::Ice::Context& __ctx)
    {
        return begin_root(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_root(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_root(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_root(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_root(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_root(const ::omero::grid::Callback_Repository_rootPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_root(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_root(const ::Ice::Context& __ctx, const ::omero::grid::Callback_Repository_rootPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_root(&__ctx, __del, __cookie);
    }

    ::omero::model::OriginalFilePtr end_root(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::model::OriginalFilePtr root(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_root(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool root_async(const ::omero::grid::AMI_Repository_rootPtr&);
    bool root_async(const ::omero::grid::AMI_Repository_rootPtr&, const ::Ice::Context&);

    ::std::string mimetype(const ::std::string& path)
    {
        return mimetype(path, 0);
    }
    ::std::string mimetype(const ::std::string& path, const ::Ice::Context& __ctx)
    {
        return mimetype(path, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_mimetype(const ::std::string& path, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_mimetype(path, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_mimetype(const ::std::string& path, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_mimetype(path, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_mimetype(const ::std::string& path, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_mimetype(path, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_mimetype(const ::std::string& path, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_mimetype(path, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_mimetype(const ::std::string& path, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::std::string&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::grid::RepositoryPrx __proxy = ::omero::grid::RepositoryPrx::uncheckedCast(__result->getProxy());
                ::std::string __ret;
                try
                {
                    __ret = __proxy->end_mimetype(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::std::string&)> _response;
        };
        return begin_mimetype(path, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_mimetype(const ::std::string& path)
    {
        return begin_mimetype(path, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_mimetype(const ::std::string& path, const ::Ice::Context& __ctx)
    {
        return begin_mimetype(path, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_mimetype(const ::std::string& path, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_mimetype(path, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_mimetype(const ::std::string& path, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_mimetype(path, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_mimetype(const ::std::string& path, const ::omero::grid::Callback_Repository_mimetypePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_mimetype(path, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_mimetype(const ::std::string& path, const ::Ice::Context& __ctx, const ::omero::grid::Callback_Repository_mimetypePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_mimetype(path, &__ctx, __del, __cookie);
    }

    ::std::string end_mimetype(const ::Ice::AsyncResultPtr&);
    
private:

    ::std::string mimetype(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_mimetype(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool mimetype_async(const ::omero::grid::AMI_Repository_mimetypePtr&, const ::std::string&);
    bool mimetype_async(const ::omero::grid::AMI_Repository_mimetypePtr&, const ::std::string&, const ::Ice::Context&);

    ::omero::api::StringSet list(const ::std::string& path)
    {
        return list(path, 0);
    }
    ::omero::api::StringSet list(const ::std::string& path, const ::Ice::Context& __ctx)
    {
        return list(path, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_list(const ::std::string& path, const ::IceInternal::Function<void (const ::omero::api::StringSet&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_list(path, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_list(const ::std::string& path, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_list(path, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_list(const ::std::string& path, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::omero::api::StringSet&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_list(path, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_list(const ::std::string& path, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_list(path, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_list(const ::std::string& path, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::omero::api::StringSet&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::omero::api::StringSet&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::grid::RepositoryPrx __proxy = ::omero::grid::RepositoryPrx::uncheckedCast(__result->getProxy());
                ::omero::api::StringSet __ret;
                try
                {
                    __ret = __proxy->end_list(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::omero::api::StringSet&)> _response;
        };
        return begin_list(path, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_list(const ::std::string& path)
    {
        return begin_list(path, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_list(const ::std::string& path, const ::Ice::Context& __ctx)
    {
        return begin_list(path, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_list(const ::std::string& path, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_list(path, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_list(const ::std::string& path, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_list(path, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_list(const ::std::string& path, const ::omero::grid::Callback_Repository_listPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_list(path, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_list(const ::std::string& path, const ::Ice::Context& __ctx, const ::omero::grid::Callback_Repository_listPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_list(path, &__ctx, __del, __cookie);
    }

    ::omero::api::StringSet end_list(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::api::StringSet list(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_list(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool list_async(const ::omero::grid::AMI_Repository_listPtr&, const ::std::string&);
    bool list_async(const ::omero::grid::AMI_Repository_listPtr&, const ::std::string&, const ::Ice::Context&);

    ::omero::api::OriginalFileList listFiles(const ::std::string& path)
    {
        return listFiles(path, 0);
    }
    ::omero::api::OriginalFileList listFiles(const ::std::string& path, const ::Ice::Context& __ctx)
    {
        return listFiles(path, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_listFiles(const ::std::string& path, const ::IceInternal::Function<void (const ::omero::api::OriginalFileList&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_listFiles(path, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_listFiles(const ::std::string& path, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_listFiles(path, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_listFiles(const ::std::string& path, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::omero::api::OriginalFileList&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_listFiles(path, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_listFiles(const ::std::string& path, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_listFiles(path, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_listFiles(const ::std::string& path, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::omero::api::OriginalFileList&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::omero::api::OriginalFileList&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::grid::RepositoryPrx __proxy = ::omero::grid::RepositoryPrx::uncheckedCast(__result->getProxy());
                ::omero::api::OriginalFileList __ret;
                try
                {
                    __ret = __proxy->end_listFiles(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::omero::api::OriginalFileList&)> _response;
        };
        return begin_listFiles(path, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_listFiles(const ::std::string& path)
    {
        return begin_listFiles(path, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_listFiles(const ::std::string& path, const ::Ice::Context& __ctx)
    {
        return begin_listFiles(path, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_listFiles(const ::std::string& path, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_listFiles(path, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_listFiles(const ::std::string& path, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_listFiles(path, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_listFiles(const ::std::string& path, const ::omero::grid::Callback_Repository_listFilesPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_listFiles(path, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_listFiles(const ::std::string& path, const ::Ice::Context& __ctx, const ::omero::grid::Callback_Repository_listFilesPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_listFiles(path, &__ctx, __del, __cookie);
    }

    ::omero::api::OriginalFileList end_listFiles(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::api::OriginalFileList listFiles(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_listFiles(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool listFiles_async(const ::omero::grid::AMI_Repository_listFilesPtr&, const ::std::string&);
    bool listFiles_async(const ::omero::grid::AMI_Repository_listFilesPtr&, const ::std::string&, const ::Ice::Context&);

    ::omero::model::OriginalFilePtr _cpp_register(const ::std::string& path, const ::omero::RStringPtr& mimetype)
    {
        return _cpp_register(path, mimetype, 0);
    }
    ::omero::model::OriginalFilePtr _cpp_register(const ::std::string& path, const ::omero::RStringPtr& mimetype, const ::Ice::Context& __ctx)
    {
        return _cpp_register(path, mimetype, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_register(const ::std::string& path, const ::omero::RStringPtr& mimetype, const ::IceInternal::Function<void (const ::omero::model::OriginalFilePtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_register(path, mimetype, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_register(const ::std::string& path, const ::omero::RStringPtr& mimetype, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_register(path, mimetype, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_register(const ::std::string& path, const ::omero::RStringPtr& mimetype, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::omero::model::OriginalFilePtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_register(path, mimetype, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_register(const ::std::string& path, const ::omero::RStringPtr& mimetype, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_register(path, mimetype, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_register(const ::std::string& path, const ::omero::RStringPtr& mimetype, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::omero::model::OriginalFilePtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::omero::model::OriginalFilePtr&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::grid::RepositoryPrx __proxy = ::omero::grid::RepositoryPrx::uncheckedCast(__result->getProxy());
                ::omero::model::OriginalFilePtr __ret;
                try
                {
                    __ret = __proxy->end_register(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::omero::model::OriginalFilePtr&)> _response;
        };
        return begin_register(path, mimetype, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_register(const ::std::string& path, const ::omero::RStringPtr& mimetype)
    {
        return begin_register(path, mimetype, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_register(const ::std::string& path, const ::omero::RStringPtr& mimetype, const ::Ice::Context& __ctx)
    {
        return begin_register(path, mimetype, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_register(const ::std::string& path, const ::omero::RStringPtr& mimetype, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_register(path, mimetype, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_register(const ::std::string& path, const ::omero::RStringPtr& mimetype, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_register(path, mimetype, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_register(const ::std::string& path, const ::omero::RStringPtr& mimetype, const ::omero::grid::Callback_Repository_registerPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_register(path, mimetype, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_register(const ::std::string& path, const ::omero::RStringPtr& mimetype, const ::Ice::Context& __ctx, const ::omero::grid::Callback_Repository_registerPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_register(path, mimetype, &__ctx, __del, __cookie);
    }

    ::omero::model::OriginalFilePtr end_register(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::model::OriginalFilePtr _cpp_register(const ::std::string&, const ::omero::RStringPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_register(const ::std::string&, const ::omero::RStringPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool register_async(const ::omero::grid::AMI_Repository_registerPtr&, const ::std::string&, const ::omero::RStringPtr&);
    bool register_async(const ::omero::grid::AMI_Repository_registerPtr&, const ::std::string&, const ::omero::RStringPtr&, const ::Ice::Context&);

    ::omero::api::RawFileStorePrx file(const ::std::string& path, const ::std::string& mode)
    {
        return file(path, mode, 0);
    }
    ::omero::api::RawFileStorePrx file(const ::std::string& path, const ::std::string& mode, const ::Ice::Context& __ctx)
    {
        return file(path, mode, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_file(const ::std::string& path, const ::std::string& mode, const ::IceInternal::Function<void (const ::omero::api::RawFileStorePrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_file(path, mode, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_file(const ::std::string& path, const ::std::string& mode, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_file(path, mode, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_file(const ::std::string& path, const ::std::string& mode, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::omero::api::RawFileStorePrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_file(path, mode, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_file(const ::std::string& path, const ::std::string& mode, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_file(path, mode, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_file(const ::std::string& path, const ::std::string& mode, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::omero::api::RawFileStorePrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::omero::api::RawFileStorePrx&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::grid::RepositoryPrx __proxy = ::omero::grid::RepositoryPrx::uncheckedCast(__result->getProxy());
                ::omero::api::RawFileStorePrx __ret;
                try
                {
                    __ret = __proxy->end_file(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::omero::api::RawFileStorePrx&)> _response;
        };
        return begin_file(path, mode, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_file(const ::std::string& path, const ::std::string& mode)
    {
        return begin_file(path, mode, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_file(const ::std::string& path, const ::std::string& mode, const ::Ice::Context& __ctx)
    {
        return begin_file(path, mode, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_file(const ::std::string& path, const ::std::string& mode, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_file(path, mode, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_file(const ::std::string& path, const ::std::string& mode, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_file(path, mode, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_file(const ::std::string& path, const ::std::string& mode, const ::omero::grid::Callback_Repository_filePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_file(path, mode, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_file(const ::std::string& path, const ::std::string& mode, const ::Ice::Context& __ctx, const ::omero::grid::Callback_Repository_filePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_file(path, mode, &__ctx, __del, __cookie);
    }

    ::omero::api::RawFileStorePrx end_file(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::api::RawFileStorePrx file(const ::std::string&, const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_file(const ::std::string&, const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool file_async(const ::omero::grid::AMI_Repository_filePtr&, const ::std::string&, const ::std::string&);
    bool file_async(const ::omero::grid::AMI_Repository_filePtr&, const ::std::string&, const ::std::string&, const ::Ice::Context&);

    ::omero::api::RawPixelsStorePrx pixels(const ::std::string& path)
    {
        return pixels(path, 0);
    }
    ::omero::api::RawPixelsStorePrx pixels(const ::std::string& path, const ::Ice::Context& __ctx)
    {
        return pixels(path, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_pixels(const ::std::string& path, const ::IceInternal::Function<void (const ::omero::api::RawPixelsStorePrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_pixels(path, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_pixels(const ::std::string& path, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_pixels(path, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_pixels(const ::std::string& path, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::omero::api::RawPixelsStorePrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_pixels(path, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_pixels(const ::std::string& path, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_pixels(path, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_pixels(const ::std::string& path, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::omero::api::RawPixelsStorePrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::omero::api::RawPixelsStorePrx&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::grid::RepositoryPrx __proxy = ::omero::grid::RepositoryPrx::uncheckedCast(__result->getProxy());
                ::omero::api::RawPixelsStorePrx __ret;
                try
                {
                    __ret = __proxy->end_pixels(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::omero::api::RawPixelsStorePrx&)> _response;
        };
        return begin_pixels(path, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_pixels(const ::std::string& path)
    {
        return begin_pixels(path, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_pixels(const ::std::string& path, const ::Ice::Context& __ctx)
    {
        return begin_pixels(path, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_pixels(const ::std::string& path, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_pixels(path, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_pixels(const ::std::string& path, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_pixels(path, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_pixels(const ::std::string& path, const ::omero::grid::Callback_Repository_pixelsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_pixels(path, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_pixels(const ::std::string& path, const ::Ice::Context& __ctx, const ::omero::grid::Callback_Repository_pixelsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_pixels(path, &__ctx, __del, __cookie);
    }

    ::omero::api::RawPixelsStorePrx end_pixels(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::api::RawPixelsStorePrx pixels(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_pixels(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool pixels_async(const ::omero::grid::AMI_Repository_pixelsPtr&, const ::std::string&);
    bool pixels_async(const ::omero::grid::AMI_Repository_pixelsPtr&, const ::std::string&, const ::Ice::Context&);

    ::omero::api::RawFileStorePrx fileById(::Ice::Long id)
    {
        return fileById(id, 0);
    }
    ::omero::api::RawFileStorePrx fileById(::Ice::Long id, const ::Ice::Context& __ctx)
    {
        return fileById(id, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_fileById(::Ice::Long id, const ::IceInternal::Function<void (const ::omero::api::RawFileStorePrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_fileById(id, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_fileById(::Ice::Long id, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_fileById(id, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_fileById(::Ice::Long id, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::omero::api::RawFileStorePrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_fileById(id, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_fileById(::Ice::Long id, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_fileById(id, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_fileById(::Ice::Long id, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::omero::api::RawFileStorePrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::omero::api::RawFileStorePrx&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::grid::RepositoryPrx __proxy = ::omero::grid::RepositoryPrx::uncheckedCast(__result->getProxy());
                ::omero::api::RawFileStorePrx __ret;
                try
                {
                    __ret = __proxy->end_fileById(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::omero::api::RawFileStorePrx&)> _response;
        };
        return begin_fileById(id, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_fileById(::Ice::Long id)
    {
        return begin_fileById(id, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_fileById(::Ice::Long id, const ::Ice::Context& __ctx)
    {
        return begin_fileById(id, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_fileById(::Ice::Long id, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_fileById(id, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_fileById(::Ice::Long id, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_fileById(id, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_fileById(::Ice::Long id, const ::omero::grid::Callback_Repository_fileByIdPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_fileById(id, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_fileById(::Ice::Long id, const ::Ice::Context& __ctx, const ::omero::grid::Callback_Repository_fileByIdPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_fileById(id, &__ctx, __del, __cookie);
    }

    ::omero::api::RawFileStorePrx end_fileById(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::api::RawFileStorePrx fileById(::Ice::Long, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_fileById(::Ice::Long, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool fileById_async(const ::omero::grid::AMI_Repository_fileByIdPtr&, ::Ice::Long);
    bool fileById_async(const ::omero::grid::AMI_Repository_fileByIdPtr&, ::Ice::Long, const ::Ice::Context&);

    bool fileExists(const ::std::string& path)
    {
        return fileExists(path, 0);
    }
    bool fileExists(const ::std::string& path, const ::Ice::Context& __ctx)
    {
        return fileExists(path, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_fileExists(const ::std::string& path, const ::IceInternal::Function<void (bool)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_fileExists(path, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_fileExists(const ::std::string& path, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_fileExists(path, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_fileExists(const ::std::string& path, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (bool)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_fileExists(path, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_fileExists(const ::std::string& path, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_fileExists(path, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_fileExists(const ::std::string& path, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (bool)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (bool)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::grid::RepositoryPrx __proxy = ::omero::grid::RepositoryPrx::uncheckedCast(__result->getProxy());
                bool __ret;
                try
                {
                    __ret = __proxy->end_fileExists(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (bool)> _response;
        };
        return begin_fileExists(path, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_fileExists(const ::std::string& path)
    {
        return begin_fileExists(path, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_fileExists(const ::std::string& path, const ::Ice::Context& __ctx)
    {
        return begin_fileExists(path, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_fileExists(const ::std::string& path, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_fileExists(path, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_fileExists(const ::std::string& path, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_fileExists(path, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_fileExists(const ::std::string& path, const ::omero::grid::Callback_Repository_fileExistsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_fileExists(path, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_fileExists(const ::std::string& path, const ::Ice::Context& __ctx, const ::omero::grid::Callback_Repository_fileExistsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_fileExists(path, &__ctx, __del, __cookie);
    }

    bool end_fileExists(const ::Ice::AsyncResultPtr&);
    
private:

    bool fileExists(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_fileExists(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool fileExists_async(const ::omero::grid::AMI_Repository_fileExistsPtr&, const ::std::string&);
    bool fileExists_async(const ::omero::grid::AMI_Repository_fileExistsPtr&, const ::std::string&, const ::Ice::Context&);

    void makeDir(const ::std::string& path, bool parents)
    {
        makeDir(path, parents, 0);
    }
    void makeDir(const ::std::string& path, bool parents, const ::Ice::Context& __ctx)
    {
        makeDir(path, parents, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_makeDir(const ::std::string& path, bool parents, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_makeDir(path, parents, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_makeDir(const ::std::string& path, bool parents, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_makeDir(path, parents, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_makeDir(const ::std::string& path, bool parents, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_makeDir(path, parents, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_makeDir(const ::std::string& path, bool parents, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_makeDir(path, parents, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_makeDir(const ::std::string& path, bool parents, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::grid::RepositoryPrx __proxy = ::omero::grid::RepositoryPrx::uncheckedCast(__result->getProxy());
                try
                {
                    __proxy->end_makeDir(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response();
                }
            }
        
        private:
            
            ::std::function<void ()> _response;
        };
        return begin_makeDir(path, parents, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_makeDir(const ::std::string& path, bool parents)
    {
        return begin_makeDir(path, parents, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_makeDir(const ::std::string& path, bool parents, const ::Ice::Context& __ctx)
    {
        return begin_makeDir(path, parents, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_makeDir(const ::std::string& path, bool parents, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_makeDir(path, parents, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_makeDir(const ::std::string& path, bool parents, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_makeDir(path, parents, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_makeDir(const ::std::string& path, bool parents, const ::omero::grid::Callback_Repository_makeDirPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_makeDir(path, parents, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_makeDir(const ::std::string& path, bool parents, const ::Ice::Context& __ctx, const ::omero::grid::Callback_Repository_makeDirPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_makeDir(path, parents, &__ctx, __del, __cookie);
    }

    void end_makeDir(const ::Ice::AsyncResultPtr&);
    
private:

    void makeDir(const ::std::string&, bool, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_makeDir(const ::std::string&, bool, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool makeDir_async(const ::omero::grid::AMI_Repository_makeDirPtr&, const ::std::string&, bool);
    bool makeDir_async(const ::omero::grid::AMI_Repository_makeDirPtr&, const ::std::string&, bool, const ::Ice::Context&);

    ::omero::RMapPtr treeList(const ::std::string& path)
    {
        return treeList(path, 0);
    }
    ::omero::RMapPtr treeList(const ::std::string& path, const ::Ice::Context& __ctx)
    {
        return treeList(path, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_treeList(const ::std::string& path, const ::IceInternal::Function<void (const ::omero::RMapPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_treeList(path, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_treeList(const ::std::string& path, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_treeList(path, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_treeList(const ::std::string& path, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::omero::RMapPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_treeList(path, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_treeList(const ::std::string& path, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_treeList(path, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_treeList(const ::std::string& path, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::omero::RMapPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::omero::RMapPtr&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::grid::RepositoryPrx __proxy = ::omero::grid::RepositoryPrx::uncheckedCast(__result->getProxy());
                ::omero::RMapPtr __ret;
                try
                {
                    __ret = __proxy->end_treeList(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::omero::RMapPtr&)> _response;
        };
        return begin_treeList(path, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_treeList(const ::std::string& path)
    {
        return begin_treeList(path, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_treeList(const ::std::string& path, const ::Ice::Context& __ctx)
    {
        return begin_treeList(path, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_treeList(const ::std::string& path, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_treeList(path, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_treeList(const ::std::string& path, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_treeList(path, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_treeList(const ::std::string& path, const ::omero::grid::Callback_Repository_treeListPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_treeList(path, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_treeList(const ::std::string& path, const ::Ice::Context& __ctx, const ::omero::grid::Callback_Repository_treeListPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_treeList(path, &__ctx, __del, __cookie);
    }

    ::omero::RMapPtr end_treeList(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::RMapPtr treeList(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_treeList(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool treeList_async(const ::omero::grid::AMI_Repository_treeListPtr&, const ::std::string&);
    bool treeList_async(const ::omero::grid::AMI_Repository_treeListPtr&, const ::std::string&, const ::Ice::Context&);

    ::omero::cmd::HandlePrx deletePaths(const ::omero::api::StringArray& paths, bool recursively, bool force)
    {
        return deletePaths(paths, recursively, force, 0);
    }
    ::omero::cmd::HandlePrx deletePaths(const ::omero::api::StringArray& paths, bool recursively, bool force, const ::Ice::Context& __ctx)
    {
        return deletePaths(paths, recursively, force, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_deletePaths(const ::omero::api::StringArray& paths, bool recursively, bool force, const ::IceInternal::Function<void (const ::omero::cmd::HandlePrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_deletePaths(paths, recursively, force, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_deletePaths(const ::omero::api::StringArray& paths, bool recursively, bool force, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_deletePaths(paths, recursively, force, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_deletePaths(const ::omero::api::StringArray& paths, bool recursively, bool force, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::omero::cmd::HandlePrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_deletePaths(paths, recursively, force, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_deletePaths(const ::omero::api::StringArray& paths, bool recursively, bool force, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_deletePaths(paths, recursively, force, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_deletePaths(const ::omero::api::StringArray& paths, bool recursively, bool force, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::omero::cmd::HandlePrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::omero::cmd::HandlePrx&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::grid::RepositoryPrx __proxy = ::omero::grid::RepositoryPrx::uncheckedCast(__result->getProxy());
                ::omero::cmd::HandlePrx __ret;
                try
                {
                    __ret = __proxy->end_deletePaths(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::omero::cmd::HandlePrx&)> _response;
        };
        return begin_deletePaths(paths, recursively, force, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_deletePaths(const ::omero::api::StringArray& paths, bool recursively, bool force)
    {
        return begin_deletePaths(paths, recursively, force, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_deletePaths(const ::omero::api::StringArray& paths, bool recursively, bool force, const ::Ice::Context& __ctx)
    {
        return begin_deletePaths(paths, recursively, force, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_deletePaths(const ::omero::api::StringArray& paths, bool recursively, bool force, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_deletePaths(paths, recursively, force, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_deletePaths(const ::omero::api::StringArray& paths, bool recursively, bool force, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_deletePaths(paths, recursively, force, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_deletePaths(const ::omero::api::StringArray& paths, bool recursively, bool force, const ::omero::grid::Callback_Repository_deletePathsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_deletePaths(paths, recursively, force, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_deletePaths(const ::omero::api::StringArray& paths, bool recursively, bool force, const ::Ice::Context& __ctx, const ::omero::grid::Callback_Repository_deletePathsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_deletePaths(paths, recursively, force, &__ctx, __del, __cookie);
    }

    ::omero::cmd::HandlePrx end_deletePaths(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::cmd::HandlePrx deletePaths(const ::omero::api::StringArray&, bool, bool, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_deletePaths(const ::omero::api::StringArray&, bool, bool, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool deletePaths_async(const ::omero::grid::AMI_Repository_deletePathsPtr&, const ::omero::api::StringArray&, bool, bool);
    bool deletePaths_async(const ::omero::grid::AMI_Repository_deletePathsPtr&, const ::omero::api::StringArray&, bool, bool, const ::Ice::Context&);
    
    ::IceInternal::ProxyHandle<Repository> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<Repository*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<Repository> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<Repository*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<Repository> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<Repository*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<Repository> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<Repository*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<Repository> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<Repository*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<Repository> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<Repository*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<Repository> ice_secure(bool __secure) const
    {
        return dynamic_cast<Repository*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<Repository> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<Repository*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<Repository> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<Repository*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<Repository> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<Repository*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<Repository> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<Repository*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<Repository> ice_twoway() const
    {
        return dynamic_cast<Repository*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<Repository> ice_oneway() const
    {
        return dynamic_cast<Repository*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<Repository> ice_batchOneway() const
    {
        return dynamic_cast<Repository*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<Repository> ice_datagram() const
    {
        return dynamic_cast<Repository*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<Repository> ice_batchDatagram() const
    {
        return dynamic_cast<Repository*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<Repository> ice_compress(bool __compress) const
    {
        return dynamic_cast<Repository*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<Repository> ice_timeout(int __timeout) const
    {
        return dynamic_cast<Repository*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<Repository> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<Repository*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<Repository> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<Repository*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class ImportLocation : virtual public ::IceProxy::Ice::Object
{
public:
    
    ::IceInternal::ProxyHandle<ImportLocation> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<ImportLocation*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<ImportLocation> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<ImportLocation*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<ImportLocation> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<ImportLocation*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<ImportLocation> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<ImportLocation*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<ImportLocation> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<ImportLocation*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<ImportLocation> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<ImportLocation*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<ImportLocation> ice_secure(bool __secure) const
    {
        return dynamic_cast<ImportLocation*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<ImportLocation> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<ImportLocation*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<ImportLocation> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<ImportLocation*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<ImportLocation> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<ImportLocation*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<ImportLocation> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<ImportLocation*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<ImportLocation> ice_twoway() const
    {
        return dynamic_cast<ImportLocation*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<ImportLocation> ice_oneway() const
    {
        return dynamic_cast<ImportLocation*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<ImportLocation> ice_batchOneway() const
    {
        return dynamic_cast<ImportLocation*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<ImportLocation> ice_datagram() const
    {
        return dynamic_cast<ImportLocation*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<ImportLocation> ice_batchDatagram() const
    {
        return dynamic_cast<ImportLocation*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<ImportLocation> ice_compress(bool __compress) const
    {
        return dynamic_cast<ImportLocation*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<ImportLocation> ice_timeout(int __timeout) const
    {
        return dynamic_cast<ImportLocation*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<ImportLocation> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<ImportLocation*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<ImportLocation> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<ImportLocation*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class ImportSettings : virtual public ::IceProxy::Ice::Object
{
public:
    
    ::IceInternal::ProxyHandle<ImportSettings> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<ImportSettings*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<ImportSettings> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<ImportSettings*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<ImportSettings> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<ImportSettings*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<ImportSettings> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<ImportSettings*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<ImportSettings> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<ImportSettings*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<ImportSettings> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<ImportSettings*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<ImportSettings> ice_secure(bool __secure) const
    {
        return dynamic_cast<ImportSettings*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<ImportSettings> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<ImportSettings*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<ImportSettings> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<ImportSettings*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<ImportSettings> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<ImportSettings*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<ImportSettings> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<ImportSettings*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<ImportSettings> ice_twoway() const
    {
        return dynamic_cast<ImportSettings*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<ImportSettings> ice_oneway() const
    {
        return dynamic_cast<ImportSettings*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<ImportSettings> ice_batchOneway() const
    {
        return dynamic_cast<ImportSettings*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<ImportSettings> ice_datagram() const
    {
        return dynamic_cast<ImportSettings*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<ImportSettings> ice_batchDatagram() const
    {
        return dynamic_cast<ImportSettings*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<ImportSettings> ice_compress(bool __compress) const
    {
        return dynamic_cast<ImportSettings*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<ImportSettings> ice_timeout(int __timeout) const
    {
        return dynamic_cast<ImportSettings*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<ImportSettings> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<ImportSettings*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<ImportSettings> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<ImportSettings*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class ImportProcess : virtual public ::IceProxy::omero::api::StatefulServiceInterface
{
public:

    ::omero::api::RawFileStorePrx getUploader(::Ice::Int i)
    {
        return getUploader(i, 0);
    }
    ::omero::api::RawFileStorePrx getUploader(::Ice::Int i, const ::Ice::Context& __ctx)
    {
        return getUploader(i, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_getUploader(::Ice::Int i, const ::IceInternal::Function<void (const ::omero::api::RawFileStorePrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getUploader(i, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getUploader(::Ice::Int i, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getUploader(i, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_getUploader(::Ice::Int i, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::omero::api::RawFileStorePrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getUploader(i, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getUploader(::Ice::Int i, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getUploader(i, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_getUploader(::Ice::Int i, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::omero::api::RawFileStorePrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::omero::api::RawFileStorePrx&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::grid::ImportProcessPrx __proxy = ::omero::grid::ImportProcessPrx::uncheckedCast(__result->getProxy());
                ::omero::api::RawFileStorePrx __ret;
                try
                {
                    __ret = __proxy->end_getUploader(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::omero::api::RawFileStorePrx&)> _response;
        };
        return begin_getUploader(i, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_getUploader(::Ice::Int i)
    {
        return begin_getUploader(i, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getUploader(::Ice::Int i, const ::Ice::Context& __ctx)
    {
        return begin_getUploader(i, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getUploader(::Ice::Int i, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getUploader(i, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getUploader(::Ice::Int i, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getUploader(i, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getUploader(::Ice::Int i, const ::omero::grid::Callback_ImportProcess_getUploaderPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getUploader(i, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getUploader(::Ice::Int i, const ::Ice::Context& __ctx, const ::omero::grid::Callback_ImportProcess_getUploaderPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getUploader(i, &__ctx, __del, __cookie);
    }

    ::omero::api::RawFileStorePrx end_getUploader(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::api::RawFileStorePrx getUploader(::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getUploader(::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::cmd::HandlePrx verifyUpload(const ::omero::api::StringSet& hash)
    {
        return verifyUpload(hash, 0);
    }
    ::omero::cmd::HandlePrx verifyUpload(const ::omero::api::StringSet& hash, const ::Ice::Context& __ctx)
    {
        return verifyUpload(hash, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_verifyUpload(const ::omero::api::StringSet& hash, const ::IceInternal::Function<void (const ::omero::cmd::HandlePrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_verifyUpload(hash, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_verifyUpload(const ::omero::api::StringSet& hash, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_verifyUpload(hash, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_verifyUpload(const ::omero::api::StringSet& hash, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::omero::cmd::HandlePrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_verifyUpload(hash, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_verifyUpload(const ::omero::api::StringSet& hash, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_verifyUpload(hash, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_verifyUpload(const ::omero::api::StringSet& hash, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::omero::cmd::HandlePrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::omero::cmd::HandlePrx&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::grid::ImportProcessPrx __proxy = ::omero::grid::ImportProcessPrx::uncheckedCast(__result->getProxy());
                ::omero::cmd::HandlePrx __ret;
                try
                {
                    __ret = __proxy->end_verifyUpload(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::omero::cmd::HandlePrx&)> _response;
        };
        return begin_verifyUpload(hash, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_verifyUpload(const ::omero::api::StringSet& hash)
    {
        return begin_verifyUpload(hash, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_verifyUpload(const ::omero::api::StringSet& hash, const ::Ice::Context& __ctx)
    {
        return begin_verifyUpload(hash, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_verifyUpload(const ::omero::api::StringSet& hash, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_verifyUpload(hash, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_verifyUpload(const ::omero::api::StringSet& hash, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_verifyUpload(hash, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_verifyUpload(const ::omero::api::StringSet& hash, const ::omero::grid::Callback_ImportProcess_verifyUploadPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_verifyUpload(hash, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_verifyUpload(const ::omero::api::StringSet& hash, const ::Ice::Context& __ctx, const ::omero::grid::Callback_ImportProcess_verifyUploadPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_verifyUpload(hash, &__ctx, __del, __cookie);
    }

    ::omero::cmd::HandlePrx end_verifyUpload(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::cmd::HandlePrx verifyUpload(const ::omero::api::StringSet&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_verifyUpload(const ::omero::api::StringSet&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Long getUploadOffset(::Ice::Int i)
    {
        return getUploadOffset(i, 0);
    }
    ::Ice::Long getUploadOffset(::Ice::Int i, const ::Ice::Context& __ctx)
    {
        return getUploadOffset(i, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_getUploadOffset(::Ice::Int i, const ::IceInternal::Function<void (::Ice::Long)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getUploadOffset(i, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getUploadOffset(::Ice::Int i, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getUploadOffset(i, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_getUploadOffset(::Ice::Int i, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (::Ice::Long)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getUploadOffset(i, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getUploadOffset(::Ice::Int i, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getUploadOffset(i, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_getUploadOffset(::Ice::Int i, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (::Ice::Long)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (::Ice::Long)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::grid::ImportProcessPrx __proxy = ::omero::grid::ImportProcessPrx::uncheckedCast(__result->getProxy());
                ::Ice::Long __ret;
                try
                {
                    __ret = __proxy->end_getUploadOffset(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (::Ice::Long)> _response;
        };
        return begin_getUploadOffset(i, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_getUploadOffset(::Ice::Int i)
    {
        return begin_getUploadOffset(i, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getUploadOffset(::Ice::Int i, const ::Ice::Context& __ctx)
    {
        return begin_getUploadOffset(i, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getUploadOffset(::Ice::Int i, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getUploadOffset(i, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getUploadOffset(::Ice::Int i, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getUploadOffset(i, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getUploadOffset(::Ice::Int i, const ::omero::grid::Callback_ImportProcess_getUploadOffsetPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getUploadOffset(i, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getUploadOffset(::Ice::Int i, const ::Ice::Context& __ctx, const ::omero::grid::Callback_ImportProcess_getUploadOffsetPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getUploadOffset(i, &__ctx, __del, __cookie);
    }

    ::Ice::Long end_getUploadOffset(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Long getUploadOffset(::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getUploadOffset(::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::cmd::HandlePrx getHandle()
    {
        return getHandle(0);
    }
    ::omero::cmd::HandlePrx getHandle(const ::Ice::Context& __ctx)
    {
        return getHandle(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_getHandle(const ::IceInternal::Function<void (const ::omero::cmd::HandlePrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getHandle(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getHandle(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getHandle(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_getHandle(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::omero::cmd::HandlePrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getHandle(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getHandle(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getHandle(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_getHandle(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::omero::cmd::HandlePrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::omero::cmd::HandlePrx&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::grid::ImportProcessPrx __proxy = ::omero::grid::ImportProcessPrx::uncheckedCast(__result->getProxy());
                ::omero::cmd::HandlePrx __ret;
                try
                {
                    __ret = __proxy->end_getHandle(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::omero::cmd::HandlePrx&)> _response;
        };
        return begin_getHandle(__ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_getHandle()
    {
        return begin_getHandle(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getHandle(const ::Ice::Context& __ctx)
    {
        return begin_getHandle(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getHandle(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getHandle(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getHandle(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getHandle(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getHandle(const ::omero::grid::Callback_ImportProcess_getHandlePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getHandle(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getHandle(const ::Ice::Context& __ctx, const ::omero::grid::Callback_ImportProcess_getHandlePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getHandle(&__ctx, __del, __cookie);
    }

    ::omero::cmd::HandlePrx end_getHandle(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::cmd::HandlePrx getHandle(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getHandle(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::grid::ImportSettingsPtr getImportSettings()
    {
        return getImportSettings(0);
    }
    ::omero::grid::ImportSettingsPtr getImportSettings(const ::Ice::Context& __ctx)
    {
        return getImportSettings(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_getImportSettings(const ::IceInternal::Function<void (const ::omero::grid::ImportSettingsPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getImportSettings(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getImportSettings(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getImportSettings(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_getImportSettings(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::omero::grid::ImportSettingsPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getImportSettings(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getImportSettings(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getImportSettings(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_getImportSettings(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::omero::grid::ImportSettingsPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::omero::grid::ImportSettingsPtr&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::grid::ImportProcessPrx __proxy = ::omero::grid::ImportProcessPrx::uncheckedCast(__result->getProxy());
                ::omero::grid::ImportSettingsPtr __ret;
                try
                {
                    __ret = __proxy->end_getImportSettings(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::omero::grid::ImportSettingsPtr&)> _response;
        };
        return begin_getImportSettings(__ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_getImportSettings()
    {
        return begin_getImportSettings(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getImportSettings(const ::Ice::Context& __ctx)
    {
        return begin_getImportSettings(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getImportSettings(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getImportSettings(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getImportSettings(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getImportSettings(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getImportSettings(const ::omero::grid::Callback_ImportProcess_getImportSettingsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getImportSettings(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getImportSettings(const ::Ice::Context& __ctx, const ::omero::grid::Callback_ImportProcess_getImportSettingsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getImportSettings(&__ctx, __del, __cookie);
    }

    ::omero::grid::ImportSettingsPtr end_getImportSettings(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::grid::ImportSettingsPtr getImportSettings(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getImportSettings(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    
    ::IceInternal::ProxyHandle<ImportProcess> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<ImportProcess*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<ImportProcess> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<ImportProcess*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<ImportProcess> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<ImportProcess*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<ImportProcess> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<ImportProcess*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<ImportProcess> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<ImportProcess*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<ImportProcess> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<ImportProcess*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<ImportProcess> ice_secure(bool __secure) const
    {
        return dynamic_cast<ImportProcess*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<ImportProcess> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<ImportProcess*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<ImportProcess> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<ImportProcess*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<ImportProcess> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<ImportProcess*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<ImportProcess> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<ImportProcess*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<ImportProcess> ice_twoway() const
    {
        return dynamic_cast<ImportProcess*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<ImportProcess> ice_oneway() const
    {
        return dynamic_cast<ImportProcess*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<ImportProcess> ice_batchOneway() const
    {
        return dynamic_cast<ImportProcess*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<ImportProcess> ice_datagram() const
    {
        return dynamic_cast<ImportProcess*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<ImportProcess> ice_batchDatagram() const
    {
        return dynamic_cast<ImportProcess*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<ImportProcess> ice_compress(bool __compress) const
    {
        return dynamic_cast<ImportProcess*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<ImportProcess> ice_timeout(int __timeout) const
    {
        return dynamic_cast<ImportProcess*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<ImportProcess> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<ImportProcess*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<ImportProcess> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<ImportProcess*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class ImportRequest : virtual public ::IceProxy::omero::cmd::Request
{
public:
    
    ::IceInternal::ProxyHandle<ImportRequest> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<ImportRequest*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<ImportRequest> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<ImportRequest*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<ImportRequest> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<ImportRequest*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<ImportRequest> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<ImportRequest*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<ImportRequest> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<ImportRequest*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<ImportRequest> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<ImportRequest*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<ImportRequest> ice_secure(bool __secure) const
    {
        return dynamic_cast<ImportRequest*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<ImportRequest> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<ImportRequest*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<ImportRequest> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<ImportRequest*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<ImportRequest> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<ImportRequest*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<ImportRequest> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<ImportRequest*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<ImportRequest> ice_twoway() const
    {
        return dynamic_cast<ImportRequest*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<ImportRequest> ice_oneway() const
    {
        return dynamic_cast<ImportRequest*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<ImportRequest> ice_batchOneway() const
    {
        return dynamic_cast<ImportRequest*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<ImportRequest> ice_datagram() const
    {
        return dynamic_cast<ImportRequest*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<ImportRequest> ice_batchDatagram() const
    {
        return dynamic_cast<ImportRequest*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<ImportRequest> ice_compress(bool __compress) const
    {
        return dynamic_cast<ImportRequest*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<ImportRequest> ice_timeout(int __timeout) const
    {
        return dynamic_cast<ImportRequest*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<ImportRequest> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<ImportRequest*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<ImportRequest> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<ImportRequest*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class ImportResponse : virtual public ::IceProxy::omero::cmd::Response
{
public:
    
    ::IceInternal::ProxyHandle<ImportResponse> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<ImportResponse*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<ImportResponse> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<ImportResponse*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<ImportResponse> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<ImportResponse*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<ImportResponse> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<ImportResponse*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<ImportResponse> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<ImportResponse*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<ImportResponse> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<ImportResponse*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<ImportResponse> ice_secure(bool __secure) const
    {
        return dynamic_cast<ImportResponse*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<ImportResponse> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<ImportResponse*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<ImportResponse> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<ImportResponse*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<ImportResponse> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<ImportResponse*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<ImportResponse> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<ImportResponse*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<ImportResponse> ice_twoway() const
    {
        return dynamic_cast<ImportResponse*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<ImportResponse> ice_oneway() const
    {
        return dynamic_cast<ImportResponse*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<ImportResponse> ice_batchOneway() const
    {
        return dynamic_cast<ImportResponse*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<ImportResponse> ice_datagram() const
    {
        return dynamic_cast<ImportResponse*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<ImportResponse> ice_batchDatagram() const
    {
        return dynamic_cast<ImportResponse*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<ImportResponse> ice_compress(bool __compress) const
    {
        return dynamic_cast<ImportResponse*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<ImportResponse> ice_timeout(int __timeout) const
    {
        return dynamic_cast<ImportResponse*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<ImportResponse> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<ImportResponse*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<ImportResponse> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<ImportResponse*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class ManagedRepository : virtual public ::IceProxy::omero::grid::Repository
{
public:

    ::omero::grid::ImportProcessPrx importFileset(const ::omero::model::FilesetPtr& fs, const ::omero::grid::ImportSettingsPtr& settings)
    {
        return importFileset(fs, settings, 0);
    }
    ::omero::grid::ImportProcessPrx importFileset(const ::omero::model::FilesetPtr& fs, const ::omero::grid::ImportSettingsPtr& settings, const ::Ice::Context& __ctx)
    {
        return importFileset(fs, settings, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_importFileset(const ::omero::model::FilesetPtr& fs, const ::omero::grid::ImportSettingsPtr& settings, const ::IceInternal::Function<void (const ::omero::grid::ImportProcessPrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_importFileset(fs, settings, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_importFileset(const ::omero::model::FilesetPtr& fs, const ::omero::grid::ImportSettingsPtr& settings, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_importFileset(fs, settings, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_importFileset(const ::omero::model::FilesetPtr& fs, const ::omero::grid::ImportSettingsPtr& settings, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::omero::grid::ImportProcessPrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_importFileset(fs, settings, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_importFileset(const ::omero::model::FilesetPtr& fs, const ::omero::grid::ImportSettingsPtr& settings, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_importFileset(fs, settings, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_importFileset(const ::omero::model::FilesetPtr& fs, const ::omero::grid::ImportSettingsPtr& settings, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::omero::grid::ImportProcessPrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::omero::grid::ImportProcessPrx&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::grid::ManagedRepositoryPrx __proxy = ::omero::grid::ManagedRepositoryPrx::uncheckedCast(__result->getProxy());
                ::omero::grid::ImportProcessPrx __ret;
                try
                {
                    __ret = __proxy->end_importFileset(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::omero::grid::ImportProcessPrx&)> _response;
        };
        return begin_importFileset(fs, settings, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_importFileset(const ::omero::model::FilesetPtr& fs, const ::omero::grid::ImportSettingsPtr& settings)
    {
        return begin_importFileset(fs, settings, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_importFileset(const ::omero::model::FilesetPtr& fs, const ::omero::grid::ImportSettingsPtr& settings, const ::Ice::Context& __ctx)
    {
        return begin_importFileset(fs, settings, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_importFileset(const ::omero::model::FilesetPtr& fs, const ::omero::grid::ImportSettingsPtr& settings, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_importFileset(fs, settings, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_importFileset(const ::omero::model::FilesetPtr& fs, const ::omero::grid::ImportSettingsPtr& settings, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_importFileset(fs, settings, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_importFileset(const ::omero::model::FilesetPtr& fs, const ::omero::grid::ImportSettingsPtr& settings, const ::omero::grid::Callback_ManagedRepository_importFilesetPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_importFileset(fs, settings, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_importFileset(const ::omero::model::FilesetPtr& fs, const ::omero::grid::ImportSettingsPtr& settings, const ::Ice::Context& __ctx, const ::omero::grid::Callback_ManagedRepository_importFilesetPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_importFileset(fs, settings, &__ctx, __del, __cookie);
    }

    ::omero::grid::ImportProcessPrx end_importFileset(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::grid::ImportProcessPrx importFileset(const ::omero::model::FilesetPtr&, const ::omero::grid::ImportSettingsPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_importFileset(const ::omero::model::FilesetPtr&, const ::omero::grid::ImportSettingsPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool importFileset_async(const ::omero::grid::AMI_ManagedRepository_importFilesetPtr&, const ::omero::model::FilesetPtr&, const ::omero::grid::ImportSettingsPtr&);
    bool importFileset_async(const ::omero::grid::AMI_ManagedRepository_importFilesetPtr&, const ::omero::model::FilesetPtr&, const ::omero::grid::ImportSettingsPtr&, const ::Ice::Context&);

    ::omero::grid::ImportProcessPrx importPaths(const ::omero::api::StringSet& filePaths)
    {
        return importPaths(filePaths, 0);
    }
    ::omero::grid::ImportProcessPrx importPaths(const ::omero::api::StringSet& filePaths, const ::Ice::Context& __ctx)
    {
        return importPaths(filePaths, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_importPaths(const ::omero::api::StringSet& filePaths, const ::IceInternal::Function<void (const ::omero::grid::ImportProcessPrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_importPaths(filePaths, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_importPaths(const ::omero::api::StringSet& filePaths, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_importPaths(filePaths, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_importPaths(const ::omero::api::StringSet& filePaths, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::omero::grid::ImportProcessPrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_importPaths(filePaths, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_importPaths(const ::omero::api::StringSet& filePaths, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_importPaths(filePaths, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_importPaths(const ::omero::api::StringSet& filePaths, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::omero::grid::ImportProcessPrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::omero::grid::ImportProcessPrx&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::grid::ManagedRepositoryPrx __proxy = ::omero::grid::ManagedRepositoryPrx::uncheckedCast(__result->getProxy());
                ::omero::grid::ImportProcessPrx __ret;
                try
                {
                    __ret = __proxy->end_importPaths(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::omero::grid::ImportProcessPrx&)> _response;
        };
        return begin_importPaths(filePaths, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_importPaths(const ::omero::api::StringSet& filePaths)
    {
        return begin_importPaths(filePaths, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_importPaths(const ::omero::api::StringSet& filePaths, const ::Ice::Context& __ctx)
    {
        return begin_importPaths(filePaths, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_importPaths(const ::omero::api::StringSet& filePaths, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_importPaths(filePaths, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_importPaths(const ::omero::api::StringSet& filePaths, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_importPaths(filePaths, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_importPaths(const ::omero::api::StringSet& filePaths, const ::omero::grid::Callback_ManagedRepository_importPathsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_importPaths(filePaths, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_importPaths(const ::omero::api::StringSet& filePaths, const ::Ice::Context& __ctx, const ::omero::grid::Callback_ManagedRepository_importPathsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_importPaths(filePaths, &__ctx, __del, __cookie);
    }

    ::omero::grid::ImportProcessPrx end_importPaths(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::grid::ImportProcessPrx importPaths(const ::omero::api::StringSet&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_importPaths(const ::omero::api::StringSet&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool importPaths_async(const ::omero::grid::AMI_ManagedRepository_importPathsPtr&, const ::omero::api::StringSet&);
    bool importPaths_async(const ::omero::grid::AMI_ManagedRepository_importPathsPtr&, const ::omero::api::StringSet&, const ::Ice::Context&);

    ::omero::grid::ImportProcessList listImports()
    {
        return listImports(0);
    }
    ::omero::grid::ImportProcessList listImports(const ::Ice::Context& __ctx)
    {
        return listImports(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_listImports(const ::IceInternal::Function<void (const ::omero::grid::ImportProcessList&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_listImports(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_listImports(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_listImports(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_listImports(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::omero::grid::ImportProcessList&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_listImports(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_listImports(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_listImports(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_listImports(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::omero::grid::ImportProcessList&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::omero::grid::ImportProcessList&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::grid::ManagedRepositoryPrx __proxy = ::omero::grid::ManagedRepositoryPrx::uncheckedCast(__result->getProxy());
                ::omero::grid::ImportProcessList __ret;
                try
                {
                    __ret = __proxy->end_listImports(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::omero::grid::ImportProcessList&)> _response;
        };
        return begin_listImports(__ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_listImports()
    {
        return begin_listImports(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_listImports(const ::Ice::Context& __ctx)
    {
        return begin_listImports(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_listImports(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_listImports(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_listImports(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_listImports(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_listImports(const ::omero::grid::Callback_ManagedRepository_listImportsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_listImports(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_listImports(const ::Ice::Context& __ctx, const ::omero::grid::Callback_ManagedRepository_listImportsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_listImports(&__ctx, __del, __cookie);
    }

    ::omero::grid::ImportProcessList end_listImports(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::grid::ImportProcessList listImports(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_listImports(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool listImports_async(const ::omero::grid::AMI_ManagedRepository_listImportsPtr&);
    bool listImports_async(const ::omero::grid::AMI_ManagedRepository_listImportsPtr&, const ::Ice::Context&);

    ::omero::api::ChecksumAlgorithmList listChecksumAlgorithms()
    {
        return listChecksumAlgorithms(0);
    }
    ::omero::api::ChecksumAlgorithmList listChecksumAlgorithms(const ::Ice::Context& __ctx)
    {
        return listChecksumAlgorithms(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_listChecksumAlgorithms(const ::IceInternal::Function<void (const ::omero::api::ChecksumAlgorithmList&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_listChecksumAlgorithms(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_listChecksumAlgorithms(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_listChecksumAlgorithms(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_listChecksumAlgorithms(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::omero::api::ChecksumAlgorithmList&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_listChecksumAlgorithms(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_listChecksumAlgorithms(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_listChecksumAlgorithms(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_listChecksumAlgorithms(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::omero::api::ChecksumAlgorithmList&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::omero::api::ChecksumAlgorithmList&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::grid::ManagedRepositoryPrx __proxy = ::omero::grid::ManagedRepositoryPrx::uncheckedCast(__result->getProxy());
                ::omero::api::ChecksumAlgorithmList __ret;
                try
                {
                    __ret = __proxy->end_listChecksumAlgorithms(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::omero::api::ChecksumAlgorithmList&)> _response;
        };
        return begin_listChecksumAlgorithms(__ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_listChecksumAlgorithms()
    {
        return begin_listChecksumAlgorithms(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_listChecksumAlgorithms(const ::Ice::Context& __ctx)
    {
        return begin_listChecksumAlgorithms(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_listChecksumAlgorithms(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_listChecksumAlgorithms(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_listChecksumAlgorithms(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_listChecksumAlgorithms(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_listChecksumAlgorithms(const ::omero::grid::Callback_ManagedRepository_listChecksumAlgorithmsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_listChecksumAlgorithms(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_listChecksumAlgorithms(const ::Ice::Context& __ctx, const ::omero::grid::Callback_ManagedRepository_listChecksumAlgorithmsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_listChecksumAlgorithms(&__ctx, __del, __cookie);
    }

    ::omero::api::ChecksumAlgorithmList end_listChecksumAlgorithms(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::api::ChecksumAlgorithmList listChecksumAlgorithms(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_listChecksumAlgorithms(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool listChecksumAlgorithms_async(const ::omero::grid::AMI_ManagedRepository_listChecksumAlgorithmsPtr&);
    bool listChecksumAlgorithms_async(const ::omero::grid::AMI_ManagedRepository_listChecksumAlgorithmsPtr&, const ::Ice::Context&);

    ::omero::model::ChecksumAlgorithmPtr suggestChecksumAlgorithm(const ::omero::api::ChecksumAlgorithmList& supported)
    {
        return suggestChecksumAlgorithm(supported, 0);
    }
    ::omero::model::ChecksumAlgorithmPtr suggestChecksumAlgorithm(const ::omero::api::ChecksumAlgorithmList& supported, const ::Ice::Context& __ctx)
    {
        return suggestChecksumAlgorithm(supported, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_suggestChecksumAlgorithm(const ::omero::api::ChecksumAlgorithmList& supported, const ::IceInternal::Function<void (const ::omero::model::ChecksumAlgorithmPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_suggestChecksumAlgorithm(supported, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_suggestChecksumAlgorithm(const ::omero::api::ChecksumAlgorithmList& supported, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_suggestChecksumAlgorithm(supported, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_suggestChecksumAlgorithm(const ::omero::api::ChecksumAlgorithmList& supported, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::omero::model::ChecksumAlgorithmPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_suggestChecksumAlgorithm(supported, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_suggestChecksumAlgorithm(const ::omero::api::ChecksumAlgorithmList& supported, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_suggestChecksumAlgorithm(supported, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_suggestChecksumAlgorithm(const ::omero::api::ChecksumAlgorithmList& supported, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::omero::model::ChecksumAlgorithmPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::omero::model::ChecksumAlgorithmPtr&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::grid::ManagedRepositoryPrx __proxy = ::omero::grid::ManagedRepositoryPrx::uncheckedCast(__result->getProxy());
                ::omero::model::ChecksumAlgorithmPtr __ret;
                try
                {
                    __ret = __proxy->end_suggestChecksumAlgorithm(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::omero::model::ChecksumAlgorithmPtr&)> _response;
        };
        return begin_suggestChecksumAlgorithm(supported, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_suggestChecksumAlgorithm(const ::omero::api::ChecksumAlgorithmList& supported)
    {
        return begin_suggestChecksumAlgorithm(supported, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_suggestChecksumAlgorithm(const ::omero::api::ChecksumAlgorithmList& supported, const ::Ice::Context& __ctx)
    {
        return begin_suggestChecksumAlgorithm(supported, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_suggestChecksumAlgorithm(const ::omero::api::ChecksumAlgorithmList& supported, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_suggestChecksumAlgorithm(supported, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_suggestChecksumAlgorithm(const ::omero::api::ChecksumAlgorithmList& supported, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_suggestChecksumAlgorithm(supported, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_suggestChecksumAlgorithm(const ::omero::api::ChecksumAlgorithmList& supported, const ::omero::grid::Callback_ManagedRepository_suggestChecksumAlgorithmPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_suggestChecksumAlgorithm(supported, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_suggestChecksumAlgorithm(const ::omero::api::ChecksumAlgorithmList& supported, const ::Ice::Context& __ctx, const ::omero::grid::Callback_ManagedRepository_suggestChecksumAlgorithmPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_suggestChecksumAlgorithm(supported, &__ctx, __del, __cookie);
    }

    ::omero::model::ChecksumAlgorithmPtr end_suggestChecksumAlgorithm(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::model::ChecksumAlgorithmPtr suggestChecksumAlgorithm(const ::omero::api::ChecksumAlgorithmList&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_suggestChecksumAlgorithm(const ::omero::api::ChecksumAlgorithmList&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool suggestChecksumAlgorithm_async(const ::omero::grid::AMI_ManagedRepository_suggestChecksumAlgorithmPtr&, const ::omero::api::ChecksumAlgorithmList&);
    bool suggestChecksumAlgorithm_async(const ::omero::grid::AMI_ManagedRepository_suggestChecksumAlgorithmPtr&, const ::omero::api::ChecksumAlgorithmList&, const ::Ice::Context&);
    
    ::IceInternal::ProxyHandle<ManagedRepository> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<ManagedRepository*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<ManagedRepository> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<ManagedRepository*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<ManagedRepository> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<ManagedRepository*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<ManagedRepository> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<ManagedRepository*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<ManagedRepository> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<ManagedRepository*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<ManagedRepository> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<ManagedRepository*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<ManagedRepository> ice_secure(bool __secure) const
    {
        return dynamic_cast<ManagedRepository*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<ManagedRepository> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<ManagedRepository*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<ManagedRepository> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<ManagedRepository*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<ManagedRepository> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<ManagedRepository*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<ManagedRepository> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<ManagedRepository*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<ManagedRepository> ice_twoway() const
    {
        return dynamic_cast<ManagedRepository*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<ManagedRepository> ice_oneway() const
    {
        return dynamic_cast<ManagedRepository*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<ManagedRepository> ice_batchOneway() const
    {
        return dynamic_cast<ManagedRepository*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<ManagedRepository> ice_datagram() const
    {
        return dynamic_cast<ManagedRepository*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<ManagedRepository> ice_batchDatagram() const
    {
        return dynamic_cast<ManagedRepository*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<ManagedRepository> ice_compress(bool __compress) const
    {
        return dynamic_cast<ManagedRepository*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<ManagedRepository> ice_timeout(int __timeout) const
    {
        return dynamic_cast<ManagedRepository*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<ManagedRepository> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<ManagedRepository*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<ManagedRepository> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<ManagedRepository*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class RawAccessRequest : virtual public ::IceProxy::omero::cmd::Request
{
public:
    
    ::IceInternal::ProxyHandle<RawAccessRequest> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<RawAccessRequest*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<RawAccessRequest> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<RawAccessRequest*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<RawAccessRequest> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<RawAccessRequest*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<RawAccessRequest> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<RawAccessRequest*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<RawAccessRequest> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<RawAccessRequest*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<RawAccessRequest> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<RawAccessRequest*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<RawAccessRequest> ice_secure(bool __secure) const
    {
        return dynamic_cast<RawAccessRequest*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<RawAccessRequest> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<RawAccessRequest*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<RawAccessRequest> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<RawAccessRequest*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<RawAccessRequest> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<RawAccessRequest*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<RawAccessRequest> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<RawAccessRequest*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<RawAccessRequest> ice_twoway() const
    {
        return dynamic_cast<RawAccessRequest*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<RawAccessRequest> ice_oneway() const
    {
        return dynamic_cast<RawAccessRequest*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<RawAccessRequest> ice_batchOneway() const
    {
        return dynamic_cast<RawAccessRequest*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<RawAccessRequest> ice_datagram() const
    {
        return dynamic_cast<RawAccessRequest*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<RawAccessRequest> ice_batchDatagram() const
    {
        return dynamic_cast<RawAccessRequest*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<RawAccessRequest> ice_compress(bool __compress) const
    {
        return dynamic_cast<RawAccessRequest*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<RawAccessRequest> ice_timeout(int __timeout) const
    {
        return dynamic_cast<RawAccessRequest*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<RawAccessRequest> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<RawAccessRequest*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<RawAccessRequest> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<RawAccessRequest*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class InternalRepository : virtual public ::IceProxy::Ice::Object
{
public:

    ::omero::api::RawFileStorePrx createRawFileStore(const ::omero::model::OriginalFilePtr& file)
    {
        return createRawFileStore(file, 0);
    }
    ::omero::api::RawFileStorePrx createRawFileStore(const ::omero::model::OriginalFilePtr& file, const ::Ice::Context& __ctx)
    {
        return createRawFileStore(file, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_createRawFileStore(const ::omero::model::OriginalFilePtr& file, const ::IceInternal::Function<void (const ::omero::api::RawFileStorePrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_createRawFileStore(file, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_createRawFileStore(const ::omero::model::OriginalFilePtr& file, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_createRawFileStore(file, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_createRawFileStore(const ::omero::model::OriginalFilePtr& file, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::omero::api::RawFileStorePrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_createRawFileStore(file, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_createRawFileStore(const ::omero::model::OriginalFilePtr& file, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_createRawFileStore(file, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_createRawFileStore(const ::omero::model::OriginalFilePtr& file, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::omero::api::RawFileStorePrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::omero::api::RawFileStorePrx&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::grid::InternalRepositoryPrx __proxy = ::omero::grid::InternalRepositoryPrx::uncheckedCast(__result->getProxy());
                ::omero::api::RawFileStorePrx __ret;
                try
                {
                    __ret = __proxy->end_createRawFileStore(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::omero::api::RawFileStorePrx&)> _response;
        };
        return begin_createRawFileStore(file, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_createRawFileStore(const ::omero::model::OriginalFilePtr& file)
    {
        return begin_createRawFileStore(file, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_createRawFileStore(const ::omero::model::OriginalFilePtr& file, const ::Ice::Context& __ctx)
    {
        return begin_createRawFileStore(file, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_createRawFileStore(const ::omero::model::OriginalFilePtr& file, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createRawFileStore(file, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_createRawFileStore(const ::omero::model::OriginalFilePtr& file, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createRawFileStore(file, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_createRawFileStore(const ::omero::model::OriginalFilePtr& file, const ::omero::grid::Callback_InternalRepository_createRawFileStorePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createRawFileStore(file, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_createRawFileStore(const ::omero::model::OriginalFilePtr& file, const ::Ice::Context& __ctx, const ::omero::grid::Callback_InternalRepository_createRawFileStorePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createRawFileStore(file, &__ctx, __del, __cookie);
    }

    ::omero::api::RawFileStorePrx end_createRawFileStore(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::api::RawFileStorePrx createRawFileStore(const ::omero::model::OriginalFilePtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_createRawFileStore(const ::omero::model::OriginalFilePtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool createRawFileStore_async(const ::omero::grid::AMI_InternalRepository_createRawFileStorePtr&, const ::omero::model::OriginalFilePtr&);
    bool createRawFileStore_async(const ::omero::grid::AMI_InternalRepository_createRawFileStorePtr&, const ::omero::model::OriginalFilePtr&, const ::Ice::Context&);

    ::omero::api::RawPixelsStorePrx createRawPixelsStore(const ::omero::model::OriginalFilePtr& file)
    {
        return createRawPixelsStore(file, 0);
    }
    ::omero::api::RawPixelsStorePrx createRawPixelsStore(const ::omero::model::OriginalFilePtr& file, const ::Ice::Context& __ctx)
    {
        return createRawPixelsStore(file, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_createRawPixelsStore(const ::omero::model::OriginalFilePtr& file, const ::IceInternal::Function<void (const ::omero::api::RawPixelsStorePrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_createRawPixelsStore(file, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_createRawPixelsStore(const ::omero::model::OriginalFilePtr& file, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_createRawPixelsStore(file, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_createRawPixelsStore(const ::omero::model::OriginalFilePtr& file, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::omero::api::RawPixelsStorePrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_createRawPixelsStore(file, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_createRawPixelsStore(const ::omero::model::OriginalFilePtr& file, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_createRawPixelsStore(file, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_createRawPixelsStore(const ::omero::model::OriginalFilePtr& file, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::omero::api::RawPixelsStorePrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::omero::api::RawPixelsStorePrx&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::grid::InternalRepositoryPrx __proxy = ::omero::grid::InternalRepositoryPrx::uncheckedCast(__result->getProxy());
                ::omero::api::RawPixelsStorePrx __ret;
                try
                {
                    __ret = __proxy->end_createRawPixelsStore(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::omero::api::RawPixelsStorePrx&)> _response;
        };
        return begin_createRawPixelsStore(file, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_createRawPixelsStore(const ::omero::model::OriginalFilePtr& file)
    {
        return begin_createRawPixelsStore(file, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_createRawPixelsStore(const ::omero::model::OriginalFilePtr& file, const ::Ice::Context& __ctx)
    {
        return begin_createRawPixelsStore(file, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_createRawPixelsStore(const ::omero::model::OriginalFilePtr& file, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createRawPixelsStore(file, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_createRawPixelsStore(const ::omero::model::OriginalFilePtr& file, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createRawPixelsStore(file, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_createRawPixelsStore(const ::omero::model::OriginalFilePtr& file, const ::omero::grid::Callback_InternalRepository_createRawPixelsStorePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createRawPixelsStore(file, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_createRawPixelsStore(const ::omero::model::OriginalFilePtr& file, const ::Ice::Context& __ctx, const ::omero::grid::Callback_InternalRepository_createRawPixelsStorePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createRawPixelsStore(file, &__ctx, __del, __cookie);
    }

    ::omero::api::RawPixelsStorePrx end_createRawPixelsStore(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::api::RawPixelsStorePrx createRawPixelsStore(const ::omero::model::OriginalFilePtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_createRawPixelsStore(const ::omero::model::OriginalFilePtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool createRawPixelsStore_async(const ::omero::grid::AMI_InternalRepository_createRawPixelsStorePtr&, const ::omero::model::OriginalFilePtr&);
    bool createRawPixelsStore_async(const ::omero::grid::AMI_InternalRepository_createRawPixelsStorePtr&, const ::omero::model::OriginalFilePtr&, const ::Ice::Context&);

    ::omero::api::RenderingEnginePrx createRenderingEngine(const ::omero::model::OriginalFilePtr& file)
    {
        return createRenderingEngine(file, 0);
    }
    ::omero::api::RenderingEnginePrx createRenderingEngine(const ::omero::model::OriginalFilePtr& file, const ::Ice::Context& __ctx)
    {
        return createRenderingEngine(file, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_createRenderingEngine(const ::omero::model::OriginalFilePtr& file, const ::IceInternal::Function<void (const ::omero::api::RenderingEnginePrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_createRenderingEngine(file, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_createRenderingEngine(const ::omero::model::OriginalFilePtr& file, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_createRenderingEngine(file, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_createRenderingEngine(const ::omero::model::OriginalFilePtr& file, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::omero::api::RenderingEnginePrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_createRenderingEngine(file, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_createRenderingEngine(const ::omero::model::OriginalFilePtr& file, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_createRenderingEngine(file, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_createRenderingEngine(const ::omero::model::OriginalFilePtr& file, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::omero::api::RenderingEnginePrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::omero::api::RenderingEnginePrx&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::grid::InternalRepositoryPrx __proxy = ::omero::grid::InternalRepositoryPrx::uncheckedCast(__result->getProxy());
                ::omero::api::RenderingEnginePrx __ret;
                try
                {
                    __ret = __proxy->end_createRenderingEngine(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::omero::api::RenderingEnginePrx&)> _response;
        };
        return begin_createRenderingEngine(file, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_createRenderingEngine(const ::omero::model::OriginalFilePtr& file)
    {
        return begin_createRenderingEngine(file, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_createRenderingEngine(const ::omero::model::OriginalFilePtr& file, const ::Ice::Context& __ctx)
    {
        return begin_createRenderingEngine(file, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_createRenderingEngine(const ::omero::model::OriginalFilePtr& file, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createRenderingEngine(file, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_createRenderingEngine(const ::omero::model::OriginalFilePtr& file, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createRenderingEngine(file, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_createRenderingEngine(const ::omero::model::OriginalFilePtr& file, const ::omero::grid::Callback_InternalRepository_createRenderingEnginePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createRenderingEngine(file, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_createRenderingEngine(const ::omero::model::OriginalFilePtr& file, const ::Ice::Context& __ctx, const ::omero::grid::Callback_InternalRepository_createRenderingEnginePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createRenderingEngine(file, &__ctx, __del, __cookie);
    }

    ::omero::api::RenderingEnginePrx end_createRenderingEngine(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::api::RenderingEnginePrx createRenderingEngine(const ::omero::model::OriginalFilePtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_createRenderingEngine(const ::omero::model::OriginalFilePtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool createRenderingEngine_async(const ::omero::grid::AMI_InternalRepository_createRenderingEnginePtr&, const ::omero::model::OriginalFilePtr&);
    bool createRenderingEngine_async(const ::omero::grid::AMI_InternalRepository_createRenderingEnginePtr&, const ::omero::model::OriginalFilePtr&, const ::Ice::Context&);

    ::omero::api::ThumbnailStorePrx createThumbnailStore(const ::omero::model::OriginalFilePtr& file)
    {
        return createThumbnailStore(file, 0);
    }
    ::omero::api::ThumbnailStorePrx createThumbnailStore(const ::omero::model::OriginalFilePtr& file, const ::Ice::Context& __ctx)
    {
        return createThumbnailStore(file, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_createThumbnailStore(const ::omero::model::OriginalFilePtr& file, const ::IceInternal::Function<void (const ::omero::api::ThumbnailStorePrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_createThumbnailStore(file, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_createThumbnailStore(const ::omero::model::OriginalFilePtr& file, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_createThumbnailStore(file, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_createThumbnailStore(const ::omero::model::OriginalFilePtr& file, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::omero::api::ThumbnailStorePrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_createThumbnailStore(file, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_createThumbnailStore(const ::omero::model::OriginalFilePtr& file, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_createThumbnailStore(file, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_createThumbnailStore(const ::omero::model::OriginalFilePtr& file, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::omero::api::ThumbnailStorePrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::omero::api::ThumbnailStorePrx&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::grid::InternalRepositoryPrx __proxy = ::omero::grid::InternalRepositoryPrx::uncheckedCast(__result->getProxy());
                ::omero::api::ThumbnailStorePrx __ret;
                try
                {
                    __ret = __proxy->end_createThumbnailStore(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::omero::api::ThumbnailStorePrx&)> _response;
        };
        return begin_createThumbnailStore(file, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_createThumbnailStore(const ::omero::model::OriginalFilePtr& file)
    {
        return begin_createThumbnailStore(file, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_createThumbnailStore(const ::omero::model::OriginalFilePtr& file, const ::Ice::Context& __ctx)
    {
        return begin_createThumbnailStore(file, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_createThumbnailStore(const ::omero::model::OriginalFilePtr& file, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createThumbnailStore(file, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_createThumbnailStore(const ::omero::model::OriginalFilePtr& file, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createThumbnailStore(file, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_createThumbnailStore(const ::omero::model::OriginalFilePtr& file, const ::omero::grid::Callback_InternalRepository_createThumbnailStorePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createThumbnailStore(file, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_createThumbnailStore(const ::omero::model::OriginalFilePtr& file, const ::Ice::Context& __ctx, const ::omero::grid::Callback_InternalRepository_createThumbnailStorePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createThumbnailStore(file, &__ctx, __del, __cookie);
    }

    ::omero::api::ThumbnailStorePrx end_createThumbnailStore(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::api::ThumbnailStorePrx createThumbnailStore(const ::omero::model::OriginalFilePtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_createThumbnailStore(const ::omero::model::OriginalFilePtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool createThumbnailStore_async(const ::omero::grid::AMI_InternalRepository_createThumbnailStorePtr&, const ::omero::model::OriginalFilePtr&);
    bool createThumbnailStore_async(const ::omero::grid::AMI_InternalRepository_createThumbnailStorePtr&, const ::omero::model::OriginalFilePtr&, const ::Ice::Context&);

    ::omero::model::OriginalFilePtr getDescription()
    {
        return getDescription(0);
    }
    ::omero::model::OriginalFilePtr getDescription(const ::Ice::Context& __ctx)
    {
        return getDescription(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_getDescription(const ::IceInternal::Function<void (const ::omero::model::OriginalFilePtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getDescription(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getDescription(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getDescription(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_getDescription(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::omero::model::OriginalFilePtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getDescription(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getDescription(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getDescription(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_getDescription(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::omero::model::OriginalFilePtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::omero::model::OriginalFilePtr&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::grid::InternalRepositoryPrx __proxy = ::omero::grid::InternalRepositoryPrx::uncheckedCast(__result->getProxy());
                ::omero::model::OriginalFilePtr __ret;
                try
                {
                    __ret = __proxy->end_getDescription(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::omero::model::OriginalFilePtr&)> _response;
        };
        return begin_getDescription(__ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_getDescription()
    {
        return begin_getDescription(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getDescription(const ::Ice::Context& __ctx)
    {
        return begin_getDescription(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getDescription(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getDescription(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getDescription(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getDescription(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getDescription(const ::omero::grid::Callback_InternalRepository_getDescriptionPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getDescription(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getDescription(const ::Ice::Context& __ctx, const ::omero::grid::Callback_InternalRepository_getDescriptionPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getDescription(&__ctx, __del, __cookie);
    }

    ::omero::model::OriginalFilePtr end_getDescription(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::model::OriginalFilePtr getDescription(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getDescription(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool getDescription_async(const ::omero::grid::AMI_InternalRepository_getDescriptionPtr&);
    bool getDescription_async(const ::omero::grid::AMI_InternalRepository_getDescriptionPtr&, const ::Ice::Context&);

    ::omero::grid::RepositoryPrx getProxy()
    {
        return getProxy(0);
    }
    ::omero::grid::RepositoryPrx getProxy(const ::Ice::Context& __ctx)
    {
        return getProxy(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_getProxy(const ::IceInternal::Function<void (const ::omero::grid::RepositoryPrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getProxy(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getProxy(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getProxy(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_getProxy(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::omero::grid::RepositoryPrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getProxy(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getProxy(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getProxy(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_getProxy(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::omero::grid::RepositoryPrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::omero::grid::RepositoryPrx&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::grid::InternalRepositoryPrx __proxy = ::omero::grid::InternalRepositoryPrx::uncheckedCast(__result->getProxy());
                ::omero::grid::RepositoryPrx __ret;
                try
                {
                    __ret = __proxy->end_getProxy(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::omero::grid::RepositoryPrx&)> _response;
        };
        return begin_getProxy(__ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_getProxy()
    {
        return begin_getProxy(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getProxy(const ::Ice::Context& __ctx)
    {
        return begin_getProxy(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getProxy(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getProxy(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getProxy(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getProxy(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getProxy(const ::omero::grid::Callback_InternalRepository_getProxyPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getProxy(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getProxy(const ::Ice::Context& __ctx, const ::omero::grid::Callback_InternalRepository_getProxyPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getProxy(&__ctx, __del, __cookie);
    }

    ::omero::grid::RepositoryPrx end_getProxy(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::grid::RepositoryPrx getProxy(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getProxy(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool getProxy_async(const ::omero::grid::AMI_InternalRepository_getProxyPtr&);
    bool getProxy_async(const ::omero::grid::AMI_InternalRepository_getProxyPtr&, const ::Ice::Context&);

    ::omero::cmd::ResponsePtr rawAccess(const ::omero::grid::RawAccessRequestPtr& raw)
    {
        return rawAccess(raw, 0);
    }
    ::omero::cmd::ResponsePtr rawAccess(const ::omero::grid::RawAccessRequestPtr& raw, const ::Ice::Context& __ctx)
    {
        return rawAccess(raw, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_rawAccess(const ::omero::grid::RawAccessRequestPtr& raw, const ::IceInternal::Function<void (const ::omero::cmd::ResponsePtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_rawAccess(raw, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_rawAccess(const ::omero::grid::RawAccessRequestPtr& raw, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_rawAccess(raw, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_rawAccess(const ::omero::grid::RawAccessRequestPtr& raw, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::omero::cmd::ResponsePtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_rawAccess(raw, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_rawAccess(const ::omero::grid::RawAccessRequestPtr& raw, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_rawAccess(raw, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_rawAccess(const ::omero::grid::RawAccessRequestPtr& raw, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::omero::cmd::ResponsePtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::omero::cmd::ResponsePtr&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::grid::InternalRepositoryPrx __proxy = ::omero::grid::InternalRepositoryPrx::uncheckedCast(__result->getProxy());
                ::omero::cmd::ResponsePtr __ret;
                try
                {
                    __ret = __proxy->end_rawAccess(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::omero::cmd::ResponsePtr&)> _response;
        };
        return begin_rawAccess(raw, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_rawAccess(const ::omero::grid::RawAccessRequestPtr& raw)
    {
        return begin_rawAccess(raw, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_rawAccess(const ::omero::grid::RawAccessRequestPtr& raw, const ::Ice::Context& __ctx)
    {
        return begin_rawAccess(raw, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_rawAccess(const ::omero::grid::RawAccessRequestPtr& raw, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_rawAccess(raw, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_rawAccess(const ::omero::grid::RawAccessRequestPtr& raw, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_rawAccess(raw, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_rawAccess(const ::omero::grid::RawAccessRequestPtr& raw, const ::omero::grid::Callback_InternalRepository_rawAccessPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_rawAccess(raw, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_rawAccess(const ::omero::grid::RawAccessRequestPtr& raw, const ::Ice::Context& __ctx, const ::omero::grid::Callback_InternalRepository_rawAccessPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_rawAccess(raw, &__ctx, __del, __cookie);
    }

    ::omero::cmd::ResponsePtr end_rawAccess(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::cmd::ResponsePtr rawAccess(const ::omero::grid::RawAccessRequestPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_rawAccess(const ::omero::grid::RawAccessRequestPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool rawAccess_async(const ::omero::grid::AMI_InternalRepository_rawAccessPtr&, const ::omero::grid::RawAccessRequestPtr&);
    bool rawAccess_async(const ::omero::grid::AMI_InternalRepository_rawAccessPtr&, const ::omero::grid::RawAccessRequestPtr&, const ::Ice::Context&);

    ::std::string getFilePath(const ::omero::model::OriginalFilePtr& file)
    {
        return getFilePath(file, 0);
    }
    ::std::string getFilePath(const ::omero::model::OriginalFilePtr& file, const ::Ice::Context& __ctx)
    {
        return getFilePath(file, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_getFilePath(const ::omero::model::OriginalFilePtr& file, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getFilePath(file, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getFilePath(const ::omero::model::OriginalFilePtr& file, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getFilePath(file, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_getFilePath(const ::omero::model::OriginalFilePtr& file, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getFilePath(file, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getFilePath(const ::omero::model::OriginalFilePtr& file, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getFilePath(file, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_getFilePath(const ::omero::model::OriginalFilePtr& file, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::std::string&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::grid::InternalRepositoryPrx __proxy = ::omero::grid::InternalRepositoryPrx::uncheckedCast(__result->getProxy());
                ::std::string __ret;
                try
                {
                    __ret = __proxy->end_getFilePath(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::std::string&)> _response;
        };
        return begin_getFilePath(file, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_getFilePath(const ::omero::model::OriginalFilePtr& file)
    {
        return begin_getFilePath(file, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getFilePath(const ::omero::model::OriginalFilePtr& file, const ::Ice::Context& __ctx)
    {
        return begin_getFilePath(file, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getFilePath(const ::omero::model::OriginalFilePtr& file, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getFilePath(file, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getFilePath(const ::omero::model::OriginalFilePtr& file, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getFilePath(file, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getFilePath(const ::omero::model::OriginalFilePtr& file, const ::omero::grid::Callback_InternalRepository_getFilePathPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getFilePath(file, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getFilePath(const ::omero::model::OriginalFilePtr& file, const ::Ice::Context& __ctx, const ::omero::grid::Callback_InternalRepository_getFilePathPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getFilePath(file, &__ctx, __del, __cookie);
    }

    ::std::string end_getFilePath(const ::Ice::AsyncResultPtr&);
    
private:

    ::std::string getFilePath(const ::omero::model::OriginalFilePtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getFilePath(const ::omero::model::OriginalFilePtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool getFilePath_async(const ::omero::grid::AMI_InternalRepository_getFilePathPtr&, const ::omero::model::OriginalFilePtr&);
    bool getFilePath_async(const ::omero::grid::AMI_InternalRepository_getFilePathPtr&, const ::omero::model::OriginalFilePtr&, const ::Ice::Context&);
    
    ::IceInternal::ProxyHandle<InternalRepository> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<InternalRepository*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<InternalRepository> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<InternalRepository*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<InternalRepository> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<InternalRepository*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<InternalRepository> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<InternalRepository*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<InternalRepository> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<InternalRepository*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<InternalRepository> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<InternalRepository*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<InternalRepository> ice_secure(bool __secure) const
    {
        return dynamic_cast<InternalRepository*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<InternalRepository> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<InternalRepository*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<InternalRepository> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<InternalRepository*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<InternalRepository> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<InternalRepository*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<InternalRepository> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<InternalRepository*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<InternalRepository> ice_twoway() const
    {
        return dynamic_cast<InternalRepository*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<InternalRepository> ice_oneway() const
    {
        return dynamic_cast<InternalRepository*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<InternalRepository> ice_batchOneway() const
    {
        return dynamic_cast<InternalRepository*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<InternalRepository> ice_datagram() const
    {
        return dynamic_cast<InternalRepository*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<InternalRepository> ice_batchDatagram() const
    {
        return dynamic_cast<InternalRepository*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<InternalRepository> ice_compress(bool __compress) const
    {
        return dynamic_cast<InternalRepository*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<InternalRepository> ice_timeout(int __timeout) const
    {
        return dynamic_cast<InternalRepository*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<InternalRepository> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<InternalRepository*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<InternalRepository> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<InternalRepository*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

}

}

}

namespace IceDelegate
{

namespace omero
{

namespace grid
{

class Repository : virtual public ::IceDelegate::Ice::Object
{
public:

    virtual ::omero::model::OriginalFilePtr root(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::std::string mimetype(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::omero::api::StringSet list(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::omero::api::OriginalFileList listFiles(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::omero::model::OriginalFilePtr _cpp_register(const ::std::string&, const ::omero::RStringPtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::omero::api::RawFileStorePrx file(const ::std::string&, const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::omero::api::RawPixelsStorePrx pixels(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::omero::api::RawFileStorePrx fileById(::Ice::Long, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual bool fileExists(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual void makeDir(const ::std::string&, bool, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::omero::RMapPtr treeList(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::omero::cmd::HandlePrx deletePaths(const ::omero::api::StringArray&, bool, bool, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;
};

class ImportLocation : virtual public ::IceDelegate::Ice::Object
{
public:
};

class ImportSettings : virtual public ::IceDelegate::Ice::Object
{
public:
};

class ImportProcess : virtual public ::IceDelegate::omero::api::StatefulServiceInterface
{
public:

    virtual ::omero::api::RawFileStorePrx getUploader(::Ice::Int, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::omero::cmd::HandlePrx verifyUpload(const ::omero::api::StringSet&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Ice::Long getUploadOffset(::Ice::Int, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::omero::cmd::HandlePrx getHandle(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::omero::grid::ImportSettingsPtr getImportSettings(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;
};

class ImportRequest : virtual public ::IceDelegate::omero::cmd::Request
{
public:
};

class ImportResponse : virtual public ::IceDelegate::omero::cmd::Response
{
public:
};

class ManagedRepository : virtual public ::IceDelegate::omero::grid::Repository
{
public:

    virtual ::omero::grid::ImportProcessPrx importFileset(const ::omero::model::FilesetPtr&, const ::omero::grid::ImportSettingsPtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::omero::grid::ImportProcessPrx importPaths(const ::omero::api::StringSet&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::omero::grid::ImportProcessList listImports(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::omero::api::ChecksumAlgorithmList listChecksumAlgorithms(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::omero::model::ChecksumAlgorithmPtr suggestChecksumAlgorithm(const ::omero::api::ChecksumAlgorithmList&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;
};

class RawAccessRequest : virtual public ::IceDelegate::omero::cmd::Request
{
public:
};

class InternalRepository : virtual public ::IceDelegate::Ice::Object
{
public:

    virtual ::omero::api::RawFileStorePrx createRawFileStore(const ::omero::model::OriginalFilePtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::omero::api::RawPixelsStorePrx createRawPixelsStore(const ::omero::model::OriginalFilePtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::omero::api::RenderingEnginePrx createRenderingEngine(const ::omero::model::OriginalFilePtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::omero::api::ThumbnailStorePrx createThumbnailStore(const ::omero::model::OriginalFilePtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::omero::model::OriginalFilePtr getDescription(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::omero::grid::RepositoryPrx getProxy(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::omero::cmd::ResponsePtr rawAccess(const ::omero::grid::RawAccessRequestPtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::std::string getFilePath(const ::omero::model::OriginalFilePtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;
};

}

}

}

namespace IceDelegateM
{

namespace omero
{

namespace grid
{

class Repository : virtual public ::IceDelegate::omero::grid::Repository,
                   virtual public ::IceDelegateM::Ice::Object
{
public:

    virtual ::omero::model::OriginalFilePtr root(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::std::string mimetype(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::api::StringSet list(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::api::OriginalFileList listFiles(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::model::OriginalFilePtr _cpp_register(const ::std::string&, const ::omero::RStringPtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::api::RawFileStorePrx file(const ::std::string&, const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::api::RawPixelsStorePrx pixels(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::api::RawFileStorePrx fileById(::Ice::Long, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual bool fileExists(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void makeDir(const ::std::string&, bool, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::RMapPtr treeList(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::cmd::HandlePrx deletePaths(const ::omero::api::StringArray&, bool, bool, const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

class ImportLocation : virtual public ::IceDelegate::omero::grid::ImportLocation,
                       virtual public ::IceDelegateM::Ice::Object
{
public:
};

class ImportSettings : virtual public ::IceDelegate::omero::grid::ImportSettings,
                       virtual public ::IceDelegateM::Ice::Object
{
public:
};

class ImportProcess : virtual public ::IceDelegate::omero::grid::ImportProcess,
                      virtual public ::IceDelegateM::omero::api::StatefulServiceInterface
{
public:

    virtual ::omero::api::RawFileStorePrx getUploader(::Ice::Int, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::cmd::HandlePrx verifyUpload(const ::omero::api::StringSet&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Ice::Long getUploadOffset(::Ice::Int, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::cmd::HandlePrx getHandle(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::grid::ImportSettingsPtr getImportSettings(const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

class ImportRequest : virtual public ::IceDelegate::omero::grid::ImportRequest,
                      virtual public ::IceDelegateM::omero::cmd::Request
{
public:
};

class ImportResponse : virtual public ::IceDelegate::omero::grid::ImportResponse,
                       virtual public ::IceDelegateM::omero::cmd::Response
{
public:
};

class ManagedRepository : virtual public ::IceDelegate::omero::grid::ManagedRepository,
                          virtual public ::IceDelegateM::omero::grid::Repository
{
public:

    virtual ::omero::grid::ImportProcessPrx importFileset(const ::omero::model::FilesetPtr&, const ::omero::grid::ImportSettingsPtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::grid::ImportProcessPrx importPaths(const ::omero::api::StringSet&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::grid::ImportProcessList listImports(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::api::ChecksumAlgorithmList listChecksumAlgorithms(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::model::ChecksumAlgorithmPtr suggestChecksumAlgorithm(const ::omero::api::ChecksumAlgorithmList&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

class RawAccessRequest : virtual public ::IceDelegate::omero::grid::RawAccessRequest,
                         virtual public ::IceDelegateM::omero::cmd::Request
{
public:
};

class InternalRepository : virtual public ::IceDelegate::omero::grid::InternalRepository,
                           virtual public ::IceDelegateM::Ice::Object
{
public:

    virtual ::omero::api::RawFileStorePrx createRawFileStore(const ::omero::model::OriginalFilePtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::api::RawPixelsStorePrx createRawPixelsStore(const ::omero::model::OriginalFilePtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::api::RenderingEnginePrx createRenderingEngine(const ::omero::model::OriginalFilePtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::api::ThumbnailStorePrx createThumbnailStore(const ::omero::model::OriginalFilePtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::model::OriginalFilePtr getDescription(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::grid::RepositoryPrx getProxy(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::cmd::ResponsePtr rawAccess(const ::omero::grid::RawAccessRequestPtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::std::string getFilePath(const ::omero::model::OriginalFilePtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

}

}

}

namespace IceDelegateD
{

namespace omero
{

namespace grid
{

class Repository : virtual public ::IceDelegate::omero::grid::Repository,
                   virtual public ::IceDelegateD::Ice::Object
{
public:

    virtual ::omero::model::OriginalFilePtr root(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::std::string mimetype(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::api::StringSet list(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::api::OriginalFileList listFiles(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::model::OriginalFilePtr _cpp_register(const ::std::string&, const ::omero::RStringPtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::api::RawFileStorePrx file(const ::std::string&, const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::api::RawPixelsStorePrx pixels(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::api::RawFileStorePrx fileById(::Ice::Long, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual bool fileExists(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void makeDir(const ::std::string&, bool, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::RMapPtr treeList(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::cmd::HandlePrx deletePaths(const ::omero::api::StringArray&, bool, bool, const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

class ImportLocation : virtual public ::IceDelegate::omero::grid::ImportLocation,
                       virtual public ::IceDelegateD::Ice::Object
{
public:
};

class ImportSettings : virtual public ::IceDelegate::omero::grid::ImportSettings,
                       virtual public ::IceDelegateD::Ice::Object
{
public:
};

class ImportProcess : virtual public ::IceDelegate::omero::grid::ImportProcess,
                      virtual public ::IceDelegateD::omero::api::StatefulServiceInterface
{
public:

    virtual ::omero::api::RawFileStorePrx getUploader(::Ice::Int, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::cmd::HandlePrx verifyUpload(const ::omero::api::StringSet&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Ice::Long getUploadOffset(::Ice::Int, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::cmd::HandlePrx getHandle(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::grid::ImportSettingsPtr getImportSettings(const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

class ImportRequest : virtual public ::IceDelegate::omero::grid::ImportRequest,
                      virtual public ::IceDelegateD::omero::cmd::Request
{
public:
};

class ImportResponse : virtual public ::IceDelegate::omero::grid::ImportResponse,
                       virtual public ::IceDelegateD::omero::cmd::Response
{
public:
};

class ManagedRepository : virtual public ::IceDelegate::omero::grid::ManagedRepository,
                          virtual public ::IceDelegateD::omero::grid::Repository
{
public:

    virtual ::omero::grid::ImportProcessPrx importFileset(const ::omero::model::FilesetPtr&, const ::omero::grid::ImportSettingsPtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::grid::ImportProcessPrx importPaths(const ::omero::api::StringSet&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::grid::ImportProcessList listImports(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::api::ChecksumAlgorithmList listChecksumAlgorithms(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::model::ChecksumAlgorithmPtr suggestChecksumAlgorithm(const ::omero::api::ChecksumAlgorithmList&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

class RawAccessRequest : virtual public ::IceDelegate::omero::grid::RawAccessRequest,
                         virtual public ::IceDelegateD::omero::cmd::Request
{
public:
};

class InternalRepository : virtual public ::IceDelegate::omero::grid::InternalRepository,
                           virtual public ::IceDelegateD::Ice::Object
{
public:

    virtual ::omero::api::RawFileStorePrx createRawFileStore(const ::omero::model::OriginalFilePtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::api::RawPixelsStorePrx createRawPixelsStore(const ::omero::model::OriginalFilePtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::api::RenderingEnginePrx createRenderingEngine(const ::omero::model::OriginalFilePtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::api::ThumbnailStorePrx createThumbnailStore(const ::omero::model::OriginalFilePtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::model::OriginalFilePtr getDescription(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::grid::RepositoryPrx getProxy(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::cmd::ResponsePtr rawAccess(const ::omero::grid::RawAccessRequestPtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::std::string getFilePath(const ::omero::model::OriginalFilePtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

}

}

}

namespace omero
{

namespace grid
{

class Repository : virtual public ::Ice::Object
{
public:

    typedef RepositoryPrx ProxyType;
    typedef RepositoryPtr PointerType;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual ::omero::model::OriginalFilePtr root(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___root(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::std::string mimetype(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___mimetype(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::api::StringSet list(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___list(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::api::OriginalFileList listFiles(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___listFiles(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::model::OriginalFilePtr _cpp_register(const ::std::string&, const ::omero::RStringPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___register(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::api::RawFileStorePrx file(const ::std::string&, const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___file(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::api::RawPixelsStorePrx pixels(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___pixels(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::api::RawFileStorePrx fileById(::Ice::Long, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___fileById(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual bool fileExists(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___fileExists(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void makeDir(const ::std::string&, bool, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___makeDir(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::RMapPtr treeList(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___treeList(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::cmd::HandlePrx deletePaths(const ::omero::api::StringArray&, bool, bool, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___deletePaths(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif
};

inline bool operator==(const Repository& l, const Repository& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const Repository& l, const Repository& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class ImportLocation : virtual public ::Ice::Object, public IceInternal::GCShared
{
public:

    typedef ImportLocationPrx ProxyType;
    typedef ImportLocationPtr PointerType;

    ImportLocation()
    {
    }

    ImportLocation(const ::std::string& __ice_sharedPath, ::Ice::Int __ice_omittedLevels, const ::omero::api::StringSet& __ice_usedFiles, const ::omero::model::OriginalFilePtr& __ice_directory) :
        sharedPath(__ice_sharedPath),
        omittedLevels(__ice_omittedLevels),
        usedFiles(__ice_usedFiles),
        directory(__ice_directory)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void __addObject(::IceInternal::GCCountMap&);
    virtual bool __usesGC();
    virtual void __gcReachable(::IceInternal::GCCountMap&) const;
    virtual void __gcClear();

    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif

public:

    ::std::string sharedPath;

    ::Ice::Int omittedLevels;

    ::omero::api::StringSet usedFiles;

    ::omero::model::OriginalFilePtr directory;

protected:

    virtual ~ImportLocation() {}

    friend class ImportLocation__staticInit;
};

class ImportLocation__staticInit
{
public:

    ::omero::grid::ImportLocation _init;
};

static ImportLocation__staticInit _ImportLocation_init;

inline bool operator==(const ImportLocation& l, const ImportLocation& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const ImportLocation& l, const ImportLocation& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class ImportSettings : virtual public ::Ice::Object, public IceInternal::GCShared
{
public:

    typedef ImportSettingsPrx ProxyType;
    typedef ImportSettingsPtr PointerType;

    ImportSettings()
    {
    }

    ImportSettings(const ::omero::model::IObjectPtr& __ice_userSpecifiedTarget, const ::omero::RStringPtr& __ice_userSpecifiedName, const ::omero::RStringPtr& __ice_userSpecifiedDescription, const ::omero::api::DoubleArray& __ice_userSpecifiedPixels, const ::omero::api::AnnotationList& __ice_userSpecifiedAnnotationList, const ::omero::RBoolPtr& __ice_doThumbnails, const ::omero::model::ChecksumAlgorithmPtr& __ice_checksumAlgorithm) :
        userSpecifiedTarget(__ice_userSpecifiedTarget),
        userSpecifiedName(__ice_userSpecifiedName),
        userSpecifiedDescription(__ice_userSpecifiedDescription),
        userSpecifiedPixels(__ice_userSpecifiedPixels),
        userSpecifiedAnnotationList(__ice_userSpecifiedAnnotationList),
        doThumbnails(__ice_doThumbnails),
        checksumAlgorithm(__ice_checksumAlgorithm)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void __addObject(::IceInternal::GCCountMap&);
    virtual bool __usesGC();
    virtual void __gcReachable(::IceInternal::GCCountMap&) const;
    virtual void __gcClear();

    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif

public:

    ::omero::model::IObjectPtr userSpecifiedTarget;

    ::omero::RStringPtr userSpecifiedName;

    ::omero::RStringPtr userSpecifiedDescription;

    ::omero::api::DoubleArray userSpecifiedPixels;

    ::omero::api::AnnotationList userSpecifiedAnnotationList;

    ::omero::RBoolPtr doThumbnails;

    ::omero::model::ChecksumAlgorithmPtr checksumAlgorithm;

protected:

    virtual ~ImportSettings() {}
};

inline bool operator==(const ImportSettings& l, const ImportSettings& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const ImportSettings& l, const ImportSettings& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class ImportProcess : virtual public ::omero::api::StatefulServiceInterface
{
public:

    typedef ImportProcessPrx ProxyType;
    typedef ImportProcessPtr PointerType;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual ::omero::api::RawFileStorePrx getUploader(::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getUploader(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::cmd::HandlePrx verifyUpload(const ::omero::api::StringSet&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___verifyUpload(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Long getUploadOffset(::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getUploadOffset(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::cmd::HandlePrx getHandle(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getHandle(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::grid::ImportSettingsPtr getImportSettings(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getImportSettings(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif
};

inline bool operator==(const ImportProcess& l, const ImportProcess& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const ImportProcess& l, const ImportProcess& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class ImportRequest : public ::omero::cmd::Request, public IceInternal::GCShared
{
public:

    typedef ImportRequestPrx ProxyType;
    typedef ImportRequestPtr PointerType;

    ImportRequest()
    {
    }

    ImportRequest(const ::std::string& __ice_clientUuid, const ::std::string& __ice_repoUuid, const ::omero::grid::ImportProcessPrx& __ice_process, const ::omero::model::FilesetJobLinkPtr& __ice_activity, const ::omero::grid::ImportSettingsPtr& __ice_settings, const ::omero::grid::ImportLocationPtr& __ice_location, const ::omero::model::OriginalFilePtr& __ice_logFile) :
        clientUuid(__ice_clientUuid),
        repoUuid(__ice_repoUuid),
        process(__ice_process),
        activity(__ice_activity),
        settings(__ice_settings),
        location(__ice_location),
        logFile(__ice_logFile)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void __addObject(::IceInternal::GCCountMap&);
    virtual bool __usesGC();
    virtual void __gcReachable(::IceInternal::GCCountMap&) const;
    virtual void __gcClear();

    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::omero::cmd::Request::__writeImpl;
    using ::omero::cmd::Request::__readImpl;
    #endif

public:

    ::std::string clientUuid;

    ::std::string repoUuid;

    ::omero::grid::ImportProcessPrx process;

    ::omero::model::FilesetJobLinkPtr activity;

    ::omero::grid::ImportSettingsPtr settings;

    ::omero::grid::ImportLocationPtr location;

    ::omero::model::OriginalFilePtr logFile;

protected:

    virtual ~ImportRequest() {}
};

inline bool operator==(const ImportRequest& l, const ImportRequest& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const ImportRequest& l, const ImportRequest& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class ImportResponse : public ::omero::cmd::Response, public IceInternal::GCShared
{
public:

    typedef ImportResponsePrx ProxyType;
    typedef ImportResponsePtr PointerType;

    ImportResponse()
    {
    }

    ImportResponse(const ::omero::api::PixelsList& __ice_pixels, const ::omero::api::IObjectList& __ice_objects) :
        pixels(__ice_pixels),
        objects(__ice_objects)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void __addObject(::IceInternal::GCCountMap&);
    virtual bool __usesGC();
    virtual void __gcReachable(::IceInternal::GCCountMap&) const;
    virtual void __gcClear();

    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::omero::cmd::Response::__writeImpl;
    using ::omero::cmd::Response::__readImpl;
    #endif

public:

    ::omero::api::PixelsList pixels;

    ::omero::api::IObjectList objects;

protected:

    virtual ~ImportResponse() {}
};

inline bool operator==(const ImportResponse& l, const ImportResponse& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const ImportResponse& l, const ImportResponse& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class ManagedRepository : virtual public ::omero::grid::Repository
{
public:

    typedef ManagedRepositoryPrx ProxyType;
    typedef ManagedRepositoryPtr PointerType;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual ::omero::grid::ImportProcessPrx importFileset(const ::omero::model::FilesetPtr&, const ::omero::grid::ImportSettingsPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___importFileset(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::grid::ImportProcessPrx importPaths(const ::omero::api::StringSet&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___importPaths(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::grid::ImportProcessList listImports(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___listImports(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::api::ChecksumAlgorithmList listChecksumAlgorithms(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___listChecksumAlgorithms(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::model::ChecksumAlgorithmPtr suggestChecksumAlgorithm(const ::omero::api::ChecksumAlgorithmList&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___suggestChecksumAlgorithm(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif
};

inline bool operator==(const ManagedRepository& l, const ManagedRepository& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const ManagedRepository& l, const ManagedRepository& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class RawAccessRequest : public ::omero::cmd::Request
{
public:

    typedef RawAccessRequestPrx ProxyType;
    typedef RawAccessRequestPtr PointerType;

    RawAccessRequest()
    {
    }

    RawAccessRequest(const ::std::string& __ice_repoUuid, const ::std::string& __ice_command, const ::omero::api::StringSet& __ice_args, const ::std::string& __ice_path) :
        repoUuid(__ice_repoUuid),
        command(__ice_command),
        args(__ice_args),
        path(__ice_path)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();


    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::omero::cmd::Request::__writeImpl;
    using ::omero::cmd::Request::__readImpl;
    #endif

public:

    ::std::string repoUuid;

    ::std::string command;

    ::omero::api::StringSet args;

    ::std::string path;

protected:

    virtual ~RawAccessRequest() {}
};

inline bool operator==(const RawAccessRequest& l, const RawAccessRequest& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const RawAccessRequest& l, const RawAccessRequest& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class InternalRepository : virtual public ::Ice::Object
{
public:

    typedef InternalRepositoryPrx ProxyType;
    typedef InternalRepositoryPtr PointerType;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual ::omero::api::RawFileStorePrx createRawFileStore(const ::omero::model::OriginalFilePtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___createRawFileStore(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::api::RawPixelsStorePrx createRawPixelsStore(const ::omero::model::OriginalFilePtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___createRawPixelsStore(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::api::RenderingEnginePrx createRenderingEngine(const ::omero::model::OriginalFilePtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___createRenderingEngine(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::api::ThumbnailStorePrx createThumbnailStore(const ::omero::model::OriginalFilePtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___createThumbnailStore(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::model::OriginalFilePtr getDescription(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getDescription(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::grid::RepositoryPrx getProxy(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getProxy(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::cmd::ResponsePtr rawAccess(const ::omero::grid::RawAccessRequestPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___rawAccess(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::std::string getFilePath(const ::omero::model::OriginalFilePtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getFilePath(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif
};

inline bool operator==(const InternalRepository& l, const InternalRepository& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const InternalRepository& l, const InternalRepository& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

}

}

namespace omero
{

namespace grid
{

template<class T>
class CallbackNC_Repository_root : public Callback_Repository_root_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::model::OriginalFilePtr&);

    CallbackNC_Repository_root(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::RepositoryPrx __proxy = ::omero::grid::RepositoryPrx::uncheckedCast(__result->getProxy());
        ::omero::model::OriginalFilePtr __ret;
        try
        {
            __ret = __proxy->end_root(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_Repository_rootPtr
newCallback_Repository_root(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::OriginalFilePtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Repository_root<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Repository_rootPtr
newCallback_Repository_root(T* instance, void (T::*cb)(const ::omero::model::OriginalFilePtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Repository_root<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Repository_root : public Callback_Repository_root_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::model::OriginalFilePtr&, const CT&);

    Callback_Repository_root(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::RepositoryPrx __proxy = ::omero::grid::RepositoryPrx::uncheckedCast(__result->getProxy());
        ::omero::model::OriginalFilePtr __ret;
        try
        {
            __ret = __proxy->end_root(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Repository_rootPtr
newCallback_Repository_root(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::OriginalFilePtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Repository_root<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Repository_rootPtr
newCallback_Repository_root(T* instance, void (T::*cb)(const ::omero::model::OriginalFilePtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Repository_root<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Repository_mimetype : public Callback_Repository_mimetype_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_Repository_mimetype(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::RepositoryPrx __proxy = ::omero::grid::RepositoryPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_mimetype(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_Repository_mimetypePtr
newCallback_Repository_mimetype(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Repository_mimetype<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Repository_mimetypePtr
newCallback_Repository_mimetype(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Repository_mimetype<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Repository_mimetype : public Callback_Repository_mimetype_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_Repository_mimetype(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::RepositoryPrx __proxy = ::omero::grid::RepositoryPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_mimetype(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Repository_mimetypePtr
newCallback_Repository_mimetype(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Repository_mimetype<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Repository_mimetypePtr
newCallback_Repository_mimetype(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Repository_mimetype<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Repository_list : public Callback_Repository_list_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::api::StringSet&);

    CallbackNC_Repository_list(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::RepositoryPrx __proxy = ::omero::grid::RepositoryPrx::uncheckedCast(__result->getProxy());
        ::omero::api::StringSet __ret;
        try
        {
            __ret = __proxy->end_list(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_Repository_listPtr
newCallback_Repository_list(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::StringSet&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Repository_list<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Repository_listPtr
newCallback_Repository_list(T* instance, void (T::*cb)(const ::omero::api::StringSet&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Repository_list<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Repository_list : public Callback_Repository_list_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::api::StringSet&, const CT&);

    Callback_Repository_list(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::RepositoryPrx __proxy = ::omero::grid::RepositoryPrx::uncheckedCast(__result->getProxy());
        ::omero::api::StringSet __ret;
        try
        {
            __ret = __proxy->end_list(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Repository_listPtr
newCallback_Repository_list(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::StringSet&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Repository_list<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Repository_listPtr
newCallback_Repository_list(T* instance, void (T::*cb)(const ::omero::api::StringSet&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Repository_list<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Repository_listFiles : public Callback_Repository_listFiles_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::api::OriginalFileList&);

    CallbackNC_Repository_listFiles(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::RepositoryPrx __proxy = ::omero::grid::RepositoryPrx::uncheckedCast(__result->getProxy());
        ::omero::api::OriginalFileList __ret;
        try
        {
            __ret = __proxy->end_listFiles(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_Repository_listFilesPtr
newCallback_Repository_listFiles(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::OriginalFileList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Repository_listFiles<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Repository_listFilesPtr
newCallback_Repository_listFiles(T* instance, void (T::*cb)(const ::omero::api::OriginalFileList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Repository_listFiles<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Repository_listFiles : public Callback_Repository_listFiles_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::api::OriginalFileList&, const CT&);

    Callback_Repository_listFiles(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::RepositoryPrx __proxy = ::omero::grid::RepositoryPrx::uncheckedCast(__result->getProxy());
        ::omero::api::OriginalFileList __ret;
        try
        {
            __ret = __proxy->end_listFiles(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Repository_listFilesPtr
newCallback_Repository_listFiles(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::OriginalFileList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Repository_listFiles<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Repository_listFilesPtr
newCallback_Repository_listFiles(T* instance, void (T::*cb)(const ::omero::api::OriginalFileList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Repository_listFiles<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Repository_register : public Callback_Repository_register_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::model::OriginalFilePtr&);

    CallbackNC_Repository_register(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::RepositoryPrx __proxy = ::omero::grid::RepositoryPrx::uncheckedCast(__result->getProxy());
        ::omero::model::OriginalFilePtr __ret;
        try
        {
            __ret = __proxy->end_register(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_Repository_registerPtr
newCallback_Repository_register(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::OriginalFilePtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Repository_register<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Repository_registerPtr
newCallback_Repository_register(T* instance, void (T::*cb)(const ::omero::model::OriginalFilePtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Repository_register<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Repository_register : public Callback_Repository_register_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::model::OriginalFilePtr&, const CT&);

    Callback_Repository_register(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::RepositoryPrx __proxy = ::omero::grid::RepositoryPrx::uncheckedCast(__result->getProxy());
        ::omero::model::OriginalFilePtr __ret;
        try
        {
            __ret = __proxy->end_register(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Repository_registerPtr
newCallback_Repository_register(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::OriginalFilePtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Repository_register<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Repository_registerPtr
newCallback_Repository_register(T* instance, void (T::*cb)(const ::omero::model::OriginalFilePtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Repository_register<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Repository_file : public Callback_Repository_file_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::api::RawFileStorePrx&);

    CallbackNC_Repository_file(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::RepositoryPrx __proxy = ::omero::grid::RepositoryPrx::uncheckedCast(__result->getProxy());
        ::omero::api::RawFileStorePrx __ret;
        try
        {
            __ret = __proxy->end_file(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_Repository_filePtr
newCallback_Repository_file(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::RawFileStorePrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Repository_file<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Repository_filePtr
newCallback_Repository_file(T* instance, void (T::*cb)(const ::omero::api::RawFileStorePrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Repository_file<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Repository_file : public Callback_Repository_file_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::api::RawFileStorePrx&, const CT&);

    Callback_Repository_file(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::RepositoryPrx __proxy = ::omero::grid::RepositoryPrx::uncheckedCast(__result->getProxy());
        ::omero::api::RawFileStorePrx __ret;
        try
        {
            __ret = __proxy->end_file(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Repository_filePtr
newCallback_Repository_file(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::RawFileStorePrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Repository_file<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Repository_filePtr
newCallback_Repository_file(T* instance, void (T::*cb)(const ::omero::api::RawFileStorePrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Repository_file<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Repository_pixels : public Callback_Repository_pixels_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::api::RawPixelsStorePrx&);

    CallbackNC_Repository_pixels(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::RepositoryPrx __proxy = ::omero::grid::RepositoryPrx::uncheckedCast(__result->getProxy());
        ::omero::api::RawPixelsStorePrx __ret;
        try
        {
            __ret = __proxy->end_pixels(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_Repository_pixelsPtr
newCallback_Repository_pixels(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::RawPixelsStorePrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Repository_pixels<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Repository_pixelsPtr
newCallback_Repository_pixels(T* instance, void (T::*cb)(const ::omero::api::RawPixelsStorePrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Repository_pixels<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Repository_pixels : public Callback_Repository_pixels_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::api::RawPixelsStorePrx&, const CT&);

    Callback_Repository_pixels(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::RepositoryPrx __proxy = ::omero::grid::RepositoryPrx::uncheckedCast(__result->getProxy());
        ::omero::api::RawPixelsStorePrx __ret;
        try
        {
            __ret = __proxy->end_pixels(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Repository_pixelsPtr
newCallback_Repository_pixels(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::RawPixelsStorePrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Repository_pixels<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Repository_pixelsPtr
newCallback_Repository_pixels(T* instance, void (T::*cb)(const ::omero::api::RawPixelsStorePrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Repository_pixels<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Repository_fileById : public Callback_Repository_fileById_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::api::RawFileStorePrx&);

    CallbackNC_Repository_fileById(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::RepositoryPrx __proxy = ::omero::grid::RepositoryPrx::uncheckedCast(__result->getProxy());
        ::omero::api::RawFileStorePrx __ret;
        try
        {
            __ret = __proxy->end_fileById(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_Repository_fileByIdPtr
newCallback_Repository_fileById(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::RawFileStorePrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Repository_fileById<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Repository_fileByIdPtr
newCallback_Repository_fileById(T* instance, void (T::*cb)(const ::omero::api::RawFileStorePrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Repository_fileById<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Repository_fileById : public Callback_Repository_fileById_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::api::RawFileStorePrx&, const CT&);

    Callback_Repository_fileById(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::RepositoryPrx __proxy = ::omero::grid::RepositoryPrx::uncheckedCast(__result->getProxy());
        ::omero::api::RawFileStorePrx __ret;
        try
        {
            __ret = __proxy->end_fileById(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Repository_fileByIdPtr
newCallback_Repository_fileById(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::RawFileStorePrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Repository_fileById<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Repository_fileByIdPtr
newCallback_Repository_fileById(T* instance, void (T::*cb)(const ::omero::api::RawFileStorePrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Repository_fileById<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Repository_fileExists : public Callback_Repository_fileExists_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_Repository_fileExists(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::RepositoryPrx __proxy = ::omero::grid::RepositoryPrx::uncheckedCast(__result->getProxy());
        bool __ret;
        try
        {
            __ret = __proxy->end_fileExists(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_Repository_fileExistsPtr
newCallback_Repository_fileExists(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Repository_fileExists<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Repository_fileExistsPtr
newCallback_Repository_fileExists(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Repository_fileExists<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Repository_fileExists : public Callback_Repository_fileExists_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_Repository_fileExists(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::RepositoryPrx __proxy = ::omero::grid::RepositoryPrx::uncheckedCast(__result->getProxy());
        bool __ret;
        try
        {
            __ret = __proxy->end_fileExists(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Repository_fileExistsPtr
newCallback_Repository_fileExists(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Repository_fileExists<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Repository_fileExistsPtr
newCallback_Repository_fileExists(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Repository_fileExists<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Repository_makeDir : public Callback_Repository_makeDir_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Repository_makeDir(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::RepositoryPrx __proxy = ::omero::grid::RepositoryPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_makeDir(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
        }
    }

    Response response;
};

template<class T> Callback_Repository_makeDirPtr
newCallback_Repository_makeDir(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Repository_makeDir<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Repository_makeDirPtr
newCallback_Repository_makeDir(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Repository_makeDir<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Repository_makeDirPtr
newCallback_Repository_makeDir(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Repository_makeDir<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Repository_makeDirPtr
newCallback_Repository_makeDir(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Repository_makeDir<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Repository_makeDir : public Callback_Repository_makeDir_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Repository_makeDir(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::RepositoryPrx __proxy = ::omero::grid::RepositoryPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_makeDir(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Repository_makeDirPtr
newCallback_Repository_makeDir(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Repository_makeDir<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Repository_makeDirPtr
newCallback_Repository_makeDir(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Repository_makeDir<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Repository_makeDirPtr
newCallback_Repository_makeDir(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Repository_makeDir<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Repository_makeDirPtr
newCallback_Repository_makeDir(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Repository_makeDir<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Repository_treeList : public Callback_Repository_treeList_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::RMapPtr&);

    CallbackNC_Repository_treeList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::RepositoryPrx __proxy = ::omero::grid::RepositoryPrx::uncheckedCast(__result->getProxy());
        ::omero::RMapPtr __ret;
        try
        {
            __ret = __proxy->end_treeList(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_Repository_treeListPtr
newCallback_Repository_treeList(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RMapPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Repository_treeList<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Repository_treeListPtr
newCallback_Repository_treeList(T* instance, void (T::*cb)(const ::omero::RMapPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Repository_treeList<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Repository_treeList : public Callback_Repository_treeList_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::RMapPtr&, const CT&);

    Callback_Repository_treeList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::RepositoryPrx __proxy = ::omero::grid::RepositoryPrx::uncheckedCast(__result->getProxy());
        ::omero::RMapPtr __ret;
        try
        {
            __ret = __proxy->end_treeList(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Repository_treeListPtr
newCallback_Repository_treeList(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RMapPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Repository_treeList<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Repository_treeListPtr
newCallback_Repository_treeList(T* instance, void (T::*cb)(const ::omero::RMapPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Repository_treeList<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Repository_deletePaths : public Callback_Repository_deletePaths_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::cmd::HandlePrx&);

    CallbackNC_Repository_deletePaths(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::RepositoryPrx __proxy = ::omero::grid::RepositoryPrx::uncheckedCast(__result->getProxy());
        ::omero::cmd::HandlePrx __ret;
        try
        {
            __ret = __proxy->end_deletePaths(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_Repository_deletePathsPtr
newCallback_Repository_deletePaths(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::cmd::HandlePrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Repository_deletePaths<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Repository_deletePathsPtr
newCallback_Repository_deletePaths(T* instance, void (T::*cb)(const ::omero::cmd::HandlePrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Repository_deletePaths<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Repository_deletePaths : public Callback_Repository_deletePaths_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::cmd::HandlePrx&, const CT&);

    Callback_Repository_deletePaths(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::RepositoryPrx __proxy = ::omero::grid::RepositoryPrx::uncheckedCast(__result->getProxy());
        ::omero::cmd::HandlePrx __ret;
        try
        {
            __ret = __proxy->end_deletePaths(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Repository_deletePathsPtr
newCallback_Repository_deletePaths(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::cmd::HandlePrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Repository_deletePaths<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Repository_deletePathsPtr
newCallback_Repository_deletePaths(T* instance, void (T::*cb)(const ::omero::cmd::HandlePrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Repository_deletePaths<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_ImportProcess_getUploader : public Callback_ImportProcess_getUploader_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::api::RawFileStorePrx&);

    CallbackNC_ImportProcess_getUploader(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::ImportProcessPrx __proxy = ::omero::grid::ImportProcessPrx::uncheckedCast(__result->getProxy());
        ::omero::api::RawFileStorePrx __ret;
        try
        {
            __ret = __proxy->end_getUploader(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_ImportProcess_getUploaderPtr
newCallback_ImportProcess_getUploader(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::RawFileStorePrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ImportProcess_getUploader<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ImportProcess_getUploaderPtr
newCallback_ImportProcess_getUploader(T* instance, void (T::*cb)(const ::omero::api::RawFileStorePrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ImportProcess_getUploader<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_ImportProcess_getUploader : public Callback_ImportProcess_getUploader_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::api::RawFileStorePrx&, const CT&);

    Callback_ImportProcess_getUploader(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::ImportProcessPrx __proxy = ::omero::grid::ImportProcessPrx::uncheckedCast(__result->getProxy());
        ::omero::api::RawFileStorePrx __ret;
        try
        {
            __ret = __proxy->end_getUploader(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ImportProcess_getUploaderPtr
newCallback_ImportProcess_getUploader(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::RawFileStorePrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ImportProcess_getUploader<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ImportProcess_getUploaderPtr
newCallback_ImportProcess_getUploader(T* instance, void (T::*cb)(const ::omero::api::RawFileStorePrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ImportProcess_getUploader<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_ImportProcess_verifyUpload : public Callback_ImportProcess_verifyUpload_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::cmd::HandlePrx&);

    CallbackNC_ImportProcess_verifyUpload(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::ImportProcessPrx __proxy = ::omero::grid::ImportProcessPrx::uncheckedCast(__result->getProxy());
        ::omero::cmd::HandlePrx __ret;
        try
        {
            __ret = __proxy->end_verifyUpload(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_ImportProcess_verifyUploadPtr
newCallback_ImportProcess_verifyUpload(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::cmd::HandlePrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ImportProcess_verifyUpload<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ImportProcess_verifyUploadPtr
newCallback_ImportProcess_verifyUpload(T* instance, void (T::*cb)(const ::omero::cmd::HandlePrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ImportProcess_verifyUpload<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_ImportProcess_verifyUpload : public Callback_ImportProcess_verifyUpload_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::cmd::HandlePrx&, const CT&);

    Callback_ImportProcess_verifyUpload(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::ImportProcessPrx __proxy = ::omero::grid::ImportProcessPrx::uncheckedCast(__result->getProxy());
        ::omero::cmd::HandlePrx __ret;
        try
        {
            __ret = __proxy->end_verifyUpload(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ImportProcess_verifyUploadPtr
newCallback_ImportProcess_verifyUpload(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::cmd::HandlePrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ImportProcess_verifyUpload<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ImportProcess_verifyUploadPtr
newCallback_ImportProcess_verifyUpload(T* instance, void (T::*cb)(const ::omero::cmd::HandlePrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ImportProcess_verifyUpload<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_ImportProcess_getUploadOffset : public Callback_ImportProcess_getUploadOffset_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Long);

    CallbackNC_ImportProcess_getUploadOffset(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::ImportProcessPrx __proxy = ::omero::grid::ImportProcessPrx::uncheckedCast(__result->getProxy());
        ::Ice::Long __ret;
        try
        {
            __ret = __proxy->end_getUploadOffset(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_ImportProcess_getUploadOffsetPtr
newCallback_ImportProcess_getUploadOffset(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Long), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ImportProcess_getUploadOffset<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ImportProcess_getUploadOffsetPtr
newCallback_ImportProcess_getUploadOffset(T* instance, void (T::*cb)(::Ice::Long), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ImportProcess_getUploadOffset<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_ImportProcess_getUploadOffset : public Callback_ImportProcess_getUploadOffset_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Long, const CT&);

    Callback_ImportProcess_getUploadOffset(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::ImportProcessPrx __proxy = ::omero::grid::ImportProcessPrx::uncheckedCast(__result->getProxy());
        ::Ice::Long __ret;
        try
        {
            __ret = __proxy->end_getUploadOffset(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ImportProcess_getUploadOffsetPtr
newCallback_ImportProcess_getUploadOffset(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Long, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ImportProcess_getUploadOffset<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ImportProcess_getUploadOffsetPtr
newCallback_ImportProcess_getUploadOffset(T* instance, void (T::*cb)(::Ice::Long, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ImportProcess_getUploadOffset<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_ImportProcess_getHandle : public Callback_ImportProcess_getHandle_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::cmd::HandlePrx&);

    CallbackNC_ImportProcess_getHandle(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::ImportProcessPrx __proxy = ::omero::grid::ImportProcessPrx::uncheckedCast(__result->getProxy());
        ::omero::cmd::HandlePrx __ret;
        try
        {
            __ret = __proxy->end_getHandle(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_ImportProcess_getHandlePtr
newCallback_ImportProcess_getHandle(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::cmd::HandlePrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ImportProcess_getHandle<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ImportProcess_getHandlePtr
newCallback_ImportProcess_getHandle(T* instance, void (T::*cb)(const ::omero::cmd::HandlePrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ImportProcess_getHandle<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_ImportProcess_getHandle : public Callback_ImportProcess_getHandle_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::cmd::HandlePrx&, const CT&);

    Callback_ImportProcess_getHandle(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::ImportProcessPrx __proxy = ::omero::grid::ImportProcessPrx::uncheckedCast(__result->getProxy());
        ::omero::cmd::HandlePrx __ret;
        try
        {
            __ret = __proxy->end_getHandle(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ImportProcess_getHandlePtr
newCallback_ImportProcess_getHandle(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::cmd::HandlePrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ImportProcess_getHandle<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ImportProcess_getHandlePtr
newCallback_ImportProcess_getHandle(T* instance, void (T::*cb)(const ::omero::cmd::HandlePrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ImportProcess_getHandle<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_ImportProcess_getImportSettings : public Callback_ImportProcess_getImportSettings_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::grid::ImportSettingsPtr&);

    CallbackNC_ImportProcess_getImportSettings(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::ImportProcessPrx __proxy = ::omero::grid::ImportProcessPrx::uncheckedCast(__result->getProxy());
        ::omero::grid::ImportSettingsPtr __ret;
        try
        {
            __ret = __proxy->end_getImportSettings(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_ImportProcess_getImportSettingsPtr
newCallback_ImportProcess_getImportSettings(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::grid::ImportSettingsPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ImportProcess_getImportSettings<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ImportProcess_getImportSettingsPtr
newCallback_ImportProcess_getImportSettings(T* instance, void (T::*cb)(const ::omero::grid::ImportSettingsPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ImportProcess_getImportSettings<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_ImportProcess_getImportSettings : public Callback_ImportProcess_getImportSettings_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::grid::ImportSettingsPtr&, const CT&);

    Callback_ImportProcess_getImportSettings(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::ImportProcessPrx __proxy = ::omero::grid::ImportProcessPrx::uncheckedCast(__result->getProxy());
        ::omero::grid::ImportSettingsPtr __ret;
        try
        {
            __ret = __proxy->end_getImportSettings(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ImportProcess_getImportSettingsPtr
newCallback_ImportProcess_getImportSettings(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::grid::ImportSettingsPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ImportProcess_getImportSettings<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ImportProcess_getImportSettingsPtr
newCallback_ImportProcess_getImportSettings(T* instance, void (T::*cb)(const ::omero::grid::ImportSettingsPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ImportProcess_getImportSettings<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_ManagedRepository_importFileset : public Callback_ManagedRepository_importFileset_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::grid::ImportProcessPrx&);

    CallbackNC_ManagedRepository_importFileset(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::ManagedRepositoryPrx __proxy = ::omero::grid::ManagedRepositoryPrx::uncheckedCast(__result->getProxy());
        ::omero::grid::ImportProcessPrx __ret;
        try
        {
            __ret = __proxy->end_importFileset(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_ManagedRepository_importFilesetPtr
newCallback_ManagedRepository_importFileset(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::grid::ImportProcessPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ManagedRepository_importFileset<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ManagedRepository_importFilesetPtr
newCallback_ManagedRepository_importFileset(T* instance, void (T::*cb)(const ::omero::grid::ImportProcessPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ManagedRepository_importFileset<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_ManagedRepository_importFileset : public Callback_ManagedRepository_importFileset_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::grid::ImportProcessPrx&, const CT&);

    Callback_ManagedRepository_importFileset(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::ManagedRepositoryPrx __proxy = ::omero::grid::ManagedRepositoryPrx::uncheckedCast(__result->getProxy());
        ::omero::grid::ImportProcessPrx __ret;
        try
        {
            __ret = __proxy->end_importFileset(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ManagedRepository_importFilesetPtr
newCallback_ManagedRepository_importFileset(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::grid::ImportProcessPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ManagedRepository_importFileset<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ManagedRepository_importFilesetPtr
newCallback_ManagedRepository_importFileset(T* instance, void (T::*cb)(const ::omero::grid::ImportProcessPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ManagedRepository_importFileset<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_ManagedRepository_importPaths : public Callback_ManagedRepository_importPaths_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::grid::ImportProcessPrx&);

    CallbackNC_ManagedRepository_importPaths(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::ManagedRepositoryPrx __proxy = ::omero::grid::ManagedRepositoryPrx::uncheckedCast(__result->getProxy());
        ::omero::grid::ImportProcessPrx __ret;
        try
        {
            __ret = __proxy->end_importPaths(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_ManagedRepository_importPathsPtr
newCallback_ManagedRepository_importPaths(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::grid::ImportProcessPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ManagedRepository_importPaths<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ManagedRepository_importPathsPtr
newCallback_ManagedRepository_importPaths(T* instance, void (T::*cb)(const ::omero::grid::ImportProcessPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ManagedRepository_importPaths<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_ManagedRepository_importPaths : public Callback_ManagedRepository_importPaths_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::grid::ImportProcessPrx&, const CT&);

    Callback_ManagedRepository_importPaths(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::ManagedRepositoryPrx __proxy = ::omero::grid::ManagedRepositoryPrx::uncheckedCast(__result->getProxy());
        ::omero::grid::ImportProcessPrx __ret;
        try
        {
            __ret = __proxy->end_importPaths(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ManagedRepository_importPathsPtr
newCallback_ManagedRepository_importPaths(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::grid::ImportProcessPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ManagedRepository_importPaths<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ManagedRepository_importPathsPtr
newCallback_ManagedRepository_importPaths(T* instance, void (T::*cb)(const ::omero::grid::ImportProcessPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ManagedRepository_importPaths<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_ManagedRepository_listImports : public Callback_ManagedRepository_listImports_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::grid::ImportProcessList&);

    CallbackNC_ManagedRepository_listImports(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::ManagedRepositoryPrx __proxy = ::omero::grid::ManagedRepositoryPrx::uncheckedCast(__result->getProxy());
        ::omero::grid::ImportProcessList __ret;
        try
        {
            __ret = __proxy->end_listImports(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_ManagedRepository_listImportsPtr
newCallback_ManagedRepository_listImports(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::grid::ImportProcessList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ManagedRepository_listImports<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ManagedRepository_listImportsPtr
newCallback_ManagedRepository_listImports(T* instance, void (T::*cb)(const ::omero::grid::ImportProcessList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ManagedRepository_listImports<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_ManagedRepository_listImports : public Callback_ManagedRepository_listImports_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::grid::ImportProcessList&, const CT&);

    Callback_ManagedRepository_listImports(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::ManagedRepositoryPrx __proxy = ::omero::grid::ManagedRepositoryPrx::uncheckedCast(__result->getProxy());
        ::omero::grid::ImportProcessList __ret;
        try
        {
            __ret = __proxy->end_listImports(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ManagedRepository_listImportsPtr
newCallback_ManagedRepository_listImports(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::grid::ImportProcessList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ManagedRepository_listImports<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ManagedRepository_listImportsPtr
newCallback_ManagedRepository_listImports(T* instance, void (T::*cb)(const ::omero::grid::ImportProcessList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ManagedRepository_listImports<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_ManagedRepository_listChecksumAlgorithms : public Callback_ManagedRepository_listChecksumAlgorithms_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::api::ChecksumAlgorithmList&);

    CallbackNC_ManagedRepository_listChecksumAlgorithms(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::ManagedRepositoryPrx __proxy = ::omero::grid::ManagedRepositoryPrx::uncheckedCast(__result->getProxy());
        ::omero::api::ChecksumAlgorithmList __ret;
        try
        {
            __ret = __proxy->end_listChecksumAlgorithms(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_ManagedRepository_listChecksumAlgorithmsPtr
newCallback_ManagedRepository_listChecksumAlgorithms(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::ChecksumAlgorithmList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ManagedRepository_listChecksumAlgorithms<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ManagedRepository_listChecksumAlgorithmsPtr
newCallback_ManagedRepository_listChecksumAlgorithms(T* instance, void (T::*cb)(const ::omero::api::ChecksumAlgorithmList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ManagedRepository_listChecksumAlgorithms<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_ManagedRepository_listChecksumAlgorithms : public Callback_ManagedRepository_listChecksumAlgorithms_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::api::ChecksumAlgorithmList&, const CT&);

    Callback_ManagedRepository_listChecksumAlgorithms(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::ManagedRepositoryPrx __proxy = ::omero::grid::ManagedRepositoryPrx::uncheckedCast(__result->getProxy());
        ::omero::api::ChecksumAlgorithmList __ret;
        try
        {
            __ret = __proxy->end_listChecksumAlgorithms(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ManagedRepository_listChecksumAlgorithmsPtr
newCallback_ManagedRepository_listChecksumAlgorithms(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::ChecksumAlgorithmList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ManagedRepository_listChecksumAlgorithms<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ManagedRepository_listChecksumAlgorithmsPtr
newCallback_ManagedRepository_listChecksumAlgorithms(T* instance, void (T::*cb)(const ::omero::api::ChecksumAlgorithmList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ManagedRepository_listChecksumAlgorithms<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_ManagedRepository_suggestChecksumAlgorithm : public Callback_ManagedRepository_suggestChecksumAlgorithm_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::model::ChecksumAlgorithmPtr&);

    CallbackNC_ManagedRepository_suggestChecksumAlgorithm(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::ManagedRepositoryPrx __proxy = ::omero::grid::ManagedRepositoryPrx::uncheckedCast(__result->getProxy());
        ::omero::model::ChecksumAlgorithmPtr __ret;
        try
        {
            __ret = __proxy->end_suggestChecksumAlgorithm(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_ManagedRepository_suggestChecksumAlgorithmPtr
newCallback_ManagedRepository_suggestChecksumAlgorithm(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::ChecksumAlgorithmPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ManagedRepository_suggestChecksumAlgorithm<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ManagedRepository_suggestChecksumAlgorithmPtr
newCallback_ManagedRepository_suggestChecksumAlgorithm(T* instance, void (T::*cb)(const ::omero::model::ChecksumAlgorithmPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ManagedRepository_suggestChecksumAlgorithm<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_ManagedRepository_suggestChecksumAlgorithm : public Callback_ManagedRepository_suggestChecksumAlgorithm_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::model::ChecksumAlgorithmPtr&, const CT&);

    Callback_ManagedRepository_suggestChecksumAlgorithm(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::ManagedRepositoryPrx __proxy = ::omero::grid::ManagedRepositoryPrx::uncheckedCast(__result->getProxy());
        ::omero::model::ChecksumAlgorithmPtr __ret;
        try
        {
            __ret = __proxy->end_suggestChecksumAlgorithm(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ManagedRepository_suggestChecksumAlgorithmPtr
newCallback_ManagedRepository_suggestChecksumAlgorithm(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::ChecksumAlgorithmPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ManagedRepository_suggestChecksumAlgorithm<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ManagedRepository_suggestChecksumAlgorithmPtr
newCallback_ManagedRepository_suggestChecksumAlgorithm(T* instance, void (T::*cb)(const ::omero::model::ChecksumAlgorithmPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ManagedRepository_suggestChecksumAlgorithm<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_InternalRepository_createRawFileStore : public Callback_InternalRepository_createRawFileStore_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::api::RawFileStorePrx&);

    CallbackNC_InternalRepository_createRawFileStore(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::InternalRepositoryPrx __proxy = ::omero::grid::InternalRepositoryPrx::uncheckedCast(__result->getProxy());
        ::omero::api::RawFileStorePrx __ret;
        try
        {
            __ret = __proxy->end_createRawFileStore(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_InternalRepository_createRawFileStorePtr
newCallback_InternalRepository_createRawFileStore(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::RawFileStorePrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InternalRepository_createRawFileStore<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_InternalRepository_createRawFileStorePtr
newCallback_InternalRepository_createRawFileStore(T* instance, void (T::*cb)(const ::omero::api::RawFileStorePrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InternalRepository_createRawFileStore<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_InternalRepository_createRawFileStore : public Callback_InternalRepository_createRawFileStore_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::api::RawFileStorePrx&, const CT&);

    Callback_InternalRepository_createRawFileStore(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::InternalRepositoryPrx __proxy = ::omero::grid::InternalRepositoryPrx::uncheckedCast(__result->getProxy());
        ::omero::api::RawFileStorePrx __ret;
        try
        {
            __ret = __proxy->end_createRawFileStore(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_InternalRepository_createRawFileStorePtr
newCallback_InternalRepository_createRawFileStore(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::RawFileStorePrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InternalRepository_createRawFileStore<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_InternalRepository_createRawFileStorePtr
newCallback_InternalRepository_createRawFileStore(T* instance, void (T::*cb)(const ::omero::api::RawFileStorePrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InternalRepository_createRawFileStore<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_InternalRepository_createRawPixelsStore : public Callback_InternalRepository_createRawPixelsStore_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::api::RawPixelsStorePrx&);

    CallbackNC_InternalRepository_createRawPixelsStore(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::InternalRepositoryPrx __proxy = ::omero::grid::InternalRepositoryPrx::uncheckedCast(__result->getProxy());
        ::omero::api::RawPixelsStorePrx __ret;
        try
        {
            __ret = __proxy->end_createRawPixelsStore(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_InternalRepository_createRawPixelsStorePtr
newCallback_InternalRepository_createRawPixelsStore(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::RawPixelsStorePrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InternalRepository_createRawPixelsStore<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_InternalRepository_createRawPixelsStorePtr
newCallback_InternalRepository_createRawPixelsStore(T* instance, void (T::*cb)(const ::omero::api::RawPixelsStorePrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InternalRepository_createRawPixelsStore<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_InternalRepository_createRawPixelsStore : public Callback_InternalRepository_createRawPixelsStore_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::api::RawPixelsStorePrx&, const CT&);

    Callback_InternalRepository_createRawPixelsStore(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::InternalRepositoryPrx __proxy = ::omero::grid::InternalRepositoryPrx::uncheckedCast(__result->getProxy());
        ::omero::api::RawPixelsStorePrx __ret;
        try
        {
            __ret = __proxy->end_createRawPixelsStore(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_InternalRepository_createRawPixelsStorePtr
newCallback_InternalRepository_createRawPixelsStore(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::RawPixelsStorePrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InternalRepository_createRawPixelsStore<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_InternalRepository_createRawPixelsStorePtr
newCallback_InternalRepository_createRawPixelsStore(T* instance, void (T::*cb)(const ::omero::api::RawPixelsStorePrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InternalRepository_createRawPixelsStore<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_InternalRepository_createRenderingEngine : public Callback_InternalRepository_createRenderingEngine_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::api::RenderingEnginePrx&);

    CallbackNC_InternalRepository_createRenderingEngine(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::InternalRepositoryPrx __proxy = ::omero::grid::InternalRepositoryPrx::uncheckedCast(__result->getProxy());
        ::omero::api::RenderingEnginePrx __ret;
        try
        {
            __ret = __proxy->end_createRenderingEngine(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_InternalRepository_createRenderingEnginePtr
newCallback_InternalRepository_createRenderingEngine(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::RenderingEnginePrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InternalRepository_createRenderingEngine<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_InternalRepository_createRenderingEnginePtr
newCallback_InternalRepository_createRenderingEngine(T* instance, void (T::*cb)(const ::omero::api::RenderingEnginePrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InternalRepository_createRenderingEngine<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_InternalRepository_createRenderingEngine : public Callback_InternalRepository_createRenderingEngine_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::api::RenderingEnginePrx&, const CT&);

    Callback_InternalRepository_createRenderingEngine(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::InternalRepositoryPrx __proxy = ::omero::grid::InternalRepositoryPrx::uncheckedCast(__result->getProxy());
        ::omero::api::RenderingEnginePrx __ret;
        try
        {
            __ret = __proxy->end_createRenderingEngine(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_InternalRepository_createRenderingEnginePtr
newCallback_InternalRepository_createRenderingEngine(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::RenderingEnginePrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InternalRepository_createRenderingEngine<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_InternalRepository_createRenderingEnginePtr
newCallback_InternalRepository_createRenderingEngine(T* instance, void (T::*cb)(const ::omero::api::RenderingEnginePrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InternalRepository_createRenderingEngine<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_InternalRepository_createThumbnailStore : public Callback_InternalRepository_createThumbnailStore_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::api::ThumbnailStorePrx&);

    CallbackNC_InternalRepository_createThumbnailStore(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::InternalRepositoryPrx __proxy = ::omero::grid::InternalRepositoryPrx::uncheckedCast(__result->getProxy());
        ::omero::api::ThumbnailStorePrx __ret;
        try
        {
            __ret = __proxy->end_createThumbnailStore(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_InternalRepository_createThumbnailStorePtr
newCallback_InternalRepository_createThumbnailStore(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::ThumbnailStorePrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InternalRepository_createThumbnailStore<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_InternalRepository_createThumbnailStorePtr
newCallback_InternalRepository_createThumbnailStore(T* instance, void (T::*cb)(const ::omero::api::ThumbnailStorePrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InternalRepository_createThumbnailStore<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_InternalRepository_createThumbnailStore : public Callback_InternalRepository_createThumbnailStore_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::api::ThumbnailStorePrx&, const CT&);

    Callback_InternalRepository_createThumbnailStore(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::InternalRepositoryPrx __proxy = ::omero::grid::InternalRepositoryPrx::uncheckedCast(__result->getProxy());
        ::omero::api::ThumbnailStorePrx __ret;
        try
        {
            __ret = __proxy->end_createThumbnailStore(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_InternalRepository_createThumbnailStorePtr
newCallback_InternalRepository_createThumbnailStore(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::ThumbnailStorePrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InternalRepository_createThumbnailStore<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_InternalRepository_createThumbnailStorePtr
newCallback_InternalRepository_createThumbnailStore(T* instance, void (T::*cb)(const ::omero::api::ThumbnailStorePrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InternalRepository_createThumbnailStore<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_InternalRepository_getDescription : public Callback_InternalRepository_getDescription_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::model::OriginalFilePtr&);

    CallbackNC_InternalRepository_getDescription(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::InternalRepositoryPrx __proxy = ::omero::grid::InternalRepositoryPrx::uncheckedCast(__result->getProxy());
        ::omero::model::OriginalFilePtr __ret;
        try
        {
            __ret = __proxy->end_getDescription(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_InternalRepository_getDescriptionPtr
newCallback_InternalRepository_getDescription(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::OriginalFilePtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InternalRepository_getDescription<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_InternalRepository_getDescriptionPtr
newCallback_InternalRepository_getDescription(T* instance, void (T::*cb)(const ::omero::model::OriginalFilePtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InternalRepository_getDescription<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_InternalRepository_getDescription : public Callback_InternalRepository_getDescription_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::model::OriginalFilePtr&, const CT&);

    Callback_InternalRepository_getDescription(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::InternalRepositoryPrx __proxy = ::omero::grid::InternalRepositoryPrx::uncheckedCast(__result->getProxy());
        ::omero::model::OriginalFilePtr __ret;
        try
        {
            __ret = __proxy->end_getDescription(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_InternalRepository_getDescriptionPtr
newCallback_InternalRepository_getDescription(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::OriginalFilePtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InternalRepository_getDescription<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_InternalRepository_getDescriptionPtr
newCallback_InternalRepository_getDescription(T* instance, void (T::*cb)(const ::omero::model::OriginalFilePtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InternalRepository_getDescription<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_InternalRepository_getProxy : public Callback_InternalRepository_getProxy_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::grid::RepositoryPrx&);

    CallbackNC_InternalRepository_getProxy(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::InternalRepositoryPrx __proxy = ::omero::grid::InternalRepositoryPrx::uncheckedCast(__result->getProxy());
        ::omero::grid::RepositoryPrx __ret;
        try
        {
            __ret = __proxy->end_getProxy(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_InternalRepository_getProxyPtr
newCallback_InternalRepository_getProxy(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::grid::RepositoryPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InternalRepository_getProxy<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_InternalRepository_getProxyPtr
newCallback_InternalRepository_getProxy(T* instance, void (T::*cb)(const ::omero::grid::RepositoryPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InternalRepository_getProxy<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_InternalRepository_getProxy : public Callback_InternalRepository_getProxy_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::grid::RepositoryPrx&, const CT&);

    Callback_InternalRepository_getProxy(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::InternalRepositoryPrx __proxy = ::omero::grid::InternalRepositoryPrx::uncheckedCast(__result->getProxy());
        ::omero::grid::RepositoryPrx __ret;
        try
        {
            __ret = __proxy->end_getProxy(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_InternalRepository_getProxyPtr
newCallback_InternalRepository_getProxy(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::grid::RepositoryPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InternalRepository_getProxy<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_InternalRepository_getProxyPtr
newCallback_InternalRepository_getProxy(T* instance, void (T::*cb)(const ::omero::grid::RepositoryPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InternalRepository_getProxy<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_InternalRepository_rawAccess : public Callback_InternalRepository_rawAccess_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::cmd::ResponsePtr&);

    CallbackNC_InternalRepository_rawAccess(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::InternalRepositoryPrx __proxy = ::omero::grid::InternalRepositoryPrx::uncheckedCast(__result->getProxy());
        ::omero::cmd::ResponsePtr __ret;
        try
        {
            __ret = __proxy->end_rawAccess(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_InternalRepository_rawAccessPtr
newCallback_InternalRepository_rawAccess(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::cmd::ResponsePtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InternalRepository_rawAccess<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_InternalRepository_rawAccessPtr
newCallback_InternalRepository_rawAccess(T* instance, void (T::*cb)(const ::omero::cmd::ResponsePtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InternalRepository_rawAccess<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_InternalRepository_rawAccess : public Callback_InternalRepository_rawAccess_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::cmd::ResponsePtr&, const CT&);

    Callback_InternalRepository_rawAccess(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::InternalRepositoryPrx __proxy = ::omero::grid::InternalRepositoryPrx::uncheckedCast(__result->getProxy());
        ::omero::cmd::ResponsePtr __ret;
        try
        {
            __ret = __proxy->end_rawAccess(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_InternalRepository_rawAccessPtr
newCallback_InternalRepository_rawAccess(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::cmd::ResponsePtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InternalRepository_rawAccess<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_InternalRepository_rawAccessPtr
newCallback_InternalRepository_rawAccess(T* instance, void (T::*cb)(const ::omero::cmd::ResponsePtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InternalRepository_rawAccess<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_InternalRepository_getFilePath : public Callback_InternalRepository_getFilePath_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_InternalRepository_getFilePath(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::InternalRepositoryPrx __proxy = ::omero::grid::InternalRepositoryPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_getFilePath(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_InternalRepository_getFilePathPtr
newCallback_InternalRepository_getFilePath(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InternalRepository_getFilePath<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_InternalRepository_getFilePathPtr
newCallback_InternalRepository_getFilePath(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InternalRepository_getFilePath<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_InternalRepository_getFilePath : public Callback_InternalRepository_getFilePath_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_InternalRepository_getFilePath(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::InternalRepositoryPrx __proxy = ::omero::grid::InternalRepositoryPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_getFilePath(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_InternalRepository_getFilePathPtr
newCallback_InternalRepository_getFilePath(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InternalRepository_getFilePath<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_InternalRepository_getFilePathPtr
newCallback_InternalRepository_getFilePath(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InternalRepository_getFilePath<T, CT>(instance, cb, excb, sentcb);
}

}

}

#endif
