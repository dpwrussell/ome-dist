// **********************************************************************
//
// Copyright (c) 2003-2013 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.5.1
//
// <auto-generated>
//
// Generated from file `Tables.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __omero__opt_hudson_workspace_OMERO_5_0_release_src_components_blitz_generated_omero_Tables_h__
#define __omero__opt_hudson_workspace_OMERO_5_0_release_src_components_blitz_generated_omero_Tables_h__

#include <Ice/ProxyF.h>
#include <Ice/ObjectF.h>
#include <Ice/Exception.h>
#include <Ice/LocalObject.h>
#include <Ice/StreamHelpers.h>
#include <Ice/Proxy.h>
#include <Ice/Object.h>
#include <Ice/Outgoing.h>
#include <Ice/OutgoingAsync.h>
#include <Ice/Incoming.h>
#include <Ice/IncomingAsync.h>
#include <Ice/Direct.h>
#include <Ice/FactoryTableInit.h>
#include <IceUtil/ScopedArray.h>
#include <IceUtil/Optional.h>
#include <Ice/StreamF.h>
#include <Ice/SlicedDataF.h>
#include <omero/ModelF.h>
#include <omero/RTypes.h>
#include <omero/System.h>
#include <omero/Collections.h>
#include <omero/Repositories.h>
#include <omero/ServerErrors.h>
#include <Ice/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 305
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 > 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 1
#       error Ice patch level mismatch!
#   endif
#endif

namespace IceProxy
{

namespace omero
{

namespace api
{

class ServiceFactory;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::omero::api::ServiceFactory>&);
::IceProxy::Ice::Object* upCast(::IceProxy::omero::api::ServiceFactory*);

}

namespace grid
{

class Column;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::omero::grid::Column>&);
::IceProxy::Ice::Object* upCast(::IceProxy::omero::grid::Column*);

class FileColumn;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::omero::grid::FileColumn>&);
::IceProxy::Ice::Object* upCast(::IceProxy::omero::grid::FileColumn*);

class ImageColumn;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::omero::grid::ImageColumn>&);
::IceProxy::Ice::Object* upCast(::IceProxy::omero::grid::ImageColumn*);

class RoiColumn;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::omero::grid::RoiColumn>&);
::IceProxy::Ice::Object* upCast(::IceProxy::omero::grid::RoiColumn*);

class WellColumn;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::omero::grid::WellColumn>&);
::IceProxy::Ice::Object* upCast(::IceProxy::omero::grid::WellColumn*);

class PlateColumn;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::omero::grid::PlateColumn>&);
::IceProxy::Ice::Object* upCast(::IceProxy::omero::grid::PlateColumn*);

class BoolColumn;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::omero::grid::BoolColumn>&);
::IceProxy::Ice::Object* upCast(::IceProxy::omero::grid::BoolColumn*);

class DoubleColumn;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::omero::grid::DoubleColumn>&);
::IceProxy::Ice::Object* upCast(::IceProxy::omero::grid::DoubleColumn*);

class LongColumn;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::omero::grid::LongColumn>&);
::IceProxy::Ice::Object* upCast(::IceProxy::omero::grid::LongColumn*);

class StringColumn;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::omero::grid::StringColumn>&);
::IceProxy::Ice::Object* upCast(::IceProxy::omero::grid::StringColumn*);

class FloatArrayColumn;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::omero::grid::FloatArrayColumn>&);
::IceProxy::Ice::Object* upCast(::IceProxy::omero::grid::FloatArrayColumn*);

class DoubleArrayColumn;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::omero::grid::DoubleArrayColumn>&);
::IceProxy::Ice::Object* upCast(::IceProxy::omero::grid::DoubleArrayColumn*);

class LongArrayColumn;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::omero::grid::LongArrayColumn>&);
::IceProxy::Ice::Object* upCast(::IceProxy::omero::grid::LongArrayColumn*);

class MaskColumn;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::omero::grid::MaskColumn>&);
::IceProxy::Ice::Object* upCast(::IceProxy::omero::grid::MaskColumn*);

class Data;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::omero::grid::Data>&);
::IceProxy::Ice::Object* upCast(::IceProxy::omero::grid::Data*);

class Table;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::omero::grid::Table>&);
::IceProxy::Ice::Object* upCast(::IceProxy::omero::grid::Table*);

class Tables;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::omero::grid::Tables>&);
::IceProxy::Ice::Object* upCast(::IceProxy::omero::grid::Tables*);

}

}

}

namespace omero
{

namespace api
{

class ServiceFactory;
bool operator==(const ServiceFactory&, const ServiceFactory&);
bool operator<(const ServiceFactory&, const ServiceFactory&);
::Ice::Object* upCast(::omero::api::ServiceFactory*);
typedef ::IceInternal::Handle< ::omero::api::ServiceFactory> ServiceFactoryPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::omero::api::ServiceFactory> ServiceFactoryPrx;
void __patch(ServiceFactoryPtr&, const ::Ice::ObjectPtr&);

}

namespace grid
{

class Column;
bool operator==(const Column&, const Column&);
bool operator<(const Column&, const Column&);
::Ice::Object* upCast(::omero::grid::Column*);
typedef ::IceInternal::Handle< ::omero::grid::Column> ColumnPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::omero::grid::Column> ColumnPrx;
void __patch(ColumnPtr&, const ::Ice::ObjectPtr&);

class FileColumn;
bool operator==(const FileColumn&, const FileColumn&);
bool operator<(const FileColumn&, const FileColumn&);
::Ice::Object* upCast(::omero::grid::FileColumn*);
typedef ::IceInternal::Handle< ::omero::grid::FileColumn> FileColumnPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::omero::grid::FileColumn> FileColumnPrx;
void __patch(FileColumnPtr&, const ::Ice::ObjectPtr&);

class ImageColumn;
bool operator==(const ImageColumn&, const ImageColumn&);
bool operator<(const ImageColumn&, const ImageColumn&);
::Ice::Object* upCast(::omero::grid::ImageColumn*);
typedef ::IceInternal::Handle< ::omero::grid::ImageColumn> ImageColumnPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::omero::grid::ImageColumn> ImageColumnPrx;
void __patch(ImageColumnPtr&, const ::Ice::ObjectPtr&);

class RoiColumn;
bool operator==(const RoiColumn&, const RoiColumn&);
bool operator<(const RoiColumn&, const RoiColumn&);
::Ice::Object* upCast(::omero::grid::RoiColumn*);
typedef ::IceInternal::Handle< ::omero::grid::RoiColumn> RoiColumnPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::omero::grid::RoiColumn> RoiColumnPrx;
void __patch(RoiColumnPtr&, const ::Ice::ObjectPtr&);

class WellColumn;
bool operator==(const WellColumn&, const WellColumn&);
bool operator<(const WellColumn&, const WellColumn&);
::Ice::Object* upCast(::omero::grid::WellColumn*);
typedef ::IceInternal::Handle< ::omero::grid::WellColumn> WellColumnPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::omero::grid::WellColumn> WellColumnPrx;
void __patch(WellColumnPtr&, const ::Ice::ObjectPtr&);

class PlateColumn;
bool operator==(const PlateColumn&, const PlateColumn&);
bool operator<(const PlateColumn&, const PlateColumn&);
::Ice::Object* upCast(::omero::grid::PlateColumn*);
typedef ::IceInternal::Handle< ::omero::grid::PlateColumn> PlateColumnPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::omero::grid::PlateColumn> PlateColumnPrx;
void __patch(PlateColumnPtr&, const ::Ice::ObjectPtr&);

class BoolColumn;
bool operator==(const BoolColumn&, const BoolColumn&);
bool operator<(const BoolColumn&, const BoolColumn&);
::Ice::Object* upCast(::omero::grid::BoolColumn*);
typedef ::IceInternal::Handle< ::omero::grid::BoolColumn> BoolColumnPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::omero::grid::BoolColumn> BoolColumnPrx;
void __patch(BoolColumnPtr&, const ::Ice::ObjectPtr&);

class DoubleColumn;
bool operator==(const DoubleColumn&, const DoubleColumn&);
bool operator<(const DoubleColumn&, const DoubleColumn&);
::Ice::Object* upCast(::omero::grid::DoubleColumn*);
typedef ::IceInternal::Handle< ::omero::grid::DoubleColumn> DoubleColumnPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::omero::grid::DoubleColumn> DoubleColumnPrx;
void __patch(DoubleColumnPtr&, const ::Ice::ObjectPtr&);

class LongColumn;
bool operator==(const LongColumn&, const LongColumn&);
bool operator<(const LongColumn&, const LongColumn&);
::Ice::Object* upCast(::omero::grid::LongColumn*);
typedef ::IceInternal::Handle< ::omero::grid::LongColumn> LongColumnPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::omero::grid::LongColumn> LongColumnPrx;
void __patch(LongColumnPtr&, const ::Ice::ObjectPtr&);

class StringColumn;
bool operator==(const StringColumn&, const StringColumn&);
bool operator<(const StringColumn&, const StringColumn&);
::Ice::Object* upCast(::omero::grid::StringColumn*);
typedef ::IceInternal::Handle< ::omero::grid::StringColumn> StringColumnPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::omero::grid::StringColumn> StringColumnPrx;
void __patch(StringColumnPtr&, const ::Ice::ObjectPtr&);

class FloatArrayColumn;
bool operator==(const FloatArrayColumn&, const FloatArrayColumn&);
bool operator<(const FloatArrayColumn&, const FloatArrayColumn&);
::Ice::Object* upCast(::omero::grid::FloatArrayColumn*);
typedef ::IceInternal::Handle< ::omero::grid::FloatArrayColumn> FloatArrayColumnPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::omero::grid::FloatArrayColumn> FloatArrayColumnPrx;
void __patch(FloatArrayColumnPtr&, const ::Ice::ObjectPtr&);

class DoubleArrayColumn;
bool operator==(const DoubleArrayColumn&, const DoubleArrayColumn&);
bool operator<(const DoubleArrayColumn&, const DoubleArrayColumn&);
::Ice::Object* upCast(::omero::grid::DoubleArrayColumn*);
typedef ::IceInternal::Handle< ::omero::grid::DoubleArrayColumn> DoubleArrayColumnPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::omero::grid::DoubleArrayColumn> DoubleArrayColumnPrx;
void __patch(DoubleArrayColumnPtr&, const ::Ice::ObjectPtr&);

class LongArrayColumn;
bool operator==(const LongArrayColumn&, const LongArrayColumn&);
bool operator<(const LongArrayColumn&, const LongArrayColumn&);
::Ice::Object* upCast(::omero::grid::LongArrayColumn*);
typedef ::IceInternal::Handle< ::omero::grid::LongArrayColumn> LongArrayColumnPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::omero::grid::LongArrayColumn> LongArrayColumnPrx;
void __patch(LongArrayColumnPtr&, const ::Ice::ObjectPtr&);

class MaskColumn;
bool operator==(const MaskColumn&, const MaskColumn&);
bool operator<(const MaskColumn&, const MaskColumn&);
::Ice::Object* upCast(::omero::grid::MaskColumn*);
typedef ::IceInternal::Handle< ::omero::grid::MaskColumn> MaskColumnPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::omero::grid::MaskColumn> MaskColumnPrx;
void __patch(MaskColumnPtr&, const ::Ice::ObjectPtr&);

class Data;
bool operator==(const Data&, const Data&);
bool operator<(const Data&, const Data&);
::Ice::Object* upCast(::omero::grid::Data*);
typedef ::IceInternal::Handle< ::omero::grid::Data> DataPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::omero::grid::Data> DataPrx;
void __patch(DataPtr&, const ::Ice::ObjectPtr&);

class Table;
bool operator==(const Table&, const Table&);
bool operator<(const Table&, const Table&);
::Ice::Object* upCast(::omero::grid::Table*);
typedef ::IceInternal::Handle< ::omero::grid::Table> TablePtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::omero::grid::Table> TablePrx;
void __patch(TablePtr&, const ::Ice::ObjectPtr&);

class Tables;
bool operator==(const Tables&, const Tables&);
bool operator<(const Tables&, const Tables&);
::Ice::Object* upCast(::omero::grid::Tables*);
typedef ::IceInternal::Handle< ::omero::grid::Tables> TablesPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::omero::grid::Tables> TablesPrx;
void __patch(TablesPtr&, const ::Ice::ObjectPtr&);

}

}

namespace omero
{

namespace grid
{

typedef ::std::vector< ::omero::grid::ColumnPtr> ColumnArray;

}

}

namespace omero
{

namespace grid
{

class AMI_Table_getOriginalFile : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::omero::model::OriginalFilePtr&) = 0;

    void __response(const ::omero::model::OriginalFilePtr& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::grid::AMI_Table_getOriginalFile> AMI_Table_getOriginalFilePtr;

class AMI_Table_getHeaders : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::omero::grid::ColumnArray&) = 0;

    void __response(const ::omero::grid::ColumnArray& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::grid::AMI_Table_getHeaders> AMI_Table_getHeadersPtr;

class AMI_Table_getNumberOfRows : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(::Ice::Long) = 0;

    void __response(::Ice::Long __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::grid::AMI_Table_getNumberOfRows> AMI_Table_getNumberOfRowsPtr;

class AMI_Table_getWhereList : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::omero::api::LongArray&) = 0;

    void __response(const ::omero::api::LongArray& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::grid::AMI_Table_getWhereList> AMI_Table_getWhereListPtr;

class AMI_Table_readCoordinates : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::omero::grid::DataPtr&) = 0;

    void __response(const ::omero::grid::DataPtr& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::grid::AMI_Table_readCoordinates> AMI_Table_readCoordinatesPtr;

class AMI_Table_read : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::omero::grid::DataPtr&) = 0;

    void __response(const ::omero::grid::DataPtr& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::grid::AMI_Table_read> AMI_Table_readPtr;

class AMI_Table_slice : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::omero::grid::DataPtr&) = 0;

    void __response(const ::omero::grid::DataPtr& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::grid::AMI_Table_slice> AMI_Table_slicePtr;

class AMI_Table_addData : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response() = 0;

    void __response()
    {
        ice_response();
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::grid::AMI_Table_addData> AMI_Table_addDataPtr;

class AMI_Table_update : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response() = 0;

    void __response()
    {
        ice_response();
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::grid::AMI_Table_update> AMI_Table_updatePtr;

class AMI_Table_getAllMetadata : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::omero::RTypeDict&) = 0;

    void __response(const ::omero::RTypeDict& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::grid::AMI_Table_getAllMetadata> AMI_Table_getAllMetadataPtr;

class AMI_Table_getMetadata : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::omero::RTypePtr&) = 0;

    void __response(const ::omero::RTypePtr& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::grid::AMI_Table_getMetadata> AMI_Table_getMetadataPtr;

class AMI_Table_setAllMetadata : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response() = 0;

    void __response()
    {
        ice_response();
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::grid::AMI_Table_setAllMetadata> AMI_Table_setAllMetadataPtr;

class AMI_Table_setMetadata : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response() = 0;

    void __response()
    {
        ice_response();
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::grid::AMI_Table_setMetadata> AMI_Table_setMetadataPtr;

class AMI_Table_initialize : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response() = 0;

    void __response()
    {
        ice_response();
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::grid::AMI_Table_initialize> AMI_Table_initializePtr;

class AMI_Table_addColumn : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(::Ice::Int) = 0;

    void __response(::Ice::Int __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::grid::AMI_Table_addColumn> AMI_Table_addColumnPtr;

class AMI_Table_delete : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response() = 0;

    void __response()
    {
        ice_response();
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::grid::AMI_Table_delete> AMI_Table_deletePtr;

class AMI_Table_close : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response() = 0;

    void __response()
    {
        ice_response();
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::grid::AMI_Table_close> AMI_Table_closePtr;

class AMI_Tables_getRepository : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::omero::grid::RepositoryPrx&) = 0;

    void __response(const ::omero::grid::RepositoryPrx& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::grid::AMI_Tables_getRepository> AMI_Tables_getRepositoryPtr;

class AMI_Tables_getTable : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::omero::grid::TablePrx&) = 0;

    void __response(const ::omero::grid::TablePrx& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::grid::AMI_Tables_getTable> AMI_Tables_getTablePtr;

}

}

namespace IceAsync
{

}

namespace omero
{

namespace grid
{

class Callback_Table_getOriginalFile_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Table_getOriginalFile_Base> Callback_Table_getOriginalFilePtr;

class Callback_Table_getHeaders_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Table_getHeaders_Base> Callback_Table_getHeadersPtr;

class Callback_Table_getNumberOfRows_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Table_getNumberOfRows_Base> Callback_Table_getNumberOfRowsPtr;

class Callback_Table_getWhereList_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Table_getWhereList_Base> Callback_Table_getWhereListPtr;

class Callback_Table_readCoordinates_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Table_readCoordinates_Base> Callback_Table_readCoordinatesPtr;

class Callback_Table_read_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Table_read_Base> Callback_Table_readPtr;

class Callback_Table_slice_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Table_slice_Base> Callback_Table_slicePtr;

class Callback_Table_addData_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Table_addData_Base> Callback_Table_addDataPtr;

class Callback_Table_update_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Table_update_Base> Callback_Table_updatePtr;

class Callback_Table_getAllMetadata_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Table_getAllMetadata_Base> Callback_Table_getAllMetadataPtr;

class Callback_Table_getMetadata_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Table_getMetadata_Base> Callback_Table_getMetadataPtr;

class Callback_Table_setAllMetadata_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Table_setAllMetadata_Base> Callback_Table_setAllMetadataPtr;

class Callback_Table_setMetadata_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Table_setMetadata_Base> Callback_Table_setMetadataPtr;

class Callback_Table_initialize_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Table_initialize_Base> Callback_Table_initializePtr;

class Callback_Table_addColumn_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Table_addColumn_Base> Callback_Table_addColumnPtr;

class Callback_Table_delete_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Table_delete_Base> Callback_Table_deletePtr;

class Callback_Table_close_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Table_close_Base> Callback_Table_closePtr;

class Callback_Tables_getRepository_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Tables_getRepository_Base> Callback_Tables_getRepositoryPtr;

class Callback_Tables_getTable_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Tables_getTable_Base> Callback_Tables_getTablePtr;

}

}

namespace IceProxy
{

namespace omero
{

namespace grid
{

class Column : virtual public ::IceProxy::Ice::Object
{
public:
    
    ::IceInternal::ProxyHandle<Column> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<Column*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<Column> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<Column*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<Column> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<Column*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<Column> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<Column*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<Column> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<Column*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<Column> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<Column*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<Column> ice_secure(bool __secure) const
    {
        return dynamic_cast<Column*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<Column> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<Column*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<Column> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<Column*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<Column> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<Column*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<Column> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<Column*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<Column> ice_twoway() const
    {
        return dynamic_cast<Column*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<Column> ice_oneway() const
    {
        return dynamic_cast<Column*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<Column> ice_batchOneway() const
    {
        return dynamic_cast<Column*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<Column> ice_datagram() const
    {
        return dynamic_cast<Column*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<Column> ice_batchDatagram() const
    {
        return dynamic_cast<Column*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<Column> ice_compress(bool __compress) const
    {
        return dynamic_cast<Column*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<Column> ice_timeout(int __timeout) const
    {
        return dynamic_cast<Column*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<Column> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<Column*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<Column> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<Column*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class FileColumn : virtual public ::IceProxy::omero::grid::Column
{
public:
    
    ::IceInternal::ProxyHandle<FileColumn> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<FileColumn*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<FileColumn> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<FileColumn*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<FileColumn> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<FileColumn*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<FileColumn> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<FileColumn*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<FileColumn> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<FileColumn*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<FileColumn> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<FileColumn*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<FileColumn> ice_secure(bool __secure) const
    {
        return dynamic_cast<FileColumn*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<FileColumn> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<FileColumn*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<FileColumn> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<FileColumn*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<FileColumn> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<FileColumn*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<FileColumn> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<FileColumn*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<FileColumn> ice_twoway() const
    {
        return dynamic_cast<FileColumn*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<FileColumn> ice_oneway() const
    {
        return dynamic_cast<FileColumn*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<FileColumn> ice_batchOneway() const
    {
        return dynamic_cast<FileColumn*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<FileColumn> ice_datagram() const
    {
        return dynamic_cast<FileColumn*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<FileColumn> ice_batchDatagram() const
    {
        return dynamic_cast<FileColumn*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<FileColumn> ice_compress(bool __compress) const
    {
        return dynamic_cast<FileColumn*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<FileColumn> ice_timeout(int __timeout) const
    {
        return dynamic_cast<FileColumn*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<FileColumn> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<FileColumn*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<FileColumn> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<FileColumn*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class ImageColumn : virtual public ::IceProxy::omero::grid::Column
{
public:
    
    ::IceInternal::ProxyHandle<ImageColumn> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<ImageColumn*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<ImageColumn> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<ImageColumn*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<ImageColumn> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<ImageColumn*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<ImageColumn> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<ImageColumn*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<ImageColumn> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<ImageColumn*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<ImageColumn> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<ImageColumn*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<ImageColumn> ice_secure(bool __secure) const
    {
        return dynamic_cast<ImageColumn*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<ImageColumn> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<ImageColumn*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<ImageColumn> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<ImageColumn*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<ImageColumn> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<ImageColumn*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<ImageColumn> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<ImageColumn*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<ImageColumn> ice_twoway() const
    {
        return dynamic_cast<ImageColumn*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<ImageColumn> ice_oneway() const
    {
        return dynamic_cast<ImageColumn*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<ImageColumn> ice_batchOneway() const
    {
        return dynamic_cast<ImageColumn*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<ImageColumn> ice_datagram() const
    {
        return dynamic_cast<ImageColumn*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<ImageColumn> ice_batchDatagram() const
    {
        return dynamic_cast<ImageColumn*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<ImageColumn> ice_compress(bool __compress) const
    {
        return dynamic_cast<ImageColumn*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<ImageColumn> ice_timeout(int __timeout) const
    {
        return dynamic_cast<ImageColumn*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<ImageColumn> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<ImageColumn*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<ImageColumn> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<ImageColumn*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class RoiColumn : virtual public ::IceProxy::omero::grid::Column
{
public:
    
    ::IceInternal::ProxyHandle<RoiColumn> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<RoiColumn*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<RoiColumn> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<RoiColumn*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<RoiColumn> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<RoiColumn*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<RoiColumn> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<RoiColumn*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<RoiColumn> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<RoiColumn*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<RoiColumn> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<RoiColumn*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<RoiColumn> ice_secure(bool __secure) const
    {
        return dynamic_cast<RoiColumn*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<RoiColumn> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<RoiColumn*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<RoiColumn> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<RoiColumn*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<RoiColumn> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<RoiColumn*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<RoiColumn> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<RoiColumn*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<RoiColumn> ice_twoway() const
    {
        return dynamic_cast<RoiColumn*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<RoiColumn> ice_oneway() const
    {
        return dynamic_cast<RoiColumn*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<RoiColumn> ice_batchOneway() const
    {
        return dynamic_cast<RoiColumn*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<RoiColumn> ice_datagram() const
    {
        return dynamic_cast<RoiColumn*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<RoiColumn> ice_batchDatagram() const
    {
        return dynamic_cast<RoiColumn*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<RoiColumn> ice_compress(bool __compress) const
    {
        return dynamic_cast<RoiColumn*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<RoiColumn> ice_timeout(int __timeout) const
    {
        return dynamic_cast<RoiColumn*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<RoiColumn> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<RoiColumn*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<RoiColumn> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<RoiColumn*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class WellColumn : virtual public ::IceProxy::omero::grid::Column
{
public:
    
    ::IceInternal::ProxyHandle<WellColumn> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<WellColumn*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<WellColumn> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<WellColumn*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<WellColumn> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<WellColumn*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<WellColumn> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<WellColumn*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<WellColumn> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<WellColumn*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<WellColumn> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<WellColumn*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<WellColumn> ice_secure(bool __secure) const
    {
        return dynamic_cast<WellColumn*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<WellColumn> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<WellColumn*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<WellColumn> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<WellColumn*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<WellColumn> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<WellColumn*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<WellColumn> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<WellColumn*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<WellColumn> ice_twoway() const
    {
        return dynamic_cast<WellColumn*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<WellColumn> ice_oneway() const
    {
        return dynamic_cast<WellColumn*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<WellColumn> ice_batchOneway() const
    {
        return dynamic_cast<WellColumn*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<WellColumn> ice_datagram() const
    {
        return dynamic_cast<WellColumn*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<WellColumn> ice_batchDatagram() const
    {
        return dynamic_cast<WellColumn*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<WellColumn> ice_compress(bool __compress) const
    {
        return dynamic_cast<WellColumn*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<WellColumn> ice_timeout(int __timeout) const
    {
        return dynamic_cast<WellColumn*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<WellColumn> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<WellColumn*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<WellColumn> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<WellColumn*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class PlateColumn : virtual public ::IceProxy::omero::grid::Column
{
public:
    
    ::IceInternal::ProxyHandle<PlateColumn> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<PlateColumn*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<PlateColumn> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<PlateColumn*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<PlateColumn> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<PlateColumn*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<PlateColumn> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<PlateColumn*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<PlateColumn> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<PlateColumn*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<PlateColumn> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<PlateColumn*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<PlateColumn> ice_secure(bool __secure) const
    {
        return dynamic_cast<PlateColumn*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<PlateColumn> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<PlateColumn*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<PlateColumn> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<PlateColumn*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<PlateColumn> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<PlateColumn*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<PlateColumn> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<PlateColumn*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<PlateColumn> ice_twoway() const
    {
        return dynamic_cast<PlateColumn*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<PlateColumn> ice_oneway() const
    {
        return dynamic_cast<PlateColumn*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<PlateColumn> ice_batchOneway() const
    {
        return dynamic_cast<PlateColumn*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<PlateColumn> ice_datagram() const
    {
        return dynamic_cast<PlateColumn*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<PlateColumn> ice_batchDatagram() const
    {
        return dynamic_cast<PlateColumn*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<PlateColumn> ice_compress(bool __compress) const
    {
        return dynamic_cast<PlateColumn*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<PlateColumn> ice_timeout(int __timeout) const
    {
        return dynamic_cast<PlateColumn*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<PlateColumn> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<PlateColumn*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<PlateColumn> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<PlateColumn*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class BoolColumn : virtual public ::IceProxy::omero::grid::Column
{
public:
    
    ::IceInternal::ProxyHandle<BoolColumn> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<BoolColumn*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<BoolColumn> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<BoolColumn*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<BoolColumn> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<BoolColumn*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<BoolColumn> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<BoolColumn*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<BoolColumn> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<BoolColumn*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<BoolColumn> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<BoolColumn*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<BoolColumn> ice_secure(bool __secure) const
    {
        return dynamic_cast<BoolColumn*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<BoolColumn> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<BoolColumn*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<BoolColumn> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<BoolColumn*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<BoolColumn> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<BoolColumn*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<BoolColumn> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<BoolColumn*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<BoolColumn> ice_twoway() const
    {
        return dynamic_cast<BoolColumn*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<BoolColumn> ice_oneway() const
    {
        return dynamic_cast<BoolColumn*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<BoolColumn> ice_batchOneway() const
    {
        return dynamic_cast<BoolColumn*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<BoolColumn> ice_datagram() const
    {
        return dynamic_cast<BoolColumn*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<BoolColumn> ice_batchDatagram() const
    {
        return dynamic_cast<BoolColumn*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<BoolColumn> ice_compress(bool __compress) const
    {
        return dynamic_cast<BoolColumn*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<BoolColumn> ice_timeout(int __timeout) const
    {
        return dynamic_cast<BoolColumn*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<BoolColumn> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<BoolColumn*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<BoolColumn> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<BoolColumn*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class DoubleColumn : virtual public ::IceProxy::omero::grid::Column
{
public:
    
    ::IceInternal::ProxyHandle<DoubleColumn> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<DoubleColumn*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<DoubleColumn> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<DoubleColumn*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<DoubleColumn> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<DoubleColumn*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<DoubleColumn> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<DoubleColumn*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<DoubleColumn> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<DoubleColumn*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<DoubleColumn> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<DoubleColumn*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<DoubleColumn> ice_secure(bool __secure) const
    {
        return dynamic_cast<DoubleColumn*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<DoubleColumn> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<DoubleColumn*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<DoubleColumn> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<DoubleColumn*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<DoubleColumn> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<DoubleColumn*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<DoubleColumn> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<DoubleColumn*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<DoubleColumn> ice_twoway() const
    {
        return dynamic_cast<DoubleColumn*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<DoubleColumn> ice_oneway() const
    {
        return dynamic_cast<DoubleColumn*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<DoubleColumn> ice_batchOneway() const
    {
        return dynamic_cast<DoubleColumn*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<DoubleColumn> ice_datagram() const
    {
        return dynamic_cast<DoubleColumn*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<DoubleColumn> ice_batchDatagram() const
    {
        return dynamic_cast<DoubleColumn*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<DoubleColumn> ice_compress(bool __compress) const
    {
        return dynamic_cast<DoubleColumn*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<DoubleColumn> ice_timeout(int __timeout) const
    {
        return dynamic_cast<DoubleColumn*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<DoubleColumn> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<DoubleColumn*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<DoubleColumn> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<DoubleColumn*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class LongColumn : virtual public ::IceProxy::omero::grid::Column
{
public:
    
    ::IceInternal::ProxyHandle<LongColumn> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<LongColumn*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<LongColumn> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<LongColumn*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<LongColumn> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<LongColumn*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<LongColumn> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<LongColumn*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<LongColumn> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<LongColumn*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<LongColumn> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<LongColumn*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<LongColumn> ice_secure(bool __secure) const
    {
        return dynamic_cast<LongColumn*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<LongColumn> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<LongColumn*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<LongColumn> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<LongColumn*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<LongColumn> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<LongColumn*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<LongColumn> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<LongColumn*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<LongColumn> ice_twoway() const
    {
        return dynamic_cast<LongColumn*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<LongColumn> ice_oneway() const
    {
        return dynamic_cast<LongColumn*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<LongColumn> ice_batchOneway() const
    {
        return dynamic_cast<LongColumn*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<LongColumn> ice_datagram() const
    {
        return dynamic_cast<LongColumn*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<LongColumn> ice_batchDatagram() const
    {
        return dynamic_cast<LongColumn*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<LongColumn> ice_compress(bool __compress) const
    {
        return dynamic_cast<LongColumn*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<LongColumn> ice_timeout(int __timeout) const
    {
        return dynamic_cast<LongColumn*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<LongColumn> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<LongColumn*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<LongColumn> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<LongColumn*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class StringColumn : virtual public ::IceProxy::omero::grid::Column
{
public:
    
    ::IceInternal::ProxyHandle<StringColumn> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<StringColumn*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<StringColumn> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<StringColumn*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<StringColumn> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<StringColumn*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<StringColumn> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<StringColumn*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<StringColumn> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<StringColumn*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<StringColumn> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<StringColumn*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<StringColumn> ice_secure(bool __secure) const
    {
        return dynamic_cast<StringColumn*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<StringColumn> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<StringColumn*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<StringColumn> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<StringColumn*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<StringColumn> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<StringColumn*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<StringColumn> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<StringColumn*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<StringColumn> ice_twoway() const
    {
        return dynamic_cast<StringColumn*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<StringColumn> ice_oneway() const
    {
        return dynamic_cast<StringColumn*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<StringColumn> ice_batchOneway() const
    {
        return dynamic_cast<StringColumn*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<StringColumn> ice_datagram() const
    {
        return dynamic_cast<StringColumn*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<StringColumn> ice_batchDatagram() const
    {
        return dynamic_cast<StringColumn*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<StringColumn> ice_compress(bool __compress) const
    {
        return dynamic_cast<StringColumn*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<StringColumn> ice_timeout(int __timeout) const
    {
        return dynamic_cast<StringColumn*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<StringColumn> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<StringColumn*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<StringColumn> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<StringColumn*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class FloatArrayColumn : virtual public ::IceProxy::omero::grid::Column
{
public:
    
    ::IceInternal::ProxyHandle<FloatArrayColumn> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<FloatArrayColumn*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<FloatArrayColumn> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<FloatArrayColumn*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<FloatArrayColumn> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<FloatArrayColumn*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<FloatArrayColumn> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<FloatArrayColumn*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<FloatArrayColumn> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<FloatArrayColumn*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<FloatArrayColumn> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<FloatArrayColumn*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<FloatArrayColumn> ice_secure(bool __secure) const
    {
        return dynamic_cast<FloatArrayColumn*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<FloatArrayColumn> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<FloatArrayColumn*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<FloatArrayColumn> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<FloatArrayColumn*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<FloatArrayColumn> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<FloatArrayColumn*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<FloatArrayColumn> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<FloatArrayColumn*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<FloatArrayColumn> ice_twoway() const
    {
        return dynamic_cast<FloatArrayColumn*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<FloatArrayColumn> ice_oneway() const
    {
        return dynamic_cast<FloatArrayColumn*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<FloatArrayColumn> ice_batchOneway() const
    {
        return dynamic_cast<FloatArrayColumn*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<FloatArrayColumn> ice_datagram() const
    {
        return dynamic_cast<FloatArrayColumn*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<FloatArrayColumn> ice_batchDatagram() const
    {
        return dynamic_cast<FloatArrayColumn*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<FloatArrayColumn> ice_compress(bool __compress) const
    {
        return dynamic_cast<FloatArrayColumn*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<FloatArrayColumn> ice_timeout(int __timeout) const
    {
        return dynamic_cast<FloatArrayColumn*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<FloatArrayColumn> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<FloatArrayColumn*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<FloatArrayColumn> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<FloatArrayColumn*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class DoubleArrayColumn : virtual public ::IceProxy::omero::grid::Column
{
public:
    
    ::IceInternal::ProxyHandle<DoubleArrayColumn> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<DoubleArrayColumn*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<DoubleArrayColumn> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<DoubleArrayColumn*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<DoubleArrayColumn> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<DoubleArrayColumn*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<DoubleArrayColumn> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<DoubleArrayColumn*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<DoubleArrayColumn> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<DoubleArrayColumn*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<DoubleArrayColumn> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<DoubleArrayColumn*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<DoubleArrayColumn> ice_secure(bool __secure) const
    {
        return dynamic_cast<DoubleArrayColumn*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<DoubleArrayColumn> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<DoubleArrayColumn*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<DoubleArrayColumn> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<DoubleArrayColumn*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<DoubleArrayColumn> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<DoubleArrayColumn*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<DoubleArrayColumn> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<DoubleArrayColumn*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<DoubleArrayColumn> ice_twoway() const
    {
        return dynamic_cast<DoubleArrayColumn*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<DoubleArrayColumn> ice_oneway() const
    {
        return dynamic_cast<DoubleArrayColumn*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<DoubleArrayColumn> ice_batchOneway() const
    {
        return dynamic_cast<DoubleArrayColumn*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<DoubleArrayColumn> ice_datagram() const
    {
        return dynamic_cast<DoubleArrayColumn*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<DoubleArrayColumn> ice_batchDatagram() const
    {
        return dynamic_cast<DoubleArrayColumn*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<DoubleArrayColumn> ice_compress(bool __compress) const
    {
        return dynamic_cast<DoubleArrayColumn*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<DoubleArrayColumn> ice_timeout(int __timeout) const
    {
        return dynamic_cast<DoubleArrayColumn*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<DoubleArrayColumn> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<DoubleArrayColumn*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<DoubleArrayColumn> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<DoubleArrayColumn*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class LongArrayColumn : virtual public ::IceProxy::omero::grid::Column
{
public:
    
    ::IceInternal::ProxyHandle<LongArrayColumn> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<LongArrayColumn*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<LongArrayColumn> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<LongArrayColumn*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<LongArrayColumn> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<LongArrayColumn*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<LongArrayColumn> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<LongArrayColumn*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<LongArrayColumn> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<LongArrayColumn*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<LongArrayColumn> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<LongArrayColumn*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<LongArrayColumn> ice_secure(bool __secure) const
    {
        return dynamic_cast<LongArrayColumn*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<LongArrayColumn> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<LongArrayColumn*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<LongArrayColumn> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<LongArrayColumn*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<LongArrayColumn> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<LongArrayColumn*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<LongArrayColumn> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<LongArrayColumn*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<LongArrayColumn> ice_twoway() const
    {
        return dynamic_cast<LongArrayColumn*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<LongArrayColumn> ice_oneway() const
    {
        return dynamic_cast<LongArrayColumn*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<LongArrayColumn> ice_batchOneway() const
    {
        return dynamic_cast<LongArrayColumn*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<LongArrayColumn> ice_datagram() const
    {
        return dynamic_cast<LongArrayColumn*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<LongArrayColumn> ice_batchDatagram() const
    {
        return dynamic_cast<LongArrayColumn*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<LongArrayColumn> ice_compress(bool __compress) const
    {
        return dynamic_cast<LongArrayColumn*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<LongArrayColumn> ice_timeout(int __timeout) const
    {
        return dynamic_cast<LongArrayColumn*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<LongArrayColumn> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<LongArrayColumn*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<LongArrayColumn> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<LongArrayColumn*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class MaskColumn : virtual public ::IceProxy::omero::grid::Column
{
public:
    
    ::IceInternal::ProxyHandle<MaskColumn> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<MaskColumn*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<MaskColumn> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<MaskColumn*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<MaskColumn> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<MaskColumn*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<MaskColumn> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<MaskColumn*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<MaskColumn> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<MaskColumn*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<MaskColumn> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<MaskColumn*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<MaskColumn> ice_secure(bool __secure) const
    {
        return dynamic_cast<MaskColumn*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<MaskColumn> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<MaskColumn*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<MaskColumn> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<MaskColumn*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<MaskColumn> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<MaskColumn*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<MaskColumn> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<MaskColumn*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<MaskColumn> ice_twoway() const
    {
        return dynamic_cast<MaskColumn*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<MaskColumn> ice_oneway() const
    {
        return dynamic_cast<MaskColumn*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<MaskColumn> ice_batchOneway() const
    {
        return dynamic_cast<MaskColumn*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<MaskColumn> ice_datagram() const
    {
        return dynamic_cast<MaskColumn*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<MaskColumn> ice_batchDatagram() const
    {
        return dynamic_cast<MaskColumn*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<MaskColumn> ice_compress(bool __compress) const
    {
        return dynamic_cast<MaskColumn*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<MaskColumn> ice_timeout(int __timeout) const
    {
        return dynamic_cast<MaskColumn*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<MaskColumn> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<MaskColumn*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<MaskColumn> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<MaskColumn*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class Data : virtual public ::IceProxy::Ice::Object
{
public:
    
    ::IceInternal::ProxyHandle<Data> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<Data*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<Data> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<Data*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<Data> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<Data*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<Data> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<Data*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<Data> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<Data*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<Data> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<Data*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<Data> ice_secure(bool __secure) const
    {
        return dynamic_cast<Data*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<Data> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<Data*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<Data> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<Data*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<Data> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<Data*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<Data> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<Data*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<Data> ice_twoway() const
    {
        return dynamic_cast<Data*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<Data> ice_oneway() const
    {
        return dynamic_cast<Data*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<Data> ice_batchOneway() const
    {
        return dynamic_cast<Data*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<Data> ice_datagram() const
    {
        return dynamic_cast<Data*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<Data> ice_batchDatagram() const
    {
        return dynamic_cast<Data*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<Data> ice_compress(bool __compress) const
    {
        return dynamic_cast<Data*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<Data> ice_timeout(int __timeout) const
    {
        return dynamic_cast<Data*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<Data> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<Data*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<Data> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<Data*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class Table : virtual public ::IceProxy::Ice::Object
{
public:

    ::omero::model::OriginalFilePtr getOriginalFile()
    {
        return getOriginalFile(0);
    }
    ::omero::model::OriginalFilePtr getOriginalFile(const ::Ice::Context& __ctx)
    {
        return getOriginalFile(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_getOriginalFile(const ::IceInternal::Function<void (const ::omero::model::OriginalFilePtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getOriginalFile(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getOriginalFile(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getOriginalFile(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_getOriginalFile(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::omero::model::OriginalFilePtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getOriginalFile(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getOriginalFile(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getOriginalFile(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_getOriginalFile(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::omero::model::OriginalFilePtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::omero::model::OriginalFilePtr&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::grid::TablePrx __proxy = ::omero::grid::TablePrx::uncheckedCast(__result->getProxy());
                ::omero::model::OriginalFilePtr __ret;
                try
                {
                    __ret = __proxy->end_getOriginalFile(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::omero::model::OriginalFilePtr&)> _response;
        };
        return begin_getOriginalFile(__ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_getOriginalFile()
    {
        return begin_getOriginalFile(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getOriginalFile(const ::Ice::Context& __ctx)
    {
        return begin_getOriginalFile(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getOriginalFile(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getOriginalFile(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getOriginalFile(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getOriginalFile(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getOriginalFile(const ::omero::grid::Callback_Table_getOriginalFilePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getOriginalFile(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getOriginalFile(const ::Ice::Context& __ctx, const ::omero::grid::Callback_Table_getOriginalFilePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getOriginalFile(&__ctx, __del, __cookie);
    }

    ::omero::model::OriginalFilePtr end_getOriginalFile(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::model::OriginalFilePtr getOriginalFile(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getOriginalFile(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool getOriginalFile_async(const ::omero::grid::AMI_Table_getOriginalFilePtr&);
    bool getOriginalFile_async(const ::omero::grid::AMI_Table_getOriginalFilePtr&, const ::Ice::Context&);

    ::omero::grid::ColumnArray getHeaders()
    {
        return getHeaders(0);
    }
    ::omero::grid::ColumnArray getHeaders(const ::Ice::Context& __ctx)
    {
        return getHeaders(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_getHeaders(const ::IceInternal::Function<void (const ::omero::grid::ColumnArray&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getHeaders(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getHeaders(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getHeaders(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_getHeaders(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::omero::grid::ColumnArray&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getHeaders(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getHeaders(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getHeaders(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_getHeaders(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::omero::grid::ColumnArray&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::omero::grid::ColumnArray&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::grid::TablePrx __proxy = ::omero::grid::TablePrx::uncheckedCast(__result->getProxy());
                ::omero::grid::ColumnArray __ret;
                try
                {
                    __ret = __proxy->end_getHeaders(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::omero::grid::ColumnArray&)> _response;
        };
        return begin_getHeaders(__ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_getHeaders()
    {
        return begin_getHeaders(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getHeaders(const ::Ice::Context& __ctx)
    {
        return begin_getHeaders(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getHeaders(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getHeaders(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getHeaders(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getHeaders(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getHeaders(const ::omero::grid::Callback_Table_getHeadersPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getHeaders(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getHeaders(const ::Ice::Context& __ctx, const ::omero::grid::Callback_Table_getHeadersPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getHeaders(&__ctx, __del, __cookie);
    }

    ::omero::grid::ColumnArray end_getHeaders(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::grid::ColumnArray getHeaders(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getHeaders(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool getHeaders_async(const ::omero::grid::AMI_Table_getHeadersPtr&);
    bool getHeaders_async(const ::omero::grid::AMI_Table_getHeadersPtr&, const ::Ice::Context&);

    ::Ice::Long getNumberOfRows()
    {
        return getNumberOfRows(0);
    }
    ::Ice::Long getNumberOfRows(const ::Ice::Context& __ctx)
    {
        return getNumberOfRows(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_getNumberOfRows(const ::IceInternal::Function<void (::Ice::Long)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getNumberOfRows(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getNumberOfRows(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getNumberOfRows(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_getNumberOfRows(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (::Ice::Long)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getNumberOfRows(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getNumberOfRows(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getNumberOfRows(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_getNumberOfRows(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (::Ice::Long)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (::Ice::Long)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::grid::TablePrx __proxy = ::omero::grid::TablePrx::uncheckedCast(__result->getProxy());
                ::Ice::Long __ret;
                try
                {
                    __ret = __proxy->end_getNumberOfRows(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (::Ice::Long)> _response;
        };
        return begin_getNumberOfRows(__ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_getNumberOfRows()
    {
        return begin_getNumberOfRows(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getNumberOfRows(const ::Ice::Context& __ctx)
    {
        return begin_getNumberOfRows(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getNumberOfRows(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getNumberOfRows(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getNumberOfRows(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getNumberOfRows(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getNumberOfRows(const ::omero::grid::Callback_Table_getNumberOfRowsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getNumberOfRows(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getNumberOfRows(const ::Ice::Context& __ctx, const ::omero::grid::Callback_Table_getNumberOfRowsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getNumberOfRows(&__ctx, __del, __cookie);
    }

    ::Ice::Long end_getNumberOfRows(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Long getNumberOfRows(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getNumberOfRows(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool getNumberOfRows_async(const ::omero::grid::AMI_Table_getNumberOfRowsPtr&);
    bool getNumberOfRows_async(const ::omero::grid::AMI_Table_getNumberOfRowsPtr&, const ::Ice::Context&);

    ::omero::api::LongArray getWhereList(const ::std::string& condition, const ::omero::RTypeDict& variables, ::Ice::Long start, ::Ice::Long stop, ::Ice::Long step)
    {
        return getWhereList(condition, variables, start, stop, step, 0);
    }
    ::omero::api::LongArray getWhereList(const ::std::string& condition, const ::omero::RTypeDict& variables, ::Ice::Long start, ::Ice::Long stop, ::Ice::Long step, const ::Ice::Context& __ctx)
    {
        return getWhereList(condition, variables, start, stop, step, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_getWhereList(const ::std::string& condition, const ::omero::RTypeDict& variables, ::Ice::Long start, ::Ice::Long stop, ::Ice::Long step, const ::IceInternal::Function<void (const ::omero::api::LongArray&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getWhereList(condition, variables, start, stop, step, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getWhereList(const ::std::string& condition, const ::omero::RTypeDict& variables, ::Ice::Long start, ::Ice::Long stop, ::Ice::Long step, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getWhereList(condition, variables, start, stop, step, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_getWhereList(const ::std::string& condition, const ::omero::RTypeDict& variables, ::Ice::Long start, ::Ice::Long stop, ::Ice::Long step, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::omero::api::LongArray&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getWhereList(condition, variables, start, stop, step, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getWhereList(const ::std::string& condition, const ::omero::RTypeDict& variables, ::Ice::Long start, ::Ice::Long stop, ::Ice::Long step, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getWhereList(condition, variables, start, stop, step, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_getWhereList(const ::std::string& condition, const ::omero::RTypeDict& variables, ::Ice::Long start, ::Ice::Long stop, ::Ice::Long step, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::omero::api::LongArray&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::omero::api::LongArray&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::grid::TablePrx __proxy = ::omero::grid::TablePrx::uncheckedCast(__result->getProxy());
                ::omero::api::LongArray __ret;
                try
                {
                    __ret = __proxy->end_getWhereList(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::omero::api::LongArray&)> _response;
        };
        return begin_getWhereList(condition, variables, start, stop, step, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_getWhereList(const ::std::string& condition, const ::omero::RTypeDict& variables, ::Ice::Long start, ::Ice::Long stop, ::Ice::Long step)
    {
        return begin_getWhereList(condition, variables, start, stop, step, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getWhereList(const ::std::string& condition, const ::omero::RTypeDict& variables, ::Ice::Long start, ::Ice::Long stop, ::Ice::Long step, const ::Ice::Context& __ctx)
    {
        return begin_getWhereList(condition, variables, start, stop, step, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getWhereList(const ::std::string& condition, const ::omero::RTypeDict& variables, ::Ice::Long start, ::Ice::Long stop, ::Ice::Long step, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getWhereList(condition, variables, start, stop, step, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getWhereList(const ::std::string& condition, const ::omero::RTypeDict& variables, ::Ice::Long start, ::Ice::Long stop, ::Ice::Long step, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getWhereList(condition, variables, start, stop, step, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getWhereList(const ::std::string& condition, const ::omero::RTypeDict& variables, ::Ice::Long start, ::Ice::Long stop, ::Ice::Long step, const ::omero::grid::Callback_Table_getWhereListPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getWhereList(condition, variables, start, stop, step, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getWhereList(const ::std::string& condition, const ::omero::RTypeDict& variables, ::Ice::Long start, ::Ice::Long stop, ::Ice::Long step, const ::Ice::Context& __ctx, const ::omero::grid::Callback_Table_getWhereListPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getWhereList(condition, variables, start, stop, step, &__ctx, __del, __cookie);
    }

    ::omero::api::LongArray end_getWhereList(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::api::LongArray getWhereList(const ::std::string&, const ::omero::RTypeDict&, ::Ice::Long, ::Ice::Long, ::Ice::Long, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getWhereList(const ::std::string&, const ::omero::RTypeDict&, ::Ice::Long, ::Ice::Long, ::Ice::Long, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool getWhereList_async(const ::omero::grid::AMI_Table_getWhereListPtr&, const ::std::string&, const ::omero::RTypeDict&, ::Ice::Long, ::Ice::Long, ::Ice::Long);
    bool getWhereList_async(const ::omero::grid::AMI_Table_getWhereListPtr&, const ::std::string&, const ::omero::RTypeDict&, ::Ice::Long, ::Ice::Long, ::Ice::Long, const ::Ice::Context&);

    ::omero::grid::DataPtr readCoordinates(const ::omero::api::LongArray& rowNumbers)
    {
        return readCoordinates(rowNumbers, 0);
    }
    ::omero::grid::DataPtr readCoordinates(const ::omero::api::LongArray& rowNumbers, const ::Ice::Context& __ctx)
    {
        return readCoordinates(rowNumbers, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_readCoordinates(const ::omero::api::LongArray& rowNumbers, const ::IceInternal::Function<void (const ::omero::grid::DataPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_readCoordinates(rowNumbers, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_readCoordinates(const ::omero::api::LongArray& rowNumbers, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_readCoordinates(rowNumbers, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_readCoordinates(const ::omero::api::LongArray& rowNumbers, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::omero::grid::DataPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_readCoordinates(rowNumbers, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_readCoordinates(const ::omero::api::LongArray& rowNumbers, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_readCoordinates(rowNumbers, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_readCoordinates(const ::omero::api::LongArray& rowNumbers, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::omero::grid::DataPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::omero::grid::DataPtr&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::grid::TablePrx __proxy = ::omero::grid::TablePrx::uncheckedCast(__result->getProxy());
                ::omero::grid::DataPtr __ret;
                try
                {
                    __ret = __proxy->end_readCoordinates(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::omero::grid::DataPtr&)> _response;
        };
        return begin_readCoordinates(rowNumbers, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_readCoordinates(const ::omero::api::LongArray& rowNumbers)
    {
        return begin_readCoordinates(rowNumbers, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_readCoordinates(const ::omero::api::LongArray& rowNumbers, const ::Ice::Context& __ctx)
    {
        return begin_readCoordinates(rowNumbers, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_readCoordinates(const ::omero::api::LongArray& rowNumbers, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_readCoordinates(rowNumbers, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_readCoordinates(const ::omero::api::LongArray& rowNumbers, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_readCoordinates(rowNumbers, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_readCoordinates(const ::omero::api::LongArray& rowNumbers, const ::omero::grid::Callback_Table_readCoordinatesPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_readCoordinates(rowNumbers, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_readCoordinates(const ::omero::api::LongArray& rowNumbers, const ::Ice::Context& __ctx, const ::omero::grid::Callback_Table_readCoordinatesPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_readCoordinates(rowNumbers, &__ctx, __del, __cookie);
    }

    ::omero::grid::DataPtr end_readCoordinates(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::grid::DataPtr readCoordinates(const ::omero::api::LongArray&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_readCoordinates(const ::omero::api::LongArray&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool readCoordinates_async(const ::omero::grid::AMI_Table_readCoordinatesPtr&, const ::omero::api::LongArray&);
    bool readCoordinates_async(const ::omero::grid::AMI_Table_readCoordinatesPtr&, const ::omero::api::LongArray&, const ::Ice::Context&);

    ::omero::grid::DataPtr read(const ::omero::api::LongArray& colNumbers, ::Ice::Long start, ::Ice::Long stop)
    {
        return read(colNumbers, start, stop, 0);
    }
    ::omero::grid::DataPtr read(const ::omero::api::LongArray& colNumbers, ::Ice::Long start, ::Ice::Long stop, const ::Ice::Context& __ctx)
    {
        return read(colNumbers, start, stop, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_read(const ::omero::api::LongArray& colNumbers, ::Ice::Long start, ::Ice::Long stop, const ::IceInternal::Function<void (const ::omero::grid::DataPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_read(colNumbers, start, stop, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_read(const ::omero::api::LongArray& colNumbers, ::Ice::Long start, ::Ice::Long stop, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_read(colNumbers, start, stop, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_read(const ::omero::api::LongArray& colNumbers, ::Ice::Long start, ::Ice::Long stop, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::omero::grid::DataPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_read(colNumbers, start, stop, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_read(const ::omero::api::LongArray& colNumbers, ::Ice::Long start, ::Ice::Long stop, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_read(colNumbers, start, stop, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_read(const ::omero::api::LongArray& colNumbers, ::Ice::Long start, ::Ice::Long stop, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::omero::grid::DataPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::omero::grid::DataPtr&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::grid::TablePrx __proxy = ::omero::grid::TablePrx::uncheckedCast(__result->getProxy());
                ::omero::grid::DataPtr __ret;
                try
                {
                    __ret = __proxy->end_read(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::omero::grid::DataPtr&)> _response;
        };
        return begin_read(colNumbers, start, stop, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_read(const ::omero::api::LongArray& colNumbers, ::Ice::Long start, ::Ice::Long stop)
    {
        return begin_read(colNumbers, start, stop, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_read(const ::omero::api::LongArray& colNumbers, ::Ice::Long start, ::Ice::Long stop, const ::Ice::Context& __ctx)
    {
        return begin_read(colNumbers, start, stop, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_read(const ::omero::api::LongArray& colNumbers, ::Ice::Long start, ::Ice::Long stop, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_read(colNumbers, start, stop, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_read(const ::omero::api::LongArray& colNumbers, ::Ice::Long start, ::Ice::Long stop, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_read(colNumbers, start, stop, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_read(const ::omero::api::LongArray& colNumbers, ::Ice::Long start, ::Ice::Long stop, const ::omero::grid::Callback_Table_readPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_read(colNumbers, start, stop, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_read(const ::omero::api::LongArray& colNumbers, ::Ice::Long start, ::Ice::Long stop, const ::Ice::Context& __ctx, const ::omero::grid::Callback_Table_readPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_read(colNumbers, start, stop, &__ctx, __del, __cookie);
    }

    ::omero::grid::DataPtr end_read(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::grid::DataPtr read(const ::omero::api::LongArray&, ::Ice::Long, ::Ice::Long, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_read(const ::omero::api::LongArray&, ::Ice::Long, ::Ice::Long, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool read_async(const ::omero::grid::AMI_Table_readPtr&, const ::omero::api::LongArray&, ::Ice::Long, ::Ice::Long);
    bool read_async(const ::omero::grid::AMI_Table_readPtr&, const ::omero::api::LongArray&, ::Ice::Long, ::Ice::Long, const ::Ice::Context&);

    ::omero::grid::DataPtr slice(const ::omero::api::LongArray& colNumbers, const ::omero::api::LongArray& rowNumbers)
    {
        return slice(colNumbers, rowNumbers, 0);
    }
    ::omero::grid::DataPtr slice(const ::omero::api::LongArray& colNumbers, const ::omero::api::LongArray& rowNumbers, const ::Ice::Context& __ctx)
    {
        return slice(colNumbers, rowNumbers, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_slice(const ::omero::api::LongArray& colNumbers, const ::omero::api::LongArray& rowNumbers, const ::IceInternal::Function<void (const ::omero::grid::DataPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_slice(colNumbers, rowNumbers, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_slice(const ::omero::api::LongArray& colNumbers, const ::omero::api::LongArray& rowNumbers, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_slice(colNumbers, rowNumbers, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_slice(const ::omero::api::LongArray& colNumbers, const ::omero::api::LongArray& rowNumbers, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::omero::grid::DataPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_slice(colNumbers, rowNumbers, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_slice(const ::omero::api::LongArray& colNumbers, const ::omero::api::LongArray& rowNumbers, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_slice(colNumbers, rowNumbers, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_slice(const ::omero::api::LongArray& colNumbers, const ::omero::api::LongArray& rowNumbers, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::omero::grid::DataPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::omero::grid::DataPtr&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::grid::TablePrx __proxy = ::omero::grid::TablePrx::uncheckedCast(__result->getProxy());
                ::omero::grid::DataPtr __ret;
                try
                {
                    __ret = __proxy->end_slice(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::omero::grid::DataPtr&)> _response;
        };
        return begin_slice(colNumbers, rowNumbers, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_slice(const ::omero::api::LongArray& colNumbers, const ::omero::api::LongArray& rowNumbers)
    {
        return begin_slice(colNumbers, rowNumbers, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_slice(const ::omero::api::LongArray& colNumbers, const ::omero::api::LongArray& rowNumbers, const ::Ice::Context& __ctx)
    {
        return begin_slice(colNumbers, rowNumbers, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_slice(const ::omero::api::LongArray& colNumbers, const ::omero::api::LongArray& rowNumbers, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_slice(colNumbers, rowNumbers, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_slice(const ::omero::api::LongArray& colNumbers, const ::omero::api::LongArray& rowNumbers, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_slice(colNumbers, rowNumbers, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_slice(const ::omero::api::LongArray& colNumbers, const ::omero::api::LongArray& rowNumbers, const ::omero::grid::Callback_Table_slicePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_slice(colNumbers, rowNumbers, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_slice(const ::omero::api::LongArray& colNumbers, const ::omero::api::LongArray& rowNumbers, const ::Ice::Context& __ctx, const ::omero::grid::Callback_Table_slicePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_slice(colNumbers, rowNumbers, &__ctx, __del, __cookie);
    }

    ::omero::grid::DataPtr end_slice(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::grid::DataPtr slice(const ::omero::api::LongArray&, const ::omero::api::LongArray&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_slice(const ::omero::api::LongArray&, const ::omero::api::LongArray&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool slice_async(const ::omero::grid::AMI_Table_slicePtr&, const ::omero::api::LongArray&, const ::omero::api::LongArray&);
    bool slice_async(const ::omero::grid::AMI_Table_slicePtr&, const ::omero::api::LongArray&, const ::omero::api::LongArray&, const ::Ice::Context&);

    void addData(const ::omero::grid::ColumnArray& cols)
    {
        addData(cols, 0);
    }
    void addData(const ::omero::grid::ColumnArray& cols, const ::Ice::Context& __ctx)
    {
        addData(cols, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_addData(const ::omero::grid::ColumnArray& cols, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_addData(cols, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_addData(const ::omero::grid::ColumnArray& cols, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_addData(cols, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_addData(const ::omero::grid::ColumnArray& cols, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_addData(cols, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_addData(const ::omero::grid::ColumnArray& cols, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_addData(cols, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_addData(const ::omero::grid::ColumnArray& cols, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::grid::TablePrx __proxy = ::omero::grid::TablePrx::uncheckedCast(__result->getProxy());
                try
                {
                    __proxy->end_addData(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response();
                }
            }
        
        private:
            
            ::std::function<void ()> _response;
        };
        return begin_addData(cols, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_addData(const ::omero::grid::ColumnArray& cols)
    {
        return begin_addData(cols, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_addData(const ::omero::grid::ColumnArray& cols, const ::Ice::Context& __ctx)
    {
        return begin_addData(cols, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_addData(const ::omero::grid::ColumnArray& cols, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_addData(cols, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_addData(const ::omero::grid::ColumnArray& cols, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_addData(cols, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_addData(const ::omero::grid::ColumnArray& cols, const ::omero::grid::Callback_Table_addDataPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_addData(cols, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_addData(const ::omero::grid::ColumnArray& cols, const ::Ice::Context& __ctx, const ::omero::grid::Callback_Table_addDataPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_addData(cols, &__ctx, __del, __cookie);
    }

    void end_addData(const ::Ice::AsyncResultPtr&);
    
private:

    void addData(const ::omero::grid::ColumnArray&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_addData(const ::omero::grid::ColumnArray&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool addData_async(const ::omero::grid::AMI_Table_addDataPtr&, const ::omero::grid::ColumnArray&);
    bool addData_async(const ::omero::grid::AMI_Table_addDataPtr&, const ::omero::grid::ColumnArray&, const ::Ice::Context&);

    void update(const ::omero::grid::DataPtr& modifiedData)
    {
        update(modifiedData, 0);
    }
    void update(const ::omero::grid::DataPtr& modifiedData, const ::Ice::Context& __ctx)
    {
        update(modifiedData, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_update(const ::omero::grid::DataPtr& modifiedData, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_update(modifiedData, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_update(const ::omero::grid::DataPtr& modifiedData, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_update(modifiedData, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_update(const ::omero::grid::DataPtr& modifiedData, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_update(modifiedData, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_update(const ::omero::grid::DataPtr& modifiedData, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_update(modifiedData, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_update(const ::omero::grid::DataPtr& modifiedData, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::grid::TablePrx __proxy = ::omero::grid::TablePrx::uncheckedCast(__result->getProxy());
                try
                {
                    __proxy->end_update(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response();
                }
            }
        
        private:
            
            ::std::function<void ()> _response;
        };
        return begin_update(modifiedData, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_update(const ::omero::grid::DataPtr& modifiedData)
    {
        return begin_update(modifiedData, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_update(const ::omero::grid::DataPtr& modifiedData, const ::Ice::Context& __ctx)
    {
        return begin_update(modifiedData, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_update(const ::omero::grid::DataPtr& modifiedData, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_update(modifiedData, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_update(const ::omero::grid::DataPtr& modifiedData, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_update(modifiedData, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_update(const ::omero::grid::DataPtr& modifiedData, const ::omero::grid::Callback_Table_updatePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_update(modifiedData, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_update(const ::omero::grid::DataPtr& modifiedData, const ::Ice::Context& __ctx, const ::omero::grid::Callback_Table_updatePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_update(modifiedData, &__ctx, __del, __cookie);
    }

    void end_update(const ::Ice::AsyncResultPtr&);
    
private:

    void update(const ::omero::grid::DataPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_update(const ::omero::grid::DataPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool update_async(const ::omero::grid::AMI_Table_updatePtr&, const ::omero::grid::DataPtr&);
    bool update_async(const ::omero::grid::AMI_Table_updatePtr&, const ::omero::grid::DataPtr&, const ::Ice::Context&);

    ::omero::RTypeDict getAllMetadata()
    {
        return getAllMetadata(0);
    }
    ::omero::RTypeDict getAllMetadata(const ::Ice::Context& __ctx)
    {
        return getAllMetadata(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_getAllMetadata(const ::IceInternal::Function<void (const ::omero::RTypeDict&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getAllMetadata(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getAllMetadata(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getAllMetadata(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_getAllMetadata(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::omero::RTypeDict&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getAllMetadata(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getAllMetadata(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getAllMetadata(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_getAllMetadata(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::omero::RTypeDict&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::omero::RTypeDict&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::grid::TablePrx __proxy = ::omero::grid::TablePrx::uncheckedCast(__result->getProxy());
                ::omero::RTypeDict __ret;
                try
                {
                    __ret = __proxy->end_getAllMetadata(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::omero::RTypeDict&)> _response;
        };
        return begin_getAllMetadata(__ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_getAllMetadata()
    {
        return begin_getAllMetadata(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getAllMetadata(const ::Ice::Context& __ctx)
    {
        return begin_getAllMetadata(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getAllMetadata(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getAllMetadata(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getAllMetadata(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getAllMetadata(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getAllMetadata(const ::omero::grid::Callback_Table_getAllMetadataPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getAllMetadata(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getAllMetadata(const ::Ice::Context& __ctx, const ::omero::grid::Callback_Table_getAllMetadataPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getAllMetadata(&__ctx, __del, __cookie);
    }

    ::omero::RTypeDict end_getAllMetadata(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::RTypeDict getAllMetadata(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getAllMetadata(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool getAllMetadata_async(const ::omero::grid::AMI_Table_getAllMetadataPtr&);
    bool getAllMetadata_async(const ::omero::grid::AMI_Table_getAllMetadataPtr&, const ::Ice::Context&);

    ::omero::RTypePtr getMetadata(const ::std::string& key)
    {
        return getMetadata(key, 0);
    }
    ::omero::RTypePtr getMetadata(const ::std::string& key, const ::Ice::Context& __ctx)
    {
        return getMetadata(key, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_getMetadata(const ::std::string& key, const ::IceInternal::Function<void (const ::omero::RTypePtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getMetadata(key, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getMetadata(const ::std::string& key, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getMetadata(key, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_getMetadata(const ::std::string& key, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::omero::RTypePtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getMetadata(key, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getMetadata(const ::std::string& key, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getMetadata(key, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_getMetadata(const ::std::string& key, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::omero::RTypePtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::omero::RTypePtr&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::grid::TablePrx __proxy = ::omero::grid::TablePrx::uncheckedCast(__result->getProxy());
                ::omero::RTypePtr __ret;
                try
                {
                    __ret = __proxy->end_getMetadata(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::omero::RTypePtr&)> _response;
        };
        return begin_getMetadata(key, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_getMetadata(const ::std::string& key)
    {
        return begin_getMetadata(key, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getMetadata(const ::std::string& key, const ::Ice::Context& __ctx)
    {
        return begin_getMetadata(key, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getMetadata(const ::std::string& key, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getMetadata(key, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getMetadata(const ::std::string& key, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getMetadata(key, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getMetadata(const ::std::string& key, const ::omero::grid::Callback_Table_getMetadataPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getMetadata(key, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getMetadata(const ::std::string& key, const ::Ice::Context& __ctx, const ::omero::grid::Callback_Table_getMetadataPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getMetadata(key, &__ctx, __del, __cookie);
    }

    ::omero::RTypePtr end_getMetadata(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::RTypePtr getMetadata(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getMetadata(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool getMetadata_async(const ::omero::grid::AMI_Table_getMetadataPtr&, const ::std::string&);
    bool getMetadata_async(const ::omero::grid::AMI_Table_getMetadataPtr&, const ::std::string&, const ::Ice::Context&);

    void setAllMetadata(const ::omero::RTypeDict& dict)
    {
        setAllMetadata(dict, 0);
    }
    void setAllMetadata(const ::omero::RTypeDict& dict, const ::Ice::Context& __ctx)
    {
        setAllMetadata(dict, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_setAllMetadata(const ::omero::RTypeDict& dict, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_setAllMetadata(dict, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_setAllMetadata(const ::omero::RTypeDict& dict, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_setAllMetadata(dict, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_setAllMetadata(const ::omero::RTypeDict& dict, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_setAllMetadata(dict, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_setAllMetadata(const ::omero::RTypeDict& dict, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_setAllMetadata(dict, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_setAllMetadata(const ::omero::RTypeDict& dict, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::grid::TablePrx __proxy = ::omero::grid::TablePrx::uncheckedCast(__result->getProxy());
                try
                {
                    __proxy->end_setAllMetadata(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response();
                }
            }
        
        private:
            
            ::std::function<void ()> _response;
        };
        return begin_setAllMetadata(dict, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_setAllMetadata(const ::omero::RTypeDict& dict)
    {
        return begin_setAllMetadata(dict, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setAllMetadata(const ::omero::RTypeDict& dict, const ::Ice::Context& __ctx)
    {
        return begin_setAllMetadata(dict, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setAllMetadata(const ::omero::RTypeDict& dict, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setAllMetadata(dict, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setAllMetadata(const ::omero::RTypeDict& dict, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setAllMetadata(dict, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setAllMetadata(const ::omero::RTypeDict& dict, const ::omero::grid::Callback_Table_setAllMetadataPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setAllMetadata(dict, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setAllMetadata(const ::omero::RTypeDict& dict, const ::Ice::Context& __ctx, const ::omero::grid::Callback_Table_setAllMetadataPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setAllMetadata(dict, &__ctx, __del, __cookie);
    }

    void end_setAllMetadata(const ::Ice::AsyncResultPtr&);
    
private:

    void setAllMetadata(const ::omero::RTypeDict&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setAllMetadata(const ::omero::RTypeDict&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool setAllMetadata_async(const ::omero::grid::AMI_Table_setAllMetadataPtr&, const ::omero::RTypeDict&);
    bool setAllMetadata_async(const ::omero::grid::AMI_Table_setAllMetadataPtr&, const ::omero::RTypeDict&, const ::Ice::Context&);

    void setMetadata(const ::std::string& key, const ::omero::RTypePtr& value)
    {
        setMetadata(key, value, 0);
    }
    void setMetadata(const ::std::string& key, const ::omero::RTypePtr& value, const ::Ice::Context& __ctx)
    {
        setMetadata(key, value, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_setMetadata(const ::std::string& key, const ::omero::RTypePtr& value, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_setMetadata(key, value, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_setMetadata(const ::std::string& key, const ::omero::RTypePtr& value, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_setMetadata(key, value, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_setMetadata(const ::std::string& key, const ::omero::RTypePtr& value, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_setMetadata(key, value, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_setMetadata(const ::std::string& key, const ::omero::RTypePtr& value, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_setMetadata(key, value, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_setMetadata(const ::std::string& key, const ::omero::RTypePtr& value, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::grid::TablePrx __proxy = ::omero::grid::TablePrx::uncheckedCast(__result->getProxy());
                try
                {
                    __proxy->end_setMetadata(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response();
                }
            }
        
        private:
            
            ::std::function<void ()> _response;
        };
        return begin_setMetadata(key, value, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_setMetadata(const ::std::string& key, const ::omero::RTypePtr& value)
    {
        return begin_setMetadata(key, value, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setMetadata(const ::std::string& key, const ::omero::RTypePtr& value, const ::Ice::Context& __ctx)
    {
        return begin_setMetadata(key, value, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setMetadata(const ::std::string& key, const ::omero::RTypePtr& value, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setMetadata(key, value, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setMetadata(const ::std::string& key, const ::omero::RTypePtr& value, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setMetadata(key, value, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setMetadata(const ::std::string& key, const ::omero::RTypePtr& value, const ::omero::grid::Callback_Table_setMetadataPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setMetadata(key, value, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setMetadata(const ::std::string& key, const ::omero::RTypePtr& value, const ::Ice::Context& __ctx, const ::omero::grid::Callback_Table_setMetadataPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setMetadata(key, value, &__ctx, __del, __cookie);
    }

    void end_setMetadata(const ::Ice::AsyncResultPtr&);
    
private:

    void setMetadata(const ::std::string&, const ::omero::RTypePtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setMetadata(const ::std::string&, const ::omero::RTypePtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool setMetadata_async(const ::omero::grid::AMI_Table_setMetadataPtr&, const ::std::string&, const ::omero::RTypePtr&);
    bool setMetadata_async(const ::omero::grid::AMI_Table_setMetadataPtr&, const ::std::string&, const ::omero::RTypePtr&, const ::Ice::Context&);

    void initialize(const ::omero::grid::ColumnArray& cols)
    {
        initialize(cols, 0);
    }
    void initialize(const ::omero::grid::ColumnArray& cols, const ::Ice::Context& __ctx)
    {
        initialize(cols, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_initialize(const ::omero::grid::ColumnArray& cols, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_initialize(cols, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_initialize(const ::omero::grid::ColumnArray& cols, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_initialize(cols, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_initialize(const ::omero::grid::ColumnArray& cols, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_initialize(cols, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_initialize(const ::omero::grid::ColumnArray& cols, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_initialize(cols, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_initialize(const ::omero::grid::ColumnArray& cols, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::grid::TablePrx __proxy = ::omero::grid::TablePrx::uncheckedCast(__result->getProxy());
                try
                {
                    __proxy->end_initialize(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response();
                }
            }
        
        private:
            
            ::std::function<void ()> _response;
        };
        return begin_initialize(cols, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_initialize(const ::omero::grid::ColumnArray& cols)
    {
        return begin_initialize(cols, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_initialize(const ::omero::grid::ColumnArray& cols, const ::Ice::Context& __ctx)
    {
        return begin_initialize(cols, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_initialize(const ::omero::grid::ColumnArray& cols, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_initialize(cols, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_initialize(const ::omero::grid::ColumnArray& cols, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_initialize(cols, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_initialize(const ::omero::grid::ColumnArray& cols, const ::omero::grid::Callback_Table_initializePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_initialize(cols, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_initialize(const ::omero::grid::ColumnArray& cols, const ::Ice::Context& __ctx, const ::omero::grid::Callback_Table_initializePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_initialize(cols, &__ctx, __del, __cookie);
    }

    void end_initialize(const ::Ice::AsyncResultPtr&);
    
private:

    void initialize(const ::omero::grid::ColumnArray&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_initialize(const ::omero::grid::ColumnArray&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool initialize_async(const ::omero::grid::AMI_Table_initializePtr&, const ::omero::grid::ColumnArray&);
    bool initialize_async(const ::omero::grid::AMI_Table_initializePtr&, const ::omero::grid::ColumnArray&, const ::Ice::Context&);

    ::Ice::Int addColumn(const ::omero::grid::ColumnPtr& col)
    {
        return addColumn(col, 0);
    }
    ::Ice::Int addColumn(const ::omero::grid::ColumnPtr& col, const ::Ice::Context& __ctx)
    {
        return addColumn(col, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_addColumn(const ::omero::grid::ColumnPtr& col, const ::IceInternal::Function<void (::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_addColumn(col, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_addColumn(const ::omero::grid::ColumnPtr& col, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_addColumn(col, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_addColumn(const ::omero::grid::ColumnPtr& col, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_addColumn(col, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_addColumn(const ::omero::grid::ColumnPtr& col, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_addColumn(col, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_addColumn(const ::omero::grid::ColumnPtr& col, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (::Ice::Int)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::grid::TablePrx __proxy = ::omero::grid::TablePrx::uncheckedCast(__result->getProxy());
                ::Ice::Int __ret;
                try
                {
                    __ret = __proxy->end_addColumn(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (::Ice::Int)> _response;
        };
        return begin_addColumn(col, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_addColumn(const ::omero::grid::ColumnPtr& col)
    {
        return begin_addColumn(col, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_addColumn(const ::omero::grid::ColumnPtr& col, const ::Ice::Context& __ctx)
    {
        return begin_addColumn(col, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_addColumn(const ::omero::grid::ColumnPtr& col, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_addColumn(col, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_addColumn(const ::omero::grid::ColumnPtr& col, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_addColumn(col, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_addColumn(const ::omero::grid::ColumnPtr& col, const ::omero::grid::Callback_Table_addColumnPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_addColumn(col, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_addColumn(const ::omero::grid::ColumnPtr& col, const ::Ice::Context& __ctx, const ::omero::grid::Callback_Table_addColumnPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_addColumn(col, &__ctx, __del, __cookie);
    }

    ::Ice::Int end_addColumn(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int addColumn(const ::omero::grid::ColumnPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_addColumn(const ::omero::grid::ColumnPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool addColumn_async(const ::omero::grid::AMI_Table_addColumnPtr&, const ::omero::grid::ColumnPtr&);
    bool addColumn_async(const ::omero::grid::AMI_Table_addColumnPtr&, const ::omero::grid::ColumnPtr&, const ::Ice::Context&);

    void _cpp_delete()
    {
        _cpp_delete(0);
    }
    void _cpp_delete(const ::Ice::Context& __ctx)
    {
        _cpp_delete(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_delete(const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_delete(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_delete(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_delete(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_delete(const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_delete(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_delete(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_delete(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_delete(const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::grid::TablePrx __proxy = ::omero::grid::TablePrx::uncheckedCast(__result->getProxy());
                try
                {
                    __proxy->end_delete(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response();
                }
            }
        
        private:
            
            ::std::function<void ()> _response;
        };
        return begin_delete(__ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_delete()
    {
        return begin_delete(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_delete(const ::Ice::Context& __ctx)
    {
        return begin_delete(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_delete(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_delete(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_delete(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_delete(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_delete(const ::omero::grid::Callback_Table_deletePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_delete(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_delete(const ::Ice::Context& __ctx, const ::omero::grid::Callback_Table_deletePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_delete(&__ctx, __del, __cookie);
    }

    void end_delete(const ::Ice::AsyncResultPtr&);
    
private:

    void _cpp_delete(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_delete(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool delete_async(const ::omero::grid::AMI_Table_deletePtr&);
    bool delete_async(const ::omero::grid::AMI_Table_deletePtr&, const ::Ice::Context&);

    void close()
    {
        close(0);
    }
    void close(const ::Ice::Context& __ctx)
    {
        close(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_close(const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_close(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_close(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_close(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_close(const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_close(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_close(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_close(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_close(const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::grid::TablePrx __proxy = ::omero::grid::TablePrx::uncheckedCast(__result->getProxy());
                try
                {
                    __proxy->end_close(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response();
                }
            }
        
        private:
            
            ::std::function<void ()> _response;
        };
        return begin_close(__ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_close()
    {
        return begin_close(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_close(const ::Ice::Context& __ctx)
    {
        return begin_close(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_close(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_close(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_close(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_close(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_close(const ::omero::grid::Callback_Table_closePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_close(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_close(const ::Ice::Context& __ctx, const ::omero::grid::Callback_Table_closePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_close(&__ctx, __del, __cookie);
    }

    void end_close(const ::Ice::AsyncResultPtr&);
    
private:

    void close(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_close(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool close_async(const ::omero::grid::AMI_Table_closePtr&);
    bool close_async(const ::omero::grid::AMI_Table_closePtr&, const ::Ice::Context&);
    
    ::IceInternal::ProxyHandle<Table> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<Table*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<Table> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<Table*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<Table> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<Table*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<Table> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<Table*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<Table> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<Table*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<Table> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<Table*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<Table> ice_secure(bool __secure) const
    {
        return dynamic_cast<Table*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<Table> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<Table*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<Table> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<Table*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<Table> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<Table*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<Table> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<Table*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<Table> ice_twoway() const
    {
        return dynamic_cast<Table*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<Table> ice_oneway() const
    {
        return dynamic_cast<Table*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<Table> ice_batchOneway() const
    {
        return dynamic_cast<Table*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<Table> ice_datagram() const
    {
        return dynamic_cast<Table*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<Table> ice_batchDatagram() const
    {
        return dynamic_cast<Table*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<Table> ice_compress(bool __compress) const
    {
        return dynamic_cast<Table*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<Table> ice_timeout(int __timeout) const
    {
        return dynamic_cast<Table*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<Table> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<Table*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<Table> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<Table*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class Tables : virtual public ::IceProxy::Ice::Object
{
public:

    ::omero::grid::RepositoryPrx getRepository()
    {
        return getRepository(0);
    }
    ::omero::grid::RepositoryPrx getRepository(const ::Ice::Context& __ctx)
    {
        return getRepository(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_getRepository(const ::IceInternal::Function<void (const ::omero::grid::RepositoryPrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getRepository(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getRepository(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getRepository(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_getRepository(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::omero::grid::RepositoryPrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getRepository(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getRepository(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getRepository(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_getRepository(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::omero::grid::RepositoryPrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::omero::grid::RepositoryPrx&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::grid::TablesPrx __proxy = ::omero::grid::TablesPrx::uncheckedCast(__result->getProxy());
                ::omero::grid::RepositoryPrx __ret;
                try
                {
                    __ret = __proxy->end_getRepository(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::omero::grid::RepositoryPrx&)> _response;
        };
        return begin_getRepository(__ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_getRepository()
    {
        return begin_getRepository(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getRepository(const ::Ice::Context& __ctx)
    {
        return begin_getRepository(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getRepository(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getRepository(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getRepository(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getRepository(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getRepository(const ::omero::grid::Callback_Tables_getRepositoryPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getRepository(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getRepository(const ::Ice::Context& __ctx, const ::omero::grid::Callback_Tables_getRepositoryPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getRepository(&__ctx, __del, __cookie);
    }

    ::omero::grid::RepositoryPrx end_getRepository(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::grid::RepositoryPrx getRepository(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getRepository(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool getRepository_async(const ::omero::grid::AMI_Tables_getRepositoryPtr&);
    bool getRepository_async(const ::omero::grid::AMI_Tables_getRepositoryPtr&, const ::Ice::Context&);

    ::omero::grid::TablePrx getTable(const ::omero::model::OriginalFilePtr& file, const ::omero::api::ServiceFactoryPrx& sf)
    {
        return getTable(file, sf, 0);
    }
    ::omero::grid::TablePrx getTable(const ::omero::model::OriginalFilePtr& file, const ::omero::api::ServiceFactoryPrx& sf, const ::Ice::Context& __ctx)
    {
        return getTable(file, sf, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_getTable(const ::omero::model::OriginalFilePtr& file, const ::omero::api::ServiceFactoryPrx& sf, const ::IceInternal::Function<void (const ::omero::grid::TablePrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getTable(file, sf, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getTable(const ::omero::model::OriginalFilePtr& file, const ::omero::api::ServiceFactoryPrx& sf, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getTable(file, sf, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_getTable(const ::omero::model::OriginalFilePtr& file, const ::omero::api::ServiceFactoryPrx& sf, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::omero::grid::TablePrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getTable(file, sf, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getTable(const ::omero::model::OriginalFilePtr& file, const ::omero::api::ServiceFactoryPrx& sf, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getTable(file, sf, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_getTable(const ::omero::model::OriginalFilePtr& file, const ::omero::api::ServiceFactoryPrx& sf, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::omero::grid::TablePrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::omero::grid::TablePrx&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::grid::TablesPrx __proxy = ::omero::grid::TablesPrx::uncheckedCast(__result->getProxy());
                ::omero::grid::TablePrx __ret;
                try
                {
                    __ret = __proxy->end_getTable(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::omero::grid::TablePrx&)> _response;
        };
        return begin_getTable(file, sf, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_getTable(const ::omero::model::OriginalFilePtr& file, const ::omero::api::ServiceFactoryPrx& sf)
    {
        return begin_getTable(file, sf, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getTable(const ::omero::model::OriginalFilePtr& file, const ::omero::api::ServiceFactoryPrx& sf, const ::Ice::Context& __ctx)
    {
        return begin_getTable(file, sf, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getTable(const ::omero::model::OriginalFilePtr& file, const ::omero::api::ServiceFactoryPrx& sf, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getTable(file, sf, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getTable(const ::omero::model::OriginalFilePtr& file, const ::omero::api::ServiceFactoryPrx& sf, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getTable(file, sf, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getTable(const ::omero::model::OriginalFilePtr& file, const ::omero::api::ServiceFactoryPrx& sf, const ::omero::grid::Callback_Tables_getTablePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getTable(file, sf, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getTable(const ::omero::model::OriginalFilePtr& file, const ::omero::api::ServiceFactoryPrx& sf, const ::Ice::Context& __ctx, const ::omero::grid::Callback_Tables_getTablePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getTable(file, sf, &__ctx, __del, __cookie);
    }

    ::omero::grid::TablePrx end_getTable(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::grid::TablePrx getTable(const ::omero::model::OriginalFilePtr&, const ::omero::api::ServiceFactoryPrx&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getTable(const ::omero::model::OriginalFilePtr&, const ::omero::api::ServiceFactoryPrx&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool getTable_async(const ::omero::grid::AMI_Tables_getTablePtr&, const ::omero::model::OriginalFilePtr&, const ::omero::api::ServiceFactoryPrx&);
    bool getTable_async(const ::omero::grid::AMI_Tables_getTablePtr&, const ::omero::model::OriginalFilePtr&, const ::omero::api::ServiceFactoryPrx&, const ::Ice::Context&);
    
    ::IceInternal::ProxyHandle<Tables> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<Tables*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<Tables> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<Tables*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<Tables> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<Tables*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<Tables> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<Tables*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<Tables> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<Tables*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<Tables> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<Tables*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<Tables> ice_secure(bool __secure) const
    {
        return dynamic_cast<Tables*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<Tables> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<Tables*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<Tables> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<Tables*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<Tables> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<Tables*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<Tables> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<Tables*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<Tables> ice_twoway() const
    {
        return dynamic_cast<Tables*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<Tables> ice_oneway() const
    {
        return dynamic_cast<Tables*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<Tables> ice_batchOneway() const
    {
        return dynamic_cast<Tables*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<Tables> ice_datagram() const
    {
        return dynamic_cast<Tables*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<Tables> ice_batchDatagram() const
    {
        return dynamic_cast<Tables*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<Tables> ice_compress(bool __compress) const
    {
        return dynamic_cast<Tables*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<Tables> ice_timeout(int __timeout) const
    {
        return dynamic_cast<Tables*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<Tables> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<Tables*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<Tables> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<Tables*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

}

}

}

namespace IceDelegate
{

namespace omero
{

namespace grid
{

class Column : virtual public ::IceDelegate::Ice::Object
{
public:
};

class FileColumn : virtual public ::IceDelegate::omero::grid::Column
{
public:
};

class ImageColumn : virtual public ::IceDelegate::omero::grid::Column
{
public:
};

class RoiColumn : virtual public ::IceDelegate::omero::grid::Column
{
public:
};

class WellColumn : virtual public ::IceDelegate::omero::grid::Column
{
public:
};

class PlateColumn : virtual public ::IceDelegate::omero::grid::Column
{
public:
};

class BoolColumn : virtual public ::IceDelegate::omero::grid::Column
{
public:
};

class DoubleColumn : virtual public ::IceDelegate::omero::grid::Column
{
public:
};

class LongColumn : virtual public ::IceDelegate::omero::grid::Column
{
public:
};

class StringColumn : virtual public ::IceDelegate::omero::grid::Column
{
public:
};

class FloatArrayColumn : virtual public ::IceDelegate::omero::grid::Column
{
public:
};

class DoubleArrayColumn : virtual public ::IceDelegate::omero::grid::Column
{
public:
};

class LongArrayColumn : virtual public ::IceDelegate::omero::grid::Column
{
public:
};

class MaskColumn : virtual public ::IceDelegate::omero::grid::Column
{
public:
};

class Data : virtual public ::IceDelegate::Ice::Object
{
public:
};

class Table : virtual public ::IceDelegate::Ice::Object
{
public:

    virtual ::omero::model::OriginalFilePtr getOriginalFile(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::omero::grid::ColumnArray getHeaders(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Ice::Long getNumberOfRows(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::omero::api::LongArray getWhereList(const ::std::string&, const ::omero::RTypeDict&, ::Ice::Long, ::Ice::Long, ::Ice::Long, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::omero::grid::DataPtr readCoordinates(const ::omero::api::LongArray&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::omero::grid::DataPtr read(const ::omero::api::LongArray&, ::Ice::Long, ::Ice::Long, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::omero::grid::DataPtr slice(const ::omero::api::LongArray&, const ::omero::api::LongArray&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual void addData(const ::omero::grid::ColumnArray&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual void update(const ::omero::grid::DataPtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::omero::RTypeDict getAllMetadata(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::omero::RTypePtr getMetadata(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual void setAllMetadata(const ::omero::RTypeDict&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual void setMetadata(const ::std::string&, const ::omero::RTypePtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual void initialize(const ::omero::grid::ColumnArray&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Ice::Int addColumn(const ::omero::grid::ColumnPtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual void _cpp_delete(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual void close(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;
};

class Tables : virtual public ::IceDelegate::Ice::Object
{
public:

    virtual ::omero::grid::RepositoryPrx getRepository(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::omero::grid::TablePrx getTable(const ::omero::model::OriginalFilePtr&, const ::omero::api::ServiceFactoryPrx&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;
};

}

}

}

namespace IceDelegateM
{

namespace omero
{

namespace grid
{

class Column : virtual public ::IceDelegate::omero::grid::Column,
               virtual public ::IceDelegateM::Ice::Object
{
public:
};

class FileColumn : virtual public ::IceDelegate::omero::grid::FileColumn,
                   virtual public ::IceDelegateM::omero::grid::Column
{
public:
};

class ImageColumn : virtual public ::IceDelegate::omero::grid::ImageColumn,
                    virtual public ::IceDelegateM::omero::grid::Column
{
public:
};

class RoiColumn : virtual public ::IceDelegate::omero::grid::RoiColumn,
                  virtual public ::IceDelegateM::omero::grid::Column
{
public:
};

class WellColumn : virtual public ::IceDelegate::omero::grid::WellColumn,
                   virtual public ::IceDelegateM::omero::grid::Column
{
public:
};

class PlateColumn : virtual public ::IceDelegate::omero::grid::PlateColumn,
                    virtual public ::IceDelegateM::omero::grid::Column
{
public:
};

class BoolColumn : virtual public ::IceDelegate::omero::grid::BoolColumn,
                   virtual public ::IceDelegateM::omero::grid::Column
{
public:
};

class DoubleColumn : virtual public ::IceDelegate::omero::grid::DoubleColumn,
                     virtual public ::IceDelegateM::omero::grid::Column
{
public:
};

class LongColumn : virtual public ::IceDelegate::omero::grid::LongColumn,
                   virtual public ::IceDelegateM::omero::grid::Column
{
public:
};

class StringColumn : virtual public ::IceDelegate::omero::grid::StringColumn,
                     virtual public ::IceDelegateM::omero::grid::Column
{
public:
};

class FloatArrayColumn : virtual public ::IceDelegate::omero::grid::FloatArrayColumn,
                         virtual public ::IceDelegateM::omero::grid::Column
{
public:
};

class DoubleArrayColumn : virtual public ::IceDelegate::omero::grid::DoubleArrayColumn,
                          virtual public ::IceDelegateM::omero::grid::Column
{
public:
};

class LongArrayColumn : virtual public ::IceDelegate::omero::grid::LongArrayColumn,
                        virtual public ::IceDelegateM::omero::grid::Column
{
public:
};

class MaskColumn : virtual public ::IceDelegate::omero::grid::MaskColumn,
                   virtual public ::IceDelegateM::omero::grid::Column
{
public:
};

class Data : virtual public ::IceDelegate::omero::grid::Data,
             virtual public ::IceDelegateM::Ice::Object
{
public:
};

class Table : virtual public ::IceDelegate::omero::grid::Table,
              virtual public ::IceDelegateM::Ice::Object
{
public:

    virtual ::omero::model::OriginalFilePtr getOriginalFile(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::grid::ColumnArray getHeaders(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Ice::Long getNumberOfRows(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::api::LongArray getWhereList(const ::std::string&, const ::omero::RTypeDict&, ::Ice::Long, ::Ice::Long, ::Ice::Long, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::grid::DataPtr readCoordinates(const ::omero::api::LongArray&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::grid::DataPtr read(const ::omero::api::LongArray&, ::Ice::Long, ::Ice::Long, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::grid::DataPtr slice(const ::omero::api::LongArray&, const ::omero::api::LongArray&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void addData(const ::omero::grid::ColumnArray&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void update(const ::omero::grid::DataPtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::RTypeDict getAllMetadata(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::RTypePtr getMetadata(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void setAllMetadata(const ::omero::RTypeDict&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void setMetadata(const ::std::string&, const ::omero::RTypePtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void initialize(const ::omero::grid::ColumnArray&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Ice::Int addColumn(const ::omero::grid::ColumnPtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void _cpp_delete(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void close(const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

class Tables : virtual public ::IceDelegate::omero::grid::Tables,
               virtual public ::IceDelegateM::Ice::Object
{
public:

    virtual ::omero::grid::RepositoryPrx getRepository(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::grid::TablePrx getTable(const ::omero::model::OriginalFilePtr&, const ::omero::api::ServiceFactoryPrx&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

}

}

}

namespace IceDelegateD
{

namespace omero
{

namespace grid
{

class Column : virtual public ::IceDelegate::omero::grid::Column,
               virtual public ::IceDelegateD::Ice::Object
{
public:
};

class FileColumn : virtual public ::IceDelegate::omero::grid::FileColumn,
                   virtual public ::IceDelegateD::omero::grid::Column
{
public:
};

class ImageColumn : virtual public ::IceDelegate::omero::grid::ImageColumn,
                    virtual public ::IceDelegateD::omero::grid::Column
{
public:
};

class RoiColumn : virtual public ::IceDelegate::omero::grid::RoiColumn,
                  virtual public ::IceDelegateD::omero::grid::Column
{
public:
};

class WellColumn : virtual public ::IceDelegate::omero::grid::WellColumn,
                   virtual public ::IceDelegateD::omero::grid::Column
{
public:
};

class PlateColumn : virtual public ::IceDelegate::omero::grid::PlateColumn,
                    virtual public ::IceDelegateD::omero::grid::Column
{
public:
};

class BoolColumn : virtual public ::IceDelegate::omero::grid::BoolColumn,
                   virtual public ::IceDelegateD::omero::grid::Column
{
public:
};

class DoubleColumn : virtual public ::IceDelegate::omero::grid::DoubleColumn,
                     virtual public ::IceDelegateD::omero::grid::Column
{
public:
};

class LongColumn : virtual public ::IceDelegate::omero::grid::LongColumn,
                   virtual public ::IceDelegateD::omero::grid::Column
{
public:
};

class StringColumn : virtual public ::IceDelegate::omero::grid::StringColumn,
                     virtual public ::IceDelegateD::omero::grid::Column
{
public:
};

class FloatArrayColumn : virtual public ::IceDelegate::omero::grid::FloatArrayColumn,
                         virtual public ::IceDelegateD::omero::grid::Column
{
public:
};

class DoubleArrayColumn : virtual public ::IceDelegate::omero::grid::DoubleArrayColumn,
                          virtual public ::IceDelegateD::omero::grid::Column
{
public:
};

class LongArrayColumn : virtual public ::IceDelegate::omero::grid::LongArrayColumn,
                        virtual public ::IceDelegateD::omero::grid::Column
{
public:
};

class MaskColumn : virtual public ::IceDelegate::omero::grid::MaskColumn,
                   virtual public ::IceDelegateD::omero::grid::Column
{
public:
};

class Data : virtual public ::IceDelegate::omero::grid::Data,
             virtual public ::IceDelegateD::Ice::Object
{
public:
};

class Table : virtual public ::IceDelegate::omero::grid::Table,
              virtual public ::IceDelegateD::Ice::Object
{
public:

    virtual ::omero::model::OriginalFilePtr getOriginalFile(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::grid::ColumnArray getHeaders(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Ice::Long getNumberOfRows(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::api::LongArray getWhereList(const ::std::string&, const ::omero::RTypeDict&, ::Ice::Long, ::Ice::Long, ::Ice::Long, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::grid::DataPtr readCoordinates(const ::omero::api::LongArray&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::grid::DataPtr read(const ::omero::api::LongArray&, ::Ice::Long, ::Ice::Long, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::grid::DataPtr slice(const ::omero::api::LongArray&, const ::omero::api::LongArray&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void addData(const ::omero::grid::ColumnArray&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void update(const ::omero::grid::DataPtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::RTypeDict getAllMetadata(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::RTypePtr getMetadata(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void setAllMetadata(const ::omero::RTypeDict&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void setMetadata(const ::std::string&, const ::omero::RTypePtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void initialize(const ::omero::grid::ColumnArray&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Ice::Int addColumn(const ::omero::grid::ColumnPtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void _cpp_delete(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void close(const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

class Tables : virtual public ::IceDelegate::omero::grid::Tables,
               virtual public ::IceDelegateD::Ice::Object
{
public:

    virtual ::omero::grid::RepositoryPrx getRepository(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::grid::TablePrx getTable(const ::omero::model::OriginalFilePtr&, const ::omero::api::ServiceFactoryPrx&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

}

}

}

namespace omero
{

namespace grid
{

class Column : virtual public ::Ice::Object
{
public:

    typedef ColumnPrx ProxyType;
    typedef ColumnPtr PointerType;

    Column()
    {
    }

    Column(const ::std::string& __ice_name, const ::std::string& __ice_description) :
        name(__ice_name),
        description(__ice_description)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();


    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif

public:

    ::std::string name;

    ::std::string description;

protected:

    virtual ~Column() {}

    friend class Column__staticInit;
};

class Column__staticInit
{
public:

    ::omero::grid::Column _init;
};

static Column__staticInit _Column_init;

inline bool operator==(const Column& l, const Column& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const Column& l, const Column& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class FileColumn : public ::omero::grid::Column
{
public:

    typedef FileColumnPrx ProxyType;
    typedef FileColumnPtr PointerType;

    FileColumn()
    {
    }

    FileColumn(const ::std::string& __ice_name, const ::std::string& __ice_description, const ::omero::api::LongArray& __ice_values) :
        ::omero::grid::Column(__ice_name, __ice_description)
        ,
        values(__ice_values)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();


    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::omero::grid::Column::__writeImpl;
    using ::omero::grid::Column::__readImpl;
    #endif

public:

    ::omero::api::LongArray values;

protected:

    virtual ~FileColumn() {}
};

inline bool operator==(const FileColumn& l, const FileColumn& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const FileColumn& l, const FileColumn& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class ImageColumn : public ::omero::grid::Column
{
public:

    typedef ImageColumnPrx ProxyType;
    typedef ImageColumnPtr PointerType;

    ImageColumn()
    {
    }

    ImageColumn(const ::std::string& __ice_name, const ::std::string& __ice_description, const ::omero::api::LongArray& __ice_values) :
        ::omero::grid::Column(__ice_name, __ice_description)
        ,
        values(__ice_values)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();


    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::omero::grid::Column::__writeImpl;
    using ::omero::grid::Column::__readImpl;
    #endif

public:

    ::omero::api::LongArray values;

protected:

    virtual ~ImageColumn() {}
};

inline bool operator==(const ImageColumn& l, const ImageColumn& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const ImageColumn& l, const ImageColumn& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class RoiColumn : public ::omero::grid::Column
{
public:

    typedef RoiColumnPrx ProxyType;
    typedef RoiColumnPtr PointerType;

    RoiColumn()
    {
    }

    RoiColumn(const ::std::string& __ice_name, const ::std::string& __ice_description, const ::omero::api::LongArray& __ice_values) :
        ::omero::grid::Column(__ice_name, __ice_description)
        ,
        values(__ice_values)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();


    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::omero::grid::Column::__writeImpl;
    using ::omero::grid::Column::__readImpl;
    #endif

public:

    ::omero::api::LongArray values;

protected:

    virtual ~RoiColumn() {}
};

inline bool operator==(const RoiColumn& l, const RoiColumn& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const RoiColumn& l, const RoiColumn& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class WellColumn : public ::omero::grid::Column
{
public:

    typedef WellColumnPrx ProxyType;
    typedef WellColumnPtr PointerType;

    WellColumn()
    {
    }

    WellColumn(const ::std::string& __ice_name, const ::std::string& __ice_description, const ::omero::api::LongArray& __ice_values) :
        ::omero::grid::Column(__ice_name, __ice_description)
        ,
        values(__ice_values)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();


    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::omero::grid::Column::__writeImpl;
    using ::omero::grid::Column::__readImpl;
    #endif

public:

    ::omero::api::LongArray values;

protected:

    virtual ~WellColumn() {}
};

inline bool operator==(const WellColumn& l, const WellColumn& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const WellColumn& l, const WellColumn& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class PlateColumn : public ::omero::grid::Column
{
public:

    typedef PlateColumnPrx ProxyType;
    typedef PlateColumnPtr PointerType;

    PlateColumn()
    {
    }

    PlateColumn(const ::std::string& __ice_name, const ::std::string& __ice_description, const ::omero::api::LongArray& __ice_values) :
        ::omero::grid::Column(__ice_name, __ice_description)
        ,
        values(__ice_values)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();


    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::omero::grid::Column::__writeImpl;
    using ::omero::grid::Column::__readImpl;
    #endif

public:

    ::omero::api::LongArray values;

protected:

    virtual ~PlateColumn() {}
};

inline bool operator==(const PlateColumn& l, const PlateColumn& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const PlateColumn& l, const PlateColumn& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class BoolColumn : public ::omero::grid::Column
{
public:

    typedef BoolColumnPrx ProxyType;
    typedef BoolColumnPtr PointerType;

    BoolColumn()
    {
    }

    BoolColumn(const ::std::string& __ice_name, const ::std::string& __ice_description, const ::omero::api::BoolArray& __ice_values) :
        ::omero::grid::Column(__ice_name, __ice_description)
        ,
        values(__ice_values)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();


    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::omero::grid::Column::__writeImpl;
    using ::omero::grid::Column::__readImpl;
    #endif

public:

    ::omero::api::BoolArray values;

protected:

    virtual ~BoolColumn() {}
};

inline bool operator==(const BoolColumn& l, const BoolColumn& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const BoolColumn& l, const BoolColumn& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class DoubleColumn : public ::omero::grid::Column
{
public:

    typedef DoubleColumnPrx ProxyType;
    typedef DoubleColumnPtr PointerType;

    DoubleColumn()
    {
    }

    DoubleColumn(const ::std::string& __ice_name, const ::std::string& __ice_description, const ::omero::api::DoubleArray& __ice_values) :
        ::omero::grid::Column(__ice_name, __ice_description)
        ,
        values(__ice_values)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();


    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::omero::grid::Column::__writeImpl;
    using ::omero::grid::Column::__readImpl;
    #endif

public:

    ::omero::api::DoubleArray values;

protected:

    virtual ~DoubleColumn() {}
};

inline bool operator==(const DoubleColumn& l, const DoubleColumn& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const DoubleColumn& l, const DoubleColumn& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class LongColumn : public ::omero::grid::Column
{
public:

    typedef LongColumnPrx ProxyType;
    typedef LongColumnPtr PointerType;

    LongColumn()
    {
    }

    LongColumn(const ::std::string& __ice_name, const ::std::string& __ice_description, const ::omero::api::LongArray& __ice_values) :
        ::omero::grid::Column(__ice_name, __ice_description)
        ,
        values(__ice_values)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();


    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::omero::grid::Column::__writeImpl;
    using ::omero::grid::Column::__readImpl;
    #endif

public:

    ::omero::api::LongArray values;

protected:

    virtual ~LongColumn() {}
};

inline bool operator==(const LongColumn& l, const LongColumn& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const LongColumn& l, const LongColumn& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class StringColumn : public ::omero::grid::Column
{
public:

    typedef StringColumnPrx ProxyType;
    typedef StringColumnPtr PointerType;

    StringColumn()
    {
    }

    StringColumn(const ::std::string& __ice_name, const ::std::string& __ice_description, ::Ice::Long __ice_size, const ::omero::api::StringArray& __ice_values) :
        ::omero::grid::Column(__ice_name, __ice_description)
        ,
        size(__ice_size),
        values(__ice_values)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();


    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::omero::grid::Column::__writeImpl;
    using ::omero::grid::Column::__readImpl;
    #endif

public:

    ::Ice::Long size;

    ::omero::api::StringArray values;

protected:

    virtual ~StringColumn() {}
};

inline bool operator==(const StringColumn& l, const StringColumn& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const StringColumn& l, const StringColumn& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class FloatArrayColumn : public ::omero::grid::Column
{
public:

    typedef FloatArrayColumnPrx ProxyType;
    typedef FloatArrayColumnPtr PointerType;

    FloatArrayColumn()
    {
    }

    FloatArrayColumn(const ::std::string& __ice_name, const ::std::string& __ice_description, ::Ice::Long __ice_size, const ::omero::api::FloatArrayArray& __ice_values) :
        ::omero::grid::Column(__ice_name, __ice_description)
        ,
        size(__ice_size),
        values(__ice_values)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();


    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::omero::grid::Column::__writeImpl;
    using ::omero::grid::Column::__readImpl;
    #endif

public:

    ::Ice::Long size;

    ::omero::api::FloatArrayArray values;

protected:

    virtual ~FloatArrayColumn() {}
};

inline bool operator==(const FloatArrayColumn& l, const FloatArrayColumn& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const FloatArrayColumn& l, const FloatArrayColumn& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class DoubleArrayColumn : public ::omero::grid::Column
{
public:

    typedef DoubleArrayColumnPrx ProxyType;
    typedef DoubleArrayColumnPtr PointerType;

    DoubleArrayColumn()
    {
    }

    DoubleArrayColumn(const ::std::string& __ice_name, const ::std::string& __ice_description, ::Ice::Long __ice_size, const ::omero::api::DoubleArrayArray& __ice_values) :
        ::omero::grid::Column(__ice_name, __ice_description)
        ,
        size(__ice_size),
        values(__ice_values)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();


    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::omero::grid::Column::__writeImpl;
    using ::omero::grid::Column::__readImpl;
    #endif

public:

    ::Ice::Long size;

    ::omero::api::DoubleArrayArray values;

protected:

    virtual ~DoubleArrayColumn() {}
};

inline bool operator==(const DoubleArrayColumn& l, const DoubleArrayColumn& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const DoubleArrayColumn& l, const DoubleArrayColumn& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class LongArrayColumn : public ::omero::grid::Column
{
public:

    typedef LongArrayColumnPrx ProxyType;
    typedef LongArrayColumnPtr PointerType;

    LongArrayColumn()
    {
    }

    LongArrayColumn(const ::std::string& __ice_name, const ::std::string& __ice_description, ::Ice::Long __ice_size, const ::omero::api::LongArrayArray& __ice_values) :
        ::omero::grid::Column(__ice_name, __ice_description)
        ,
        size(__ice_size),
        values(__ice_values)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();


    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::omero::grid::Column::__writeImpl;
    using ::omero::grid::Column::__readImpl;
    #endif

public:

    ::Ice::Long size;

    ::omero::api::LongArrayArray values;

protected:

    virtual ~LongArrayColumn() {}
};

inline bool operator==(const LongArrayColumn& l, const LongArrayColumn& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const LongArrayColumn& l, const LongArrayColumn& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class MaskColumn : public ::omero::grid::Column
{
public:

    typedef MaskColumnPrx ProxyType;
    typedef MaskColumnPtr PointerType;

    MaskColumn()
    {
    }

    MaskColumn(const ::std::string& __ice_name, const ::std::string& __ice_description, const ::omero::api::LongArray& __ice_imageId, const ::omero::api::IntegerArray& __ice_theZ, const ::omero::api::IntegerArray& __ice_theT, const ::omero::api::DoubleArray& __ice_x, const ::omero::api::DoubleArray& __ice_y, const ::omero::api::DoubleArray& __ice_w, const ::omero::api::DoubleArray& __ice_h, const ::omero::api::ByteArrayArray& __ice_bytes) :
        ::omero::grid::Column(__ice_name, __ice_description)
        ,
        imageId(__ice_imageId),
        theZ(__ice_theZ),
        theT(__ice_theT),
        x(__ice_x),
        y(__ice_y),
        w(__ice_w),
        h(__ice_h),
        bytes(__ice_bytes)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();


    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::omero::grid::Column::__writeImpl;
    using ::omero::grid::Column::__readImpl;
    #endif

public:

    ::omero::api::LongArray imageId;

    ::omero::api::IntegerArray theZ;

    ::omero::api::IntegerArray theT;

    ::omero::api::DoubleArray x;

    ::omero::api::DoubleArray y;

    ::omero::api::DoubleArray w;

    ::omero::api::DoubleArray h;

    ::omero::api::ByteArrayArray bytes;

protected:

    virtual ~MaskColumn() {}
};

inline bool operator==(const MaskColumn& l, const MaskColumn& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const MaskColumn& l, const MaskColumn& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class Data : virtual public ::Ice::Object, public IceInternal::GCShared
{
public:

    typedef DataPrx ProxyType;
    typedef DataPtr PointerType;

    Data()
    {
    }

    Data(::Ice::Long __ice_lastModification, const ::omero::api::LongArray& __ice_rowNumbers, const ::omero::grid::ColumnArray& __ice_columns) :
        lastModification(__ice_lastModification),
        rowNumbers(__ice_rowNumbers),
        columns(__ice_columns)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void __addObject(::IceInternal::GCCountMap&);
    virtual bool __usesGC();
    virtual void __gcReachable(::IceInternal::GCCountMap&) const;
    virtual void __gcClear();

    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif

public:

    ::Ice::Long lastModification;

    ::omero::api::LongArray rowNumbers;

    ::omero::grid::ColumnArray columns;

protected:

    virtual ~Data() {}
};

inline bool operator==(const Data& l, const Data& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const Data& l, const Data& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class Table : virtual public ::Ice::Object
{
public:

    typedef TablePrx ProxyType;
    typedef TablePtr PointerType;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual ::omero::model::OriginalFilePtr getOriginalFile(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getOriginalFile(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::grid::ColumnArray getHeaders(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getHeaders(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Long getNumberOfRows(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getNumberOfRows(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::api::LongArray getWhereList(const ::std::string&, const ::omero::RTypeDict&, ::Ice::Long, ::Ice::Long, ::Ice::Long, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getWhereList(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::grid::DataPtr readCoordinates(const ::omero::api::LongArray&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___readCoordinates(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::grid::DataPtr read(const ::omero::api::LongArray&, ::Ice::Long, ::Ice::Long, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___read(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::grid::DataPtr slice(const ::omero::api::LongArray&, const ::omero::api::LongArray&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___slice(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void addData(const ::omero::grid::ColumnArray&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___addData(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void update(const ::omero::grid::DataPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___update(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::RTypeDict getAllMetadata(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getAllMetadata(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::RTypePtr getMetadata(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getMetadata(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setAllMetadata(const ::omero::RTypeDict&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setAllMetadata(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setMetadata(const ::std::string&, const ::omero::RTypePtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setMetadata(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void initialize(const ::omero::grid::ColumnArray&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___initialize(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Int addColumn(const ::omero::grid::ColumnPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___addColumn(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void _cpp_delete(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___delete(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void close(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___close(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif
};

inline bool operator==(const Table& l, const Table& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const Table& l, const Table& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class Tables : virtual public ::Ice::Object
{
public:

    typedef TablesPrx ProxyType;
    typedef TablesPtr PointerType;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual ::omero::grid::RepositoryPrx getRepository(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getRepository(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::grid::TablePrx getTable(const ::omero::model::OriginalFilePtr&, const ::omero::api::ServiceFactoryPrx&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getTable(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif
};

inline bool operator==(const Tables& l, const Tables& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const Tables& l, const Tables& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

}

}

namespace omero
{

namespace grid
{

template<class T>
class CallbackNC_Table_getOriginalFile : public Callback_Table_getOriginalFile_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::model::OriginalFilePtr&);

    CallbackNC_Table_getOriginalFile(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::TablePrx __proxy = ::omero::grid::TablePrx::uncheckedCast(__result->getProxy());
        ::omero::model::OriginalFilePtr __ret;
        try
        {
            __ret = __proxy->end_getOriginalFile(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_Table_getOriginalFilePtr
newCallback_Table_getOriginalFile(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::OriginalFilePtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Table_getOriginalFile<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Table_getOriginalFilePtr
newCallback_Table_getOriginalFile(T* instance, void (T::*cb)(const ::omero::model::OriginalFilePtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Table_getOriginalFile<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Table_getOriginalFile : public Callback_Table_getOriginalFile_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::model::OriginalFilePtr&, const CT&);

    Callback_Table_getOriginalFile(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::TablePrx __proxy = ::omero::grid::TablePrx::uncheckedCast(__result->getProxy());
        ::omero::model::OriginalFilePtr __ret;
        try
        {
            __ret = __proxy->end_getOriginalFile(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Table_getOriginalFilePtr
newCallback_Table_getOriginalFile(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::OriginalFilePtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Table_getOriginalFile<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Table_getOriginalFilePtr
newCallback_Table_getOriginalFile(T* instance, void (T::*cb)(const ::omero::model::OriginalFilePtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Table_getOriginalFile<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Table_getHeaders : public Callback_Table_getHeaders_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::grid::ColumnArray&);

    CallbackNC_Table_getHeaders(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::TablePrx __proxy = ::omero::grid::TablePrx::uncheckedCast(__result->getProxy());
        ::omero::grid::ColumnArray __ret;
        try
        {
            __ret = __proxy->end_getHeaders(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_Table_getHeadersPtr
newCallback_Table_getHeaders(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::grid::ColumnArray&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Table_getHeaders<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Table_getHeadersPtr
newCallback_Table_getHeaders(T* instance, void (T::*cb)(const ::omero::grid::ColumnArray&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Table_getHeaders<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Table_getHeaders : public Callback_Table_getHeaders_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::grid::ColumnArray&, const CT&);

    Callback_Table_getHeaders(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::TablePrx __proxy = ::omero::grid::TablePrx::uncheckedCast(__result->getProxy());
        ::omero::grid::ColumnArray __ret;
        try
        {
            __ret = __proxy->end_getHeaders(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Table_getHeadersPtr
newCallback_Table_getHeaders(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::grid::ColumnArray&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Table_getHeaders<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Table_getHeadersPtr
newCallback_Table_getHeaders(T* instance, void (T::*cb)(const ::omero::grid::ColumnArray&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Table_getHeaders<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Table_getNumberOfRows : public Callback_Table_getNumberOfRows_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Long);

    CallbackNC_Table_getNumberOfRows(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::TablePrx __proxy = ::omero::grid::TablePrx::uncheckedCast(__result->getProxy());
        ::Ice::Long __ret;
        try
        {
            __ret = __proxy->end_getNumberOfRows(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_Table_getNumberOfRowsPtr
newCallback_Table_getNumberOfRows(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Long), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Table_getNumberOfRows<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Table_getNumberOfRowsPtr
newCallback_Table_getNumberOfRows(T* instance, void (T::*cb)(::Ice::Long), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Table_getNumberOfRows<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Table_getNumberOfRows : public Callback_Table_getNumberOfRows_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Long, const CT&);

    Callback_Table_getNumberOfRows(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::TablePrx __proxy = ::omero::grid::TablePrx::uncheckedCast(__result->getProxy());
        ::Ice::Long __ret;
        try
        {
            __ret = __proxy->end_getNumberOfRows(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Table_getNumberOfRowsPtr
newCallback_Table_getNumberOfRows(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Long, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Table_getNumberOfRows<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Table_getNumberOfRowsPtr
newCallback_Table_getNumberOfRows(T* instance, void (T::*cb)(::Ice::Long, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Table_getNumberOfRows<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Table_getWhereList : public Callback_Table_getWhereList_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::api::LongArray&);

    CallbackNC_Table_getWhereList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::TablePrx __proxy = ::omero::grid::TablePrx::uncheckedCast(__result->getProxy());
        ::omero::api::LongArray __ret;
        try
        {
            __ret = __proxy->end_getWhereList(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_Table_getWhereListPtr
newCallback_Table_getWhereList(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::LongArray&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Table_getWhereList<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Table_getWhereListPtr
newCallback_Table_getWhereList(T* instance, void (T::*cb)(const ::omero::api::LongArray&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Table_getWhereList<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Table_getWhereList : public Callback_Table_getWhereList_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::api::LongArray&, const CT&);

    Callback_Table_getWhereList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::TablePrx __proxy = ::omero::grid::TablePrx::uncheckedCast(__result->getProxy());
        ::omero::api::LongArray __ret;
        try
        {
            __ret = __proxy->end_getWhereList(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Table_getWhereListPtr
newCallback_Table_getWhereList(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::LongArray&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Table_getWhereList<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Table_getWhereListPtr
newCallback_Table_getWhereList(T* instance, void (T::*cb)(const ::omero::api::LongArray&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Table_getWhereList<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Table_readCoordinates : public Callback_Table_readCoordinates_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::grid::DataPtr&);

    CallbackNC_Table_readCoordinates(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::TablePrx __proxy = ::omero::grid::TablePrx::uncheckedCast(__result->getProxy());
        ::omero::grid::DataPtr __ret;
        try
        {
            __ret = __proxy->end_readCoordinates(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_Table_readCoordinatesPtr
newCallback_Table_readCoordinates(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::grid::DataPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Table_readCoordinates<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Table_readCoordinatesPtr
newCallback_Table_readCoordinates(T* instance, void (T::*cb)(const ::omero::grid::DataPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Table_readCoordinates<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Table_readCoordinates : public Callback_Table_readCoordinates_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::grid::DataPtr&, const CT&);

    Callback_Table_readCoordinates(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::TablePrx __proxy = ::omero::grid::TablePrx::uncheckedCast(__result->getProxy());
        ::omero::grid::DataPtr __ret;
        try
        {
            __ret = __proxy->end_readCoordinates(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Table_readCoordinatesPtr
newCallback_Table_readCoordinates(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::grid::DataPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Table_readCoordinates<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Table_readCoordinatesPtr
newCallback_Table_readCoordinates(T* instance, void (T::*cb)(const ::omero::grid::DataPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Table_readCoordinates<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Table_read : public Callback_Table_read_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::grid::DataPtr&);

    CallbackNC_Table_read(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::TablePrx __proxy = ::omero::grid::TablePrx::uncheckedCast(__result->getProxy());
        ::omero::grid::DataPtr __ret;
        try
        {
            __ret = __proxy->end_read(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_Table_readPtr
newCallback_Table_read(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::grid::DataPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Table_read<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Table_readPtr
newCallback_Table_read(T* instance, void (T::*cb)(const ::omero::grid::DataPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Table_read<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Table_read : public Callback_Table_read_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::grid::DataPtr&, const CT&);

    Callback_Table_read(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::TablePrx __proxy = ::omero::grid::TablePrx::uncheckedCast(__result->getProxy());
        ::omero::grid::DataPtr __ret;
        try
        {
            __ret = __proxy->end_read(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Table_readPtr
newCallback_Table_read(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::grid::DataPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Table_read<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Table_readPtr
newCallback_Table_read(T* instance, void (T::*cb)(const ::omero::grid::DataPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Table_read<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Table_slice : public Callback_Table_slice_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::grid::DataPtr&);

    CallbackNC_Table_slice(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::TablePrx __proxy = ::omero::grid::TablePrx::uncheckedCast(__result->getProxy());
        ::omero::grid::DataPtr __ret;
        try
        {
            __ret = __proxy->end_slice(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_Table_slicePtr
newCallback_Table_slice(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::grid::DataPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Table_slice<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Table_slicePtr
newCallback_Table_slice(T* instance, void (T::*cb)(const ::omero::grid::DataPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Table_slice<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Table_slice : public Callback_Table_slice_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::grid::DataPtr&, const CT&);

    Callback_Table_slice(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::TablePrx __proxy = ::omero::grid::TablePrx::uncheckedCast(__result->getProxy());
        ::omero::grid::DataPtr __ret;
        try
        {
            __ret = __proxy->end_slice(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Table_slicePtr
newCallback_Table_slice(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::grid::DataPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Table_slice<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Table_slicePtr
newCallback_Table_slice(T* instance, void (T::*cb)(const ::omero::grid::DataPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Table_slice<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Table_addData : public Callback_Table_addData_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Table_addData(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::TablePrx __proxy = ::omero::grid::TablePrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_addData(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
        }
    }

    Response response;
};

template<class T> Callback_Table_addDataPtr
newCallback_Table_addData(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Table_addData<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Table_addDataPtr
newCallback_Table_addData(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Table_addData<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Table_addDataPtr
newCallback_Table_addData(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Table_addData<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Table_addDataPtr
newCallback_Table_addData(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Table_addData<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Table_addData : public Callback_Table_addData_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Table_addData(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::TablePrx __proxy = ::omero::grid::TablePrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_addData(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Table_addDataPtr
newCallback_Table_addData(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Table_addData<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Table_addDataPtr
newCallback_Table_addData(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Table_addData<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Table_addDataPtr
newCallback_Table_addData(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Table_addData<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Table_addDataPtr
newCallback_Table_addData(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Table_addData<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Table_update : public Callback_Table_update_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Table_update(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::TablePrx __proxy = ::omero::grid::TablePrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_update(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
        }
    }

    Response response;
};

template<class T> Callback_Table_updatePtr
newCallback_Table_update(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Table_update<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Table_updatePtr
newCallback_Table_update(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Table_update<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Table_updatePtr
newCallback_Table_update(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Table_update<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Table_updatePtr
newCallback_Table_update(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Table_update<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Table_update : public Callback_Table_update_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Table_update(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::TablePrx __proxy = ::omero::grid::TablePrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_update(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Table_updatePtr
newCallback_Table_update(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Table_update<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Table_updatePtr
newCallback_Table_update(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Table_update<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Table_updatePtr
newCallback_Table_update(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Table_update<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Table_updatePtr
newCallback_Table_update(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Table_update<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Table_getAllMetadata : public Callback_Table_getAllMetadata_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::RTypeDict&);

    CallbackNC_Table_getAllMetadata(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::TablePrx __proxy = ::omero::grid::TablePrx::uncheckedCast(__result->getProxy());
        ::omero::RTypeDict __ret;
        try
        {
            __ret = __proxy->end_getAllMetadata(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_Table_getAllMetadataPtr
newCallback_Table_getAllMetadata(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RTypeDict&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Table_getAllMetadata<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Table_getAllMetadataPtr
newCallback_Table_getAllMetadata(T* instance, void (T::*cb)(const ::omero::RTypeDict&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Table_getAllMetadata<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Table_getAllMetadata : public Callback_Table_getAllMetadata_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::RTypeDict&, const CT&);

    Callback_Table_getAllMetadata(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::TablePrx __proxy = ::omero::grid::TablePrx::uncheckedCast(__result->getProxy());
        ::omero::RTypeDict __ret;
        try
        {
            __ret = __proxy->end_getAllMetadata(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Table_getAllMetadataPtr
newCallback_Table_getAllMetadata(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RTypeDict&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Table_getAllMetadata<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Table_getAllMetadataPtr
newCallback_Table_getAllMetadata(T* instance, void (T::*cb)(const ::omero::RTypeDict&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Table_getAllMetadata<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Table_getMetadata : public Callback_Table_getMetadata_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::RTypePtr&);

    CallbackNC_Table_getMetadata(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::TablePrx __proxy = ::omero::grid::TablePrx::uncheckedCast(__result->getProxy());
        ::omero::RTypePtr __ret;
        try
        {
            __ret = __proxy->end_getMetadata(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_Table_getMetadataPtr
newCallback_Table_getMetadata(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RTypePtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Table_getMetadata<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Table_getMetadataPtr
newCallback_Table_getMetadata(T* instance, void (T::*cb)(const ::omero::RTypePtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Table_getMetadata<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Table_getMetadata : public Callback_Table_getMetadata_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::RTypePtr&, const CT&);

    Callback_Table_getMetadata(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::TablePrx __proxy = ::omero::grid::TablePrx::uncheckedCast(__result->getProxy());
        ::omero::RTypePtr __ret;
        try
        {
            __ret = __proxy->end_getMetadata(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Table_getMetadataPtr
newCallback_Table_getMetadata(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RTypePtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Table_getMetadata<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Table_getMetadataPtr
newCallback_Table_getMetadata(T* instance, void (T::*cb)(const ::omero::RTypePtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Table_getMetadata<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Table_setAllMetadata : public Callback_Table_setAllMetadata_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Table_setAllMetadata(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::TablePrx __proxy = ::omero::grid::TablePrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_setAllMetadata(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
        }
    }

    Response response;
};

template<class T> Callback_Table_setAllMetadataPtr
newCallback_Table_setAllMetadata(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Table_setAllMetadata<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Table_setAllMetadataPtr
newCallback_Table_setAllMetadata(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Table_setAllMetadata<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Table_setAllMetadataPtr
newCallback_Table_setAllMetadata(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Table_setAllMetadata<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Table_setAllMetadataPtr
newCallback_Table_setAllMetadata(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Table_setAllMetadata<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Table_setAllMetadata : public Callback_Table_setAllMetadata_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Table_setAllMetadata(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::TablePrx __proxy = ::omero::grid::TablePrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_setAllMetadata(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Table_setAllMetadataPtr
newCallback_Table_setAllMetadata(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Table_setAllMetadata<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Table_setAllMetadataPtr
newCallback_Table_setAllMetadata(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Table_setAllMetadata<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Table_setAllMetadataPtr
newCallback_Table_setAllMetadata(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Table_setAllMetadata<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Table_setAllMetadataPtr
newCallback_Table_setAllMetadata(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Table_setAllMetadata<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Table_setMetadata : public Callback_Table_setMetadata_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Table_setMetadata(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::TablePrx __proxy = ::omero::grid::TablePrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_setMetadata(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
        }
    }

    Response response;
};

template<class T> Callback_Table_setMetadataPtr
newCallback_Table_setMetadata(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Table_setMetadata<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Table_setMetadataPtr
newCallback_Table_setMetadata(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Table_setMetadata<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Table_setMetadataPtr
newCallback_Table_setMetadata(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Table_setMetadata<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Table_setMetadataPtr
newCallback_Table_setMetadata(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Table_setMetadata<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Table_setMetadata : public Callback_Table_setMetadata_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Table_setMetadata(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::TablePrx __proxy = ::omero::grid::TablePrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_setMetadata(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Table_setMetadataPtr
newCallback_Table_setMetadata(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Table_setMetadata<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Table_setMetadataPtr
newCallback_Table_setMetadata(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Table_setMetadata<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Table_setMetadataPtr
newCallback_Table_setMetadata(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Table_setMetadata<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Table_setMetadataPtr
newCallback_Table_setMetadata(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Table_setMetadata<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Table_initialize : public Callback_Table_initialize_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Table_initialize(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::TablePrx __proxy = ::omero::grid::TablePrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_initialize(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
        }
    }

    Response response;
};

template<class T> Callback_Table_initializePtr
newCallback_Table_initialize(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Table_initialize<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Table_initializePtr
newCallback_Table_initialize(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Table_initialize<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Table_initializePtr
newCallback_Table_initialize(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Table_initialize<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Table_initializePtr
newCallback_Table_initialize(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Table_initialize<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Table_initialize : public Callback_Table_initialize_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Table_initialize(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::TablePrx __proxy = ::omero::grid::TablePrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_initialize(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Table_initializePtr
newCallback_Table_initialize(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Table_initialize<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Table_initializePtr
newCallback_Table_initialize(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Table_initialize<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Table_initializePtr
newCallback_Table_initialize(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Table_initialize<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Table_initializePtr
newCallback_Table_initialize(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Table_initialize<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Table_addColumn : public Callback_Table_addColumn_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int);

    CallbackNC_Table_addColumn(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::TablePrx __proxy = ::omero::grid::TablePrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_addColumn(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_Table_addColumnPtr
newCallback_Table_addColumn(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Table_addColumn<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Table_addColumnPtr
newCallback_Table_addColumn(T* instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Table_addColumn<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Table_addColumn : public Callback_Table_addColumn_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const CT&);

    Callback_Table_addColumn(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::TablePrx __proxy = ::omero::grid::TablePrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_addColumn(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Table_addColumnPtr
newCallback_Table_addColumn(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Table_addColumn<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Table_addColumnPtr
newCallback_Table_addColumn(T* instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Table_addColumn<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Table_delete : public Callback_Table_delete_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Table_delete(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::TablePrx __proxy = ::omero::grid::TablePrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_delete(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
        }
    }

    Response response;
};

template<class T> Callback_Table_deletePtr
newCallback_Table_delete(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Table_delete<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Table_deletePtr
newCallback_Table_delete(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Table_delete<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Table_deletePtr
newCallback_Table_delete(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Table_delete<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Table_deletePtr
newCallback_Table_delete(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Table_delete<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Table_delete : public Callback_Table_delete_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Table_delete(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::TablePrx __proxy = ::omero::grid::TablePrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_delete(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Table_deletePtr
newCallback_Table_delete(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Table_delete<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Table_deletePtr
newCallback_Table_delete(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Table_delete<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Table_deletePtr
newCallback_Table_delete(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Table_delete<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Table_deletePtr
newCallback_Table_delete(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Table_delete<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Table_close : public Callback_Table_close_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Table_close(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::TablePrx __proxy = ::omero::grid::TablePrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_close(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
        }
    }

    Response response;
};

template<class T> Callback_Table_closePtr
newCallback_Table_close(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Table_close<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Table_closePtr
newCallback_Table_close(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Table_close<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Table_closePtr
newCallback_Table_close(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Table_close<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Table_closePtr
newCallback_Table_close(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Table_close<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Table_close : public Callback_Table_close_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Table_close(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::TablePrx __proxy = ::omero::grid::TablePrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_close(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Table_closePtr
newCallback_Table_close(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Table_close<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Table_closePtr
newCallback_Table_close(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Table_close<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Table_closePtr
newCallback_Table_close(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Table_close<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Table_closePtr
newCallback_Table_close(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Table_close<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Tables_getRepository : public Callback_Tables_getRepository_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::grid::RepositoryPrx&);

    CallbackNC_Tables_getRepository(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::TablesPrx __proxy = ::omero::grid::TablesPrx::uncheckedCast(__result->getProxy());
        ::omero::grid::RepositoryPrx __ret;
        try
        {
            __ret = __proxy->end_getRepository(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_Tables_getRepositoryPtr
newCallback_Tables_getRepository(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::grid::RepositoryPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Tables_getRepository<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Tables_getRepositoryPtr
newCallback_Tables_getRepository(T* instance, void (T::*cb)(const ::omero::grid::RepositoryPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Tables_getRepository<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Tables_getRepository : public Callback_Tables_getRepository_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::grid::RepositoryPrx&, const CT&);

    Callback_Tables_getRepository(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::TablesPrx __proxy = ::omero::grid::TablesPrx::uncheckedCast(__result->getProxy());
        ::omero::grid::RepositoryPrx __ret;
        try
        {
            __ret = __proxy->end_getRepository(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Tables_getRepositoryPtr
newCallback_Tables_getRepository(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::grid::RepositoryPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Tables_getRepository<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Tables_getRepositoryPtr
newCallback_Tables_getRepository(T* instance, void (T::*cb)(const ::omero::grid::RepositoryPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Tables_getRepository<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Tables_getTable : public Callback_Tables_getTable_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::grid::TablePrx&);

    CallbackNC_Tables_getTable(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::TablesPrx __proxy = ::omero::grid::TablesPrx::uncheckedCast(__result->getProxy());
        ::omero::grid::TablePrx __ret;
        try
        {
            __ret = __proxy->end_getTable(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_Tables_getTablePtr
newCallback_Tables_getTable(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::grid::TablePrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Tables_getTable<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Tables_getTablePtr
newCallback_Tables_getTable(T* instance, void (T::*cb)(const ::omero::grid::TablePrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Tables_getTable<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Tables_getTable : public Callback_Tables_getTable_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::grid::TablePrx&, const CT&);

    Callback_Tables_getTable(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::grid::TablesPrx __proxy = ::omero::grid::TablesPrx::uncheckedCast(__result->getProxy());
        ::omero::grid::TablePrx __ret;
        try
        {
            __ret = __proxy->end_getTable(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Tables_getTablePtr
newCallback_Tables_getTable(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::grid::TablePrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Tables_getTable<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Tables_getTablePtr
newCallback_Tables_getTable(T* instance, void (T::*cb)(const ::omero::grid::TablePrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Tables_getTable<T, CT>(instance, cb, excb, sentcb);
}

}

}

#endif
