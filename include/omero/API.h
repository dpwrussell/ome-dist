// **********************************************************************
//
// Copyright (c) 2003-2011 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.4.2
//
// <auto-generated>
//
// Generated from file `API.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __omero__opt_hudson_workspace_OMERO_5_0_release_src_components_blitz_generated_omero_API_h__
#define __omero__opt_hudson_workspace_OMERO_5_0_release_src_components_blitz_generated_omero_API_h__

#include <Ice/LocalObjectF.h>
#include <Ice/ProxyF.h>
#include <Ice/ObjectF.h>
#include <Ice/Exception.h>
#include <Ice/LocalObject.h>
#include <Ice/Proxy.h>
#include <Ice/Object.h>
#include <Ice/Outgoing.h>
#include <Ice/OutgoingAsync.h>
#include <Ice/Incoming.h>
#include <Ice/IncomingAsync.h>
#include <Ice/Direct.h>
#include <Ice/FactoryTableInit.h>
#include <IceUtil/ScopedArray.h>
#include <Ice/StreamF.h>
#include <omero/cmd/API.h>
#include <omero/ServerErrors.h>
#include <omero/ModelF.h>
#include <omero/ServicesF.h>
#include <omero/System.h>
#include <omero/Collections.h>
#include <Glacier2/Session.h>
#include <Ice/BuiltinSequences.h>
#include <Ice/Identity.h>
#include <Ice/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 304
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 > 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 2
#       error Ice patch level mismatch!
#   endif
#endif

namespace IceProxy
{

namespace omero
{

namespace api
{

class ClientCallback;

class ServiceFactory;

}

}

}

namespace omero
{

namespace api
{

class ClientCallback;
bool operator==(const ClientCallback&, const ClientCallback&);
bool operator<(const ClientCallback&, const ClientCallback&);

class ServiceFactory;
bool operator==(const ServiceFactory&, const ServiceFactory&);
bool operator<(const ServiceFactory&, const ServiceFactory&);

}

}

namespace IceInternal
{

::Ice::Object* upCast(::omero::api::ClientCallback*);
::IceProxy::Ice::Object* upCast(::IceProxy::omero::api::ClientCallback*);

::Ice::Object* upCast(::omero::api::ServiceFactory*);
::IceProxy::Ice::Object* upCast(::IceProxy::omero::api::ServiceFactory*);

}

namespace omero
{

namespace api
{

typedef ::IceInternal::Handle< ::omero::api::ClientCallback> ClientCallbackPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::omero::api::ClientCallback> ClientCallbackPrx;

void __read(::IceInternal::BasicStream*, ClientCallbackPrx&);
void __patch__ClientCallbackPtr(void*, ::Ice::ObjectPtr&);

typedef ::IceInternal::Handle< ::omero::api::ServiceFactory> ServiceFactoryPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::omero::api::ServiceFactory> ServiceFactoryPrx;

void __read(::IceInternal::BasicStream*, ServiceFactoryPrx&);
void __patch__ServiceFactoryPtr(void*, ::Ice::ObjectPtr&);

}

}

namespace omero
{

namespace api
{

class AMI_ClientCallback_requestHeartbeat : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response() = 0;

    void __response()
    {
        ice_response();
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        AMICallbackBase::__sent(sentSynchronously);
#else
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
#endif
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_ClientCallback_requestHeartbeat> AMI_ClientCallback_requestHeartbeatPtr;

class AMI_ClientCallback_sessionClosed : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response() = 0;

    void __response()
    {
        ice_response();
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        AMICallbackBase::__sent(sentSynchronously);
#else
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
#endif
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_ClientCallback_sessionClosed> AMI_ClientCallback_sessionClosedPtr;

class AMI_ClientCallback_shutdownIn : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response() = 0;

    void __response()
    {
        ice_response();
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        AMICallbackBase::__sent(sentSynchronously);
#else
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
#endif
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_ClientCallback_shutdownIn> AMI_ClientCallback_shutdownInPtr;

}

}

namespace IceAsync
{

}

namespace omero
{

namespace api
{

class Callback_ClientCallback_requestHeartbeat_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ClientCallback_requestHeartbeat_Base> Callback_ClientCallback_requestHeartbeatPtr;

class Callback_ClientCallback_sessionClosed_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ClientCallback_sessionClosed_Base> Callback_ClientCallback_sessionClosedPtr;

class Callback_ClientCallback_shutdownIn_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ClientCallback_shutdownIn_Base> Callback_ClientCallback_shutdownInPtr;

class Callback_ServiceFactory_getSecurityContexts_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ServiceFactory_getSecurityContexts_Base> Callback_ServiceFactory_getSecurityContextsPtr;

class Callback_ServiceFactory_setSecurityContext_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ServiceFactory_setSecurityContext_Base> Callback_ServiceFactory_setSecurityContextPtr;

class Callback_ServiceFactory_setSecurityPassword_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ServiceFactory_setSecurityPassword_Base> Callback_ServiceFactory_setSecurityPasswordPtr;

class Callback_ServiceFactory_getAdminService_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ServiceFactory_getAdminService_Base> Callback_ServiceFactory_getAdminServicePtr;

class Callback_ServiceFactory_getConfigService_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ServiceFactory_getConfigService_Base> Callback_ServiceFactory_getConfigServicePtr;

class Callback_ServiceFactory_getContainerService_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ServiceFactory_getContainerService_Base> Callback_ServiceFactory_getContainerServicePtr;

class Callback_ServiceFactory_getDeleteService_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ServiceFactory_getDeleteService_Base> Callback_ServiceFactory_getDeleteServicePtr;

class Callback_ServiceFactory_getLdapService_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ServiceFactory_getLdapService_Base> Callback_ServiceFactory_getLdapServicePtr;

class Callback_ServiceFactory_getPixelsService_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ServiceFactory_getPixelsService_Base> Callback_ServiceFactory_getPixelsServicePtr;

class Callback_ServiceFactory_getProjectionService_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ServiceFactory_getProjectionService_Base> Callback_ServiceFactory_getProjectionServicePtr;

class Callback_ServiceFactory_getQueryService_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ServiceFactory_getQueryService_Base> Callback_ServiceFactory_getQueryServicePtr;

class Callback_ServiceFactory_getRenderingSettingsService_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ServiceFactory_getRenderingSettingsService_Base> Callback_ServiceFactory_getRenderingSettingsServicePtr;

class Callback_ServiceFactory_getRepositoryInfoService_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ServiceFactory_getRepositoryInfoService_Base> Callback_ServiceFactory_getRepositoryInfoServicePtr;

class Callback_ServiceFactory_getRoiService_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ServiceFactory_getRoiService_Base> Callback_ServiceFactory_getRoiServicePtr;

class Callback_ServiceFactory_getScriptService_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ServiceFactory_getScriptService_Base> Callback_ServiceFactory_getScriptServicePtr;

class Callback_ServiceFactory_getSessionService_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ServiceFactory_getSessionService_Base> Callback_ServiceFactory_getSessionServicePtr;

class Callback_ServiceFactory_getShareService_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ServiceFactory_getShareService_Base> Callback_ServiceFactory_getShareServicePtr;

class Callback_ServiceFactory_getTimelineService_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ServiceFactory_getTimelineService_Base> Callback_ServiceFactory_getTimelineServicePtr;

class Callback_ServiceFactory_getTypesService_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ServiceFactory_getTypesService_Base> Callback_ServiceFactory_getTypesServicePtr;

class Callback_ServiceFactory_getUpdateService_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ServiceFactory_getUpdateService_Base> Callback_ServiceFactory_getUpdateServicePtr;

class Callback_ServiceFactory_getMetadataService_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ServiceFactory_getMetadataService_Base> Callback_ServiceFactory_getMetadataServicePtr;

class Callback_ServiceFactory_createGateway_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ServiceFactory_createGateway_Base> Callback_ServiceFactory_createGatewayPtr;

class Callback_ServiceFactory_createExporter_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ServiceFactory_createExporter_Base> Callback_ServiceFactory_createExporterPtr;

class Callback_ServiceFactory_createJobHandle_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ServiceFactory_createJobHandle_Base> Callback_ServiceFactory_createJobHandlePtr;

class Callback_ServiceFactory_createRawFileStore_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ServiceFactory_createRawFileStore_Base> Callback_ServiceFactory_createRawFileStorePtr;

class Callback_ServiceFactory_createRawPixelsStore_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ServiceFactory_createRawPixelsStore_Base> Callback_ServiceFactory_createRawPixelsStorePtr;

class Callback_ServiceFactory_createRenderingEngine_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ServiceFactory_createRenderingEngine_Base> Callback_ServiceFactory_createRenderingEnginePtr;

class Callback_ServiceFactory_createSearchService_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ServiceFactory_createSearchService_Base> Callback_ServiceFactory_createSearchServicePtr;

class Callback_ServiceFactory_createThumbnailStore_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ServiceFactory_createThumbnailStore_Base> Callback_ServiceFactory_createThumbnailStorePtr;

class Callback_ServiceFactory_sharedResources_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ServiceFactory_sharedResources_Base> Callback_ServiceFactory_sharedResourcesPtr;

class Callback_ServiceFactory_getByName_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ServiceFactory_getByName_Base> Callback_ServiceFactory_getByNamePtr;

class Callback_ServiceFactory_createByName_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ServiceFactory_createByName_Base> Callback_ServiceFactory_createByNamePtr;

class Callback_ServiceFactory_subscribe_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ServiceFactory_subscribe_Base> Callback_ServiceFactory_subscribePtr;

class Callback_ServiceFactory_setCallback_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ServiceFactory_setCallback_Base> Callback_ServiceFactory_setCallbackPtr;

class Callback_ServiceFactory_close_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ServiceFactory_close_Base> Callback_ServiceFactory_closePtr;

class Callback_ServiceFactory_closeOnDestroy_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ServiceFactory_closeOnDestroy_Base> Callback_ServiceFactory_closeOnDestroyPtr;

class Callback_ServiceFactory_detachOnDestroy_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ServiceFactory_detachOnDestroy_Base> Callback_ServiceFactory_detachOnDestroyPtr;

class Callback_ServiceFactory_activeServices_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ServiceFactory_activeServices_Base> Callback_ServiceFactory_activeServicesPtr;

class Callback_ServiceFactory_keepAllAlive_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ServiceFactory_keepAllAlive_Base> Callback_ServiceFactory_keepAllAlivePtr;

class Callback_ServiceFactory_keepAlive_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ServiceFactory_keepAlive_Base> Callback_ServiceFactory_keepAlivePtr;

}

}

namespace IceProxy
{

namespace omero
{

namespace api
{

class ClientCallback : virtual public ::IceProxy::Ice::Object
{
public:

    void requestHeartbeat()
    {
        requestHeartbeat(0);
    }
    void requestHeartbeat(const ::Ice::Context& __ctx)
    {
        requestHeartbeat(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_requestHeartbeat()
    {
        return begin_requestHeartbeat(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_requestHeartbeat(const ::Ice::Context& __ctx)
    {
        return begin_requestHeartbeat(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_requestHeartbeat(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_requestHeartbeat(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_requestHeartbeat(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_requestHeartbeat(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_requestHeartbeat(const ::omero::api::Callback_ClientCallback_requestHeartbeatPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_requestHeartbeat(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_requestHeartbeat(const ::Ice::Context& __ctx, const ::omero::api::Callback_ClientCallback_requestHeartbeatPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_requestHeartbeat(&__ctx, __del, __cookie);
    }

    void end_requestHeartbeat(const ::Ice::AsyncResultPtr&);
    
private:

    void requestHeartbeat(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_requestHeartbeat(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool requestHeartbeat_async(const ::omero::api::AMI_ClientCallback_requestHeartbeatPtr&);
    bool requestHeartbeat_async(const ::omero::api::AMI_ClientCallback_requestHeartbeatPtr&, const ::Ice::Context&);

    void sessionClosed()
    {
        sessionClosed(0);
    }
    void sessionClosed(const ::Ice::Context& __ctx)
    {
        sessionClosed(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_sessionClosed()
    {
        return begin_sessionClosed(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_sessionClosed(const ::Ice::Context& __ctx)
    {
        return begin_sessionClosed(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_sessionClosed(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_sessionClosed(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_sessionClosed(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_sessionClosed(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_sessionClosed(const ::omero::api::Callback_ClientCallback_sessionClosedPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_sessionClosed(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_sessionClosed(const ::Ice::Context& __ctx, const ::omero::api::Callback_ClientCallback_sessionClosedPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_sessionClosed(&__ctx, __del, __cookie);
    }

    void end_sessionClosed(const ::Ice::AsyncResultPtr&);
    
private:

    void sessionClosed(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_sessionClosed(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool sessionClosed_async(const ::omero::api::AMI_ClientCallback_sessionClosedPtr&);
    bool sessionClosed_async(const ::omero::api::AMI_ClientCallback_sessionClosedPtr&, const ::Ice::Context&);

    void shutdownIn(::Ice::Long milliseconds)
    {
        shutdownIn(milliseconds, 0);
    }
    void shutdownIn(::Ice::Long milliseconds, const ::Ice::Context& __ctx)
    {
        shutdownIn(milliseconds, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_shutdownIn(::Ice::Long milliseconds)
    {
        return begin_shutdownIn(milliseconds, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_shutdownIn(::Ice::Long milliseconds, const ::Ice::Context& __ctx)
    {
        return begin_shutdownIn(milliseconds, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_shutdownIn(::Ice::Long milliseconds, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_shutdownIn(milliseconds, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_shutdownIn(::Ice::Long milliseconds, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_shutdownIn(milliseconds, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_shutdownIn(::Ice::Long milliseconds, const ::omero::api::Callback_ClientCallback_shutdownInPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_shutdownIn(milliseconds, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_shutdownIn(::Ice::Long milliseconds, const ::Ice::Context& __ctx, const ::omero::api::Callback_ClientCallback_shutdownInPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_shutdownIn(milliseconds, &__ctx, __del, __cookie);
    }

    void end_shutdownIn(const ::Ice::AsyncResultPtr&);
    
private:

    void shutdownIn(::Ice::Long, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_shutdownIn(::Ice::Long, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool shutdownIn_async(const ::omero::api::AMI_ClientCallback_shutdownInPtr&, ::Ice::Long);
    bool shutdownIn_async(const ::omero::api::AMI_ClientCallback_shutdownInPtr&, ::Ice::Long, const ::Ice::Context&);
    
    ::IceInternal::ProxyHandle<ClientCallback> ice_context(const ::Ice::Context& __context) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ClientCallback*>(_Base::ice_context(__context).get());
    #else
        return dynamic_cast<ClientCallback*>(::IceProxy::Ice::Object::ice_context(__context).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ClientCallback> ice_adapterId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ClientCallback*>(_Base::ice_adapterId(__id).get());
    #else
        return dynamic_cast<ClientCallback*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ClientCallback> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ClientCallback*>(_Base::ice_endpoints(__endpoints).get());
    #else
        return dynamic_cast<ClientCallback*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ClientCallback> ice_locatorCacheTimeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ClientCallback*>(_Base::ice_locatorCacheTimeout(__timeout).get());
    #else
        return dynamic_cast<ClientCallback*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ClientCallback> ice_connectionCached(bool __cached) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ClientCallback*>(_Base::ice_connectionCached(__cached).get());
    #else
        return dynamic_cast<ClientCallback*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ClientCallback> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ClientCallback*>(_Base::ice_endpointSelection(__est).get());
    #else
        return dynamic_cast<ClientCallback*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ClientCallback> ice_secure(bool __secure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ClientCallback*>(_Base::ice_secure(__secure).get());
    #else
        return dynamic_cast<ClientCallback*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ClientCallback> ice_preferSecure(bool __preferSecure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ClientCallback*>(_Base::ice_preferSecure(__preferSecure).get());
    #else
        return dynamic_cast<ClientCallback*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ClientCallback> ice_router(const ::Ice::RouterPrx& __router) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ClientCallback*>(_Base::ice_router(__router).get());
    #else
        return dynamic_cast<ClientCallback*>(::IceProxy::Ice::Object::ice_router(__router).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ClientCallback> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ClientCallback*>(_Base::ice_locator(__locator).get());
    #else
        return dynamic_cast<ClientCallback*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ClientCallback> ice_collocationOptimized(bool __co) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ClientCallback*>(_Base::ice_collocationOptimized(__co).get());
    #else
        return dynamic_cast<ClientCallback*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ClientCallback> ice_twoway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ClientCallback*>(_Base::ice_twoway().get());
    #else
        return dynamic_cast<ClientCallback*>(::IceProxy::Ice::Object::ice_twoway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ClientCallback> ice_oneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ClientCallback*>(_Base::ice_oneway().get());
    #else
        return dynamic_cast<ClientCallback*>(::IceProxy::Ice::Object::ice_oneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ClientCallback> ice_batchOneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ClientCallback*>(_Base::ice_batchOneway().get());
    #else
        return dynamic_cast<ClientCallback*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ClientCallback> ice_datagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ClientCallback*>(_Base::ice_datagram().get());
    #else
        return dynamic_cast<ClientCallback*>(::IceProxy::Ice::Object::ice_datagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ClientCallback> ice_batchDatagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ClientCallback*>(_Base::ice_batchDatagram().get());
    #else
        return dynamic_cast<ClientCallback*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ClientCallback> ice_compress(bool __compress) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ClientCallback*>(_Base::ice_compress(__compress).get());
    #else
        return dynamic_cast<ClientCallback*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ClientCallback> ice_timeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ClientCallback*>(_Base::ice_timeout(__timeout).get());
    #else
        return dynamic_cast<ClientCallback*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ClientCallback> ice_connectionId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ClientCallback*>(_Base::ice_connectionId(__id).get());
    #else
        return dynamic_cast<ClientCallback*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    #endif
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class ServiceFactory : virtual public ::IceProxy::omero::cmd::Session
{
public:

    ::omero::api::IObjectList getSecurityContexts()
    {
        return getSecurityContexts(0);
    }
    ::omero::api::IObjectList getSecurityContexts(const ::Ice::Context& __ctx)
    {
        return getSecurityContexts(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getSecurityContexts()
    {
        return begin_getSecurityContexts(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getSecurityContexts(const ::Ice::Context& __ctx)
    {
        return begin_getSecurityContexts(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getSecurityContexts(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getSecurityContexts(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getSecurityContexts(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getSecurityContexts(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getSecurityContexts(const ::omero::api::Callback_ServiceFactory_getSecurityContextsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getSecurityContexts(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getSecurityContexts(const ::Ice::Context& __ctx, const ::omero::api::Callback_ServiceFactory_getSecurityContextsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getSecurityContexts(&__ctx, __del, __cookie);
    }

    ::omero::api::IObjectList end_getSecurityContexts(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::api::IObjectList getSecurityContexts(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getSecurityContexts(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::model::IObjectPtr setSecurityContext(const ::omero::model::IObjectPtr& obj)
    {
        return setSecurityContext(obj, 0);
    }
    ::omero::model::IObjectPtr setSecurityContext(const ::omero::model::IObjectPtr& obj, const ::Ice::Context& __ctx)
    {
        return setSecurityContext(obj, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setSecurityContext(const ::omero::model::IObjectPtr& obj)
    {
        return begin_setSecurityContext(obj, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setSecurityContext(const ::omero::model::IObjectPtr& obj, const ::Ice::Context& __ctx)
    {
        return begin_setSecurityContext(obj, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setSecurityContext(const ::omero::model::IObjectPtr& obj, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setSecurityContext(obj, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setSecurityContext(const ::omero::model::IObjectPtr& obj, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setSecurityContext(obj, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setSecurityContext(const ::omero::model::IObjectPtr& obj, const ::omero::api::Callback_ServiceFactory_setSecurityContextPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setSecurityContext(obj, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setSecurityContext(const ::omero::model::IObjectPtr& obj, const ::Ice::Context& __ctx, const ::omero::api::Callback_ServiceFactory_setSecurityContextPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setSecurityContext(obj, &__ctx, __del, __cookie);
    }

    ::omero::model::IObjectPtr end_setSecurityContext(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::model::IObjectPtr setSecurityContext(const ::omero::model::IObjectPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setSecurityContext(const ::omero::model::IObjectPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setSecurityPassword(const ::std::string& password)
    {
        setSecurityPassword(password, 0);
    }
    void setSecurityPassword(const ::std::string& password, const ::Ice::Context& __ctx)
    {
        setSecurityPassword(password, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setSecurityPassword(const ::std::string& password)
    {
        return begin_setSecurityPassword(password, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setSecurityPassword(const ::std::string& password, const ::Ice::Context& __ctx)
    {
        return begin_setSecurityPassword(password, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setSecurityPassword(const ::std::string& password, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setSecurityPassword(password, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setSecurityPassword(const ::std::string& password, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setSecurityPassword(password, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setSecurityPassword(const ::std::string& password, const ::omero::api::Callback_ServiceFactory_setSecurityPasswordPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setSecurityPassword(password, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setSecurityPassword(const ::std::string& password, const ::Ice::Context& __ctx, const ::omero::api::Callback_ServiceFactory_setSecurityPasswordPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setSecurityPassword(password, &__ctx, __del, __cookie);
    }

    void end_setSecurityPassword(const ::Ice::AsyncResultPtr&);
    
private:

    void setSecurityPassword(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setSecurityPassword(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::api::IAdminPrx getAdminService()
    {
        return getAdminService(0);
    }
    ::omero::api::IAdminPrx getAdminService(const ::Ice::Context& __ctx)
    {
        return getAdminService(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getAdminService()
    {
        return begin_getAdminService(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getAdminService(const ::Ice::Context& __ctx)
    {
        return begin_getAdminService(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getAdminService(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getAdminService(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getAdminService(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getAdminService(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getAdminService(const ::omero::api::Callback_ServiceFactory_getAdminServicePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getAdminService(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getAdminService(const ::Ice::Context& __ctx, const ::omero::api::Callback_ServiceFactory_getAdminServicePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getAdminService(&__ctx, __del, __cookie);
    }

    ::omero::api::IAdminPrx end_getAdminService(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::api::IAdminPrx getAdminService(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getAdminService(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::api::IConfigPrx getConfigService()
    {
        return getConfigService(0);
    }
    ::omero::api::IConfigPrx getConfigService(const ::Ice::Context& __ctx)
    {
        return getConfigService(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getConfigService()
    {
        return begin_getConfigService(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getConfigService(const ::Ice::Context& __ctx)
    {
        return begin_getConfigService(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getConfigService(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getConfigService(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getConfigService(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getConfigService(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getConfigService(const ::omero::api::Callback_ServiceFactory_getConfigServicePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getConfigService(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getConfigService(const ::Ice::Context& __ctx, const ::omero::api::Callback_ServiceFactory_getConfigServicePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getConfigService(&__ctx, __del, __cookie);
    }

    ::omero::api::IConfigPrx end_getConfigService(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::api::IConfigPrx getConfigService(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getConfigService(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::api::IContainerPrx getContainerService()
    {
        return getContainerService(0);
    }
    ::omero::api::IContainerPrx getContainerService(const ::Ice::Context& __ctx)
    {
        return getContainerService(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getContainerService()
    {
        return begin_getContainerService(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getContainerService(const ::Ice::Context& __ctx)
    {
        return begin_getContainerService(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getContainerService(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getContainerService(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getContainerService(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getContainerService(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getContainerService(const ::omero::api::Callback_ServiceFactory_getContainerServicePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getContainerService(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getContainerService(const ::Ice::Context& __ctx, const ::omero::api::Callback_ServiceFactory_getContainerServicePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getContainerService(&__ctx, __del, __cookie);
    }

    ::omero::api::IContainerPrx end_getContainerService(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::api::IContainerPrx getContainerService(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getContainerService(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::api::IDeletePrx getDeleteService()
    {
        return getDeleteService(0);
    }
    ::omero::api::IDeletePrx getDeleteService(const ::Ice::Context& __ctx)
    {
        return getDeleteService(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getDeleteService()
    {
        return begin_getDeleteService(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getDeleteService(const ::Ice::Context& __ctx)
    {
        return begin_getDeleteService(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getDeleteService(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getDeleteService(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getDeleteService(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getDeleteService(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getDeleteService(const ::omero::api::Callback_ServiceFactory_getDeleteServicePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getDeleteService(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getDeleteService(const ::Ice::Context& __ctx, const ::omero::api::Callback_ServiceFactory_getDeleteServicePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getDeleteService(&__ctx, __del, __cookie);
    }

    ::omero::api::IDeletePrx end_getDeleteService(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::api::IDeletePrx getDeleteService(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getDeleteService(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::api::ILdapPrx getLdapService()
    {
        return getLdapService(0);
    }
    ::omero::api::ILdapPrx getLdapService(const ::Ice::Context& __ctx)
    {
        return getLdapService(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getLdapService()
    {
        return begin_getLdapService(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getLdapService(const ::Ice::Context& __ctx)
    {
        return begin_getLdapService(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getLdapService(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getLdapService(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getLdapService(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getLdapService(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getLdapService(const ::omero::api::Callback_ServiceFactory_getLdapServicePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getLdapService(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getLdapService(const ::Ice::Context& __ctx, const ::omero::api::Callback_ServiceFactory_getLdapServicePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getLdapService(&__ctx, __del, __cookie);
    }

    ::omero::api::ILdapPrx end_getLdapService(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::api::ILdapPrx getLdapService(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getLdapService(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::api::IPixelsPrx getPixelsService()
    {
        return getPixelsService(0);
    }
    ::omero::api::IPixelsPrx getPixelsService(const ::Ice::Context& __ctx)
    {
        return getPixelsService(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getPixelsService()
    {
        return begin_getPixelsService(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getPixelsService(const ::Ice::Context& __ctx)
    {
        return begin_getPixelsService(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getPixelsService(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getPixelsService(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getPixelsService(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getPixelsService(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getPixelsService(const ::omero::api::Callback_ServiceFactory_getPixelsServicePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getPixelsService(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getPixelsService(const ::Ice::Context& __ctx, const ::omero::api::Callback_ServiceFactory_getPixelsServicePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getPixelsService(&__ctx, __del, __cookie);
    }

    ::omero::api::IPixelsPrx end_getPixelsService(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::api::IPixelsPrx getPixelsService(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getPixelsService(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::api::IProjectionPrx getProjectionService()
    {
        return getProjectionService(0);
    }
    ::omero::api::IProjectionPrx getProjectionService(const ::Ice::Context& __ctx)
    {
        return getProjectionService(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getProjectionService()
    {
        return begin_getProjectionService(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getProjectionService(const ::Ice::Context& __ctx)
    {
        return begin_getProjectionService(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getProjectionService(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getProjectionService(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getProjectionService(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getProjectionService(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getProjectionService(const ::omero::api::Callback_ServiceFactory_getProjectionServicePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getProjectionService(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getProjectionService(const ::Ice::Context& __ctx, const ::omero::api::Callback_ServiceFactory_getProjectionServicePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getProjectionService(&__ctx, __del, __cookie);
    }

    ::omero::api::IProjectionPrx end_getProjectionService(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::api::IProjectionPrx getProjectionService(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getProjectionService(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::api::IQueryPrx getQueryService()
    {
        return getQueryService(0);
    }
    ::omero::api::IQueryPrx getQueryService(const ::Ice::Context& __ctx)
    {
        return getQueryService(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getQueryService()
    {
        return begin_getQueryService(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getQueryService(const ::Ice::Context& __ctx)
    {
        return begin_getQueryService(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getQueryService(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getQueryService(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getQueryService(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getQueryService(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getQueryService(const ::omero::api::Callback_ServiceFactory_getQueryServicePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getQueryService(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getQueryService(const ::Ice::Context& __ctx, const ::omero::api::Callback_ServiceFactory_getQueryServicePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getQueryService(&__ctx, __del, __cookie);
    }

    ::omero::api::IQueryPrx end_getQueryService(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::api::IQueryPrx getQueryService(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getQueryService(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::api::IRenderingSettingsPrx getRenderingSettingsService()
    {
        return getRenderingSettingsService(0);
    }
    ::omero::api::IRenderingSettingsPrx getRenderingSettingsService(const ::Ice::Context& __ctx)
    {
        return getRenderingSettingsService(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getRenderingSettingsService()
    {
        return begin_getRenderingSettingsService(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getRenderingSettingsService(const ::Ice::Context& __ctx)
    {
        return begin_getRenderingSettingsService(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getRenderingSettingsService(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getRenderingSettingsService(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getRenderingSettingsService(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getRenderingSettingsService(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getRenderingSettingsService(const ::omero::api::Callback_ServiceFactory_getRenderingSettingsServicePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getRenderingSettingsService(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getRenderingSettingsService(const ::Ice::Context& __ctx, const ::omero::api::Callback_ServiceFactory_getRenderingSettingsServicePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getRenderingSettingsService(&__ctx, __del, __cookie);
    }

    ::omero::api::IRenderingSettingsPrx end_getRenderingSettingsService(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::api::IRenderingSettingsPrx getRenderingSettingsService(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getRenderingSettingsService(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::api::IRepositoryInfoPrx getRepositoryInfoService()
    {
        return getRepositoryInfoService(0);
    }
    ::omero::api::IRepositoryInfoPrx getRepositoryInfoService(const ::Ice::Context& __ctx)
    {
        return getRepositoryInfoService(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getRepositoryInfoService()
    {
        return begin_getRepositoryInfoService(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getRepositoryInfoService(const ::Ice::Context& __ctx)
    {
        return begin_getRepositoryInfoService(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getRepositoryInfoService(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getRepositoryInfoService(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getRepositoryInfoService(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getRepositoryInfoService(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getRepositoryInfoService(const ::omero::api::Callback_ServiceFactory_getRepositoryInfoServicePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getRepositoryInfoService(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getRepositoryInfoService(const ::Ice::Context& __ctx, const ::omero::api::Callback_ServiceFactory_getRepositoryInfoServicePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getRepositoryInfoService(&__ctx, __del, __cookie);
    }

    ::omero::api::IRepositoryInfoPrx end_getRepositoryInfoService(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::api::IRepositoryInfoPrx getRepositoryInfoService(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getRepositoryInfoService(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::api::IRoiPrx getRoiService()
    {
        return getRoiService(0);
    }
    ::omero::api::IRoiPrx getRoiService(const ::Ice::Context& __ctx)
    {
        return getRoiService(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getRoiService()
    {
        return begin_getRoiService(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getRoiService(const ::Ice::Context& __ctx)
    {
        return begin_getRoiService(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getRoiService(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getRoiService(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getRoiService(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getRoiService(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getRoiService(const ::omero::api::Callback_ServiceFactory_getRoiServicePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getRoiService(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getRoiService(const ::Ice::Context& __ctx, const ::omero::api::Callback_ServiceFactory_getRoiServicePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getRoiService(&__ctx, __del, __cookie);
    }

    ::omero::api::IRoiPrx end_getRoiService(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::api::IRoiPrx getRoiService(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getRoiService(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::api::IScriptPrx getScriptService()
    {
        return getScriptService(0);
    }
    ::omero::api::IScriptPrx getScriptService(const ::Ice::Context& __ctx)
    {
        return getScriptService(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getScriptService()
    {
        return begin_getScriptService(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getScriptService(const ::Ice::Context& __ctx)
    {
        return begin_getScriptService(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getScriptService(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getScriptService(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getScriptService(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getScriptService(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getScriptService(const ::omero::api::Callback_ServiceFactory_getScriptServicePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getScriptService(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getScriptService(const ::Ice::Context& __ctx, const ::omero::api::Callback_ServiceFactory_getScriptServicePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getScriptService(&__ctx, __del, __cookie);
    }

    ::omero::api::IScriptPrx end_getScriptService(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::api::IScriptPrx getScriptService(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getScriptService(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::api::ISessionPrx getSessionService()
    {
        return getSessionService(0);
    }
    ::omero::api::ISessionPrx getSessionService(const ::Ice::Context& __ctx)
    {
        return getSessionService(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getSessionService()
    {
        return begin_getSessionService(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getSessionService(const ::Ice::Context& __ctx)
    {
        return begin_getSessionService(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getSessionService(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getSessionService(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getSessionService(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getSessionService(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getSessionService(const ::omero::api::Callback_ServiceFactory_getSessionServicePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getSessionService(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getSessionService(const ::Ice::Context& __ctx, const ::omero::api::Callback_ServiceFactory_getSessionServicePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getSessionService(&__ctx, __del, __cookie);
    }

    ::omero::api::ISessionPrx end_getSessionService(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::api::ISessionPrx getSessionService(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getSessionService(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::api::ISharePrx getShareService()
    {
        return getShareService(0);
    }
    ::omero::api::ISharePrx getShareService(const ::Ice::Context& __ctx)
    {
        return getShareService(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getShareService()
    {
        return begin_getShareService(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getShareService(const ::Ice::Context& __ctx)
    {
        return begin_getShareService(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getShareService(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getShareService(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getShareService(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getShareService(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getShareService(const ::omero::api::Callback_ServiceFactory_getShareServicePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getShareService(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getShareService(const ::Ice::Context& __ctx, const ::omero::api::Callback_ServiceFactory_getShareServicePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getShareService(&__ctx, __del, __cookie);
    }

    ::omero::api::ISharePrx end_getShareService(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::api::ISharePrx getShareService(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getShareService(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::api::ITimelinePrx getTimelineService()
    {
        return getTimelineService(0);
    }
    ::omero::api::ITimelinePrx getTimelineService(const ::Ice::Context& __ctx)
    {
        return getTimelineService(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getTimelineService()
    {
        return begin_getTimelineService(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getTimelineService(const ::Ice::Context& __ctx)
    {
        return begin_getTimelineService(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getTimelineService(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getTimelineService(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getTimelineService(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getTimelineService(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getTimelineService(const ::omero::api::Callback_ServiceFactory_getTimelineServicePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getTimelineService(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getTimelineService(const ::Ice::Context& __ctx, const ::omero::api::Callback_ServiceFactory_getTimelineServicePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getTimelineService(&__ctx, __del, __cookie);
    }

    ::omero::api::ITimelinePrx end_getTimelineService(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::api::ITimelinePrx getTimelineService(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getTimelineService(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::api::ITypesPrx getTypesService()
    {
        return getTypesService(0);
    }
    ::omero::api::ITypesPrx getTypesService(const ::Ice::Context& __ctx)
    {
        return getTypesService(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getTypesService()
    {
        return begin_getTypesService(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getTypesService(const ::Ice::Context& __ctx)
    {
        return begin_getTypesService(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getTypesService(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getTypesService(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getTypesService(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getTypesService(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getTypesService(const ::omero::api::Callback_ServiceFactory_getTypesServicePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getTypesService(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getTypesService(const ::Ice::Context& __ctx, const ::omero::api::Callback_ServiceFactory_getTypesServicePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getTypesService(&__ctx, __del, __cookie);
    }

    ::omero::api::ITypesPrx end_getTypesService(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::api::ITypesPrx getTypesService(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getTypesService(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::api::IUpdatePrx getUpdateService()
    {
        return getUpdateService(0);
    }
    ::omero::api::IUpdatePrx getUpdateService(const ::Ice::Context& __ctx)
    {
        return getUpdateService(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getUpdateService()
    {
        return begin_getUpdateService(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getUpdateService(const ::Ice::Context& __ctx)
    {
        return begin_getUpdateService(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getUpdateService(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getUpdateService(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getUpdateService(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getUpdateService(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getUpdateService(const ::omero::api::Callback_ServiceFactory_getUpdateServicePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getUpdateService(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getUpdateService(const ::Ice::Context& __ctx, const ::omero::api::Callback_ServiceFactory_getUpdateServicePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getUpdateService(&__ctx, __del, __cookie);
    }

    ::omero::api::IUpdatePrx end_getUpdateService(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::api::IUpdatePrx getUpdateService(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getUpdateService(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::api::IMetadataPrx getMetadataService()
    {
        return getMetadataService(0);
    }
    ::omero::api::IMetadataPrx getMetadataService(const ::Ice::Context& __ctx)
    {
        return getMetadataService(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getMetadataService()
    {
        return begin_getMetadataService(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getMetadataService(const ::Ice::Context& __ctx)
    {
        return begin_getMetadataService(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getMetadataService(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getMetadataService(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getMetadataService(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getMetadataService(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getMetadataService(const ::omero::api::Callback_ServiceFactory_getMetadataServicePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getMetadataService(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getMetadataService(const ::Ice::Context& __ctx, const ::omero::api::Callback_ServiceFactory_getMetadataServicePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getMetadataService(&__ctx, __del, __cookie);
    }

    ::omero::api::IMetadataPrx end_getMetadataService(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::api::IMetadataPrx getMetadataService(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getMetadataService(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ICE_DEPRECATED_API ::omero::api::GatewayPrx createGateway()
    {
        return createGateway(0);
    }
    ICE_DEPRECATED_API ::omero::api::GatewayPrx createGateway(const ::Ice::Context& __ctx)
    {
        return createGateway(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_createGateway()
    {
        return begin_createGateway(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_createGateway(const ::Ice::Context& __ctx)
    {
        return begin_createGateway(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_createGateway(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createGateway(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_createGateway(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createGateway(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_createGateway(const ::omero::api::Callback_ServiceFactory_createGatewayPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createGateway(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_createGateway(const ::Ice::Context& __ctx, const ::omero::api::Callback_ServiceFactory_createGatewayPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createGateway(&__ctx, __del, __cookie);
    }

    ::omero::api::GatewayPrx end_createGateway(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::api::GatewayPrx createGateway(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_createGateway(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::api::ExporterPrx createExporter()
    {
        return createExporter(0);
    }
    ::omero::api::ExporterPrx createExporter(const ::Ice::Context& __ctx)
    {
        return createExporter(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_createExporter()
    {
        return begin_createExporter(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_createExporter(const ::Ice::Context& __ctx)
    {
        return begin_createExporter(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_createExporter(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createExporter(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_createExporter(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createExporter(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_createExporter(const ::omero::api::Callback_ServiceFactory_createExporterPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createExporter(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_createExporter(const ::Ice::Context& __ctx, const ::omero::api::Callback_ServiceFactory_createExporterPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createExporter(&__ctx, __del, __cookie);
    }

    ::omero::api::ExporterPrx end_createExporter(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::api::ExporterPrx createExporter(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_createExporter(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::api::JobHandlePrx createJobHandle()
    {
        return createJobHandle(0);
    }
    ::omero::api::JobHandlePrx createJobHandle(const ::Ice::Context& __ctx)
    {
        return createJobHandle(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_createJobHandle()
    {
        return begin_createJobHandle(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_createJobHandle(const ::Ice::Context& __ctx)
    {
        return begin_createJobHandle(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_createJobHandle(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createJobHandle(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_createJobHandle(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createJobHandle(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_createJobHandle(const ::omero::api::Callback_ServiceFactory_createJobHandlePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createJobHandle(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_createJobHandle(const ::Ice::Context& __ctx, const ::omero::api::Callback_ServiceFactory_createJobHandlePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createJobHandle(&__ctx, __del, __cookie);
    }

    ::omero::api::JobHandlePrx end_createJobHandle(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::api::JobHandlePrx createJobHandle(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_createJobHandle(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::api::RawFileStorePrx createRawFileStore()
    {
        return createRawFileStore(0);
    }
    ::omero::api::RawFileStorePrx createRawFileStore(const ::Ice::Context& __ctx)
    {
        return createRawFileStore(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_createRawFileStore()
    {
        return begin_createRawFileStore(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_createRawFileStore(const ::Ice::Context& __ctx)
    {
        return begin_createRawFileStore(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_createRawFileStore(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createRawFileStore(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_createRawFileStore(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createRawFileStore(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_createRawFileStore(const ::omero::api::Callback_ServiceFactory_createRawFileStorePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createRawFileStore(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_createRawFileStore(const ::Ice::Context& __ctx, const ::omero::api::Callback_ServiceFactory_createRawFileStorePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createRawFileStore(&__ctx, __del, __cookie);
    }

    ::omero::api::RawFileStorePrx end_createRawFileStore(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::api::RawFileStorePrx createRawFileStore(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_createRawFileStore(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::api::RawPixelsStorePrx createRawPixelsStore()
    {
        return createRawPixelsStore(0);
    }
    ::omero::api::RawPixelsStorePrx createRawPixelsStore(const ::Ice::Context& __ctx)
    {
        return createRawPixelsStore(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_createRawPixelsStore()
    {
        return begin_createRawPixelsStore(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_createRawPixelsStore(const ::Ice::Context& __ctx)
    {
        return begin_createRawPixelsStore(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_createRawPixelsStore(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createRawPixelsStore(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_createRawPixelsStore(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createRawPixelsStore(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_createRawPixelsStore(const ::omero::api::Callback_ServiceFactory_createRawPixelsStorePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createRawPixelsStore(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_createRawPixelsStore(const ::Ice::Context& __ctx, const ::omero::api::Callback_ServiceFactory_createRawPixelsStorePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createRawPixelsStore(&__ctx, __del, __cookie);
    }

    ::omero::api::RawPixelsStorePrx end_createRawPixelsStore(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::api::RawPixelsStorePrx createRawPixelsStore(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_createRawPixelsStore(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::api::RenderingEnginePrx createRenderingEngine()
    {
        return createRenderingEngine(0);
    }
    ::omero::api::RenderingEnginePrx createRenderingEngine(const ::Ice::Context& __ctx)
    {
        return createRenderingEngine(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_createRenderingEngine()
    {
        return begin_createRenderingEngine(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_createRenderingEngine(const ::Ice::Context& __ctx)
    {
        return begin_createRenderingEngine(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_createRenderingEngine(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createRenderingEngine(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_createRenderingEngine(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createRenderingEngine(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_createRenderingEngine(const ::omero::api::Callback_ServiceFactory_createRenderingEnginePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createRenderingEngine(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_createRenderingEngine(const ::Ice::Context& __ctx, const ::omero::api::Callback_ServiceFactory_createRenderingEnginePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createRenderingEngine(&__ctx, __del, __cookie);
    }

    ::omero::api::RenderingEnginePrx end_createRenderingEngine(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::api::RenderingEnginePrx createRenderingEngine(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_createRenderingEngine(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::api::SearchPrx createSearchService()
    {
        return createSearchService(0);
    }
    ::omero::api::SearchPrx createSearchService(const ::Ice::Context& __ctx)
    {
        return createSearchService(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_createSearchService()
    {
        return begin_createSearchService(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_createSearchService(const ::Ice::Context& __ctx)
    {
        return begin_createSearchService(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_createSearchService(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createSearchService(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_createSearchService(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createSearchService(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_createSearchService(const ::omero::api::Callback_ServiceFactory_createSearchServicePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createSearchService(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_createSearchService(const ::Ice::Context& __ctx, const ::omero::api::Callback_ServiceFactory_createSearchServicePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createSearchService(&__ctx, __del, __cookie);
    }

    ::omero::api::SearchPrx end_createSearchService(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::api::SearchPrx createSearchService(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_createSearchService(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::api::ThumbnailStorePrx createThumbnailStore()
    {
        return createThumbnailStore(0);
    }
    ::omero::api::ThumbnailStorePrx createThumbnailStore(const ::Ice::Context& __ctx)
    {
        return createThumbnailStore(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_createThumbnailStore()
    {
        return begin_createThumbnailStore(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_createThumbnailStore(const ::Ice::Context& __ctx)
    {
        return begin_createThumbnailStore(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_createThumbnailStore(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createThumbnailStore(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_createThumbnailStore(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createThumbnailStore(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_createThumbnailStore(const ::omero::api::Callback_ServiceFactory_createThumbnailStorePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createThumbnailStore(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_createThumbnailStore(const ::Ice::Context& __ctx, const ::omero::api::Callback_ServiceFactory_createThumbnailStorePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createThumbnailStore(&__ctx, __del, __cookie);
    }

    ::omero::api::ThumbnailStorePrx end_createThumbnailStore(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::api::ThumbnailStorePrx createThumbnailStore(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_createThumbnailStore(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::grid::SharedResourcesPrx sharedResources()
    {
        return sharedResources(0);
    }
    ::omero::grid::SharedResourcesPrx sharedResources(const ::Ice::Context& __ctx)
    {
        return sharedResources(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_sharedResources()
    {
        return begin_sharedResources(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_sharedResources(const ::Ice::Context& __ctx)
    {
        return begin_sharedResources(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_sharedResources(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_sharedResources(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_sharedResources(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_sharedResources(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_sharedResources(const ::omero::api::Callback_ServiceFactory_sharedResourcesPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_sharedResources(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_sharedResources(const ::Ice::Context& __ctx, const ::omero::api::Callback_ServiceFactory_sharedResourcesPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_sharedResources(&__ctx, __del, __cookie);
    }

    ::omero::grid::SharedResourcesPrx end_sharedResources(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::grid::SharedResourcesPrx sharedResources(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_sharedResources(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::api::ServiceInterfacePrx getByName(const ::std::string& name)
    {
        return getByName(name, 0);
    }
    ::omero::api::ServiceInterfacePrx getByName(const ::std::string& name, const ::Ice::Context& __ctx)
    {
        return getByName(name, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_getByName(const ::std::string& name)
    {
        return begin_getByName(name, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getByName(const ::std::string& name, const ::Ice::Context& __ctx)
    {
        return begin_getByName(name, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getByName(const ::std::string& name, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getByName(name, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getByName(const ::std::string& name, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getByName(name, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getByName(const ::std::string& name, const ::omero::api::Callback_ServiceFactory_getByNamePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getByName(name, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getByName(const ::std::string& name, const ::Ice::Context& __ctx, const ::omero::api::Callback_ServiceFactory_getByNamePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getByName(name, &__ctx, __del, __cookie);
    }

    ::omero::api::ServiceInterfacePrx end_getByName(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::api::ServiceInterfacePrx getByName(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getByName(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::api::StatefulServiceInterfacePrx createByName(const ::std::string& name)
    {
        return createByName(name, 0);
    }
    ::omero::api::StatefulServiceInterfacePrx createByName(const ::std::string& name, const ::Ice::Context& __ctx)
    {
        return createByName(name, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_createByName(const ::std::string& name)
    {
        return begin_createByName(name, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_createByName(const ::std::string& name, const ::Ice::Context& __ctx)
    {
        return begin_createByName(name, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_createByName(const ::std::string& name, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createByName(name, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_createByName(const ::std::string& name, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createByName(name, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_createByName(const ::std::string& name, const ::omero::api::Callback_ServiceFactory_createByNamePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createByName(name, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_createByName(const ::std::string& name, const ::Ice::Context& __ctx, const ::omero::api::Callback_ServiceFactory_createByNamePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createByName(name, &__ctx, __del, __cookie);
    }

    ::omero::api::StatefulServiceInterfacePrx end_createByName(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::api::StatefulServiceInterfacePrx createByName(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_createByName(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void subscribe(const ::std::string& topicName, const ::Ice::ObjectPrx& prx)
    {
        subscribe(topicName, prx, 0);
    }
    void subscribe(const ::std::string& topicName, const ::Ice::ObjectPrx& prx, const ::Ice::Context& __ctx)
    {
        subscribe(topicName, prx, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_subscribe(const ::std::string& topicName, const ::Ice::ObjectPrx& prx)
    {
        return begin_subscribe(topicName, prx, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_subscribe(const ::std::string& topicName, const ::Ice::ObjectPrx& prx, const ::Ice::Context& __ctx)
    {
        return begin_subscribe(topicName, prx, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_subscribe(const ::std::string& topicName, const ::Ice::ObjectPrx& prx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_subscribe(topicName, prx, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_subscribe(const ::std::string& topicName, const ::Ice::ObjectPrx& prx, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_subscribe(topicName, prx, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_subscribe(const ::std::string& topicName, const ::Ice::ObjectPrx& prx, const ::omero::api::Callback_ServiceFactory_subscribePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_subscribe(topicName, prx, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_subscribe(const ::std::string& topicName, const ::Ice::ObjectPrx& prx, const ::Ice::Context& __ctx, const ::omero::api::Callback_ServiceFactory_subscribePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_subscribe(topicName, prx, &__ctx, __del, __cookie);
    }

    void end_subscribe(const ::Ice::AsyncResultPtr&);
    
private:

    void subscribe(const ::std::string&, const ::Ice::ObjectPrx&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_subscribe(const ::std::string&, const ::Ice::ObjectPrx&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setCallback(const ::omero::api::ClientCallbackPrx& callback)
    {
        setCallback(callback, 0);
    }
    void setCallback(const ::omero::api::ClientCallbackPrx& callback, const ::Ice::Context& __ctx)
    {
        setCallback(callback, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setCallback(const ::omero::api::ClientCallbackPrx& callback)
    {
        return begin_setCallback(callback, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setCallback(const ::omero::api::ClientCallbackPrx& callback, const ::Ice::Context& __ctx)
    {
        return begin_setCallback(callback, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setCallback(const ::omero::api::ClientCallbackPrx& callback, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setCallback(callback, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setCallback(const ::omero::api::ClientCallbackPrx& callback, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setCallback(callback, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setCallback(const ::omero::api::ClientCallbackPrx& callback, const ::omero::api::Callback_ServiceFactory_setCallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setCallback(callback, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setCallback(const ::omero::api::ClientCallbackPrx& callback, const ::Ice::Context& __ctx, const ::omero::api::Callback_ServiceFactory_setCallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setCallback(callback, &__ctx, __del, __cookie);
    }

    void end_setCallback(const ::Ice::AsyncResultPtr&);
    
private:

    void setCallback(const ::omero::api::ClientCallbackPrx&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setCallback(const ::omero::api::ClientCallbackPrx&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ICE_DEPRECATED_API void close()
    {
        close(0);
    }
    ICE_DEPRECATED_API void close(const ::Ice::Context& __ctx)
    {
        close(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_close()
    {
        return begin_close(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_close(const ::Ice::Context& __ctx)
    {
        return begin_close(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_close(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_close(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_close(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_close(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_close(const ::omero::api::Callback_ServiceFactory_closePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_close(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_close(const ::Ice::Context& __ctx, const ::omero::api::Callback_ServiceFactory_closePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_close(&__ctx, __del, __cookie);
    }

    void end_close(const ::Ice::AsyncResultPtr&);
    
private:

    void close(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_close(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void closeOnDestroy()
    {
        closeOnDestroy(0);
    }
    void closeOnDestroy(const ::Ice::Context& __ctx)
    {
        closeOnDestroy(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_closeOnDestroy()
    {
        return begin_closeOnDestroy(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_closeOnDestroy(const ::Ice::Context& __ctx)
    {
        return begin_closeOnDestroy(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_closeOnDestroy(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_closeOnDestroy(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_closeOnDestroy(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_closeOnDestroy(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_closeOnDestroy(const ::omero::api::Callback_ServiceFactory_closeOnDestroyPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_closeOnDestroy(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_closeOnDestroy(const ::Ice::Context& __ctx, const ::omero::api::Callback_ServiceFactory_closeOnDestroyPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_closeOnDestroy(&__ctx, __del, __cookie);
    }

    void end_closeOnDestroy(const ::Ice::AsyncResultPtr&);
    
private:

    void closeOnDestroy(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_closeOnDestroy(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void detachOnDestroy()
    {
        detachOnDestroy(0);
    }
    void detachOnDestroy(const ::Ice::Context& __ctx)
    {
        detachOnDestroy(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_detachOnDestroy()
    {
        return begin_detachOnDestroy(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_detachOnDestroy(const ::Ice::Context& __ctx)
    {
        return begin_detachOnDestroy(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_detachOnDestroy(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_detachOnDestroy(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_detachOnDestroy(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_detachOnDestroy(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_detachOnDestroy(const ::omero::api::Callback_ServiceFactory_detachOnDestroyPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_detachOnDestroy(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_detachOnDestroy(const ::Ice::Context& __ctx, const ::omero::api::Callback_ServiceFactory_detachOnDestroyPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_detachOnDestroy(&__ctx, __del, __cookie);
    }

    void end_detachOnDestroy(const ::Ice::AsyncResultPtr&);
    
private:

    void detachOnDestroy(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_detachOnDestroy(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::api::StringSet activeServices()
    {
        return activeServices(0);
    }
    ::omero::api::StringSet activeServices(const ::Ice::Context& __ctx)
    {
        return activeServices(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_activeServices()
    {
        return begin_activeServices(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_activeServices(const ::Ice::Context& __ctx)
    {
        return begin_activeServices(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_activeServices(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_activeServices(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_activeServices(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_activeServices(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_activeServices(const ::omero::api::Callback_ServiceFactory_activeServicesPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_activeServices(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_activeServices(const ::Ice::Context& __ctx, const ::omero::api::Callback_ServiceFactory_activeServicesPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_activeServices(&__ctx, __del, __cookie);
    }

    ::omero::api::StringSet end_activeServices(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::api::StringSet activeServices(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_activeServices(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Long keepAllAlive(const ::omero::api::ServiceList& proxies)
    {
        return keepAllAlive(proxies, 0);
    }
    ::Ice::Long keepAllAlive(const ::omero::api::ServiceList& proxies, const ::Ice::Context& __ctx)
    {
        return keepAllAlive(proxies, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_keepAllAlive(const ::omero::api::ServiceList& proxies)
    {
        return begin_keepAllAlive(proxies, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_keepAllAlive(const ::omero::api::ServiceList& proxies, const ::Ice::Context& __ctx)
    {
        return begin_keepAllAlive(proxies, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_keepAllAlive(const ::omero::api::ServiceList& proxies, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_keepAllAlive(proxies, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_keepAllAlive(const ::omero::api::ServiceList& proxies, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_keepAllAlive(proxies, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_keepAllAlive(const ::omero::api::ServiceList& proxies, const ::omero::api::Callback_ServiceFactory_keepAllAlivePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_keepAllAlive(proxies, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_keepAllAlive(const ::omero::api::ServiceList& proxies, const ::Ice::Context& __ctx, const ::omero::api::Callback_ServiceFactory_keepAllAlivePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_keepAllAlive(proxies, &__ctx, __del, __cookie);
    }

    ::Ice::Long end_keepAllAlive(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Long keepAllAlive(const ::omero::api::ServiceList&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_keepAllAlive(const ::omero::api::ServiceList&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    bool keepAlive(const ::omero::api::ServiceInterfacePrx& proxy)
    {
        return keepAlive(proxy, 0);
    }
    bool keepAlive(const ::omero::api::ServiceInterfacePrx& proxy, const ::Ice::Context& __ctx)
    {
        return keepAlive(proxy, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_keepAlive(const ::omero::api::ServiceInterfacePrx& proxy)
    {
        return begin_keepAlive(proxy, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_keepAlive(const ::omero::api::ServiceInterfacePrx& proxy, const ::Ice::Context& __ctx)
    {
        return begin_keepAlive(proxy, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_keepAlive(const ::omero::api::ServiceInterfacePrx& proxy, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_keepAlive(proxy, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_keepAlive(const ::omero::api::ServiceInterfacePrx& proxy, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_keepAlive(proxy, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_keepAlive(const ::omero::api::ServiceInterfacePrx& proxy, const ::omero::api::Callback_ServiceFactory_keepAlivePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_keepAlive(proxy, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_keepAlive(const ::omero::api::ServiceInterfacePrx& proxy, const ::Ice::Context& __ctx, const ::omero::api::Callback_ServiceFactory_keepAlivePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_keepAlive(proxy, &__ctx, __del, __cookie);
    }

    bool end_keepAlive(const ::Ice::AsyncResultPtr&);
    
private:

    bool keepAlive(const ::omero::api::ServiceInterfacePrx&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_keepAlive(const ::omero::api::ServiceInterfacePrx&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    
    ::IceInternal::ProxyHandle<ServiceFactory> ice_context(const ::Ice::Context& __context) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServiceFactory*>(_Base::ice_context(__context).get());
    #else
        return dynamic_cast<ServiceFactory*>(::IceProxy::Ice::Object::ice_context(__context).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServiceFactory> ice_adapterId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServiceFactory*>(_Base::ice_adapterId(__id).get());
    #else
        return dynamic_cast<ServiceFactory*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServiceFactory> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServiceFactory*>(_Base::ice_endpoints(__endpoints).get());
    #else
        return dynamic_cast<ServiceFactory*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServiceFactory> ice_locatorCacheTimeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServiceFactory*>(_Base::ice_locatorCacheTimeout(__timeout).get());
    #else
        return dynamic_cast<ServiceFactory*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServiceFactory> ice_connectionCached(bool __cached) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServiceFactory*>(_Base::ice_connectionCached(__cached).get());
    #else
        return dynamic_cast<ServiceFactory*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServiceFactory> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServiceFactory*>(_Base::ice_endpointSelection(__est).get());
    #else
        return dynamic_cast<ServiceFactory*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServiceFactory> ice_secure(bool __secure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServiceFactory*>(_Base::ice_secure(__secure).get());
    #else
        return dynamic_cast<ServiceFactory*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServiceFactory> ice_preferSecure(bool __preferSecure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServiceFactory*>(_Base::ice_preferSecure(__preferSecure).get());
    #else
        return dynamic_cast<ServiceFactory*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServiceFactory> ice_router(const ::Ice::RouterPrx& __router) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServiceFactory*>(_Base::ice_router(__router).get());
    #else
        return dynamic_cast<ServiceFactory*>(::IceProxy::Ice::Object::ice_router(__router).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServiceFactory> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServiceFactory*>(_Base::ice_locator(__locator).get());
    #else
        return dynamic_cast<ServiceFactory*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServiceFactory> ice_collocationOptimized(bool __co) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServiceFactory*>(_Base::ice_collocationOptimized(__co).get());
    #else
        return dynamic_cast<ServiceFactory*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServiceFactory> ice_twoway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServiceFactory*>(_Base::ice_twoway().get());
    #else
        return dynamic_cast<ServiceFactory*>(::IceProxy::Ice::Object::ice_twoway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServiceFactory> ice_oneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServiceFactory*>(_Base::ice_oneway().get());
    #else
        return dynamic_cast<ServiceFactory*>(::IceProxy::Ice::Object::ice_oneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServiceFactory> ice_batchOneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServiceFactory*>(_Base::ice_batchOneway().get());
    #else
        return dynamic_cast<ServiceFactory*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServiceFactory> ice_datagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServiceFactory*>(_Base::ice_datagram().get());
    #else
        return dynamic_cast<ServiceFactory*>(::IceProxy::Ice::Object::ice_datagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServiceFactory> ice_batchDatagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServiceFactory*>(_Base::ice_batchDatagram().get());
    #else
        return dynamic_cast<ServiceFactory*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServiceFactory> ice_compress(bool __compress) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServiceFactory*>(_Base::ice_compress(__compress).get());
    #else
        return dynamic_cast<ServiceFactory*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServiceFactory> ice_timeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServiceFactory*>(_Base::ice_timeout(__timeout).get());
    #else
        return dynamic_cast<ServiceFactory*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServiceFactory> ice_connectionId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServiceFactory*>(_Base::ice_connectionId(__id).get());
    #else
        return dynamic_cast<ServiceFactory*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    #endif
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

}

}

}

namespace IceDelegate
{

namespace omero
{

namespace api
{

class ClientCallback : virtual public ::IceDelegate::Ice::Object
{
public:

    virtual void requestHeartbeat(const ::Ice::Context*) = 0;

    virtual void sessionClosed(const ::Ice::Context*) = 0;

    virtual void shutdownIn(::Ice::Long, const ::Ice::Context*) = 0;
};

class ServiceFactory : virtual public ::IceDelegate::omero::cmd::Session
{
public:

    virtual ::omero::api::IObjectList getSecurityContexts(const ::Ice::Context*) = 0;

    virtual ::omero::model::IObjectPtr setSecurityContext(const ::omero::model::IObjectPtr&, const ::Ice::Context*) = 0;

    virtual void setSecurityPassword(const ::std::string&, const ::Ice::Context*) = 0;

    virtual ::omero::api::IAdminPrx getAdminService(const ::Ice::Context*) = 0;

    virtual ::omero::api::IConfigPrx getConfigService(const ::Ice::Context*) = 0;

    virtual ::omero::api::IContainerPrx getContainerService(const ::Ice::Context*) = 0;

    virtual ::omero::api::IDeletePrx getDeleteService(const ::Ice::Context*) = 0;

    virtual ::omero::api::ILdapPrx getLdapService(const ::Ice::Context*) = 0;

    virtual ::omero::api::IPixelsPrx getPixelsService(const ::Ice::Context*) = 0;

    virtual ::omero::api::IProjectionPrx getProjectionService(const ::Ice::Context*) = 0;

    virtual ::omero::api::IQueryPrx getQueryService(const ::Ice::Context*) = 0;

    virtual ::omero::api::IRenderingSettingsPrx getRenderingSettingsService(const ::Ice::Context*) = 0;

    virtual ::omero::api::IRepositoryInfoPrx getRepositoryInfoService(const ::Ice::Context*) = 0;

    virtual ::omero::api::IRoiPrx getRoiService(const ::Ice::Context*) = 0;

    virtual ::omero::api::IScriptPrx getScriptService(const ::Ice::Context*) = 0;

    virtual ::omero::api::ISessionPrx getSessionService(const ::Ice::Context*) = 0;

    virtual ::omero::api::ISharePrx getShareService(const ::Ice::Context*) = 0;

    virtual ::omero::api::ITimelinePrx getTimelineService(const ::Ice::Context*) = 0;

    virtual ::omero::api::ITypesPrx getTypesService(const ::Ice::Context*) = 0;

    virtual ::omero::api::IUpdatePrx getUpdateService(const ::Ice::Context*) = 0;

    virtual ::omero::api::IMetadataPrx getMetadataService(const ::Ice::Context*) = 0;

    virtual ::omero::api::GatewayPrx createGateway(const ::Ice::Context*) = 0;

    virtual ::omero::api::ExporterPrx createExporter(const ::Ice::Context*) = 0;

    virtual ::omero::api::JobHandlePrx createJobHandle(const ::Ice::Context*) = 0;

    virtual ::omero::api::RawFileStorePrx createRawFileStore(const ::Ice::Context*) = 0;

    virtual ::omero::api::RawPixelsStorePrx createRawPixelsStore(const ::Ice::Context*) = 0;

    virtual ::omero::api::RenderingEnginePrx createRenderingEngine(const ::Ice::Context*) = 0;

    virtual ::omero::api::SearchPrx createSearchService(const ::Ice::Context*) = 0;

    virtual ::omero::api::ThumbnailStorePrx createThumbnailStore(const ::Ice::Context*) = 0;

    virtual ::omero::grid::SharedResourcesPrx sharedResources(const ::Ice::Context*) = 0;

    virtual ::omero::api::ServiceInterfacePrx getByName(const ::std::string&, const ::Ice::Context*) = 0;

    virtual ::omero::api::StatefulServiceInterfacePrx createByName(const ::std::string&, const ::Ice::Context*) = 0;

    virtual void subscribe(const ::std::string&, const ::Ice::ObjectPrx&, const ::Ice::Context*) = 0;

    virtual void setCallback(const ::omero::api::ClientCallbackPrx&, const ::Ice::Context*) = 0;

    virtual void close(const ::Ice::Context*) = 0;

    virtual void closeOnDestroy(const ::Ice::Context*) = 0;

    virtual void detachOnDestroy(const ::Ice::Context*) = 0;

    virtual ::omero::api::StringSet activeServices(const ::Ice::Context*) = 0;

    virtual ::Ice::Long keepAllAlive(const ::omero::api::ServiceList&, const ::Ice::Context*) = 0;

    virtual bool keepAlive(const ::omero::api::ServiceInterfacePrx&, const ::Ice::Context*) = 0;
};

}

}

}

namespace IceDelegateM
{

namespace omero
{

namespace api
{

class ClientCallback : virtual public ::IceDelegate::omero::api::ClientCallback,
                       virtual public ::IceDelegateM::Ice::Object
{
public:

    virtual void requestHeartbeat(const ::Ice::Context*);

    virtual void sessionClosed(const ::Ice::Context*);

    virtual void shutdownIn(::Ice::Long, const ::Ice::Context*);
};

class ServiceFactory : virtual public ::IceDelegate::omero::api::ServiceFactory,
                       virtual public ::IceDelegateM::omero::cmd::Session
{
public:

    virtual ::omero::api::IObjectList getSecurityContexts(const ::Ice::Context*);

    virtual ::omero::model::IObjectPtr setSecurityContext(const ::omero::model::IObjectPtr&, const ::Ice::Context*);

    virtual void setSecurityPassword(const ::std::string&, const ::Ice::Context*);

    virtual ::omero::api::IAdminPrx getAdminService(const ::Ice::Context*);

    virtual ::omero::api::IConfigPrx getConfigService(const ::Ice::Context*);

    virtual ::omero::api::IContainerPrx getContainerService(const ::Ice::Context*);

    virtual ::omero::api::IDeletePrx getDeleteService(const ::Ice::Context*);

    virtual ::omero::api::ILdapPrx getLdapService(const ::Ice::Context*);

    virtual ::omero::api::IPixelsPrx getPixelsService(const ::Ice::Context*);

    virtual ::omero::api::IProjectionPrx getProjectionService(const ::Ice::Context*);

    virtual ::omero::api::IQueryPrx getQueryService(const ::Ice::Context*);

    virtual ::omero::api::IRenderingSettingsPrx getRenderingSettingsService(const ::Ice::Context*);

    virtual ::omero::api::IRepositoryInfoPrx getRepositoryInfoService(const ::Ice::Context*);

    virtual ::omero::api::IRoiPrx getRoiService(const ::Ice::Context*);

    virtual ::omero::api::IScriptPrx getScriptService(const ::Ice::Context*);

    virtual ::omero::api::ISessionPrx getSessionService(const ::Ice::Context*);

    virtual ::omero::api::ISharePrx getShareService(const ::Ice::Context*);

    virtual ::omero::api::ITimelinePrx getTimelineService(const ::Ice::Context*);

    virtual ::omero::api::ITypesPrx getTypesService(const ::Ice::Context*);

    virtual ::omero::api::IUpdatePrx getUpdateService(const ::Ice::Context*);

    virtual ::omero::api::IMetadataPrx getMetadataService(const ::Ice::Context*);

    virtual ::omero::api::GatewayPrx createGateway(const ::Ice::Context*);

    virtual ::omero::api::ExporterPrx createExporter(const ::Ice::Context*);

    virtual ::omero::api::JobHandlePrx createJobHandle(const ::Ice::Context*);

    virtual ::omero::api::RawFileStorePrx createRawFileStore(const ::Ice::Context*);

    virtual ::omero::api::RawPixelsStorePrx createRawPixelsStore(const ::Ice::Context*);

    virtual ::omero::api::RenderingEnginePrx createRenderingEngine(const ::Ice::Context*);

    virtual ::omero::api::SearchPrx createSearchService(const ::Ice::Context*);

    virtual ::omero::api::ThumbnailStorePrx createThumbnailStore(const ::Ice::Context*);

    virtual ::omero::grid::SharedResourcesPrx sharedResources(const ::Ice::Context*);

    virtual ::omero::api::ServiceInterfacePrx getByName(const ::std::string&, const ::Ice::Context*);

    virtual ::omero::api::StatefulServiceInterfacePrx createByName(const ::std::string&, const ::Ice::Context*);

    virtual void subscribe(const ::std::string&, const ::Ice::ObjectPrx&, const ::Ice::Context*);

    virtual void setCallback(const ::omero::api::ClientCallbackPrx&, const ::Ice::Context*);

    virtual void close(const ::Ice::Context*);

    virtual void closeOnDestroy(const ::Ice::Context*);

    virtual void detachOnDestroy(const ::Ice::Context*);

    virtual ::omero::api::StringSet activeServices(const ::Ice::Context*);

    virtual ::Ice::Long keepAllAlive(const ::omero::api::ServiceList&, const ::Ice::Context*);

    virtual bool keepAlive(const ::omero::api::ServiceInterfacePrx&, const ::Ice::Context*);
};

}

}

}

namespace IceDelegateD
{

namespace omero
{

namespace api
{

class ClientCallback : virtual public ::IceDelegate::omero::api::ClientCallback,
                       virtual public ::IceDelegateD::Ice::Object
{
public:

    virtual void requestHeartbeat(const ::Ice::Context*);

    virtual void sessionClosed(const ::Ice::Context*);

    virtual void shutdownIn(::Ice::Long, const ::Ice::Context*);
};

class ServiceFactory : virtual public ::IceDelegate::omero::api::ServiceFactory,
                       virtual public ::IceDelegateD::omero::cmd::Session
{
public:

    virtual ::omero::api::IObjectList getSecurityContexts(const ::Ice::Context*);

    virtual ::omero::model::IObjectPtr setSecurityContext(const ::omero::model::IObjectPtr&, const ::Ice::Context*);

    virtual void setSecurityPassword(const ::std::string&, const ::Ice::Context*);

    virtual ::omero::api::IAdminPrx getAdminService(const ::Ice::Context*);

    virtual ::omero::api::IConfigPrx getConfigService(const ::Ice::Context*);

    virtual ::omero::api::IContainerPrx getContainerService(const ::Ice::Context*);

    virtual ::omero::api::IDeletePrx getDeleteService(const ::Ice::Context*);

    virtual ::omero::api::ILdapPrx getLdapService(const ::Ice::Context*);

    virtual ::omero::api::IPixelsPrx getPixelsService(const ::Ice::Context*);

    virtual ::omero::api::IProjectionPrx getProjectionService(const ::Ice::Context*);

    virtual ::omero::api::IQueryPrx getQueryService(const ::Ice::Context*);

    virtual ::omero::api::IRenderingSettingsPrx getRenderingSettingsService(const ::Ice::Context*);

    virtual ::omero::api::IRepositoryInfoPrx getRepositoryInfoService(const ::Ice::Context*);

    virtual ::omero::api::IRoiPrx getRoiService(const ::Ice::Context*);

    virtual ::omero::api::IScriptPrx getScriptService(const ::Ice::Context*);

    virtual ::omero::api::ISessionPrx getSessionService(const ::Ice::Context*);

    virtual ::omero::api::ISharePrx getShareService(const ::Ice::Context*);

    virtual ::omero::api::ITimelinePrx getTimelineService(const ::Ice::Context*);

    virtual ::omero::api::ITypesPrx getTypesService(const ::Ice::Context*);

    virtual ::omero::api::IUpdatePrx getUpdateService(const ::Ice::Context*);

    virtual ::omero::api::IMetadataPrx getMetadataService(const ::Ice::Context*);

    virtual ::omero::api::GatewayPrx createGateway(const ::Ice::Context*);

    virtual ::omero::api::ExporterPrx createExporter(const ::Ice::Context*);

    virtual ::omero::api::JobHandlePrx createJobHandle(const ::Ice::Context*);

    virtual ::omero::api::RawFileStorePrx createRawFileStore(const ::Ice::Context*);

    virtual ::omero::api::RawPixelsStorePrx createRawPixelsStore(const ::Ice::Context*);

    virtual ::omero::api::RenderingEnginePrx createRenderingEngine(const ::Ice::Context*);

    virtual ::omero::api::SearchPrx createSearchService(const ::Ice::Context*);

    virtual ::omero::api::ThumbnailStorePrx createThumbnailStore(const ::Ice::Context*);

    virtual ::omero::grid::SharedResourcesPrx sharedResources(const ::Ice::Context*);

    virtual ::omero::api::ServiceInterfacePrx getByName(const ::std::string&, const ::Ice::Context*);

    virtual ::omero::api::StatefulServiceInterfacePrx createByName(const ::std::string&, const ::Ice::Context*);

    virtual void subscribe(const ::std::string&, const ::Ice::ObjectPrx&, const ::Ice::Context*);

    virtual void setCallback(const ::omero::api::ClientCallbackPrx&, const ::Ice::Context*);

    virtual void close(const ::Ice::Context*);

    virtual void closeOnDestroy(const ::Ice::Context*);

    virtual void detachOnDestroy(const ::Ice::Context*);

    virtual ::omero::api::StringSet activeServices(const ::Ice::Context*);

    virtual ::Ice::Long keepAllAlive(const ::omero::api::ServiceList&, const ::Ice::Context*);

    virtual bool keepAlive(const ::omero::api::ServiceInterfacePrx&, const ::Ice::Context*);
};

}

}

}

namespace omero
{

namespace api
{

class ClientCallback : virtual public ::Ice::Object
{
public:

    typedef ClientCallbackPrx ProxyType;
    typedef ClientCallbackPtr PointerType;
    
    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void requestHeartbeat(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___requestHeartbeat(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void sessionClosed(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___sessionClosed(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void shutdownIn(::Ice::Long, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___shutdownIn(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void __write(::IceInternal::BasicStream*) const;
    virtual void __read(::IceInternal::BasicStream*, bool);
// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
    virtual void __write(const ::Ice::OutputStreamPtr&) const;
    virtual void __read(const ::Ice::InputStreamPtr&, bool);
#endif
};

inline bool operator==(const ClientCallback& l, const ClientCallback& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const ClientCallback& l, const ClientCallback& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class ServiceFactory : virtual public ::omero::cmd::Session
{
public:

    typedef ServiceFactoryPrx ProxyType;
    typedef ServiceFactoryPtr PointerType;
    
    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual ::omero::api::IObjectList getSecurityContexts(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getSecurityContexts(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::model::IObjectPtr setSecurityContext(const ::omero::model::IObjectPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setSecurityContext(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setSecurityPassword(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setSecurityPassword(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::api::IAdminPrx getAdminService(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getAdminService(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::api::IConfigPrx getConfigService(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getConfigService(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::api::IContainerPrx getContainerService(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getContainerService(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::api::IDeletePrx getDeleteService(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getDeleteService(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::api::ILdapPrx getLdapService(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getLdapService(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::api::IPixelsPrx getPixelsService(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getPixelsService(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::api::IProjectionPrx getProjectionService(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getProjectionService(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::api::IQueryPrx getQueryService(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getQueryService(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::api::IRenderingSettingsPrx getRenderingSettingsService(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getRenderingSettingsService(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::api::IRepositoryInfoPrx getRepositoryInfoService(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getRepositoryInfoService(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::api::IRoiPrx getRoiService(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getRoiService(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::api::IScriptPrx getScriptService(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getScriptService(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::api::ISessionPrx getSessionService(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getSessionService(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::api::ISharePrx getShareService(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getShareService(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::api::ITimelinePrx getTimelineService(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getTimelineService(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::api::ITypesPrx getTypesService(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getTypesService(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::api::IUpdatePrx getUpdateService(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getUpdateService(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::api::IMetadataPrx getMetadataService(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getMetadataService(::IceInternal::Incoming&, const ::Ice::Current&);

    ICE_DEPRECATED_API virtual ::omero::api::GatewayPrx createGateway(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___createGateway(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::api::ExporterPrx createExporter(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___createExporter(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::api::JobHandlePrx createJobHandle(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___createJobHandle(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::api::RawFileStorePrx createRawFileStore(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___createRawFileStore(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::api::RawPixelsStorePrx createRawPixelsStore(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___createRawPixelsStore(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::api::RenderingEnginePrx createRenderingEngine(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___createRenderingEngine(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::api::SearchPrx createSearchService(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___createSearchService(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::api::ThumbnailStorePrx createThumbnailStore(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___createThumbnailStore(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::grid::SharedResourcesPrx sharedResources(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___sharedResources(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::api::ServiceInterfacePrx getByName(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getByName(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::api::StatefulServiceInterfacePrx createByName(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___createByName(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void subscribe(const ::std::string&, const ::Ice::ObjectPrx&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___subscribe(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setCallback(const ::omero::api::ClientCallbackPrx&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setCallback(::IceInternal::Incoming&, const ::Ice::Current&);

    ICE_DEPRECATED_API virtual void close(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___close(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void closeOnDestroy(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___closeOnDestroy(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void detachOnDestroy(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___detachOnDestroy(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::api::StringSet activeServices(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___activeServices(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Long keepAllAlive(const ::omero::api::ServiceList&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___keepAllAlive(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual bool keepAlive(const ::omero::api::ServiceInterfacePrx&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___keepAlive(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void __write(::IceInternal::BasicStream*) const;
    virtual void __read(::IceInternal::BasicStream*, bool);
// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
    virtual void __write(const ::Ice::OutputStreamPtr&) const;
    virtual void __read(const ::Ice::InputStreamPtr&, bool);
#endif
};

inline bool operator==(const ServiceFactory& l, const ServiceFactory& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const ServiceFactory& l, const ServiceFactory& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

}

}

namespace omero
{

namespace api
{

template<class T>
class CallbackNC_ClientCallback_requestHeartbeat : public Callback_ClientCallback_requestHeartbeat_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_ClientCallback_requestHeartbeat(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_ClientCallback_requestHeartbeatPtr
newCallback_ClientCallback_requestHeartbeat(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ClientCallback_requestHeartbeat<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ClientCallback_requestHeartbeatPtr
newCallback_ClientCallback_requestHeartbeat(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ClientCallback_requestHeartbeat<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_ClientCallback_requestHeartbeatPtr
newCallback_ClientCallback_requestHeartbeat(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ClientCallback_requestHeartbeat<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ClientCallback_requestHeartbeatPtr
newCallback_ClientCallback_requestHeartbeat(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ClientCallback_requestHeartbeat<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_ClientCallback_requestHeartbeat : public Callback_ClientCallback_requestHeartbeat_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_ClientCallback_requestHeartbeat(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_ClientCallback_requestHeartbeatPtr
newCallback_ClientCallback_requestHeartbeat(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ClientCallback_requestHeartbeat<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ClientCallback_requestHeartbeatPtr
newCallback_ClientCallback_requestHeartbeat(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ClientCallback_requestHeartbeat<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_ClientCallback_requestHeartbeatPtr
newCallback_ClientCallback_requestHeartbeat(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ClientCallback_requestHeartbeat<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ClientCallback_requestHeartbeatPtr
newCallback_ClientCallback_requestHeartbeat(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ClientCallback_requestHeartbeat<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_ClientCallback_sessionClosed : public Callback_ClientCallback_sessionClosed_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_ClientCallback_sessionClosed(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_ClientCallback_sessionClosedPtr
newCallback_ClientCallback_sessionClosed(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ClientCallback_sessionClosed<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ClientCallback_sessionClosedPtr
newCallback_ClientCallback_sessionClosed(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ClientCallback_sessionClosed<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_ClientCallback_sessionClosedPtr
newCallback_ClientCallback_sessionClosed(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ClientCallback_sessionClosed<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ClientCallback_sessionClosedPtr
newCallback_ClientCallback_sessionClosed(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ClientCallback_sessionClosed<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_ClientCallback_sessionClosed : public Callback_ClientCallback_sessionClosed_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_ClientCallback_sessionClosed(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_ClientCallback_sessionClosedPtr
newCallback_ClientCallback_sessionClosed(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ClientCallback_sessionClosed<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ClientCallback_sessionClosedPtr
newCallback_ClientCallback_sessionClosed(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ClientCallback_sessionClosed<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_ClientCallback_sessionClosedPtr
newCallback_ClientCallback_sessionClosed(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ClientCallback_sessionClosed<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ClientCallback_sessionClosedPtr
newCallback_ClientCallback_sessionClosed(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ClientCallback_sessionClosed<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_ClientCallback_shutdownIn : public Callback_ClientCallback_shutdownIn_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_ClientCallback_shutdownIn(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_ClientCallback_shutdownInPtr
newCallback_ClientCallback_shutdownIn(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ClientCallback_shutdownIn<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ClientCallback_shutdownInPtr
newCallback_ClientCallback_shutdownIn(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ClientCallback_shutdownIn<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_ClientCallback_shutdownInPtr
newCallback_ClientCallback_shutdownIn(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ClientCallback_shutdownIn<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ClientCallback_shutdownInPtr
newCallback_ClientCallback_shutdownIn(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ClientCallback_shutdownIn<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_ClientCallback_shutdownIn : public Callback_ClientCallback_shutdownIn_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_ClientCallback_shutdownIn(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_ClientCallback_shutdownInPtr
newCallback_ClientCallback_shutdownIn(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ClientCallback_shutdownIn<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ClientCallback_shutdownInPtr
newCallback_ClientCallback_shutdownIn(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ClientCallback_shutdownIn<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_ClientCallback_shutdownInPtr
newCallback_ClientCallback_shutdownIn(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ClientCallback_shutdownIn<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ClientCallback_shutdownInPtr
newCallback_ClientCallback_shutdownIn(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ClientCallback_shutdownIn<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_ServiceFactory_getSecurityContexts : public Callback_ServiceFactory_getSecurityContexts_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::api::IObjectList&);

    CallbackNC_ServiceFactory_getSecurityContexts(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ServiceFactoryPrx __proxy = ::omero::api::ServiceFactoryPrx::uncheckedCast(__result->getProxy());
        ::omero::api::IObjectList __ret;
        try
        {
            __ret = __proxy->end_getSecurityContexts(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_ServiceFactory_getSecurityContextsPtr
newCallback_ServiceFactory_getSecurityContexts(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::IObjectList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServiceFactory_getSecurityContexts<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ServiceFactory_getSecurityContextsPtr
newCallback_ServiceFactory_getSecurityContexts(T* instance, void (T::*cb)(const ::omero::api::IObjectList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServiceFactory_getSecurityContexts<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_ServiceFactory_getSecurityContexts : public Callback_ServiceFactory_getSecurityContexts_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::api::IObjectList&, const CT&);

    Callback_ServiceFactory_getSecurityContexts(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ServiceFactoryPrx __proxy = ::omero::api::ServiceFactoryPrx::uncheckedCast(__result->getProxy());
        ::omero::api::IObjectList __ret;
        try
        {
            __ret = __proxy->end_getSecurityContexts(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ServiceFactory_getSecurityContextsPtr
newCallback_ServiceFactory_getSecurityContexts(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::IObjectList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServiceFactory_getSecurityContexts<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ServiceFactory_getSecurityContextsPtr
newCallback_ServiceFactory_getSecurityContexts(T* instance, void (T::*cb)(const ::omero::api::IObjectList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServiceFactory_getSecurityContexts<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_ServiceFactory_setSecurityContext : public Callback_ServiceFactory_setSecurityContext_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::model::IObjectPtr&);

    CallbackNC_ServiceFactory_setSecurityContext(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ServiceFactoryPrx __proxy = ::omero::api::ServiceFactoryPrx::uncheckedCast(__result->getProxy());
        ::omero::model::IObjectPtr __ret;
        try
        {
            __ret = __proxy->end_setSecurityContext(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_ServiceFactory_setSecurityContextPtr
newCallback_ServiceFactory_setSecurityContext(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::IObjectPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServiceFactory_setSecurityContext<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ServiceFactory_setSecurityContextPtr
newCallback_ServiceFactory_setSecurityContext(T* instance, void (T::*cb)(const ::omero::model::IObjectPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServiceFactory_setSecurityContext<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_ServiceFactory_setSecurityContext : public Callback_ServiceFactory_setSecurityContext_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::model::IObjectPtr&, const CT&);

    Callback_ServiceFactory_setSecurityContext(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ServiceFactoryPrx __proxy = ::omero::api::ServiceFactoryPrx::uncheckedCast(__result->getProxy());
        ::omero::model::IObjectPtr __ret;
        try
        {
            __ret = __proxy->end_setSecurityContext(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ServiceFactory_setSecurityContextPtr
newCallback_ServiceFactory_setSecurityContext(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::IObjectPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServiceFactory_setSecurityContext<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ServiceFactory_setSecurityContextPtr
newCallback_ServiceFactory_setSecurityContext(T* instance, void (T::*cb)(const ::omero::model::IObjectPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServiceFactory_setSecurityContext<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_ServiceFactory_setSecurityPassword : public Callback_ServiceFactory_setSecurityPassword_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_ServiceFactory_setSecurityPassword(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ServiceFactoryPrx __proxy = ::omero::api::ServiceFactoryPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_setSecurityPassword(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)();
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
#endif
        }
    }

    Response response;
};

template<class T> Callback_ServiceFactory_setSecurityPasswordPtr
newCallback_ServiceFactory_setSecurityPassword(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServiceFactory_setSecurityPassword<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ServiceFactory_setSecurityPasswordPtr
newCallback_ServiceFactory_setSecurityPassword(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServiceFactory_setSecurityPassword<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_ServiceFactory_setSecurityPasswordPtr
newCallback_ServiceFactory_setSecurityPassword(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServiceFactory_setSecurityPassword<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ServiceFactory_setSecurityPasswordPtr
newCallback_ServiceFactory_setSecurityPassword(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServiceFactory_setSecurityPassword<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_ServiceFactory_setSecurityPassword : public Callback_ServiceFactory_setSecurityPassword_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_ServiceFactory_setSecurityPassword(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ServiceFactoryPrx __proxy = ::omero::api::ServiceFactoryPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_setSecurityPassword(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ServiceFactory_setSecurityPasswordPtr
newCallback_ServiceFactory_setSecurityPassword(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServiceFactory_setSecurityPassword<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ServiceFactory_setSecurityPasswordPtr
newCallback_ServiceFactory_setSecurityPassword(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServiceFactory_setSecurityPassword<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_ServiceFactory_setSecurityPasswordPtr
newCallback_ServiceFactory_setSecurityPassword(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServiceFactory_setSecurityPassword<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ServiceFactory_setSecurityPasswordPtr
newCallback_ServiceFactory_setSecurityPassword(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServiceFactory_setSecurityPassword<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_ServiceFactory_getAdminService : public Callback_ServiceFactory_getAdminService_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::api::IAdminPrx&);

    CallbackNC_ServiceFactory_getAdminService(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ServiceFactoryPrx __proxy = ::omero::api::ServiceFactoryPrx::uncheckedCast(__result->getProxy());
        ::omero::api::IAdminPrx __ret;
        try
        {
            __ret = __proxy->end_getAdminService(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_ServiceFactory_getAdminServicePtr
newCallback_ServiceFactory_getAdminService(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::IAdminPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServiceFactory_getAdminService<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ServiceFactory_getAdminServicePtr
newCallback_ServiceFactory_getAdminService(T* instance, void (T::*cb)(const ::omero::api::IAdminPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServiceFactory_getAdminService<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_ServiceFactory_getAdminService : public Callback_ServiceFactory_getAdminService_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::api::IAdminPrx&, const CT&);

    Callback_ServiceFactory_getAdminService(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ServiceFactoryPrx __proxy = ::omero::api::ServiceFactoryPrx::uncheckedCast(__result->getProxy());
        ::omero::api::IAdminPrx __ret;
        try
        {
            __ret = __proxy->end_getAdminService(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ServiceFactory_getAdminServicePtr
newCallback_ServiceFactory_getAdminService(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::IAdminPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServiceFactory_getAdminService<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ServiceFactory_getAdminServicePtr
newCallback_ServiceFactory_getAdminService(T* instance, void (T::*cb)(const ::omero::api::IAdminPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServiceFactory_getAdminService<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_ServiceFactory_getConfigService : public Callback_ServiceFactory_getConfigService_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::api::IConfigPrx&);

    CallbackNC_ServiceFactory_getConfigService(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ServiceFactoryPrx __proxy = ::omero::api::ServiceFactoryPrx::uncheckedCast(__result->getProxy());
        ::omero::api::IConfigPrx __ret;
        try
        {
            __ret = __proxy->end_getConfigService(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_ServiceFactory_getConfigServicePtr
newCallback_ServiceFactory_getConfigService(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::IConfigPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServiceFactory_getConfigService<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ServiceFactory_getConfigServicePtr
newCallback_ServiceFactory_getConfigService(T* instance, void (T::*cb)(const ::omero::api::IConfigPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServiceFactory_getConfigService<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_ServiceFactory_getConfigService : public Callback_ServiceFactory_getConfigService_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::api::IConfigPrx&, const CT&);

    Callback_ServiceFactory_getConfigService(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ServiceFactoryPrx __proxy = ::omero::api::ServiceFactoryPrx::uncheckedCast(__result->getProxy());
        ::omero::api::IConfigPrx __ret;
        try
        {
            __ret = __proxy->end_getConfigService(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ServiceFactory_getConfigServicePtr
newCallback_ServiceFactory_getConfigService(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::IConfigPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServiceFactory_getConfigService<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ServiceFactory_getConfigServicePtr
newCallback_ServiceFactory_getConfigService(T* instance, void (T::*cb)(const ::omero::api::IConfigPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServiceFactory_getConfigService<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_ServiceFactory_getContainerService : public Callback_ServiceFactory_getContainerService_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::api::IContainerPrx&);

    CallbackNC_ServiceFactory_getContainerService(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ServiceFactoryPrx __proxy = ::omero::api::ServiceFactoryPrx::uncheckedCast(__result->getProxy());
        ::omero::api::IContainerPrx __ret;
        try
        {
            __ret = __proxy->end_getContainerService(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_ServiceFactory_getContainerServicePtr
newCallback_ServiceFactory_getContainerService(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::IContainerPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServiceFactory_getContainerService<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ServiceFactory_getContainerServicePtr
newCallback_ServiceFactory_getContainerService(T* instance, void (T::*cb)(const ::omero::api::IContainerPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServiceFactory_getContainerService<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_ServiceFactory_getContainerService : public Callback_ServiceFactory_getContainerService_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::api::IContainerPrx&, const CT&);

    Callback_ServiceFactory_getContainerService(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ServiceFactoryPrx __proxy = ::omero::api::ServiceFactoryPrx::uncheckedCast(__result->getProxy());
        ::omero::api::IContainerPrx __ret;
        try
        {
            __ret = __proxy->end_getContainerService(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ServiceFactory_getContainerServicePtr
newCallback_ServiceFactory_getContainerService(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::IContainerPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServiceFactory_getContainerService<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ServiceFactory_getContainerServicePtr
newCallback_ServiceFactory_getContainerService(T* instance, void (T::*cb)(const ::omero::api::IContainerPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServiceFactory_getContainerService<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_ServiceFactory_getDeleteService : public Callback_ServiceFactory_getDeleteService_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::api::IDeletePrx&);

    CallbackNC_ServiceFactory_getDeleteService(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ServiceFactoryPrx __proxy = ::omero::api::ServiceFactoryPrx::uncheckedCast(__result->getProxy());
        ::omero::api::IDeletePrx __ret;
        try
        {
            __ret = __proxy->end_getDeleteService(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_ServiceFactory_getDeleteServicePtr
newCallback_ServiceFactory_getDeleteService(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::IDeletePrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServiceFactory_getDeleteService<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ServiceFactory_getDeleteServicePtr
newCallback_ServiceFactory_getDeleteService(T* instance, void (T::*cb)(const ::omero::api::IDeletePrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServiceFactory_getDeleteService<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_ServiceFactory_getDeleteService : public Callback_ServiceFactory_getDeleteService_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::api::IDeletePrx&, const CT&);

    Callback_ServiceFactory_getDeleteService(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ServiceFactoryPrx __proxy = ::omero::api::ServiceFactoryPrx::uncheckedCast(__result->getProxy());
        ::omero::api::IDeletePrx __ret;
        try
        {
            __ret = __proxy->end_getDeleteService(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ServiceFactory_getDeleteServicePtr
newCallback_ServiceFactory_getDeleteService(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::IDeletePrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServiceFactory_getDeleteService<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ServiceFactory_getDeleteServicePtr
newCallback_ServiceFactory_getDeleteService(T* instance, void (T::*cb)(const ::omero::api::IDeletePrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServiceFactory_getDeleteService<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_ServiceFactory_getLdapService : public Callback_ServiceFactory_getLdapService_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::api::ILdapPrx&);

    CallbackNC_ServiceFactory_getLdapService(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ServiceFactoryPrx __proxy = ::omero::api::ServiceFactoryPrx::uncheckedCast(__result->getProxy());
        ::omero::api::ILdapPrx __ret;
        try
        {
            __ret = __proxy->end_getLdapService(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_ServiceFactory_getLdapServicePtr
newCallback_ServiceFactory_getLdapService(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::ILdapPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServiceFactory_getLdapService<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ServiceFactory_getLdapServicePtr
newCallback_ServiceFactory_getLdapService(T* instance, void (T::*cb)(const ::omero::api::ILdapPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServiceFactory_getLdapService<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_ServiceFactory_getLdapService : public Callback_ServiceFactory_getLdapService_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::api::ILdapPrx&, const CT&);

    Callback_ServiceFactory_getLdapService(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ServiceFactoryPrx __proxy = ::omero::api::ServiceFactoryPrx::uncheckedCast(__result->getProxy());
        ::omero::api::ILdapPrx __ret;
        try
        {
            __ret = __proxy->end_getLdapService(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ServiceFactory_getLdapServicePtr
newCallback_ServiceFactory_getLdapService(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::ILdapPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServiceFactory_getLdapService<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ServiceFactory_getLdapServicePtr
newCallback_ServiceFactory_getLdapService(T* instance, void (T::*cb)(const ::omero::api::ILdapPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServiceFactory_getLdapService<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_ServiceFactory_getPixelsService : public Callback_ServiceFactory_getPixelsService_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::api::IPixelsPrx&);

    CallbackNC_ServiceFactory_getPixelsService(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ServiceFactoryPrx __proxy = ::omero::api::ServiceFactoryPrx::uncheckedCast(__result->getProxy());
        ::omero::api::IPixelsPrx __ret;
        try
        {
            __ret = __proxy->end_getPixelsService(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_ServiceFactory_getPixelsServicePtr
newCallback_ServiceFactory_getPixelsService(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::IPixelsPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServiceFactory_getPixelsService<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ServiceFactory_getPixelsServicePtr
newCallback_ServiceFactory_getPixelsService(T* instance, void (T::*cb)(const ::omero::api::IPixelsPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServiceFactory_getPixelsService<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_ServiceFactory_getPixelsService : public Callback_ServiceFactory_getPixelsService_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::api::IPixelsPrx&, const CT&);

    Callback_ServiceFactory_getPixelsService(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ServiceFactoryPrx __proxy = ::omero::api::ServiceFactoryPrx::uncheckedCast(__result->getProxy());
        ::omero::api::IPixelsPrx __ret;
        try
        {
            __ret = __proxy->end_getPixelsService(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ServiceFactory_getPixelsServicePtr
newCallback_ServiceFactory_getPixelsService(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::IPixelsPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServiceFactory_getPixelsService<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ServiceFactory_getPixelsServicePtr
newCallback_ServiceFactory_getPixelsService(T* instance, void (T::*cb)(const ::omero::api::IPixelsPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServiceFactory_getPixelsService<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_ServiceFactory_getProjectionService : public Callback_ServiceFactory_getProjectionService_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::api::IProjectionPrx&);

    CallbackNC_ServiceFactory_getProjectionService(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ServiceFactoryPrx __proxy = ::omero::api::ServiceFactoryPrx::uncheckedCast(__result->getProxy());
        ::omero::api::IProjectionPrx __ret;
        try
        {
            __ret = __proxy->end_getProjectionService(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_ServiceFactory_getProjectionServicePtr
newCallback_ServiceFactory_getProjectionService(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::IProjectionPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServiceFactory_getProjectionService<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ServiceFactory_getProjectionServicePtr
newCallback_ServiceFactory_getProjectionService(T* instance, void (T::*cb)(const ::omero::api::IProjectionPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServiceFactory_getProjectionService<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_ServiceFactory_getProjectionService : public Callback_ServiceFactory_getProjectionService_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::api::IProjectionPrx&, const CT&);

    Callback_ServiceFactory_getProjectionService(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ServiceFactoryPrx __proxy = ::omero::api::ServiceFactoryPrx::uncheckedCast(__result->getProxy());
        ::omero::api::IProjectionPrx __ret;
        try
        {
            __ret = __proxy->end_getProjectionService(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ServiceFactory_getProjectionServicePtr
newCallback_ServiceFactory_getProjectionService(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::IProjectionPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServiceFactory_getProjectionService<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ServiceFactory_getProjectionServicePtr
newCallback_ServiceFactory_getProjectionService(T* instance, void (T::*cb)(const ::omero::api::IProjectionPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServiceFactory_getProjectionService<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_ServiceFactory_getQueryService : public Callback_ServiceFactory_getQueryService_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::api::IQueryPrx&);

    CallbackNC_ServiceFactory_getQueryService(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ServiceFactoryPrx __proxy = ::omero::api::ServiceFactoryPrx::uncheckedCast(__result->getProxy());
        ::omero::api::IQueryPrx __ret;
        try
        {
            __ret = __proxy->end_getQueryService(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_ServiceFactory_getQueryServicePtr
newCallback_ServiceFactory_getQueryService(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::IQueryPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServiceFactory_getQueryService<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ServiceFactory_getQueryServicePtr
newCallback_ServiceFactory_getQueryService(T* instance, void (T::*cb)(const ::omero::api::IQueryPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServiceFactory_getQueryService<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_ServiceFactory_getQueryService : public Callback_ServiceFactory_getQueryService_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::api::IQueryPrx&, const CT&);

    Callback_ServiceFactory_getQueryService(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ServiceFactoryPrx __proxy = ::omero::api::ServiceFactoryPrx::uncheckedCast(__result->getProxy());
        ::omero::api::IQueryPrx __ret;
        try
        {
            __ret = __proxy->end_getQueryService(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ServiceFactory_getQueryServicePtr
newCallback_ServiceFactory_getQueryService(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::IQueryPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServiceFactory_getQueryService<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ServiceFactory_getQueryServicePtr
newCallback_ServiceFactory_getQueryService(T* instance, void (T::*cb)(const ::omero::api::IQueryPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServiceFactory_getQueryService<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_ServiceFactory_getRenderingSettingsService : public Callback_ServiceFactory_getRenderingSettingsService_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::api::IRenderingSettingsPrx&);

    CallbackNC_ServiceFactory_getRenderingSettingsService(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ServiceFactoryPrx __proxy = ::omero::api::ServiceFactoryPrx::uncheckedCast(__result->getProxy());
        ::omero::api::IRenderingSettingsPrx __ret;
        try
        {
            __ret = __proxy->end_getRenderingSettingsService(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_ServiceFactory_getRenderingSettingsServicePtr
newCallback_ServiceFactory_getRenderingSettingsService(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::IRenderingSettingsPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServiceFactory_getRenderingSettingsService<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ServiceFactory_getRenderingSettingsServicePtr
newCallback_ServiceFactory_getRenderingSettingsService(T* instance, void (T::*cb)(const ::omero::api::IRenderingSettingsPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServiceFactory_getRenderingSettingsService<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_ServiceFactory_getRenderingSettingsService : public Callback_ServiceFactory_getRenderingSettingsService_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::api::IRenderingSettingsPrx&, const CT&);

    Callback_ServiceFactory_getRenderingSettingsService(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ServiceFactoryPrx __proxy = ::omero::api::ServiceFactoryPrx::uncheckedCast(__result->getProxy());
        ::omero::api::IRenderingSettingsPrx __ret;
        try
        {
            __ret = __proxy->end_getRenderingSettingsService(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ServiceFactory_getRenderingSettingsServicePtr
newCallback_ServiceFactory_getRenderingSettingsService(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::IRenderingSettingsPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServiceFactory_getRenderingSettingsService<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ServiceFactory_getRenderingSettingsServicePtr
newCallback_ServiceFactory_getRenderingSettingsService(T* instance, void (T::*cb)(const ::omero::api::IRenderingSettingsPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServiceFactory_getRenderingSettingsService<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_ServiceFactory_getRepositoryInfoService : public Callback_ServiceFactory_getRepositoryInfoService_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::api::IRepositoryInfoPrx&);

    CallbackNC_ServiceFactory_getRepositoryInfoService(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ServiceFactoryPrx __proxy = ::omero::api::ServiceFactoryPrx::uncheckedCast(__result->getProxy());
        ::omero::api::IRepositoryInfoPrx __ret;
        try
        {
            __ret = __proxy->end_getRepositoryInfoService(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_ServiceFactory_getRepositoryInfoServicePtr
newCallback_ServiceFactory_getRepositoryInfoService(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::IRepositoryInfoPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServiceFactory_getRepositoryInfoService<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ServiceFactory_getRepositoryInfoServicePtr
newCallback_ServiceFactory_getRepositoryInfoService(T* instance, void (T::*cb)(const ::omero::api::IRepositoryInfoPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServiceFactory_getRepositoryInfoService<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_ServiceFactory_getRepositoryInfoService : public Callback_ServiceFactory_getRepositoryInfoService_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::api::IRepositoryInfoPrx&, const CT&);

    Callback_ServiceFactory_getRepositoryInfoService(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ServiceFactoryPrx __proxy = ::omero::api::ServiceFactoryPrx::uncheckedCast(__result->getProxy());
        ::omero::api::IRepositoryInfoPrx __ret;
        try
        {
            __ret = __proxy->end_getRepositoryInfoService(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ServiceFactory_getRepositoryInfoServicePtr
newCallback_ServiceFactory_getRepositoryInfoService(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::IRepositoryInfoPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServiceFactory_getRepositoryInfoService<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ServiceFactory_getRepositoryInfoServicePtr
newCallback_ServiceFactory_getRepositoryInfoService(T* instance, void (T::*cb)(const ::omero::api::IRepositoryInfoPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServiceFactory_getRepositoryInfoService<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_ServiceFactory_getRoiService : public Callback_ServiceFactory_getRoiService_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::api::IRoiPrx&);

    CallbackNC_ServiceFactory_getRoiService(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ServiceFactoryPrx __proxy = ::omero::api::ServiceFactoryPrx::uncheckedCast(__result->getProxy());
        ::omero::api::IRoiPrx __ret;
        try
        {
            __ret = __proxy->end_getRoiService(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_ServiceFactory_getRoiServicePtr
newCallback_ServiceFactory_getRoiService(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::IRoiPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServiceFactory_getRoiService<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ServiceFactory_getRoiServicePtr
newCallback_ServiceFactory_getRoiService(T* instance, void (T::*cb)(const ::omero::api::IRoiPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServiceFactory_getRoiService<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_ServiceFactory_getRoiService : public Callback_ServiceFactory_getRoiService_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::api::IRoiPrx&, const CT&);

    Callback_ServiceFactory_getRoiService(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ServiceFactoryPrx __proxy = ::omero::api::ServiceFactoryPrx::uncheckedCast(__result->getProxy());
        ::omero::api::IRoiPrx __ret;
        try
        {
            __ret = __proxy->end_getRoiService(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ServiceFactory_getRoiServicePtr
newCallback_ServiceFactory_getRoiService(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::IRoiPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServiceFactory_getRoiService<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ServiceFactory_getRoiServicePtr
newCallback_ServiceFactory_getRoiService(T* instance, void (T::*cb)(const ::omero::api::IRoiPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServiceFactory_getRoiService<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_ServiceFactory_getScriptService : public Callback_ServiceFactory_getScriptService_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::api::IScriptPrx&);

    CallbackNC_ServiceFactory_getScriptService(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ServiceFactoryPrx __proxy = ::omero::api::ServiceFactoryPrx::uncheckedCast(__result->getProxy());
        ::omero::api::IScriptPrx __ret;
        try
        {
            __ret = __proxy->end_getScriptService(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_ServiceFactory_getScriptServicePtr
newCallback_ServiceFactory_getScriptService(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::IScriptPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServiceFactory_getScriptService<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ServiceFactory_getScriptServicePtr
newCallback_ServiceFactory_getScriptService(T* instance, void (T::*cb)(const ::omero::api::IScriptPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServiceFactory_getScriptService<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_ServiceFactory_getScriptService : public Callback_ServiceFactory_getScriptService_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::api::IScriptPrx&, const CT&);

    Callback_ServiceFactory_getScriptService(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ServiceFactoryPrx __proxy = ::omero::api::ServiceFactoryPrx::uncheckedCast(__result->getProxy());
        ::omero::api::IScriptPrx __ret;
        try
        {
            __ret = __proxy->end_getScriptService(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ServiceFactory_getScriptServicePtr
newCallback_ServiceFactory_getScriptService(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::IScriptPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServiceFactory_getScriptService<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ServiceFactory_getScriptServicePtr
newCallback_ServiceFactory_getScriptService(T* instance, void (T::*cb)(const ::omero::api::IScriptPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServiceFactory_getScriptService<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_ServiceFactory_getSessionService : public Callback_ServiceFactory_getSessionService_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::api::ISessionPrx&);

    CallbackNC_ServiceFactory_getSessionService(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ServiceFactoryPrx __proxy = ::omero::api::ServiceFactoryPrx::uncheckedCast(__result->getProxy());
        ::omero::api::ISessionPrx __ret;
        try
        {
            __ret = __proxy->end_getSessionService(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_ServiceFactory_getSessionServicePtr
newCallback_ServiceFactory_getSessionService(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::ISessionPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServiceFactory_getSessionService<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ServiceFactory_getSessionServicePtr
newCallback_ServiceFactory_getSessionService(T* instance, void (T::*cb)(const ::omero::api::ISessionPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServiceFactory_getSessionService<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_ServiceFactory_getSessionService : public Callback_ServiceFactory_getSessionService_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::api::ISessionPrx&, const CT&);

    Callback_ServiceFactory_getSessionService(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ServiceFactoryPrx __proxy = ::omero::api::ServiceFactoryPrx::uncheckedCast(__result->getProxy());
        ::omero::api::ISessionPrx __ret;
        try
        {
            __ret = __proxy->end_getSessionService(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ServiceFactory_getSessionServicePtr
newCallback_ServiceFactory_getSessionService(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::ISessionPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServiceFactory_getSessionService<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ServiceFactory_getSessionServicePtr
newCallback_ServiceFactory_getSessionService(T* instance, void (T::*cb)(const ::omero::api::ISessionPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServiceFactory_getSessionService<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_ServiceFactory_getShareService : public Callback_ServiceFactory_getShareService_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::api::ISharePrx&);

    CallbackNC_ServiceFactory_getShareService(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ServiceFactoryPrx __proxy = ::omero::api::ServiceFactoryPrx::uncheckedCast(__result->getProxy());
        ::omero::api::ISharePrx __ret;
        try
        {
            __ret = __proxy->end_getShareService(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_ServiceFactory_getShareServicePtr
newCallback_ServiceFactory_getShareService(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::ISharePrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServiceFactory_getShareService<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ServiceFactory_getShareServicePtr
newCallback_ServiceFactory_getShareService(T* instance, void (T::*cb)(const ::omero::api::ISharePrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServiceFactory_getShareService<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_ServiceFactory_getShareService : public Callback_ServiceFactory_getShareService_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::api::ISharePrx&, const CT&);

    Callback_ServiceFactory_getShareService(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ServiceFactoryPrx __proxy = ::omero::api::ServiceFactoryPrx::uncheckedCast(__result->getProxy());
        ::omero::api::ISharePrx __ret;
        try
        {
            __ret = __proxy->end_getShareService(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ServiceFactory_getShareServicePtr
newCallback_ServiceFactory_getShareService(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::ISharePrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServiceFactory_getShareService<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ServiceFactory_getShareServicePtr
newCallback_ServiceFactory_getShareService(T* instance, void (T::*cb)(const ::omero::api::ISharePrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServiceFactory_getShareService<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_ServiceFactory_getTimelineService : public Callback_ServiceFactory_getTimelineService_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::api::ITimelinePrx&);

    CallbackNC_ServiceFactory_getTimelineService(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ServiceFactoryPrx __proxy = ::omero::api::ServiceFactoryPrx::uncheckedCast(__result->getProxy());
        ::omero::api::ITimelinePrx __ret;
        try
        {
            __ret = __proxy->end_getTimelineService(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_ServiceFactory_getTimelineServicePtr
newCallback_ServiceFactory_getTimelineService(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::ITimelinePrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServiceFactory_getTimelineService<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ServiceFactory_getTimelineServicePtr
newCallback_ServiceFactory_getTimelineService(T* instance, void (T::*cb)(const ::omero::api::ITimelinePrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServiceFactory_getTimelineService<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_ServiceFactory_getTimelineService : public Callback_ServiceFactory_getTimelineService_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::api::ITimelinePrx&, const CT&);

    Callback_ServiceFactory_getTimelineService(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ServiceFactoryPrx __proxy = ::omero::api::ServiceFactoryPrx::uncheckedCast(__result->getProxy());
        ::omero::api::ITimelinePrx __ret;
        try
        {
            __ret = __proxy->end_getTimelineService(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ServiceFactory_getTimelineServicePtr
newCallback_ServiceFactory_getTimelineService(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::ITimelinePrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServiceFactory_getTimelineService<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ServiceFactory_getTimelineServicePtr
newCallback_ServiceFactory_getTimelineService(T* instance, void (T::*cb)(const ::omero::api::ITimelinePrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServiceFactory_getTimelineService<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_ServiceFactory_getTypesService : public Callback_ServiceFactory_getTypesService_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::api::ITypesPrx&);

    CallbackNC_ServiceFactory_getTypesService(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ServiceFactoryPrx __proxy = ::omero::api::ServiceFactoryPrx::uncheckedCast(__result->getProxy());
        ::omero::api::ITypesPrx __ret;
        try
        {
            __ret = __proxy->end_getTypesService(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_ServiceFactory_getTypesServicePtr
newCallback_ServiceFactory_getTypesService(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::ITypesPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServiceFactory_getTypesService<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ServiceFactory_getTypesServicePtr
newCallback_ServiceFactory_getTypesService(T* instance, void (T::*cb)(const ::omero::api::ITypesPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServiceFactory_getTypesService<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_ServiceFactory_getTypesService : public Callback_ServiceFactory_getTypesService_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::api::ITypesPrx&, const CT&);

    Callback_ServiceFactory_getTypesService(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ServiceFactoryPrx __proxy = ::omero::api::ServiceFactoryPrx::uncheckedCast(__result->getProxy());
        ::omero::api::ITypesPrx __ret;
        try
        {
            __ret = __proxy->end_getTypesService(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ServiceFactory_getTypesServicePtr
newCallback_ServiceFactory_getTypesService(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::ITypesPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServiceFactory_getTypesService<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ServiceFactory_getTypesServicePtr
newCallback_ServiceFactory_getTypesService(T* instance, void (T::*cb)(const ::omero::api::ITypesPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServiceFactory_getTypesService<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_ServiceFactory_getUpdateService : public Callback_ServiceFactory_getUpdateService_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::api::IUpdatePrx&);

    CallbackNC_ServiceFactory_getUpdateService(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ServiceFactoryPrx __proxy = ::omero::api::ServiceFactoryPrx::uncheckedCast(__result->getProxy());
        ::omero::api::IUpdatePrx __ret;
        try
        {
            __ret = __proxy->end_getUpdateService(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_ServiceFactory_getUpdateServicePtr
newCallback_ServiceFactory_getUpdateService(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::IUpdatePrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServiceFactory_getUpdateService<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ServiceFactory_getUpdateServicePtr
newCallback_ServiceFactory_getUpdateService(T* instance, void (T::*cb)(const ::omero::api::IUpdatePrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServiceFactory_getUpdateService<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_ServiceFactory_getUpdateService : public Callback_ServiceFactory_getUpdateService_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::api::IUpdatePrx&, const CT&);

    Callback_ServiceFactory_getUpdateService(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ServiceFactoryPrx __proxy = ::omero::api::ServiceFactoryPrx::uncheckedCast(__result->getProxy());
        ::omero::api::IUpdatePrx __ret;
        try
        {
            __ret = __proxy->end_getUpdateService(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ServiceFactory_getUpdateServicePtr
newCallback_ServiceFactory_getUpdateService(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::IUpdatePrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServiceFactory_getUpdateService<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ServiceFactory_getUpdateServicePtr
newCallback_ServiceFactory_getUpdateService(T* instance, void (T::*cb)(const ::omero::api::IUpdatePrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServiceFactory_getUpdateService<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_ServiceFactory_getMetadataService : public Callback_ServiceFactory_getMetadataService_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::api::IMetadataPrx&);

    CallbackNC_ServiceFactory_getMetadataService(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ServiceFactoryPrx __proxy = ::omero::api::ServiceFactoryPrx::uncheckedCast(__result->getProxy());
        ::omero::api::IMetadataPrx __ret;
        try
        {
            __ret = __proxy->end_getMetadataService(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_ServiceFactory_getMetadataServicePtr
newCallback_ServiceFactory_getMetadataService(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::IMetadataPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServiceFactory_getMetadataService<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ServiceFactory_getMetadataServicePtr
newCallback_ServiceFactory_getMetadataService(T* instance, void (T::*cb)(const ::omero::api::IMetadataPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServiceFactory_getMetadataService<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_ServiceFactory_getMetadataService : public Callback_ServiceFactory_getMetadataService_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::api::IMetadataPrx&, const CT&);

    Callback_ServiceFactory_getMetadataService(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ServiceFactoryPrx __proxy = ::omero::api::ServiceFactoryPrx::uncheckedCast(__result->getProxy());
        ::omero::api::IMetadataPrx __ret;
        try
        {
            __ret = __proxy->end_getMetadataService(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ServiceFactory_getMetadataServicePtr
newCallback_ServiceFactory_getMetadataService(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::IMetadataPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServiceFactory_getMetadataService<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ServiceFactory_getMetadataServicePtr
newCallback_ServiceFactory_getMetadataService(T* instance, void (T::*cb)(const ::omero::api::IMetadataPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServiceFactory_getMetadataService<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_ServiceFactory_createGateway : public Callback_ServiceFactory_createGateway_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::api::GatewayPrx&);

    CallbackNC_ServiceFactory_createGateway(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ServiceFactoryPrx __proxy = ::omero::api::ServiceFactoryPrx::uncheckedCast(__result->getProxy());
        ::omero::api::GatewayPrx __ret;
        try
        {
            __ret = __proxy->end_createGateway(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_ServiceFactory_createGatewayPtr
newCallback_ServiceFactory_createGateway(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::GatewayPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServiceFactory_createGateway<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ServiceFactory_createGatewayPtr
newCallback_ServiceFactory_createGateway(T* instance, void (T::*cb)(const ::omero::api::GatewayPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServiceFactory_createGateway<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_ServiceFactory_createGateway : public Callback_ServiceFactory_createGateway_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::api::GatewayPrx&, const CT&);

    Callback_ServiceFactory_createGateway(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ServiceFactoryPrx __proxy = ::omero::api::ServiceFactoryPrx::uncheckedCast(__result->getProxy());
        ::omero::api::GatewayPrx __ret;
        try
        {
            __ret = __proxy->end_createGateway(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ServiceFactory_createGatewayPtr
newCallback_ServiceFactory_createGateway(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::GatewayPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServiceFactory_createGateway<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ServiceFactory_createGatewayPtr
newCallback_ServiceFactory_createGateway(T* instance, void (T::*cb)(const ::omero::api::GatewayPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServiceFactory_createGateway<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_ServiceFactory_createExporter : public Callback_ServiceFactory_createExporter_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::api::ExporterPrx&);

    CallbackNC_ServiceFactory_createExporter(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ServiceFactoryPrx __proxy = ::omero::api::ServiceFactoryPrx::uncheckedCast(__result->getProxy());
        ::omero::api::ExporterPrx __ret;
        try
        {
            __ret = __proxy->end_createExporter(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_ServiceFactory_createExporterPtr
newCallback_ServiceFactory_createExporter(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::ExporterPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServiceFactory_createExporter<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ServiceFactory_createExporterPtr
newCallback_ServiceFactory_createExporter(T* instance, void (T::*cb)(const ::omero::api::ExporterPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServiceFactory_createExporter<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_ServiceFactory_createExporter : public Callback_ServiceFactory_createExporter_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::api::ExporterPrx&, const CT&);

    Callback_ServiceFactory_createExporter(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ServiceFactoryPrx __proxy = ::omero::api::ServiceFactoryPrx::uncheckedCast(__result->getProxy());
        ::omero::api::ExporterPrx __ret;
        try
        {
            __ret = __proxy->end_createExporter(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ServiceFactory_createExporterPtr
newCallback_ServiceFactory_createExporter(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::ExporterPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServiceFactory_createExporter<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ServiceFactory_createExporterPtr
newCallback_ServiceFactory_createExporter(T* instance, void (T::*cb)(const ::omero::api::ExporterPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServiceFactory_createExporter<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_ServiceFactory_createJobHandle : public Callback_ServiceFactory_createJobHandle_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::api::JobHandlePrx&);

    CallbackNC_ServiceFactory_createJobHandle(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ServiceFactoryPrx __proxy = ::omero::api::ServiceFactoryPrx::uncheckedCast(__result->getProxy());
        ::omero::api::JobHandlePrx __ret;
        try
        {
            __ret = __proxy->end_createJobHandle(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_ServiceFactory_createJobHandlePtr
newCallback_ServiceFactory_createJobHandle(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::JobHandlePrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServiceFactory_createJobHandle<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ServiceFactory_createJobHandlePtr
newCallback_ServiceFactory_createJobHandle(T* instance, void (T::*cb)(const ::omero::api::JobHandlePrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServiceFactory_createJobHandle<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_ServiceFactory_createJobHandle : public Callback_ServiceFactory_createJobHandle_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::api::JobHandlePrx&, const CT&);

    Callback_ServiceFactory_createJobHandle(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ServiceFactoryPrx __proxy = ::omero::api::ServiceFactoryPrx::uncheckedCast(__result->getProxy());
        ::omero::api::JobHandlePrx __ret;
        try
        {
            __ret = __proxy->end_createJobHandle(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ServiceFactory_createJobHandlePtr
newCallback_ServiceFactory_createJobHandle(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::JobHandlePrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServiceFactory_createJobHandle<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ServiceFactory_createJobHandlePtr
newCallback_ServiceFactory_createJobHandle(T* instance, void (T::*cb)(const ::omero::api::JobHandlePrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServiceFactory_createJobHandle<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_ServiceFactory_createRawFileStore : public Callback_ServiceFactory_createRawFileStore_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::api::RawFileStorePrx&);

    CallbackNC_ServiceFactory_createRawFileStore(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ServiceFactoryPrx __proxy = ::omero::api::ServiceFactoryPrx::uncheckedCast(__result->getProxy());
        ::omero::api::RawFileStorePrx __ret;
        try
        {
            __ret = __proxy->end_createRawFileStore(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_ServiceFactory_createRawFileStorePtr
newCallback_ServiceFactory_createRawFileStore(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::RawFileStorePrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServiceFactory_createRawFileStore<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ServiceFactory_createRawFileStorePtr
newCallback_ServiceFactory_createRawFileStore(T* instance, void (T::*cb)(const ::omero::api::RawFileStorePrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServiceFactory_createRawFileStore<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_ServiceFactory_createRawFileStore : public Callback_ServiceFactory_createRawFileStore_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::api::RawFileStorePrx&, const CT&);

    Callback_ServiceFactory_createRawFileStore(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ServiceFactoryPrx __proxy = ::omero::api::ServiceFactoryPrx::uncheckedCast(__result->getProxy());
        ::omero::api::RawFileStorePrx __ret;
        try
        {
            __ret = __proxy->end_createRawFileStore(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ServiceFactory_createRawFileStorePtr
newCallback_ServiceFactory_createRawFileStore(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::RawFileStorePrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServiceFactory_createRawFileStore<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ServiceFactory_createRawFileStorePtr
newCallback_ServiceFactory_createRawFileStore(T* instance, void (T::*cb)(const ::omero::api::RawFileStorePrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServiceFactory_createRawFileStore<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_ServiceFactory_createRawPixelsStore : public Callback_ServiceFactory_createRawPixelsStore_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::api::RawPixelsStorePrx&);

    CallbackNC_ServiceFactory_createRawPixelsStore(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ServiceFactoryPrx __proxy = ::omero::api::ServiceFactoryPrx::uncheckedCast(__result->getProxy());
        ::omero::api::RawPixelsStorePrx __ret;
        try
        {
            __ret = __proxy->end_createRawPixelsStore(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_ServiceFactory_createRawPixelsStorePtr
newCallback_ServiceFactory_createRawPixelsStore(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::RawPixelsStorePrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServiceFactory_createRawPixelsStore<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ServiceFactory_createRawPixelsStorePtr
newCallback_ServiceFactory_createRawPixelsStore(T* instance, void (T::*cb)(const ::omero::api::RawPixelsStorePrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServiceFactory_createRawPixelsStore<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_ServiceFactory_createRawPixelsStore : public Callback_ServiceFactory_createRawPixelsStore_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::api::RawPixelsStorePrx&, const CT&);

    Callback_ServiceFactory_createRawPixelsStore(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ServiceFactoryPrx __proxy = ::omero::api::ServiceFactoryPrx::uncheckedCast(__result->getProxy());
        ::omero::api::RawPixelsStorePrx __ret;
        try
        {
            __ret = __proxy->end_createRawPixelsStore(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ServiceFactory_createRawPixelsStorePtr
newCallback_ServiceFactory_createRawPixelsStore(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::RawPixelsStorePrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServiceFactory_createRawPixelsStore<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ServiceFactory_createRawPixelsStorePtr
newCallback_ServiceFactory_createRawPixelsStore(T* instance, void (T::*cb)(const ::omero::api::RawPixelsStorePrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServiceFactory_createRawPixelsStore<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_ServiceFactory_createRenderingEngine : public Callback_ServiceFactory_createRenderingEngine_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::api::RenderingEnginePrx&);

    CallbackNC_ServiceFactory_createRenderingEngine(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ServiceFactoryPrx __proxy = ::omero::api::ServiceFactoryPrx::uncheckedCast(__result->getProxy());
        ::omero::api::RenderingEnginePrx __ret;
        try
        {
            __ret = __proxy->end_createRenderingEngine(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_ServiceFactory_createRenderingEnginePtr
newCallback_ServiceFactory_createRenderingEngine(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::RenderingEnginePrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServiceFactory_createRenderingEngine<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ServiceFactory_createRenderingEnginePtr
newCallback_ServiceFactory_createRenderingEngine(T* instance, void (T::*cb)(const ::omero::api::RenderingEnginePrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServiceFactory_createRenderingEngine<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_ServiceFactory_createRenderingEngine : public Callback_ServiceFactory_createRenderingEngine_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::api::RenderingEnginePrx&, const CT&);

    Callback_ServiceFactory_createRenderingEngine(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ServiceFactoryPrx __proxy = ::omero::api::ServiceFactoryPrx::uncheckedCast(__result->getProxy());
        ::omero::api::RenderingEnginePrx __ret;
        try
        {
            __ret = __proxy->end_createRenderingEngine(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ServiceFactory_createRenderingEnginePtr
newCallback_ServiceFactory_createRenderingEngine(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::RenderingEnginePrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServiceFactory_createRenderingEngine<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ServiceFactory_createRenderingEnginePtr
newCallback_ServiceFactory_createRenderingEngine(T* instance, void (T::*cb)(const ::omero::api::RenderingEnginePrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServiceFactory_createRenderingEngine<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_ServiceFactory_createSearchService : public Callback_ServiceFactory_createSearchService_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::api::SearchPrx&);

    CallbackNC_ServiceFactory_createSearchService(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ServiceFactoryPrx __proxy = ::omero::api::ServiceFactoryPrx::uncheckedCast(__result->getProxy());
        ::omero::api::SearchPrx __ret;
        try
        {
            __ret = __proxy->end_createSearchService(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_ServiceFactory_createSearchServicePtr
newCallback_ServiceFactory_createSearchService(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::SearchPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServiceFactory_createSearchService<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ServiceFactory_createSearchServicePtr
newCallback_ServiceFactory_createSearchService(T* instance, void (T::*cb)(const ::omero::api::SearchPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServiceFactory_createSearchService<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_ServiceFactory_createSearchService : public Callback_ServiceFactory_createSearchService_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::api::SearchPrx&, const CT&);

    Callback_ServiceFactory_createSearchService(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ServiceFactoryPrx __proxy = ::omero::api::ServiceFactoryPrx::uncheckedCast(__result->getProxy());
        ::omero::api::SearchPrx __ret;
        try
        {
            __ret = __proxy->end_createSearchService(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ServiceFactory_createSearchServicePtr
newCallback_ServiceFactory_createSearchService(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::SearchPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServiceFactory_createSearchService<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ServiceFactory_createSearchServicePtr
newCallback_ServiceFactory_createSearchService(T* instance, void (T::*cb)(const ::omero::api::SearchPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServiceFactory_createSearchService<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_ServiceFactory_createThumbnailStore : public Callback_ServiceFactory_createThumbnailStore_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::api::ThumbnailStorePrx&);

    CallbackNC_ServiceFactory_createThumbnailStore(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ServiceFactoryPrx __proxy = ::omero::api::ServiceFactoryPrx::uncheckedCast(__result->getProxy());
        ::omero::api::ThumbnailStorePrx __ret;
        try
        {
            __ret = __proxy->end_createThumbnailStore(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_ServiceFactory_createThumbnailStorePtr
newCallback_ServiceFactory_createThumbnailStore(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::ThumbnailStorePrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServiceFactory_createThumbnailStore<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ServiceFactory_createThumbnailStorePtr
newCallback_ServiceFactory_createThumbnailStore(T* instance, void (T::*cb)(const ::omero::api::ThumbnailStorePrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServiceFactory_createThumbnailStore<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_ServiceFactory_createThumbnailStore : public Callback_ServiceFactory_createThumbnailStore_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::api::ThumbnailStorePrx&, const CT&);

    Callback_ServiceFactory_createThumbnailStore(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ServiceFactoryPrx __proxy = ::omero::api::ServiceFactoryPrx::uncheckedCast(__result->getProxy());
        ::omero::api::ThumbnailStorePrx __ret;
        try
        {
            __ret = __proxy->end_createThumbnailStore(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ServiceFactory_createThumbnailStorePtr
newCallback_ServiceFactory_createThumbnailStore(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::ThumbnailStorePrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServiceFactory_createThumbnailStore<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ServiceFactory_createThumbnailStorePtr
newCallback_ServiceFactory_createThumbnailStore(T* instance, void (T::*cb)(const ::omero::api::ThumbnailStorePrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServiceFactory_createThumbnailStore<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_ServiceFactory_sharedResources : public Callback_ServiceFactory_sharedResources_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::grid::SharedResourcesPrx&);

    CallbackNC_ServiceFactory_sharedResources(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ServiceFactoryPrx __proxy = ::omero::api::ServiceFactoryPrx::uncheckedCast(__result->getProxy());
        ::omero::grid::SharedResourcesPrx __ret;
        try
        {
            __ret = __proxy->end_sharedResources(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_ServiceFactory_sharedResourcesPtr
newCallback_ServiceFactory_sharedResources(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::grid::SharedResourcesPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServiceFactory_sharedResources<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ServiceFactory_sharedResourcesPtr
newCallback_ServiceFactory_sharedResources(T* instance, void (T::*cb)(const ::omero::grid::SharedResourcesPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServiceFactory_sharedResources<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_ServiceFactory_sharedResources : public Callback_ServiceFactory_sharedResources_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::grid::SharedResourcesPrx&, const CT&);

    Callback_ServiceFactory_sharedResources(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ServiceFactoryPrx __proxy = ::omero::api::ServiceFactoryPrx::uncheckedCast(__result->getProxy());
        ::omero::grid::SharedResourcesPrx __ret;
        try
        {
            __ret = __proxy->end_sharedResources(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ServiceFactory_sharedResourcesPtr
newCallback_ServiceFactory_sharedResources(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::grid::SharedResourcesPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServiceFactory_sharedResources<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ServiceFactory_sharedResourcesPtr
newCallback_ServiceFactory_sharedResources(T* instance, void (T::*cb)(const ::omero::grid::SharedResourcesPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServiceFactory_sharedResources<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_ServiceFactory_getByName : public Callback_ServiceFactory_getByName_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::api::ServiceInterfacePrx&);

    CallbackNC_ServiceFactory_getByName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ServiceFactoryPrx __proxy = ::omero::api::ServiceFactoryPrx::uncheckedCast(__result->getProxy());
        ::omero::api::ServiceInterfacePrx __ret;
        try
        {
            __ret = __proxy->end_getByName(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_ServiceFactory_getByNamePtr
newCallback_ServiceFactory_getByName(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::ServiceInterfacePrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServiceFactory_getByName<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ServiceFactory_getByNamePtr
newCallback_ServiceFactory_getByName(T* instance, void (T::*cb)(const ::omero::api::ServiceInterfacePrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServiceFactory_getByName<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_ServiceFactory_getByName : public Callback_ServiceFactory_getByName_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::api::ServiceInterfacePrx&, const CT&);

    Callback_ServiceFactory_getByName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ServiceFactoryPrx __proxy = ::omero::api::ServiceFactoryPrx::uncheckedCast(__result->getProxy());
        ::omero::api::ServiceInterfacePrx __ret;
        try
        {
            __ret = __proxy->end_getByName(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ServiceFactory_getByNamePtr
newCallback_ServiceFactory_getByName(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::ServiceInterfacePrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServiceFactory_getByName<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ServiceFactory_getByNamePtr
newCallback_ServiceFactory_getByName(T* instance, void (T::*cb)(const ::omero::api::ServiceInterfacePrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServiceFactory_getByName<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_ServiceFactory_createByName : public Callback_ServiceFactory_createByName_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::api::StatefulServiceInterfacePrx&);

    CallbackNC_ServiceFactory_createByName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ServiceFactoryPrx __proxy = ::omero::api::ServiceFactoryPrx::uncheckedCast(__result->getProxy());
        ::omero::api::StatefulServiceInterfacePrx __ret;
        try
        {
            __ret = __proxy->end_createByName(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_ServiceFactory_createByNamePtr
newCallback_ServiceFactory_createByName(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::StatefulServiceInterfacePrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServiceFactory_createByName<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ServiceFactory_createByNamePtr
newCallback_ServiceFactory_createByName(T* instance, void (T::*cb)(const ::omero::api::StatefulServiceInterfacePrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServiceFactory_createByName<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_ServiceFactory_createByName : public Callback_ServiceFactory_createByName_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::api::StatefulServiceInterfacePrx&, const CT&);

    Callback_ServiceFactory_createByName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ServiceFactoryPrx __proxy = ::omero::api::ServiceFactoryPrx::uncheckedCast(__result->getProxy());
        ::omero::api::StatefulServiceInterfacePrx __ret;
        try
        {
            __ret = __proxy->end_createByName(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ServiceFactory_createByNamePtr
newCallback_ServiceFactory_createByName(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::StatefulServiceInterfacePrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServiceFactory_createByName<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ServiceFactory_createByNamePtr
newCallback_ServiceFactory_createByName(T* instance, void (T::*cb)(const ::omero::api::StatefulServiceInterfacePrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServiceFactory_createByName<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_ServiceFactory_subscribe : public Callback_ServiceFactory_subscribe_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_ServiceFactory_subscribe(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ServiceFactoryPrx __proxy = ::omero::api::ServiceFactoryPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_subscribe(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)();
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
#endif
        }
    }

    Response response;
};

template<class T> Callback_ServiceFactory_subscribePtr
newCallback_ServiceFactory_subscribe(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServiceFactory_subscribe<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ServiceFactory_subscribePtr
newCallback_ServiceFactory_subscribe(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServiceFactory_subscribe<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_ServiceFactory_subscribePtr
newCallback_ServiceFactory_subscribe(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServiceFactory_subscribe<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ServiceFactory_subscribePtr
newCallback_ServiceFactory_subscribe(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServiceFactory_subscribe<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_ServiceFactory_subscribe : public Callback_ServiceFactory_subscribe_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_ServiceFactory_subscribe(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ServiceFactoryPrx __proxy = ::omero::api::ServiceFactoryPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_subscribe(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ServiceFactory_subscribePtr
newCallback_ServiceFactory_subscribe(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServiceFactory_subscribe<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ServiceFactory_subscribePtr
newCallback_ServiceFactory_subscribe(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServiceFactory_subscribe<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_ServiceFactory_subscribePtr
newCallback_ServiceFactory_subscribe(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServiceFactory_subscribe<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ServiceFactory_subscribePtr
newCallback_ServiceFactory_subscribe(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServiceFactory_subscribe<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_ServiceFactory_setCallback : public Callback_ServiceFactory_setCallback_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_ServiceFactory_setCallback(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ServiceFactoryPrx __proxy = ::omero::api::ServiceFactoryPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_setCallback(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)();
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
#endif
        }
    }

    Response response;
};

template<class T> Callback_ServiceFactory_setCallbackPtr
newCallback_ServiceFactory_setCallback(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServiceFactory_setCallback<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ServiceFactory_setCallbackPtr
newCallback_ServiceFactory_setCallback(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServiceFactory_setCallback<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_ServiceFactory_setCallbackPtr
newCallback_ServiceFactory_setCallback(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServiceFactory_setCallback<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ServiceFactory_setCallbackPtr
newCallback_ServiceFactory_setCallback(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServiceFactory_setCallback<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_ServiceFactory_setCallback : public Callback_ServiceFactory_setCallback_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_ServiceFactory_setCallback(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ServiceFactoryPrx __proxy = ::omero::api::ServiceFactoryPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_setCallback(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ServiceFactory_setCallbackPtr
newCallback_ServiceFactory_setCallback(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServiceFactory_setCallback<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ServiceFactory_setCallbackPtr
newCallback_ServiceFactory_setCallback(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServiceFactory_setCallback<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_ServiceFactory_setCallbackPtr
newCallback_ServiceFactory_setCallback(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServiceFactory_setCallback<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ServiceFactory_setCallbackPtr
newCallback_ServiceFactory_setCallback(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServiceFactory_setCallback<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_ServiceFactory_close : public Callback_ServiceFactory_close_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_ServiceFactory_close(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ServiceFactoryPrx __proxy = ::omero::api::ServiceFactoryPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_close(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)();
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
#endif
        }
    }

    Response response;
};

template<class T> Callback_ServiceFactory_closePtr
newCallback_ServiceFactory_close(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServiceFactory_close<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ServiceFactory_closePtr
newCallback_ServiceFactory_close(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServiceFactory_close<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_ServiceFactory_closePtr
newCallback_ServiceFactory_close(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServiceFactory_close<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ServiceFactory_closePtr
newCallback_ServiceFactory_close(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServiceFactory_close<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_ServiceFactory_close : public Callback_ServiceFactory_close_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_ServiceFactory_close(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ServiceFactoryPrx __proxy = ::omero::api::ServiceFactoryPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_close(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ServiceFactory_closePtr
newCallback_ServiceFactory_close(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServiceFactory_close<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ServiceFactory_closePtr
newCallback_ServiceFactory_close(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServiceFactory_close<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_ServiceFactory_closePtr
newCallback_ServiceFactory_close(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServiceFactory_close<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ServiceFactory_closePtr
newCallback_ServiceFactory_close(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServiceFactory_close<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_ServiceFactory_closeOnDestroy : public Callback_ServiceFactory_closeOnDestroy_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_ServiceFactory_closeOnDestroy(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ServiceFactoryPrx __proxy = ::omero::api::ServiceFactoryPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_closeOnDestroy(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)();
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
#endif
        }
    }

    Response response;
};

template<class T> Callback_ServiceFactory_closeOnDestroyPtr
newCallback_ServiceFactory_closeOnDestroy(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServiceFactory_closeOnDestroy<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ServiceFactory_closeOnDestroyPtr
newCallback_ServiceFactory_closeOnDestroy(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServiceFactory_closeOnDestroy<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_ServiceFactory_closeOnDestroyPtr
newCallback_ServiceFactory_closeOnDestroy(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServiceFactory_closeOnDestroy<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ServiceFactory_closeOnDestroyPtr
newCallback_ServiceFactory_closeOnDestroy(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServiceFactory_closeOnDestroy<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_ServiceFactory_closeOnDestroy : public Callback_ServiceFactory_closeOnDestroy_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_ServiceFactory_closeOnDestroy(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ServiceFactoryPrx __proxy = ::omero::api::ServiceFactoryPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_closeOnDestroy(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ServiceFactory_closeOnDestroyPtr
newCallback_ServiceFactory_closeOnDestroy(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServiceFactory_closeOnDestroy<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ServiceFactory_closeOnDestroyPtr
newCallback_ServiceFactory_closeOnDestroy(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServiceFactory_closeOnDestroy<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_ServiceFactory_closeOnDestroyPtr
newCallback_ServiceFactory_closeOnDestroy(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServiceFactory_closeOnDestroy<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ServiceFactory_closeOnDestroyPtr
newCallback_ServiceFactory_closeOnDestroy(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServiceFactory_closeOnDestroy<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_ServiceFactory_detachOnDestroy : public Callback_ServiceFactory_detachOnDestroy_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_ServiceFactory_detachOnDestroy(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ServiceFactoryPrx __proxy = ::omero::api::ServiceFactoryPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_detachOnDestroy(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)();
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
#endif
        }
    }

    Response response;
};

template<class T> Callback_ServiceFactory_detachOnDestroyPtr
newCallback_ServiceFactory_detachOnDestroy(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServiceFactory_detachOnDestroy<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ServiceFactory_detachOnDestroyPtr
newCallback_ServiceFactory_detachOnDestroy(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServiceFactory_detachOnDestroy<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_ServiceFactory_detachOnDestroyPtr
newCallback_ServiceFactory_detachOnDestroy(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServiceFactory_detachOnDestroy<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ServiceFactory_detachOnDestroyPtr
newCallback_ServiceFactory_detachOnDestroy(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServiceFactory_detachOnDestroy<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_ServiceFactory_detachOnDestroy : public Callback_ServiceFactory_detachOnDestroy_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_ServiceFactory_detachOnDestroy(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ServiceFactoryPrx __proxy = ::omero::api::ServiceFactoryPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_detachOnDestroy(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ServiceFactory_detachOnDestroyPtr
newCallback_ServiceFactory_detachOnDestroy(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServiceFactory_detachOnDestroy<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ServiceFactory_detachOnDestroyPtr
newCallback_ServiceFactory_detachOnDestroy(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServiceFactory_detachOnDestroy<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_ServiceFactory_detachOnDestroyPtr
newCallback_ServiceFactory_detachOnDestroy(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServiceFactory_detachOnDestroy<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ServiceFactory_detachOnDestroyPtr
newCallback_ServiceFactory_detachOnDestroy(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServiceFactory_detachOnDestroy<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_ServiceFactory_activeServices : public Callback_ServiceFactory_activeServices_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::api::StringSet&);

    CallbackNC_ServiceFactory_activeServices(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ServiceFactoryPrx __proxy = ::omero::api::ServiceFactoryPrx::uncheckedCast(__result->getProxy());
        ::omero::api::StringSet __ret;
        try
        {
            __ret = __proxy->end_activeServices(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_ServiceFactory_activeServicesPtr
newCallback_ServiceFactory_activeServices(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::StringSet&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServiceFactory_activeServices<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ServiceFactory_activeServicesPtr
newCallback_ServiceFactory_activeServices(T* instance, void (T::*cb)(const ::omero::api::StringSet&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServiceFactory_activeServices<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_ServiceFactory_activeServices : public Callback_ServiceFactory_activeServices_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::api::StringSet&, const CT&);

    Callback_ServiceFactory_activeServices(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ServiceFactoryPrx __proxy = ::omero::api::ServiceFactoryPrx::uncheckedCast(__result->getProxy());
        ::omero::api::StringSet __ret;
        try
        {
            __ret = __proxy->end_activeServices(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ServiceFactory_activeServicesPtr
newCallback_ServiceFactory_activeServices(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::StringSet&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServiceFactory_activeServices<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ServiceFactory_activeServicesPtr
newCallback_ServiceFactory_activeServices(T* instance, void (T::*cb)(const ::omero::api::StringSet&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServiceFactory_activeServices<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_ServiceFactory_keepAllAlive : public Callback_ServiceFactory_keepAllAlive_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Long);

    CallbackNC_ServiceFactory_keepAllAlive(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ServiceFactoryPrx __proxy = ::omero::api::ServiceFactoryPrx::uncheckedCast(__result->getProxy());
        ::Ice::Long __ret;
        try
        {
            __ret = __proxy->end_keepAllAlive(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_ServiceFactory_keepAllAlivePtr
newCallback_ServiceFactory_keepAllAlive(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Long), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServiceFactory_keepAllAlive<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ServiceFactory_keepAllAlivePtr
newCallback_ServiceFactory_keepAllAlive(T* instance, void (T::*cb)(::Ice::Long), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServiceFactory_keepAllAlive<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_ServiceFactory_keepAllAlive : public Callback_ServiceFactory_keepAllAlive_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Long, const CT&);

    Callback_ServiceFactory_keepAllAlive(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ServiceFactoryPrx __proxy = ::omero::api::ServiceFactoryPrx::uncheckedCast(__result->getProxy());
        ::Ice::Long __ret;
        try
        {
            __ret = __proxy->end_keepAllAlive(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ServiceFactory_keepAllAlivePtr
newCallback_ServiceFactory_keepAllAlive(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Long, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServiceFactory_keepAllAlive<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ServiceFactory_keepAllAlivePtr
newCallback_ServiceFactory_keepAllAlive(T* instance, void (T::*cb)(::Ice::Long, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServiceFactory_keepAllAlive<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_ServiceFactory_keepAlive : public Callback_ServiceFactory_keepAlive_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_ServiceFactory_keepAlive(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ServiceFactoryPrx __proxy = ::omero::api::ServiceFactoryPrx::uncheckedCast(__result->getProxy());
        bool __ret;
        try
        {
            __ret = __proxy->end_keepAlive(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_ServiceFactory_keepAlivePtr
newCallback_ServiceFactory_keepAlive(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServiceFactory_keepAlive<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ServiceFactory_keepAlivePtr
newCallback_ServiceFactory_keepAlive(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServiceFactory_keepAlive<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_ServiceFactory_keepAlive : public Callback_ServiceFactory_keepAlive_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_ServiceFactory_keepAlive(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ServiceFactoryPrx __proxy = ::omero::api::ServiceFactoryPrx::uncheckedCast(__result->getProxy());
        bool __ret;
        try
        {
            __ret = __proxy->end_keepAlive(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ServiceFactory_keepAlivePtr
newCallback_ServiceFactory_keepAlive(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServiceFactory_keepAlive<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ServiceFactory_keepAlivePtr
newCallback_ServiceFactory_keepAlive(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServiceFactory_keepAlive<T, CT>(instance, cb, excb, sentcb);
}

}

}

#endif
