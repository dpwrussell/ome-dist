// **********************************************************************
//
// Copyright (c) 2003-2011 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.4.2
//
// <auto-generated>
//
// Generated from file `Shape.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __omero_model__opt_hudson_workspace_OMERO_5_0_release_src_components_blitz_generated_omero_model_Shape_h__
#define __omero_model__opt_hudson_workspace_OMERO_5_0_release_src_components_blitz_generated_omero_model_Shape_h__

#include <Ice/LocalObjectF.h>
#include <Ice/ProxyF.h>
#include <Ice/ObjectF.h>
#include <Ice/Exception.h>
#include <Ice/LocalObject.h>
#include <Ice/Proxy.h>
#include <Ice/Object.h>
#include <Ice/Outgoing.h>
#include <Ice/OutgoingAsync.h>
#include <Ice/Incoming.h>
#include <Ice/Direct.h>
#include <Ice/FactoryTableInit.h>
#include <IceUtil/ScopedArray.h>
#include <Ice/StreamF.h>
#include <omero/model/IObject.h>
#include <omero/RTypes.h>
#include <omero/System.h>
#include <omero/Collections.h>
#include <Ice/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 304
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 > 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 2
#       error Ice patch level mismatch!
#   endif
#endif

namespace IceProxy
{

namespace omero
{

namespace model
{

class Roi;

class Details;

class Shape;

}

}

}

namespace omero
{

namespace model
{

class Roi;
bool operator==(const Roi&, const Roi&);
bool operator<(const Roi&, const Roi&);

class Details;
bool operator==(const Details&, const Details&);
bool operator<(const Details&, const Details&);

class Shape;
bool operator==(const Shape&, const Shape&);
bool operator<(const Shape&, const Shape&);

}

}

namespace IceInternal
{

::Ice::Object* upCast(::omero::model::Roi*);
::IceProxy::Ice::Object* upCast(::IceProxy::omero::model::Roi*);

::Ice::Object* upCast(::omero::model::Details*);
::IceProxy::Ice::Object* upCast(::IceProxy::omero::model::Details*);

::Ice::Object* upCast(::omero::model::Shape*);
::IceProxy::Ice::Object* upCast(::IceProxy::omero::model::Shape*);

}

namespace omero
{

namespace model
{

typedef ::IceInternal::Handle< ::omero::model::Roi> RoiPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::omero::model::Roi> RoiPrx;

void __read(::IceInternal::BasicStream*, RoiPrx&);
void __patch__RoiPtr(void*, ::Ice::ObjectPtr&);

typedef ::IceInternal::Handle< ::omero::model::Details> DetailsPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::omero::model::Details> DetailsPrx;

void __read(::IceInternal::BasicStream*, DetailsPrx&);
void __patch__DetailsPtr(void*, ::Ice::ObjectPtr&);

typedef ::IceInternal::Handle< ::omero::model::Shape> ShapePtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::omero::model::Shape> ShapePrx;

void __read(::IceInternal::BasicStream*, ShapePrx&);
void __patch__ShapePtr(void*, ::Ice::ObjectPtr&);

}

}

namespace omero
{

namespace model
{

class Callback_Shape_getVersion_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Shape_getVersion_Base> Callback_Shape_getVersionPtr;

class Callback_Shape_setVersion_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Shape_setVersion_Base> Callback_Shape_setVersionPtr;

class Callback_Shape_getTheZ_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Shape_getTheZ_Base> Callback_Shape_getTheZPtr;

class Callback_Shape_setTheZ_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Shape_setTheZ_Base> Callback_Shape_setTheZPtr;

class Callback_Shape_getTheT_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Shape_getTheT_Base> Callback_Shape_getTheTPtr;

class Callback_Shape_setTheT_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Shape_setTheT_Base> Callback_Shape_setTheTPtr;

class Callback_Shape_getTheC_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Shape_getTheC_Base> Callback_Shape_getTheCPtr;

class Callback_Shape_setTheC_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Shape_setTheC_Base> Callback_Shape_setTheCPtr;

class Callback_Shape_getRoi_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Shape_getRoi_Base> Callback_Shape_getRoiPtr;

class Callback_Shape_setRoi_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Shape_setRoi_Base> Callback_Shape_setRoiPtr;

class Callback_Shape_getLocked_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Shape_getLocked_Base> Callback_Shape_getLockedPtr;

class Callback_Shape_setLocked_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Shape_setLocked_Base> Callback_Shape_setLockedPtr;

class Callback_Shape_getG_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Shape_getG_Base> Callback_Shape_getGPtr;

class Callback_Shape_setG_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Shape_setG_Base> Callback_Shape_setGPtr;

class Callback_Shape_getTransform_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Shape_getTransform_Base> Callback_Shape_getTransformPtr;

class Callback_Shape_setTransform_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Shape_setTransform_Base> Callback_Shape_setTransformPtr;

class Callback_Shape_getVectorEffect_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Shape_getVectorEffect_Base> Callback_Shape_getVectorEffectPtr;

class Callback_Shape_setVectorEffect_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Shape_setVectorEffect_Base> Callback_Shape_setVectorEffectPtr;

class Callback_Shape_getVisibility_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Shape_getVisibility_Base> Callback_Shape_getVisibilityPtr;

class Callback_Shape_setVisibility_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Shape_setVisibility_Base> Callback_Shape_setVisibilityPtr;

class Callback_Shape_getFillColor_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Shape_getFillColor_Base> Callback_Shape_getFillColorPtr;

class Callback_Shape_setFillColor_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Shape_setFillColor_Base> Callback_Shape_setFillColorPtr;

class Callback_Shape_getFillRule_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Shape_getFillRule_Base> Callback_Shape_getFillRulePtr;

class Callback_Shape_setFillRule_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Shape_setFillRule_Base> Callback_Shape_setFillRulePtr;

class Callback_Shape_getStrokeColor_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Shape_getStrokeColor_Base> Callback_Shape_getStrokeColorPtr;

class Callback_Shape_setStrokeColor_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Shape_setStrokeColor_Base> Callback_Shape_setStrokeColorPtr;

class Callback_Shape_getStrokeDashArray_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Shape_getStrokeDashArray_Base> Callback_Shape_getStrokeDashArrayPtr;

class Callback_Shape_setStrokeDashArray_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Shape_setStrokeDashArray_Base> Callback_Shape_setStrokeDashArrayPtr;

class Callback_Shape_getStrokeDashOffset_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Shape_getStrokeDashOffset_Base> Callback_Shape_getStrokeDashOffsetPtr;

class Callback_Shape_setStrokeDashOffset_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Shape_setStrokeDashOffset_Base> Callback_Shape_setStrokeDashOffsetPtr;

class Callback_Shape_getStrokeLineCap_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Shape_getStrokeLineCap_Base> Callback_Shape_getStrokeLineCapPtr;

class Callback_Shape_setStrokeLineCap_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Shape_setStrokeLineCap_Base> Callback_Shape_setStrokeLineCapPtr;

class Callback_Shape_getStrokeLineJoin_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Shape_getStrokeLineJoin_Base> Callback_Shape_getStrokeLineJoinPtr;

class Callback_Shape_setStrokeLineJoin_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Shape_setStrokeLineJoin_Base> Callback_Shape_setStrokeLineJoinPtr;

class Callback_Shape_getStrokeMiterLimit_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Shape_getStrokeMiterLimit_Base> Callback_Shape_getStrokeMiterLimitPtr;

class Callback_Shape_setStrokeMiterLimit_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Shape_setStrokeMiterLimit_Base> Callback_Shape_setStrokeMiterLimitPtr;

class Callback_Shape_getStrokeWidth_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Shape_getStrokeWidth_Base> Callback_Shape_getStrokeWidthPtr;

class Callback_Shape_setStrokeWidth_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Shape_setStrokeWidth_Base> Callback_Shape_setStrokeWidthPtr;

class Callback_Shape_getFontFamily_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Shape_getFontFamily_Base> Callback_Shape_getFontFamilyPtr;

class Callback_Shape_setFontFamily_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Shape_setFontFamily_Base> Callback_Shape_setFontFamilyPtr;

class Callback_Shape_getFontSize_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Shape_getFontSize_Base> Callback_Shape_getFontSizePtr;

class Callback_Shape_setFontSize_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Shape_setFontSize_Base> Callback_Shape_setFontSizePtr;

class Callback_Shape_getFontStretch_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Shape_getFontStretch_Base> Callback_Shape_getFontStretchPtr;

class Callback_Shape_setFontStretch_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Shape_setFontStretch_Base> Callback_Shape_setFontStretchPtr;

class Callback_Shape_getFontStyle_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Shape_getFontStyle_Base> Callback_Shape_getFontStylePtr;

class Callback_Shape_setFontStyle_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Shape_setFontStyle_Base> Callback_Shape_setFontStylePtr;

class Callback_Shape_getFontVariant_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Shape_getFontVariant_Base> Callback_Shape_getFontVariantPtr;

class Callback_Shape_setFontVariant_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Shape_setFontVariant_Base> Callback_Shape_setFontVariantPtr;

class Callback_Shape_getFontWeight_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Shape_getFontWeight_Base> Callback_Shape_getFontWeightPtr;

class Callback_Shape_setFontWeight_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Shape_setFontWeight_Base> Callback_Shape_setFontWeightPtr;

}

}

namespace IceProxy
{

namespace omero
{

namespace model
{

class Shape : virtual public ::IceProxy::omero::model::IObject
{
public:

    ::omero::RIntPtr getVersion()
    {
        return getVersion(0);
    }
    ::omero::RIntPtr getVersion(const ::Ice::Context& __ctx)
    {
        return getVersion(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getVersion()
    {
        return begin_getVersion(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getVersion(const ::Ice::Context& __ctx)
    {
        return begin_getVersion(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getVersion(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getVersion(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getVersion(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getVersion(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getVersion(const ::omero::model::Callback_Shape_getVersionPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getVersion(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getVersion(const ::Ice::Context& __ctx, const ::omero::model::Callback_Shape_getVersionPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getVersion(&__ctx, __del, __cookie);
    }

    ::omero::RIntPtr end_getVersion(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::RIntPtr getVersion(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getVersion(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setVersion(const ::omero::RIntPtr& theVersion)
    {
        setVersion(theVersion, 0);
    }
    void setVersion(const ::omero::RIntPtr& theVersion, const ::Ice::Context& __ctx)
    {
        setVersion(theVersion, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setVersion(const ::omero::RIntPtr& theVersion)
    {
        return begin_setVersion(theVersion, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setVersion(const ::omero::RIntPtr& theVersion, const ::Ice::Context& __ctx)
    {
        return begin_setVersion(theVersion, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setVersion(const ::omero::RIntPtr& theVersion, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setVersion(theVersion, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setVersion(const ::omero::RIntPtr& theVersion, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setVersion(theVersion, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setVersion(const ::omero::RIntPtr& theVersion, const ::omero::model::Callback_Shape_setVersionPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setVersion(theVersion, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setVersion(const ::omero::RIntPtr& theVersion, const ::Ice::Context& __ctx, const ::omero::model::Callback_Shape_setVersionPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setVersion(theVersion, &__ctx, __del, __cookie);
    }

    void end_setVersion(const ::Ice::AsyncResultPtr&);
    
private:

    void setVersion(const ::omero::RIntPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setVersion(const ::omero::RIntPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::RIntPtr getTheZ()
    {
        return getTheZ(0);
    }
    ::omero::RIntPtr getTheZ(const ::Ice::Context& __ctx)
    {
        return getTheZ(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getTheZ()
    {
        return begin_getTheZ(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getTheZ(const ::Ice::Context& __ctx)
    {
        return begin_getTheZ(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getTheZ(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getTheZ(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getTheZ(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getTheZ(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getTheZ(const ::omero::model::Callback_Shape_getTheZPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getTheZ(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getTheZ(const ::Ice::Context& __ctx, const ::omero::model::Callback_Shape_getTheZPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getTheZ(&__ctx, __del, __cookie);
    }

    ::omero::RIntPtr end_getTheZ(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::RIntPtr getTheZ(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getTheZ(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setTheZ(const ::omero::RIntPtr& theTheZ)
    {
        setTheZ(theTheZ, 0);
    }
    void setTheZ(const ::omero::RIntPtr& theTheZ, const ::Ice::Context& __ctx)
    {
        setTheZ(theTheZ, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setTheZ(const ::omero::RIntPtr& theTheZ)
    {
        return begin_setTheZ(theTheZ, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setTheZ(const ::omero::RIntPtr& theTheZ, const ::Ice::Context& __ctx)
    {
        return begin_setTheZ(theTheZ, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setTheZ(const ::omero::RIntPtr& theTheZ, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setTheZ(theTheZ, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setTheZ(const ::omero::RIntPtr& theTheZ, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setTheZ(theTheZ, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setTheZ(const ::omero::RIntPtr& theTheZ, const ::omero::model::Callback_Shape_setTheZPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setTheZ(theTheZ, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setTheZ(const ::omero::RIntPtr& theTheZ, const ::Ice::Context& __ctx, const ::omero::model::Callback_Shape_setTheZPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setTheZ(theTheZ, &__ctx, __del, __cookie);
    }

    void end_setTheZ(const ::Ice::AsyncResultPtr&);
    
private:

    void setTheZ(const ::omero::RIntPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setTheZ(const ::omero::RIntPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::RIntPtr getTheT()
    {
        return getTheT(0);
    }
    ::omero::RIntPtr getTheT(const ::Ice::Context& __ctx)
    {
        return getTheT(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getTheT()
    {
        return begin_getTheT(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getTheT(const ::Ice::Context& __ctx)
    {
        return begin_getTheT(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getTheT(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getTheT(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getTheT(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getTheT(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getTheT(const ::omero::model::Callback_Shape_getTheTPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getTheT(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getTheT(const ::Ice::Context& __ctx, const ::omero::model::Callback_Shape_getTheTPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getTheT(&__ctx, __del, __cookie);
    }

    ::omero::RIntPtr end_getTheT(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::RIntPtr getTheT(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getTheT(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setTheT(const ::omero::RIntPtr& theTheT)
    {
        setTheT(theTheT, 0);
    }
    void setTheT(const ::omero::RIntPtr& theTheT, const ::Ice::Context& __ctx)
    {
        setTheT(theTheT, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setTheT(const ::omero::RIntPtr& theTheT)
    {
        return begin_setTheT(theTheT, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setTheT(const ::omero::RIntPtr& theTheT, const ::Ice::Context& __ctx)
    {
        return begin_setTheT(theTheT, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setTheT(const ::omero::RIntPtr& theTheT, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setTheT(theTheT, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setTheT(const ::omero::RIntPtr& theTheT, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setTheT(theTheT, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setTheT(const ::omero::RIntPtr& theTheT, const ::omero::model::Callback_Shape_setTheTPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setTheT(theTheT, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setTheT(const ::omero::RIntPtr& theTheT, const ::Ice::Context& __ctx, const ::omero::model::Callback_Shape_setTheTPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setTheT(theTheT, &__ctx, __del, __cookie);
    }

    void end_setTheT(const ::Ice::AsyncResultPtr&);
    
private:

    void setTheT(const ::omero::RIntPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setTheT(const ::omero::RIntPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::RIntPtr getTheC()
    {
        return getTheC(0);
    }
    ::omero::RIntPtr getTheC(const ::Ice::Context& __ctx)
    {
        return getTheC(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getTheC()
    {
        return begin_getTheC(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getTheC(const ::Ice::Context& __ctx)
    {
        return begin_getTheC(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getTheC(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getTheC(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getTheC(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getTheC(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getTheC(const ::omero::model::Callback_Shape_getTheCPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getTheC(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getTheC(const ::Ice::Context& __ctx, const ::omero::model::Callback_Shape_getTheCPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getTheC(&__ctx, __del, __cookie);
    }

    ::omero::RIntPtr end_getTheC(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::RIntPtr getTheC(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getTheC(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setTheC(const ::omero::RIntPtr& theTheC)
    {
        setTheC(theTheC, 0);
    }
    void setTheC(const ::omero::RIntPtr& theTheC, const ::Ice::Context& __ctx)
    {
        setTheC(theTheC, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setTheC(const ::omero::RIntPtr& theTheC)
    {
        return begin_setTheC(theTheC, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setTheC(const ::omero::RIntPtr& theTheC, const ::Ice::Context& __ctx)
    {
        return begin_setTheC(theTheC, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setTheC(const ::omero::RIntPtr& theTheC, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setTheC(theTheC, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setTheC(const ::omero::RIntPtr& theTheC, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setTheC(theTheC, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setTheC(const ::omero::RIntPtr& theTheC, const ::omero::model::Callback_Shape_setTheCPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setTheC(theTheC, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setTheC(const ::omero::RIntPtr& theTheC, const ::Ice::Context& __ctx, const ::omero::model::Callback_Shape_setTheCPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setTheC(theTheC, &__ctx, __del, __cookie);
    }

    void end_setTheC(const ::Ice::AsyncResultPtr&);
    
private:

    void setTheC(const ::omero::RIntPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setTheC(const ::omero::RIntPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::model::RoiPtr getRoi()
    {
        return getRoi(0);
    }
    ::omero::model::RoiPtr getRoi(const ::Ice::Context& __ctx)
    {
        return getRoi(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getRoi()
    {
        return begin_getRoi(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getRoi(const ::Ice::Context& __ctx)
    {
        return begin_getRoi(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getRoi(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getRoi(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getRoi(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getRoi(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getRoi(const ::omero::model::Callback_Shape_getRoiPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getRoi(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getRoi(const ::Ice::Context& __ctx, const ::omero::model::Callback_Shape_getRoiPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getRoi(&__ctx, __del, __cookie);
    }

    ::omero::model::RoiPtr end_getRoi(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::model::RoiPtr getRoi(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getRoi(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setRoi(const ::omero::model::RoiPtr& theRoi)
    {
        setRoi(theRoi, 0);
    }
    void setRoi(const ::omero::model::RoiPtr& theRoi, const ::Ice::Context& __ctx)
    {
        setRoi(theRoi, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setRoi(const ::omero::model::RoiPtr& theRoi)
    {
        return begin_setRoi(theRoi, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setRoi(const ::omero::model::RoiPtr& theRoi, const ::Ice::Context& __ctx)
    {
        return begin_setRoi(theRoi, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setRoi(const ::omero::model::RoiPtr& theRoi, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setRoi(theRoi, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setRoi(const ::omero::model::RoiPtr& theRoi, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setRoi(theRoi, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setRoi(const ::omero::model::RoiPtr& theRoi, const ::omero::model::Callback_Shape_setRoiPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setRoi(theRoi, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setRoi(const ::omero::model::RoiPtr& theRoi, const ::Ice::Context& __ctx, const ::omero::model::Callback_Shape_setRoiPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setRoi(theRoi, &__ctx, __del, __cookie);
    }

    void end_setRoi(const ::Ice::AsyncResultPtr&);
    
private:

    void setRoi(const ::omero::model::RoiPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setRoi(const ::omero::model::RoiPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::RBoolPtr getLocked()
    {
        return getLocked(0);
    }
    ::omero::RBoolPtr getLocked(const ::Ice::Context& __ctx)
    {
        return getLocked(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getLocked()
    {
        return begin_getLocked(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getLocked(const ::Ice::Context& __ctx)
    {
        return begin_getLocked(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getLocked(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getLocked(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getLocked(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getLocked(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getLocked(const ::omero::model::Callback_Shape_getLockedPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getLocked(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getLocked(const ::Ice::Context& __ctx, const ::omero::model::Callback_Shape_getLockedPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getLocked(&__ctx, __del, __cookie);
    }

    ::omero::RBoolPtr end_getLocked(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::RBoolPtr getLocked(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getLocked(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setLocked(const ::omero::RBoolPtr& theLocked)
    {
        setLocked(theLocked, 0);
    }
    void setLocked(const ::omero::RBoolPtr& theLocked, const ::Ice::Context& __ctx)
    {
        setLocked(theLocked, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setLocked(const ::omero::RBoolPtr& theLocked)
    {
        return begin_setLocked(theLocked, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setLocked(const ::omero::RBoolPtr& theLocked, const ::Ice::Context& __ctx)
    {
        return begin_setLocked(theLocked, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setLocked(const ::omero::RBoolPtr& theLocked, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setLocked(theLocked, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setLocked(const ::omero::RBoolPtr& theLocked, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setLocked(theLocked, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setLocked(const ::omero::RBoolPtr& theLocked, const ::omero::model::Callback_Shape_setLockedPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setLocked(theLocked, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setLocked(const ::omero::RBoolPtr& theLocked, const ::Ice::Context& __ctx, const ::omero::model::Callback_Shape_setLockedPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setLocked(theLocked, &__ctx, __del, __cookie);
    }

    void end_setLocked(const ::Ice::AsyncResultPtr&);
    
private:

    void setLocked(const ::omero::RBoolPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setLocked(const ::omero::RBoolPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::RStringPtr getG()
    {
        return getG(0);
    }
    ::omero::RStringPtr getG(const ::Ice::Context& __ctx)
    {
        return getG(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getG()
    {
        return begin_getG(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getG(const ::Ice::Context& __ctx)
    {
        return begin_getG(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getG(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getG(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getG(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getG(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getG(const ::omero::model::Callback_Shape_getGPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getG(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getG(const ::Ice::Context& __ctx, const ::omero::model::Callback_Shape_getGPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getG(&__ctx, __del, __cookie);
    }

    ::omero::RStringPtr end_getG(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::RStringPtr getG(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getG(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setG(const ::omero::RStringPtr& theG)
    {
        setG(theG, 0);
    }
    void setG(const ::omero::RStringPtr& theG, const ::Ice::Context& __ctx)
    {
        setG(theG, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setG(const ::omero::RStringPtr& theG)
    {
        return begin_setG(theG, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setG(const ::omero::RStringPtr& theG, const ::Ice::Context& __ctx)
    {
        return begin_setG(theG, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setG(const ::omero::RStringPtr& theG, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setG(theG, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setG(const ::omero::RStringPtr& theG, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setG(theG, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setG(const ::omero::RStringPtr& theG, const ::omero::model::Callback_Shape_setGPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setG(theG, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setG(const ::omero::RStringPtr& theG, const ::Ice::Context& __ctx, const ::omero::model::Callback_Shape_setGPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setG(theG, &__ctx, __del, __cookie);
    }

    void end_setG(const ::Ice::AsyncResultPtr&);
    
private:

    void setG(const ::omero::RStringPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setG(const ::omero::RStringPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::RStringPtr getTransform()
    {
        return getTransform(0);
    }
    ::omero::RStringPtr getTransform(const ::Ice::Context& __ctx)
    {
        return getTransform(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getTransform()
    {
        return begin_getTransform(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getTransform(const ::Ice::Context& __ctx)
    {
        return begin_getTransform(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getTransform(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getTransform(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getTransform(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getTransform(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getTransform(const ::omero::model::Callback_Shape_getTransformPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getTransform(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getTransform(const ::Ice::Context& __ctx, const ::omero::model::Callback_Shape_getTransformPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getTransform(&__ctx, __del, __cookie);
    }

    ::omero::RStringPtr end_getTransform(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::RStringPtr getTransform(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getTransform(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setTransform(const ::omero::RStringPtr& theTransform)
    {
        setTransform(theTransform, 0);
    }
    void setTransform(const ::omero::RStringPtr& theTransform, const ::Ice::Context& __ctx)
    {
        setTransform(theTransform, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setTransform(const ::omero::RStringPtr& theTransform)
    {
        return begin_setTransform(theTransform, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setTransform(const ::omero::RStringPtr& theTransform, const ::Ice::Context& __ctx)
    {
        return begin_setTransform(theTransform, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setTransform(const ::omero::RStringPtr& theTransform, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setTransform(theTransform, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setTransform(const ::omero::RStringPtr& theTransform, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setTransform(theTransform, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setTransform(const ::omero::RStringPtr& theTransform, const ::omero::model::Callback_Shape_setTransformPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setTransform(theTransform, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setTransform(const ::omero::RStringPtr& theTransform, const ::Ice::Context& __ctx, const ::omero::model::Callback_Shape_setTransformPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setTransform(theTransform, &__ctx, __del, __cookie);
    }

    void end_setTransform(const ::Ice::AsyncResultPtr&);
    
private:

    void setTransform(const ::omero::RStringPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setTransform(const ::omero::RStringPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::RStringPtr getVectorEffect()
    {
        return getVectorEffect(0);
    }
    ::omero::RStringPtr getVectorEffect(const ::Ice::Context& __ctx)
    {
        return getVectorEffect(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getVectorEffect()
    {
        return begin_getVectorEffect(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getVectorEffect(const ::Ice::Context& __ctx)
    {
        return begin_getVectorEffect(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getVectorEffect(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getVectorEffect(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getVectorEffect(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getVectorEffect(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getVectorEffect(const ::omero::model::Callback_Shape_getVectorEffectPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getVectorEffect(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getVectorEffect(const ::Ice::Context& __ctx, const ::omero::model::Callback_Shape_getVectorEffectPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getVectorEffect(&__ctx, __del, __cookie);
    }

    ::omero::RStringPtr end_getVectorEffect(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::RStringPtr getVectorEffect(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getVectorEffect(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setVectorEffect(const ::omero::RStringPtr& theVectorEffect)
    {
        setVectorEffect(theVectorEffect, 0);
    }
    void setVectorEffect(const ::omero::RStringPtr& theVectorEffect, const ::Ice::Context& __ctx)
    {
        setVectorEffect(theVectorEffect, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setVectorEffect(const ::omero::RStringPtr& theVectorEffect)
    {
        return begin_setVectorEffect(theVectorEffect, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setVectorEffect(const ::omero::RStringPtr& theVectorEffect, const ::Ice::Context& __ctx)
    {
        return begin_setVectorEffect(theVectorEffect, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setVectorEffect(const ::omero::RStringPtr& theVectorEffect, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setVectorEffect(theVectorEffect, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setVectorEffect(const ::omero::RStringPtr& theVectorEffect, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setVectorEffect(theVectorEffect, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setVectorEffect(const ::omero::RStringPtr& theVectorEffect, const ::omero::model::Callback_Shape_setVectorEffectPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setVectorEffect(theVectorEffect, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setVectorEffect(const ::omero::RStringPtr& theVectorEffect, const ::Ice::Context& __ctx, const ::omero::model::Callback_Shape_setVectorEffectPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setVectorEffect(theVectorEffect, &__ctx, __del, __cookie);
    }

    void end_setVectorEffect(const ::Ice::AsyncResultPtr&);
    
private:

    void setVectorEffect(const ::omero::RStringPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setVectorEffect(const ::omero::RStringPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::RBoolPtr getVisibility()
    {
        return getVisibility(0);
    }
    ::omero::RBoolPtr getVisibility(const ::Ice::Context& __ctx)
    {
        return getVisibility(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getVisibility()
    {
        return begin_getVisibility(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getVisibility(const ::Ice::Context& __ctx)
    {
        return begin_getVisibility(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getVisibility(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getVisibility(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getVisibility(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getVisibility(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getVisibility(const ::omero::model::Callback_Shape_getVisibilityPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getVisibility(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getVisibility(const ::Ice::Context& __ctx, const ::omero::model::Callback_Shape_getVisibilityPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getVisibility(&__ctx, __del, __cookie);
    }

    ::omero::RBoolPtr end_getVisibility(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::RBoolPtr getVisibility(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getVisibility(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setVisibility(const ::omero::RBoolPtr& theVisibility)
    {
        setVisibility(theVisibility, 0);
    }
    void setVisibility(const ::omero::RBoolPtr& theVisibility, const ::Ice::Context& __ctx)
    {
        setVisibility(theVisibility, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setVisibility(const ::omero::RBoolPtr& theVisibility)
    {
        return begin_setVisibility(theVisibility, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setVisibility(const ::omero::RBoolPtr& theVisibility, const ::Ice::Context& __ctx)
    {
        return begin_setVisibility(theVisibility, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setVisibility(const ::omero::RBoolPtr& theVisibility, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setVisibility(theVisibility, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setVisibility(const ::omero::RBoolPtr& theVisibility, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setVisibility(theVisibility, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setVisibility(const ::omero::RBoolPtr& theVisibility, const ::omero::model::Callback_Shape_setVisibilityPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setVisibility(theVisibility, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setVisibility(const ::omero::RBoolPtr& theVisibility, const ::Ice::Context& __ctx, const ::omero::model::Callback_Shape_setVisibilityPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setVisibility(theVisibility, &__ctx, __del, __cookie);
    }

    void end_setVisibility(const ::Ice::AsyncResultPtr&);
    
private:

    void setVisibility(const ::omero::RBoolPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setVisibility(const ::omero::RBoolPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::RIntPtr getFillColor()
    {
        return getFillColor(0);
    }
    ::omero::RIntPtr getFillColor(const ::Ice::Context& __ctx)
    {
        return getFillColor(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getFillColor()
    {
        return begin_getFillColor(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getFillColor(const ::Ice::Context& __ctx)
    {
        return begin_getFillColor(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getFillColor(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getFillColor(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getFillColor(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getFillColor(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getFillColor(const ::omero::model::Callback_Shape_getFillColorPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getFillColor(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getFillColor(const ::Ice::Context& __ctx, const ::omero::model::Callback_Shape_getFillColorPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getFillColor(&__ctx, __del, __cookie);
    }

    ::omero::RIntPtr end_getFillColor(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::RIntPtr getFillColor(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getFillColor(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setFillColor(const ::omero::RIntPtr& theFillColor)
    {
        setFillColor(theFillColor, 0);
    }
    void setFillColor(const ::omero::RIntPtr& theFillColor, const ::Ice::Context& __ctx)
    {
        setFillColor(theFillColor, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setFillColor(const ::omero::RIntPtr& theFillColor)
    {
        return begin_setFillColor(theFillColor, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setFillColor(const ::omero::RIntPtr& theFillColor, const ::Ice::Context& __ctx)
    {
        return begin_setFillColor(theFillColor, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setFillColor(const ::omero::RIntPtr& theFillColor, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setFillColor(theFillColor, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setFillColor(const ::omero::RIntPtr& theFillColor, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setFillColor(theFillColor, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setFillColor(const ::omero::RIntPtr& theFillColor, const ::omero::model::Callback_Shape_setFillColorPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setFillColor(theFillColor, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setFillColor(const ::omero::RIntPtr& theFillColor, const ::Ice::Context& __ctx, const ::omero::model::Callback_Shape_setFillColorPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setFillColor(theFillColor, &__ctx, __del, __cookie);
    }

    void end_setFillColor(const ::Ice::AsyncResultPtr&);
    
private:

    void setFillColor(const ::omero::RIntPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setFillColor(const ::omero::RIntPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::RStringPtr getFillRule()
    {
        return getFillRule(0);
    }
    ::omero::RStringPtr getFillRule(const ::Ice::Context& __ctx)
    {
        return getFillRule(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getFillRule()
    {
        return begin_getFillRule(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getFillRule(const ::Ice::Context& __ctx)
    {
        return begin_getFillRule(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getFillRule(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getFillRule(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getFillRule(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getFillRule(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getFillRule(const ::omero::model::Callback_Shape_getFillRulePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getFillRule(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getFillRule(const ::Ice::Context& __ctx, const ::omero::model::Callback_Shape_getFillRulePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getFillRule(&__ctx, __del, __cookie);
    }

    ::omero::RStringPtr end_getFillRule(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::RStringPtr getFillRule(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getFillRule(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setFillRule(const ::omero::RStringPtr& theFillRule)
    {
        setFillRule(theFillRule, 0);
    }
    void setFillRule(const ::omero::RStringPtr& theFillRule, const ::Ice::Context& __ctx)
    {
        setFillRule(theFillRule, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setFillRule(const ::omero::RStringPtr& theFillRule)
    {
        return begin_setFillRule(theFillRule, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setFillRule(const ::omero::RStringPtr& theFillRule, const ::Ice::Context& __ctx)
    {
        return begin_setFillRule(theFillRule, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setFillRule(const ::omero::RStringPtr& theFillRule, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setFillRule(theFillRule, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setFillRule(const ::omero::RStringPtr& theFillRule, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setFillRule(theFillRule, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setFillRule(const ::omero::RStringPtr& theFillRule, const ::omero::model::Callback_Shape_setFillRulePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setFillRule(theFillRule, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setFillRule(const ::omero::RStringPtr& theFillRule, const ::Ice::Context& __ctx, const ::omero::model::Callback_Shape_setFillRulePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setFillRule(theFillRule, &__ctx, __del, __cookie);
    }

    void end_setFillRule(const ::Ice::AsyncResultPtr&);
    
private:

    void setFillRule(const ::omero::RStringPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setFillRule(const ::omero::RStringPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::RIntPtr getStrokeColor()
    {
        return getStrokeColor(0);
    }
    ::omero::RIntPtr getStrokeColor(const ::Ice::Context& __ctx)
    {
        return getStrokeColor(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getStrokeColor()
    {
        return begin_getStrokeColor(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getStrokeColor(const ::Ice::Context& __ctx)
    {
        return begin_getStrokeColor(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getStrokeColor(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getStrokeColor(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getStrokeColor(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getStrokeColor(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getStrokeColor(const ::omero::model::Callback_Shape_getStrokeColorPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getStrokeColor(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getStrokeColor(const ::Ice::Context& __ctx, const ::omero::model::Callback_Shape_getStrokeColorPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getStrokeColor(&__ctx, __del, __cookie);
    }

    ::omero::RIntPtr end_getStrokeColor(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::RIntPtr getStrokeColor(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getStrokeColor(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setStrokeColor(const ::omero::RIntPtr& theStrokeColor)
    {
        setStrokeColor(theStrokeColor, 0);
    }
    void setStrokeColor(const ::omero::RIntPtr& theStrokeColor, const ::Ice::Context& __ctx)
    {
        setStrokeColor(theStrokeColor, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setStrokeColor(const ::omero::RIntPtr& theStrokeColor)
    {
        return begin_setStrokeColor(theStrokeColor, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setStrokeColor(const ::omero::RIntPtr& theStrokeColor, const ::Ice::Context& __ctx)
    {
        return begin_setStrokeColor(theStrokeColor, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setStrokeColor(const ::omero::RIntPtr& theStrokeColor, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setStrokeColor(theStrokeColor, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setStrokeColor(const ::omero::RIntPtr& theStrokeColor, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setStrokeColor(theStrokeColor, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setStrokeColor(const ::omero::RIntPtr& theStrokeColor, const ::omero::model::Callback_Shape_setStrokeColorPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setStrokeColor(theStrokeColor, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setStrokeColor(const ::omero::RIntPtr& theStrokeColor, const ::Ice::Context& __ctx, const ::omero::model::Callback_Shape_setStrokeColorPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setStrokeColor(theStrokeColor, &__ctx, __del, __cookie);
    }

    void end_setStrokeColor(const ::Ice::AsyncResultPtr&);
    
private:

    void setStrokeColor(const ::omero::RIntPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setStrokeColor(const ::omero::RIntPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::RStringPtr getStrokeDashArray()
    {
        return getStrokeDashArray(0);
    }
    ::omero::RStringPtr getStrokeDashArray(const ::Ice::Context& __ctx)
    {
        return getStrokeDashArray(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getStrokeDashArray()
    {
        return begin_getStrokeDashArray(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getStrokeDashArray(const ::Ice::Context& __ctx)
    {
        return begin_getStrokeDashArray(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getStrokeDashArray(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getStrokeDashArray(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getStrokeDashArray(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getStrokeDashArray(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getStrokeDashArray(const ::omero::model::Callback_Shape_getStrokeDashArrayPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getStrokeDashArray(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getStrokeDashArray(const ::Ice::Context& __ctx, const ::omero::model::Callback_Shape_getStrokeDashArrayPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getStrokeDashArray(&__ctx, __del, __cookie);
    }

    ::omero::RStringPtr end_getStrokeDashArray(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::RStringPtr getStrokeDashArray(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getStrokeDashArray(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setStrokeDashArray(const ::omero::RStringPtr& theStrokeDashArray)
    {
        setStrokeDashArray(theStrokeDashArray, 0);
    }
    void setStrokeDashArray(const ::omero::RStringPtr& theStrokeDashArray, const ::Ice::Context& __ctx)
    {
        setStrokeDashArray(theStrokeDashArray, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setStrokeDashArray(const ::omero::RStringPtr& theStrokeDashArray)
    {
        return begin_setStrokeDashArray(theStrokeDashArray, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setStrokeDashArray(const ::omero::RStringPtr& theStrokeDashArray, const ::Ice::Context& __ctx)
    {
        return begin_setStrokeDashArray(theStrokeDashArray, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setStrokeDashArray(const ::omero::RStringPtr& theStrokeDashArray, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setStrokeDashArray(theStrokeDashArray, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setStrokeDashArray(const ::omero::RStringPtr& theStrokeDashArray, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setStrokeDashArray(theStrokeDashArray, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setStrokeDashArray(const ::omero::RStringPtr& theStrokeDashArray, const ::omero::model::Callback_Shape_setStrokeDashArrayPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setStrokeDashArray(theStrokeDashArray, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setStrokeDashArray(const ::omero::RStringPtr& theStrokeDashArray, const ::Ice::Context& __ctx, const ::omero::model::Callback_Shape_setStrokeDashArrayPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setStrokeDashArray(theStrokeDashArray, &__ctx, __del, __cookie);
    }

    void end_setStrokeDashArray(const ::Ice::AsyncResultPtr&);
    
private:

    void setStrokeDashArray(const ::omero::RStringPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setStrokeDashArray(const ::omero::RStringPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::RIntPtr getStrokeDashOffset()
    {
        return getStrokeDashOffset(0);
    }
    ::omero::RIntPtr getStrokeDashOffset(const ::Ice::Context& __ctx)
    {
        return getStrokeDashOffset(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getStrokeDashOffset()
    {
        return begin_getStrokeDashOffset(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getStrokeDashOffset(const ::Ice::Context& __ctx)
    {
        return begin_getStrokeDashOffset(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getStrokeDashOffset(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getStrokeDashOffset(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getStrokeDashOffset(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getStrokeDashOffset(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getStrokeDashOffset(const ::omero::model::Callback_Shape_getStrokeDashOffsetPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getStrokeDashOffset(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getStrokeDashOffset(const ::Ice::Context& __ctx, const ::omero::model::Callback_Shape_getStrokeDashOffsetPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getStrokeDashOffset(&__ctx, __del, __cookie);
    }

    ::omero::RIntPtr end_getStrokeDashOffset(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::RIntPtr getStrokeDashOffset(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getStrokeDashOffset(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setStrokeDashOffset(const ::omero::RIntPtr& theStrokeDashOffset)
    {
        setStrokeDashOffset(theStrokeDashOffset, 0);
    }
    void setStrokeDashOffset(const ::omero::RIntPtr& theStrokeDashOffset, const ::Ice::Context& __ctx)
    {
        setStrokeDashOffset(theStrokeDashOffset, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setStrokeDashOffset(const ::omero::RIntPtr& theStrokeDashOffset)
    {
        return begin_setStrokeDashOffset(theStrokeDashOffset, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setStrokeDashOffset(const ::omero::RIntPtr& theStrokeDashOffset, const ::Ice::Context& __ctx)
    {
        return begin_setStrokeDashOffset(theStrokeDashOffset, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setStrokeDashOffset(const ::omero::RIntPtr& theStrokeDashOffset, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setStrokeDashOffset(theStrokeDashOffset, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setStrokeDashOffset(const ::omero::RIntPtr& theStrokeDashOffset, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setStrokeDashOffset(theStrokeDashOffset, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setStrokeDashOffset(const ::omero::RIntPtr& theStrokeDashOffset, const ::omero::model::Callback_Shape_setStrokeDashOffsetPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setStrokeDashOffset(theStrokeDashOffset, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setStrokeDashOffset(const ::omero::RIntPtr& theStrokeDashOffset, const ::Ice::Context& __ctx, const ::omero::model::Callback_Shape_setStrokeDashOffsetPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setStrokeDashOffset(theStrokeDashOffset, &__ctx, __del, __cookie);
    }

    void end_setStrokeDashOffset(const ::Ice::AsyncResultPtr&);
    
private:

    void setStrokeDashOffset(const ::omero::RIntPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setStrokeDashOffset(const ::omero::RIntPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::RStringPtr getStrokeLineCap()
    {
        return getStrokeLineCap(0);
    }
    ::omero::RStringPtr getStrokeLineCap(const ::Ice::Context& __ctx)
    {
        return getStrokeLineCap(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getStrokeLineCap()
    {
        return begin_getStrokeLineCap(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getStrokeLineCap(const ::Ice::Context& __ctx)
    {
        return begin_getStrokeLineCap(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getStrokeLineCap(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getStrokeLineCap(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getStrokeLineCap(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getStrokeLineCap(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getStrokeLineCap(const ::omero::model::Callback_Shape_getStrokeLineCapPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getStrokeLineCap(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getStrokeLineCap(const ::Ice::Context& __ctx, const ::omero::model::Callback_Shape_getStrokeLineCapPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getStrokeLineCap(&__ctx, __del, __cookie);
    }

    ::omero::RStringPtr end_getStrokeLineCap(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::RStringPtr getStrokeLineCap(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getStrokeLineCap(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setStrokeLineCap(const ::omero::RStringPtr& theStrokeLineCap)
    {
        setStrokeLineCap(theStrokeLineCap, 0);
    }
    void setStrokeLineCap(const ::omero::RStringPtr& theStrokeLineCap, const ::Ice::Context& __ctx)
    {
        setStrokeLineCap(theStrokeLineCap, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setStrokeLineCap(const ::omero::RStringPtr& theStrokeLineCap)
    {
        return begin_setStrokeLineCap(theStrokeLineCap, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setStrokeLineCap(const ::omero::RStringPtr& theStrokeLineCap, const ::Ice::Context& __ctx)
    {
        return begin_setStrokeLineCap(theStrokeLineCap, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setStrokeLineCap(const ::omero::RStringPtr& theStrokeLineCap, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setStrokeLineCap(theStrokeLineCap, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setStrokeLineCap(const ::omero::RStringPtr& theStrokeLineCap, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setStrokeLineCap(theStrokeLineCap, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setStrokeLineCap(const ::omero::RStringPtr& theStrokeLineCap, const ::omero::model::Callback_Shape_setStrokeLineCapPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setStrokeLineCap(theStrokeLineCap, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setStrokeLineCap(const ::omero::RStringPtr& theStrokeLineCap, const ::Ice::Context& __ctx, const ::omero::model::Callback_Shape_setStrokeLineCapPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setStrokeLineCap(theStrokeLineCap, &__ctx, __del, __cookie);
    }

    void end_setStrokeLineCap(const ::Ice::AsyncResultPtr&);
    
private:

    void setStrokeLineCap(const ::omero::RStringPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setStrokeLineCap(const ::omero::RStringPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::RStringPtr getStrokeLineJoin()
    {
        return getStrokeLineJoin(0);
    }
    ::omero::RStringPtr getStrokeLineJoin(const ::Ice::Context& __ctx)
    {
        return getStrokeLineJoin(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getStrokeLineJoin()
    {
        return begin_getStrokeLineJoin(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getStrokeLineJoin(const ::Ice::Context& __ctx)
    {
        return begin_getStrokeLineJoin(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getStrokeLineJoin(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getStrokeLineJoin(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getStrokeLineJoin(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getStrokeLineJoin(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getStrokeLineJoin(const ::omero::model::Callback_Shape_getStrokeLineJoinPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getStrokeLineJoin(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getStrokeLineJoin(const ::Ice::Context& __ctx, const ::omero::model::Callback_Shape_getStrokeLineJoinPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getStrokeLineJoin(&__ctx, __del, __cookie);
    }

    ::omero::RStringPtr end_getStrokeLineJoin(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::RStringPtr getStrokeLineJoin(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getStrokeLineJoin(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setStrokeLineJoin(const ::omero::RStringPtr& theStrokeLineJoin)
    {
        setStrokeLineJoin(theStrokeLineJoin, 0);
    }
    void setStrokeLineJoin(const ::omero::RStringPtr& theStrokeLineJoin, const ::Ice::Context& __ctx)
    {
        setStrokeLineJoin(theStrokeLineJoin, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setStrokeLineJoin(const ::omero::RStringPtr& theStrokeLineJoin)
    {
        return begin_setStrokeLineJoin(theStrokeLineJoin, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setStrokeLineJoin(const ::omero::RStringPtr& theStrokeLineJoin, const ::Ice::Context& __ctx)
    {
        return begin_setStrokeLineJoin(theStrokeLineJoin, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setStrokeLineJoin(const ::omero::RStringPtr& theStrokeLineJoin, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setStrokeLineJoin(theStrokeLineJoin, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setStrokeLineJoin(const ::omero::RStringPtr& theStrokeLineJoin, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setStrokeLineJoin(theStrokeLineJoin, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setStrokeLineJoin(const ::omero::RStringPtr& theStrokeLineJoin, const ::omero::model::Callback_Shape_setStrokeLineJoinPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setStrokeLineJoin(theStrokeLineJoin, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setStrokeLineJoin(const ::omero::RStringPtr& theStrokeLineJoin, const ::Ice::Context& __ctx, const ::omero::model::Callback_Shape_setStrokeLineJoinPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setStrokeLineJoin(theStrokeLineJoin, &__ctx, __del, __cookie);
    }

    void end_setStrokeLineJoin(const ::Ice::AsyncResultPtr&);
    
private:

    void setStrokeLineJoin(const ::omero::RStringPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setStrokeLineJoin(const ::omero::RStringPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::RIntPtr getStrokeMiterLimit()
    {
        return getStrokeMiterLimit(0);
    }
    ::omero::RIntPtr getStrokeMiterLimit(const ::Ice::Context& __ctx)
    {
        return getStrokeMiterLimit(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getStrokeMiterLimit()
    {
        return begin_getStrokeMiterLimit(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getStrokeMiterLimit(const ::Ice::Context& __ctx)
    {
        return begin_getStrokeMiterLimit(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getStrokeMiterLimit(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getStrokeMiterLimit(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getStrokeMiterLimit(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getStrokeMiterLimit(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getStrokeMiterLimit(const ::omero::model::Callback_Shape_getStrokeMiterLimitPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getStrokeMiterLimit(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getStrokeMiterLimit(const ::Ice::Context& __ctx, const ::omero::model::Callback_Shape_getStrokeMiterLimitPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getStrokeMiterLimit(&__ctx, __del, __cookie);
    }

    ::omero::RIntPtr end_getStrokeMiterLimit(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::RIntPtr getStrokeMiterLimit(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getStrokeMiterLimit(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setStrokeMiterLimit(const ::omero::RIntPtr& theStrokeMiterLimit)
    {
        setStrokeMiterLimit(theStrokeMiterLimit, 0);
    }
    void setStrokeMiterLimit(const ::omero::RIntPtr& theStrokeMiterLimit, const ::Ice::Context& __ctx)
    {
        setStrokeMiterLimit(theStrokeMiterLimit, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setStrokeMiterLimit(const ::omero::RIntPtr& theStrokeMiterLimit)
    {
        return begin_setStrokeMiterLimit(theStrokeMiterLimit, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setStrokeMiterLimit(const ::omero::RIntPtr& theStrokeMiterLimit, const ::Ice::Context& __ctx)
    {
        return begin_setStrokeMiterLimit(theStrokeMiterLimit, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setStrokeMiterLimit(const ::omero::RIntPtr& theStrokeMiterLimit, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setStrokeMiterLimit(theStrokeMiterLimit, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setStrokeMiterLimit(const ::omero::RIntPtr& theStrokeMiterLimit, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setStrokeMiterLimit(theStrokeMiterLimit, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setStrokeMiterLimit(const ::omero::RIntPtr& theStrokeMiterLimit, const ::omero::model::Callback_Shape_setStrokeMiterLimitPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setStrokeMiterLimit(theStrokeMiterLimit, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setStrokeMiterLimit(const ::omero::RIntPtr& theStrokeMiterLimit, const ::Ice::Context& __ctx, const ::omero::model::Callback_Shape_setStrokeMiterLimitPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setStrokeMiterLimit(theStrokeMiterLimit, &__ctx, __del, __cookie);
    }

    void end_setStrokeMiterLimit(const ::Ice::AsyncResultPtr&);
    
private:

    void setStrokeMiterLimit(const ::omero::RIntPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setStrokeMiterLimit(const ::omero::RIntPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::RIntPtr getStrokeWidth()
    {
        return getStrokeWidth(0);
    }
    ::omero::RIntPtr getStrokeWidth(const ::Ice::Context& __ctx)
    {
        return getStrokeWidth(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getStrokeWidth()
    {
        return begin_getStrokeWidth(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getStrokeWidth(const ::Ice::Context& __ctx)
    {
        return begin_getStrokeWidth(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getStrokeWidth(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getStrokeWidth(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getStrokeWidth(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getStrokeWidth(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getStrokeWidth(const ::omero::model::Callback_Shape_getStrokeWidthPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getStrokeWidth(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getStrokeWidth(const ::Ice::Context& __ctx, const ::omero::model::Callback_Shape_getStrokeWidthPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getStrokeWidth(&__ctx, __del, __cookie);
    }

    ::omero::RIntPtr end_getStrokeWidth(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::RIntPtr getStrokeWidth(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getStrokeWidth(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setStrokeWidth(const ::omero::RIntPtr& theStrokeWidth)
    {
        setStrokeWidth(theStrokeWidth, 0);
    }
    void setStrokeWidth(const ::omero::RIntPtr& theStrokeWidth, const ::Ice::Context& __ctx)
    {
        setStrokeWidth(theStrokeWidth, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setStrokeWidth(const ::omero::RIntPtr& theStrokeWidth)
    {
        return begin_setStrokeWidth(theStrokeWidth, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setStrokeWidth(const ::omero::RIntPtr& theStrokeWidth, const ::Ice::Context& __ctx)
    {
        return begin_setStrokeWidth(theStrokeWidth, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setStrokeWidth(const ::omero::RIntPtr& theStrokeWidth, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setStrokeWidth(theStrokeWidth, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setStrokeWidth(const ::omero::RIntPtr& theStrokeWidth, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setStrokeWidth(theStrokeWidth, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setStrokeWidth(const ::omero::RIntPtr& theStrokeWidth, const ::omero::model::Callback_Shape_setStrokeWidthPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setStrokeWidth(theStrokeWidth, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setStrokeWidth(const ::omero::RIntPtr& theStrokeWidth, const ::Ice::Context& __ctx, const ::omero::model::Callback_Shape_setStrokeWidthPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setStrokeWidth(theStrokeWidth, &__ctx, __del, __cookie);
    }

    void end_setStrokeWidth(const ::Ice::AsyncResultPtr&);
    
private:

    void setStrokeWidth(const ::omero::RIntPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setStrokeWidth(const ::omero::RIntPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::RStringPtr getFontFamily()
    {
        return getFontFamily(0);
    }
    ::omero::RStringPtr getFontFamily(const ::Ice::Context& __ctx)
    {
        return getFontFamily(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getFontFamily()
    {
        return begin_getFontFamily(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getFontFamily(const ::Ice::Context& __ctx)
    {
        return begin_getFontFamily(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getFontFamily(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getFontFamily(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getFontFamily(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getFontFamily(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getFontFamily(const ::omero::model::Callback_Shape_getFontFamilyPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getFontFamily(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getFontFamily(const ::Ice::Context& __ctx, const ::omero::model::Callback_Shape_getFontFamilyPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getFontFamily(&__ctx, __del, __cookie);
    }

    ::omero::RStringPtr end_getFontFamily(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::RStringPtr getFontFamily(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getFontFamily(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setFontFamily(const ::omero::RStringPtr& theFontFamily)
    {
        setFontFamily(theFontFamily, 0);
    }
    void setFontFamily(const ::omero::RStringPtr& theFontFamily, const ::Ice::Context& __ctx)
    {
        setFontFamily(theFontFamily, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setFontFamily(const ::omero::RStringPtr& theFontFamily)
    {
        return begin_setFontFamily(theFontFamily, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setFontFamily(const ::omero::RStringPtr& theFontFamily, const ::Ice::Context& __ctx)
    {
        return begin_setFontFamily(theFontFamily, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setFontFamily(const ::omero::RStringPtr& theFontFamily, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setFontFamily(theFontFamily, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setFontFamily(const ::omero::RStringPtr& theFontFamily, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setFontFamily(theFontFamily, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setFontFamily(const ::omero::RStringPtr& theFontFamily, const ::omero::model::Callback_Shape_setFontFamilyPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setFontFamily(theFontFamily, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setFontFamily(const ::omero::RStringPtr& theFontFamily, const ::Ice::Context& __ctx, const ::omero::model::Callback_Shape_setFontFamilyPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setFontFamily(theFontFamily, &__ctx, __del, __cookie);
    }

    void end_setFontFamily(const ::Ice::AsyncResultPtr&);
    
private:

    void setFontFamily(const ::omero::RStringPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setFontFamily(const ::omero::RStringPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::RIntPtr getFontSize()
    {
        return getFontSize(0);
    }
    ::omero::RIntPtr getFontSize(const ::Ice::Context& __ctx)
    {
        return getFontSize(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getFontSize()
    {
        return begin_getFontSize(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getFontSize(const ::Ice::Context& __ctx)
    {
        return begin_getFontSize(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getFontSize(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getFontSize(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getFontSize(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getFontSize(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getFontSize(const ::omero::model::Callback_Shape_getFontSizePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getFontSize(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getFontSize(const ::Ice::Context& __ctx, const ::omero::model::Callback_Shape_getFontSizePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getFontSize(&__ctx, __del, __cookie);
    }

    ::omero::RIntPtr end_getFontSize(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::RIntPtr getFontSize(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getFontSize(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setFontSize(const ::omero::RIntPtr& theFontSize)
    {
        setFontSize(theFontSize, 0);
    }
    void setFontSize(const ::omero::RIntPtr& theFontSize, const ::Ice::Context& __ctx)
    {
        setFontSize(theFontSize, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setFontSize(const ::omero::RIntPtr& theFontSize)
    {
        return begin_setFontSize(theFontSize, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setFontSize(const ::omero::RIntPtr& theFontSize, const ::Ice::Context& __ctx)
    {
        return begin_setFontSize(theFontSize, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setFontSize(const ::omero::RIntPtr& theFontSize, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setFontSize(theFontSize, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setFontSize(const ::omero::RIntPtr& theFontSize, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setFontSize(theFontSize, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setFontSize(const ::omero::RIntPtr& theFontSize, const ::omero::model::Callback_Shape_setFontSizePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setFontSize(theFontSize, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setFontSize(const ::omero::RIntPtr& theFontSize, const ::Ice::Context& __ctx, const ::omero::model::Callback_Shape_setFontSizePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setFontSize(theFontSize, &__ctx, __del, __cookie);
    }

    void end_setFontSize(const ::Ice::AsyncResultPtr&);
    
private:

    void setFontSize(const ::omero::RIntPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setFontSize(const ::omero::RIntPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::RStringPtr getFontStretch()
    {
        return getFontStretch(0);
    }
    ::omero::RStringPtr getFontStretch(const ::Ice::Context& __ctx)
    {
        return getFontStretch(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getFontStretch()
    {
        return begin_getFontStretch(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getFontStretch(const ::Ice::Context& __ctx)
    {
        return begin_getFontStretch(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getFontStretch(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getFontStretch(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getFontStretch(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getFontStretch(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getFontStretch(const ::omero::model::Callback_Shape_getFontStretchPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getFontStretch(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getFontStretch(const ::Ice::Context& __ctx, const ::omero::model::Callback_Shape_getFontStretchPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getFontStretch(&__ctx, __del, __cookie);
    }

    ::omero::RStringPtr end_getFontStretch(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::RStringPtr getFontStretch(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getFontStretch(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setFontStretch(const ::omero::RStringPtr& theFontStretch)
    {
        setFontStretch(theFontStretch, 0);
    }
    void setFontStretch(const ::omero::RStringPtr& theFontStretch, const ::Ice::Context& __ctx)
    {
        setFontStretch(theFontStretch, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setFontStretch(const ::omero::RStringPtr& theFontStretch)
    {
        return begin_setFontStretch(theFontStretch, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setFontStretch(const ::omero::RStringPtr& theFontStretch, const ::Ice::Context& __ctx)
    {
        return begin_setFontStretch(theFontStretch, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setFontStretch(const ::omero::RStringPtr& theFontStretch, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setFontStretch(theFontStretch, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setFontStretch(const ::omero::RStringPtr& theFontStretch, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setFontStretch(theFontStretch, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setFontStretch(const ::omero::RStringPtr& theFontStretch, const ::omero::model::Callback_Shape_setFontStretchPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setFontStretch(theFontStretch, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setFontStretch(const ::omero::RStringPtr& theFontStretch, const ::Ice::Context& __ctx, const ::omero::model::Callback_Shape_setFontStretchPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setFontStretch(theFontStretch, &__ctx, __del, __cookie);
    }

    void end_setFontStretch(const ::Ice::AsyncResultPtr&);
    
private:

    void setFontStretch(const ::omero::RStringPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setFontStretch(const ::omero::RStringPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::RStringPtr getFontStyle()
    {
        return getFontStyle(0);
    }
    ::omero::RStringPtr getFontStyle(const ::Ice::Context& __ctx)
    {
        return getFontStyle(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getFontStyle()
    {
        return begin_getFontStyle(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getFontStyle(const ::Ice::Context& __ctx)
    {
        return begin_getFontStyle(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getFontStyle(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getFontStyle(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getFontStyle(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getFontStyle(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getFontStyle(const ::omero::model::Callback_Shape_getFontStylePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getFontStyle(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getFontStyle(const ::Ice::Context& __ctx, const ::omero::model::Callback_Shape_getFontStylePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getFontStyle(&__ctx, __del, __cookie);
    }

    ::omero::RStringPtr end_getFontStyle(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::RStringPtr getFontStyle(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getFontStyle(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setFontStyle(const ::omero::RStringPtr& theFontStyle)
    {
        setFontStyle(theFontStyle, 0);
    }
    void setFontStyle(const ::omero::RStringPtr& theFontStyle, const ::Ice::Context& __ctx)
    {
        setFontStyle(theFontStyle, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setFontStyle(const ::omero::RStringPtr& theFontStyle)
    {
        return begin_setFontStyle(theFontStyle, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setFontStyle(const ::omero::RStringPtr& theFontStyle, const ::Ice::Context& __ctx)
    {
        return begin_setFontStyle(theFontStyle, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setFontStyle(const ::omero::RStringPtr& theFontStyle, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setFontStyle(theFontStyle, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setFontStyle(const ::omero::RStringPtr& theFontStyle, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setFontStyle(theFontStyle, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setFontStyle(const ::omero::RStringPtr& theFontStyle, const ::omero::model::Callback_Shape_setFontStylePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setFontStyle(theFontStyle, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setFontStyle(const ::omero::RStringPtr& theFontStyle, const ::Ice::Context& __ctx, const ::omero::model::Callback_Shape_setFontStylePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setFontStyle(theFontStyle, &__ctx, __del, __cookie);
    }

    void end_setFontStyle(const ::Ice::AsyncResultPtr&);
    
private:

    void setFontStyle(const ::omero::RStringPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setFontStyle(const ::omero::RStringPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::RStringPtr getFontVariant()
    {
        return getFontVariant(0);
    }
    ::omero::RStringPtr getFontVariant(const ::Ice::Context& __ctx)
    {
        return getFontVariant(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getFontVariant()
    {
        return begin_getFontVariant(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getFontVariant(const ::Ice::Context& __ctx)
    {
        return begin_getFontVariant(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getFontVariant(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getFontVariant(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getFontVariant(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getFontVariant(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getFontVariant(const ::omero::model::Callback_Shape_getFontVariantPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getFontVariant(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getFontVariant(const ::Ice::Context& __ctx, const ::omero::model::Callback_Shape_getFontVariantPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getFontVariant(&__ctx, __del, __cookie);
    }

    ::omero::RStringPtr end_getFontVariant(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::RStringPtr getFontVariant(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getFontVariant(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setFontVariant(const ::omero::RStringPtr& theFontVariant)
    {
        setFontVariant(theFontVariant, 0);
    }
    void setFontVariant(const ::omero::RStringPtr& theFontVariant, const ::Ice::Context& __ctx)
    {
        setFontVariant(theFontVariant, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setFontVariant(const ::omero::RStringPtr& theFontVariant)
    {
        return begin_setFontVariant(theFontVariant, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setFontVariant(const ::omero::RStringPtr& theFontVariant, const ::Ice::Context& __ctx)
    {
        return begin_setFontVariant(theFontVariant, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setFontVariant(const ::omero::RStringPtr& theFontVariant, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setFontVariant(theFontVariant, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setFontVariant(const ::omero::RStringPtr& theFontVariant, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setFontVariant(theFontVariant, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setFontVariant(const ::omero::RStringPtr& theFontVariant, const ::omero::model::Callback_Shape_setFontVariantPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setFontVariant(theFontVariant, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setFontVariant(const ::omero::RStringPtr& theFontVariant, const ::Ice::Context& __ctx, const ::omero::model::Callback_Shape_setFontVariantPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setFontVariant(theFontVariant, &__ctx, __del, __cookie);
    }

    void end_setFontVariant(const ::Ice::AsyncResultPtr&);
    
private:

    void setFontVariant(const ::omero::RStringPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setFontVariant(const ::omero::RStringPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::RStringPtr getFontWeight()
    {
        return getFontWeight(0);
    }
    ::omero::RStringPtr getFontWeight(const ::Ice::Context& __ctx)
    {
        return getFontWeight(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getFontWeight()
    {
        return begin_getFontWeight(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getFontWeight(const ::Ice::Context& __ctx)
    {
        return begin_getFontWeight(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getFontWeight(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getFontWeight(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getFontWeight(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getFontWeight(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getFontWeight(const ::omero::model::Callback_Shape_getFontWeightPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getFontWeight(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getFontWeight(const ::Ice::Context& __ctx, const ::omero::model::Callback_Shape_getFontWeightPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getFontWeight(&__ctx, __del, __cookie);
    }

    ::omero::RStringPtr end_getFontWeight(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::RStringPtr getFontWeight(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getFontWeight(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setFontWeight(const ::omero::RStringPtr& theFontWeight)
    {
        setFontWeight(theFontWeight, 0);
    }
    void setFontWeight(const ::omero::RStringPtr& theFontWeight, const ::Ice::Context& __ctx)
    {
        setFontWeight(theFontWeight, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setFontWeight(const ::omero::RStringPtr& theFontWeight)
    {
        return begin_setFontWeight(theFontWeight, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setFontWeight(const ::omero::RStringPtr& theFontWeight, const ::Ice::Context& __ctx)
    {
        return begin_setFontWeight(theFontWeight, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setFontWeight(const ::omero::RStringPtr& theFontWeight, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setFontWeight(theFontWeight, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setFontWeight(const ::omero::RStringPtr& theFontWeight, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setFontWeight(theFontWeight, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setFontWeight(const ::omero::RStringPtr& theFontWeight, const ::omero::model::Callback_Shape_setFontWeightPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setFontWeight(theFontWeight, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setFontWeight(const ::omero::RStringPtr& theFontWeight, const ::Ice::Context& __ctx, const ::omero::model::Callback_Shape_setFontWeightPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setFontWeight(theFontWeight, &__ctx, __del, __cookie);
    }

    void end_setFontWeight(const ::Ice::AsyncResultPtr&);
    
private:

    void setFontWeight(const ::omero::RStringPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setFontWeight(const ::omero::RStringPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    
    ::IceInternal::ProxyHandle<Shape> ice_context(const ::Ice::Context& __context) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Shape*>(_Base::ice_context(__context).get());
    #else
        return dynamic_cast<Shape*>(::IceProxy::Ice::Object::ice_context(__context).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Shape> ice_adapterId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Shape*>(_Base::ice_adapterId(__id).get());
    #else
        return dynamic_cast<Shape*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Shape> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Shape*>(_Base::ice_endpoints(__endpoints).get());
    #else
        return dynamic_cast<Shape*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Shape> ice_locatorCacheTimeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Shape*>(_Base::ice_locatorCacheTimeout(__timeout).get());
    #else
        return dynamic_cast<Shape*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Shape> ice_connectionCached(bool __cached) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Shape*>(_Base::ice_connectionCached(__cached).get());
    #else
        return dynamic_cast<Shape*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Shape> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Shape*>(_Base::ice_endpointSelection(__est).get());
    #else
        return dynamic_cast<Shape*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Shape> ice_secure(bool __secure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Shape*>(_Base::ice_secure(__secure).get());
    #else
        return dynamic_cast<Shape*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Shape> ice_preferSecure(bool __preferSecure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Shape*>(_Base::ice_preferSecure(__preferSecure).get());
    #else
        return dynamic_cast<Shape*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Shape> ice_router(const ::Ice::RouterPrx& __router) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Shape*>(_Base::ice_router(__router).get());
    #else
        return dynamic_cast<Shape*>(::IceProxy::Ice::Object::ice_router(__router).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Shape> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Shape*>(_Base::ice_locator(__locator).get());
    #else
        return dynamic_cast<Shape*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Shape> ice_collocationOptimized(bool __co) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Shape*>(_Base::ice_collocationOptimized(__co).get());
    #else
        return dynamic_cast<Shape*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Shape> ice_twoway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Shape*>(_Base::ice_twoway().get());
    #else
        return dynamic_cast<Shape*>(::IceProxy::Ice::Object::ice_twoway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Shape> ice_oneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Shape*>(_Base::ice_oneway().get());
    #else
        return dynamic_cast<Shape*>(::IceProxy::Ice::Object::ice_oneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Shape> ice_batchOneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Shape*>(_Base::ice_batchOneway().get());
    #else
        return dynamic_cast<Shape*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Shape> ice_datagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Shape*>(_Base::ice_datagram().get());
    #else
        return dynamic_cast<Shape*>(::IceProxy::Ice::Object::ice_datagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Shape> ice_batchDatagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Shape*>(_Base::ice_batchDatagram().get());
    #else
        return dynamic_cast<Shape*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Shape> ice_compress(bool __compress) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Shape*>(_Base::ice_compress(__compress).get());
    #else
        return dynamic_cast<Shape*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Shape> ice_timeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Shape*>(_Base::ice_timeout(__timeout).get());
    #else
        return dynamic_cast<Shape*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Shape> ice_connectionId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Shape*>(_Base::ice_connectionId(__id).get());
    #else
        return dynamic_cast<Shape*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    #endif
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

}

}

}

namespace IceDelegate
{

namespace omero
{

namespace model
{

class Shape : virtual public ::IceDelegate::omero::model::IObject
{
public:

    virtual ::omero::RIntPtr getVersion(const ::Ice::Context*) = 0;

    virtual void setVersion(const ::omero::RIntPtr&, const ::Ice::Context*) = 0;

    virtual ::omero::RIntPtr getTheZ(const ::Ice::Context*) = 0;

    virtual void setTheZ(const ::omero::RIntPtr&, const ::Ice::Context*) = 0;

    virtual ::omero::RIntPtr getTheT(const ::Ice::Context*) = 0;

    virtual void setTheT(const ::omero::RIntPtr&, const ::Ice::Context*) = 0;

    virtual ::omero::RIntPtr getTheC(const ::Ice::Context*) = 0;

    virtual void setTheC(const ::omero::RIntPtr&, const ::Ice::Context*) = 0;

    virtual ::omero::model::RoiPtr getRoi(const ::Ice::Context*) = 0;

    virtual void setRoi(const ::omero::model::RoiPtr&, const ::Ice::Context*) = 0;

    virtual ::omero::RBoolPtr getLocked(const ::Ice::Context*) = 0;

    virtual void setLocked(const ::omero::RBoolPtr&, const ::Ice::Context*) = 0;

    virtual ::omero::RStringPtr getG(const ::Ice::Context*) = 0;

    virtual void setG(const ::omero::RStringPtr&, const ::Ice::Context*) = 0;

    virtual ::omero::RStringPtr getTransform(const ::Ice::Context*) = 0;

    virtual void setTransform(const ::omero::RStringPtr&, const ::Ice::Context*) = 0;

    virtual ::omero::RStringPtr getVectorEffect(const ::Ice::Context*) = 0;

    virtual void setVectorEffect(const ::omero::RStringPtr&, const ::Ice::Context*) = 0;

    virtual ::omero::RBoolPtr getVisibility(const ::Ice::Context*) = 0;

    virtual void setVisibility(const ::omero::RBoolPtr&, const ::Ice::Context*) = 0;

    virtual ::omero::RIntPtr getFillColor(const ::Ice::Context*) = 0;

    virtual void setFillColor(const ::omero::RIntPtr&, const ::Ice::Context*) = 0;

    virtual ::omero::RStringPtr getFillRule(const ::Ice::Context*) = 0;

    virtual void setFillRule(const ::omero::RStringPtr&, const ::Ice::Context*) = 0;

    virtual ::omero::RIntPtr getStrokeColor(const ::Ice::Context*) = 0;

    virtual void setStrokeColor(const ::omero::RIntPtr&, const ::Ice::Context*) = 0;

    virtual ::omero::RStringPtr getStrokeDashArray(const ::Ice::Context*) = 0;

    virtual void setStrokeDashArray(const ::omero::RStringPtr&, const ::Ice::Context*) = 0;

    virtual ::omero::RIntPtr getStrokeDashOffset(const ::Ice::Context*) = 0;

    virtual void setStrokeDashOffset(const ::omero::RIntPtr&, const ::Ice::Context*) = 0;

    virtual ::omero::RStringPtr getStrokeLineCap(const ::Ice::Context*) = 0;

    virtual void setStrokeLineCap(const ::omero::RStringPtr&, const ::Ice::Context*) = 0;

    virtual ::omero::RStringPtr getStrokeLineJoin(const ::Ice::Context*) = 0;

    virtual void setStrokeLineJoin(const ::omero::RStringPtr&, const ::Ice::Context*) = 0;

    virtual ::omero::RIntPtr getStrokeMiterLimit(const ::Ice::Context*) = 0;

    virtual void setStrokeMiterLimit(const ::omero::RIntPtr&, const ::Ice::Context*) = 0;

    virtual ::omero::RIntPtr getStrokeWidth(const ::Ice::Context*) = 0;

    virtual void setStrokeWidth(const ::omero::RIntPtr&, const ::Ice::Context*) = 0;

    virtual ::omero::RStringPtr getFontFamily(const ::Ice::Context*) = 0;

    virtual void setFontFamily(const ::omero::RStringPtr&, const ::Ice::Context*) = 0;

    virtual ::omero::RIntPtr getFontSize(const ::Ice::Context*) = 0;

    virtual void setFontSize(const ::omero::RIntPtr&, const ::Ice::Context*) = 0;

    virtual ::omero::RStringPtr getFontStretch(const ::Ice::Context*) = 0;

    virtual void setFontStretch(const ::omero::RStringPtr&, const ::Ice::Context*) = 0;

    virtual ::omero::RStringPtr getFontStyle(const ::Ice::Context*) = 0;

    virtual void setFontStyle(const ::omero::RStringPtr&, const ::Ice::Context*) = 0;

    virtual ::omero::RStringPtr getFontVariant(const ::Ice::Context*) = 0;

    virtual void setFontVariant(const ::omero::RStringPtr&, const ::Ice::Context*) = 0;

    virtual ::omero::RStringPtr getFontWeight(const ::Ice::Context*) = 0;

    virtual void setFontWeight(const ::omero::RStringPtr&, const ::Ice::Context*) = 0;
};

}

}

}

namespace IceDelegateM
{

namespace omero
{

namespace model
{

class Shape : virtual public ::IceDelegate::omero::model::Shape,
              virtual public ::IceDelegateM::omero::model::IObject
{
public:

    virtual ::omero::RIntPtr getVersion(const ::Ice::Context*);

    virtual void setVersion(const ::omero::RIntPtr&, const ::Ice::Context*);

    virtual ::omero::RIntPtr getTheZ(const ::Ice::Context*);

    virtual void setTheZ(const ::omero::RIntPtr&, const ::Ice::Context*);

    virtual ::omero::RIntPtr getTheT(const ::Ice::Context*);

    virtual void setTheT(const ::omero::RIntPtr&, const ::Ice::Context*);

    virtual ::omero::RIntPtr getTheC(const ::Ice::Context*);

    virtual void setTheC(const ::omero::RIntPtr&, const ::Ice::Context*);

    virtual ::omero::model::RoiPtr getRoi(const ::Ice::Context*);

    virtual void setRoi(const ::omero::model::RoiPtr&, const ::Ice::Context*);

    virtual ::omero::RBoolPtr getLocked(const ::Ice::Context*);

    virtual void setLocked(const ::omero::RBoolPtr&, const ::Ice::Context*);

    virtual ::omero::RStringPtr getG(const ::Ice::Context*);

    virtual void setG(const ::omero::RStringPtr&, const ::Ice::Context*);

    virtual ::omero::RStringPtr getTransform(const ::Ice::Context*);

    virtual void setTransform(const ::omero::RStringPtr&, const ::Ice::Context*);

    virtual ::omero::RStringPtr getVectorEffect(const ::Ice::Context*);

    virtual void setVectorEffect(const ::omero::RStringPtr&, const ::Ice::Context*);

    virtual ::omero::RBoolPtr getVisibility(const ::Ice::Context*);

    virtual void setVisibility(const ::omero::RBoolPtr&, const ::Ice::Context*);

    virtual ::omero::RIntPtr getFillColor(const ::Ice::Context*);

    virtual void setFillColor(const ::omero::RIntPtr&, const ::Ice::Context*);

    virtual ::omero::RStringPtr getFillRule(const ::Ice::Context*);

    virtual void setFillRule(const ::omero::RStringPtr&, const ::Ice::Context*);

    virtual ::omero::RIntPtr getStrokeColor(const ::Ice::Context*);

    virtual void setStrokeColor(const ::omero::RIntPtr&, const ::Ice::Context*);

    virtual ::omero::RStringPtr getStrokeDashArray(const ::Ice::Context*);

    virtual void setStrokeDashArray(const ::omero::RStringPtr&, const ::Ice::Context*);

    virtual ::omero::RIntPtr getStrokeDashOffset(const ::Ice::Context*);

    virtual void setStrokeDashOffset(const ::omero::RIntPtr&, const ::Ice::Context*);

    virtual ::omero::RStringPtr getStrokeLineCap(const ::Ice::Context*);

    virtual void setStrokeLineCap(const ::omero::RStringPtr&, const ::Ice::Context*);

    virtual ::omero::RStringPtr getStrokeLineJoin(const ::Ice::Context*);

    virtual void setStrokeLineJoin(const ::omero::RStringPtr&, const ::Ice::Context*);

    virtual ::omero::RIntPtr getStrokeMiterLimit(const ::Ice::Context*);

    virtual void setStrokeMiterLimit(const ::omero::RIntPtr&, const ::Ice::Context*);

    virtual ::omero::RIntPtr getStrokeWidth(const ::Ice::Context*);

    virtual void setStrokeWidth(const ::omero::RIntPtr&, const ::Ice::Context*);

    virtual ::omero::RStringPtr getFontFamily(const ::Ice::Context*);

    virtual void setFontFamily(const ::omero::RStringPtr&, const ::Ice::Context*);

    virtual ::omero::RIntPtr getFontSize(const ::Ice::Context*);

    virtual void setFontSize(const ::omero::RIntPtr&, const ::Ice::Context*);

    virtual ::omero::RStringPtr getFontStretch(const ::Ice::Context*);

    virtual void setFontStretch(const ::omero::RStringPtr&, const ::Ice::Context*);

    virtual ::omero::RStringPtr getFontStyle(const ::Ice::Context*);

    virtual void setFontStyle(const ::omero::RStringPtr&, const ::Ice::Context*);

    virtual ::omero::RStringPtr getFontVariant(const ::Ice::Context*);

    virtual void setFontVariant(const ::omero::RStringPtr&, const ::Ice::Context*);

    virtual ::omero::RStringPtr getFontWeight(const ::Ice::Context*);

    virtual void setFontWeight(const ::omero::RStringPtr&, const ::Ice::Context*);
};

}

}

}

namespace IceDelegateD
{

namespace omero
{

namespace model
{

class Shape : virtual public ::IceDelegate::omero::model::Shape,
              virtual public ::IceDelegateD::omero::model::IObject
{
public:

    virtual ::omero::RIntPtr getVersion(const ::Ice::Context*);

    virtual void setVersion(const ::omero::RIntPtr&, const ::Ice::Context*);

    virtual ::omero::RIntPtr getTheZ(const ::Ice::Context*);

    virtual void setTheZ(const ::omero::RIntPtr&, const ::Ice::Context*);

    virtual ::omero::RIntPtr getTheT(const ::Ice::Context*);

    virtual void setTheT(const ::omero::RIntPtr&, const ::Ice::Context*);

    virtual ::omero::RIntPtr getTheC(const ::Ice::Context*);

    virtual void setTheC(const ::omero::RIntPtr&, const ::Ice::Context*);

    virtual ::omero::model::RoiPtr getRoi(const ::Ice::Context*);

    virtual void setRoi(const ::omero::model::RoiPtr&, const ::Ice::Context*);

    virtual ::omero::RBoolPtr getLocked(const ::Ice::Context*);

    virtual void setLocked(const ::omero::RBoolPtr&, const ::Ice::Context*);

    virtual ::omero::RStringPtr getG(const ::Ice::Context*);

    virtual void setG(const ::omero::RStringPtr&, const ::Ice::Context*);

    virtual ::omero::RStringPtr getTransform(const ::Ice::Context*);

    virtual void setTransform(const ::omero::RStringPtr&, const ::Ice::Context*);

    virtual ::omero::RStringPtr getVectorEffect(const ::Ice::Context*);

    virtual void setVectorEffect(const ::omero::RStringPtr&, const ::Ice::Context*);

    virtual ::omero::RBoolPtr getVisibility(const ::Ice::Context*);

    virtual void setVisibility(const ::omero::RBoolPtr&, const ::Ice::Context*);

    virtual ::omero::RIntPtr getFillColor(const ::Ice::Context*);

    virtual void setFillColor(const ::omero::RIntPtr&, const ::Ice::Context*);

    virtual ::omero::RStringPtr getFillRule(const ::Ice::Context*);

    virtual void setFillRule(const ::omero::RStringPtr&, const ::Ice::Context*);

    virtual ::omero::RIntPtr getStrokeColor(const ::Ice::Context*);

    virtual void setStrokeColor(const ::omero::RIntPtr&, const ::Ice::Context*);

    virtual ::omero::RStringPtr getStrokeDashArray(const ::Ice::Context*);

    virtual void setStrokeDashArray(const ::omero::RStringPtr&, const ::Ice::Context*);

    virtual ::omero::RIntPtr getStrokeDashOffset(const ::Ice::Context*);

    virtual void setStrokeDashOffset(const ::omero::RIntPtr&, const ::Ice::Context*);

    virtual ::omero::RStringPtr getStrokeLineCap(const ::Ice::Context*);

    virtual void setStrokeLineCap(const ::omero::RStringPtr&, const ::Ice::Context*);

    virtual ::omero::RStringPtr getStrokeLineJoin(const ::Ice::Context*);

    virtual void setStrokeLineJoin(const ::omero::RStringPtr&, const ::Ice::Context*);

    virtual ::omero::RIntPtr getStrokeMiterLimit(const ::Ice::Context*);

    virtual void setStrokeMiterLimit(const ::omero::RIntPtr&, const ::Ice::Context*);

    virtual ::omero::RIntPtr getStrokeWidth(const ::Ice::Context*);

    virtual void setStrokeWidth(const ::omero::RIntPtr&, const ::Ice::Context*);

    virtual ::omero::RStringPtr getFontFamily(const ::Ice::Context*);

    virtual void setFontFamily(const ::omero::RStringPtr&, const ::Ice::Context*);

    virtual ::omero::RIntPtr getFontSize(const ::Ice::Context*);

    virtual void setFontSize(const ::omero::RIntPtr&, const ::Ice::Context*);

    virtual ::omero::RStringPtr getFontStretch(const ::Ice::Context*);

    virtual void setFontStretch(const ::omero::RStringPtr&, const ::Ice::Context*);

    virtual ::omero::RStringPtr getFontStyle(const ::Ice::Context*);

    virtual void setFontStyle(const ::omero::RStringPtr&, const ::Ice::Context*);

    virtual ::omero::RStringPtr getFontVariant(const ::Ice::Context*);

    virtual void setFontVariant(const ::omero::RStringPtr&, const ::Ice::Context*);

    virtual ::omero::RStringPtr getFontWeight(const ::Ice::Context*);

    virtual void setFontWeight(const ::omero::RStringPtr&, const ::Ice::Context*);
};

}

}

}

namespace omero
{

namespace model
{

class Shape : public ::omero::model::IObject
{
public:

    typedef ShapePrx ProxyType;
    typedef ShapePtr PointerType;
    
    Shape() {}
    Shape(const ::omero::RLongPtr&, const ::omero::model::DetailsPtr&, bool, const ::omero::RIntPtr&, const ::omero::RIntPtr&, const ::omero::RIntPtr&, const ::omero::RIntPtr&, const ::omero::model::RoiPtr&, const ::omero::RBoolPtr&, const ::omero::RStringPtr&, const ::omero::RStringPtr&, const ::omero::RStringPtr&, const ::omero::RBoolPtr&, const ::omero::RIntPtr&, const ::omero::RStringPtr&, const ::omero::RIntPtr&, const ::omero::RStringPtr&, const ::omero::RIntPtr&, const ::omero::RStringPtr&, const ::omero::RStringPtr&, const ::omero::RIntPtr&, const ::omero::RIntPtr&, const ::omero::RStringPtr&, const ::omero::RIntPtr&, const ::omero::RStringPtr&, const ::omero::RStringPtr&, const ::omero::RStringPtr&, const ::omero::RStringPtr&);
    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void __gcReachable(::IceInternal::GCCountMap&) const;
    virtual void __gcClear();

    virtual ::omero::RIntPtr getVersion(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getVersion(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setVersion(const ::omero::RIntPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setVersion(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::RIntPtr getTheZ(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getTheZ(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setTheZ(const ::omero::RIntPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setTheZ(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::RIntPtr getTheT(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getTheT(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setTheT(const ::omero::RIntPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setTheT(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::RIntPtr getTheC(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getTheC(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setTheC(const ::omero::RIntPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setTheC(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::model::RoiPtr getRoi(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getRoi(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setRoi(const ::omero::model::RoiPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setRoi(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::RBoolPtr getLocked(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getLocked(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setLocked(const ::omero::RBoolPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setLocked(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::RStringPtr getG(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getG(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setG(const ::omero::RStringPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setG(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::RStringPtr getTransform(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getTransform(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setTransform(const ::omero::RStringPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setTransform(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::RStringPtr getVectorEffect(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getVectorEffect(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setVectorEffect(const ::omero::RStringPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setVectorEffect(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::RBoolPtr getVisibility(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getVisibility(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setVisibility(const ::omero::RBoolPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setVisibility(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::RIntPtr getFillColor(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getFillColor(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setFillColor(const ::omero::RIntPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setFillColor(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::RStringPtr getFillRule(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getFillRule(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setFillRule(const ::omero::RStringPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setFillRule(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::RIntPtr getStrokeColor(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getStrokeColor(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setStrokeColor(const ::omero::RIntPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setStrokeColor(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::RStringPtr getStrokeDashArray(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getStrokeDashArray(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setStrokeDashArray(const ::omero::RStringPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setStrokeDashArray(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::RIntPtr getStrokeDashOffset(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getStrokeDashOffset(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setStrokeDashOffset(const ::omero::RIntPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setStrokeDashOffset(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::RStringPtr getStrokeLineCap(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getStrokeLineCap(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setStrokeLineCap(const ::omero::RStringPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setStrokeLineCap(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::RStringPtr getStrokeLineJoin(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getStrokeLineJoin(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setStrokeLineJoin(const ::omero::RStringPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setStrokeLineJoin(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::RIntPtr getStrokeMiterLimit(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getStrokeMiterLimit(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setStrokeMiterLimit(const ::omero::RIntPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setStrokeMiterLimit(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::RIntPtr getStrokeWidth(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getStrokeWidth(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setStrokeWidth(const ::omero::RIntPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setStrokeWidth(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::RStringPtr getFontFamily(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getFontFamily(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setFontFamily(const ::omero::RStringPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setFontFamily(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::RIntPtr getFontSize(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getFontSize(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setFontSize(const ::omero::RIntPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setFontSize(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::RStringPtr getFontStretch(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getFontStretch(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setFontStretch(const ::omero::RStringPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setFontStretch(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::RStringPtr getFontStyle(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getFontStyle(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setFontStyle(const ::omero::RStringPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setFontStyle(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::RStringPtr getFontVariant(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getFontVariant(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setFontVariant(const ::omero::RStringPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setFontVariant(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::RStringPtr getFontWeight(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getFontWeight(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setFontWeight(const ::omero::RStringPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setFontWeight(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void __write(::IceInternal::BasicStream*) const;
    virtual void __read(::IceInternal::BasicStream*, bool);
// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
    virtual void __write(const ::Ice::OutputStreamPtr&) const;
    virtual void __read(const ::Ice::InputStreamPtr&, bool);
#endif

protected:

    ::omero::RIntPtr version;

    ::omero::RIntPtr theZ;

    ::omero::RIntPtr theT;

    ::omero::RIntPtr theC;

    ::omero::model::RoiPtr roi;

    ::omero::RBoolPtr locked;

    ::omero::RStringPtr g;

    ::omero::RStringPtr transform;

    ::omero::RStringPtr vectorEffect;

    ::omero::RBoolPtr visibility;

    ::omero::RIntPtr fillColor;

    ::omero::RStringPtr fillRule;

    ::omero::RIntPtr strokeColor;

    ::omero::RStringPtr strokeDashArray;

    ::omero::RIntPtr strokeDashOffset;

    ::omero::RStringPtr strokeLineCap;

    ::omero::RStringPtr strokeLineJoin;

    ::omero::RIntPtr strokeMiterLimit;

    ::omero::RIntPtr strokeWidth;

    ::omero::RStringPtr fontFamily;

    ::omero::RIntPtr fontSize;

    ::omero::RStringPtr fontStretch;

    ::omero::RStringPtr fontStyle;

    ::omero::RStringPtr fontVariant;

    ::omero::RStringPtr fontWeight;
};

inline bool operator==(const Shape& l, const Shape& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const Shape& l, const Shape& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

}

}

namespace omero
{

namespace model
{

template<class T>
class CallbackNC_Shape_getVersion : public Callback_Shape_getVersion_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::RIntPtr&);

    CallbackNC_Shape_getVersion(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::ShapePrx __proxy = ::omero::model::ShapePrx::uncheckedCast(__result->getProxy());
        ::omero::RIntPtr __ret;
        try
        {
            __ret = __proxy->end_getVersion(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_Shape_getVersionPtr
newCallback_Shape_getVersion(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RIntPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_getVersion<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Shape_getVersionPtr
newCallback_Shape_getVersion(T* instance, void (T::*cb)(const ::omero::RIntPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_getVersion<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Shape_getVersion : public Callback_Shape_getVersion_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::RIntPtr&, const CT&);

    Callback_Shape_getVersion(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::ShapePrx __proxy = ::omero::model::ShapePrx::uncheckedCast(__result->getProxy());
        ::omero::RIntPtr __ret;
        try
        {
            __ret = __proxy->end_getVersion(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Shape_getVersionPtr
newCallback_Shape_getVersion(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RIntPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_getVersion<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Shape_getVersionPtr
newCallback_Shape_getVersion(T* instance, void (T::*cb)(const ::omero::RIntPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_getVersion<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Shape_setVersion : public Callback_Shape_setVersion_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Shape_setVersion(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_Shape_setVersionPtr
newCallback_Shape_setVersion(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_setVersion<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Shape_setVersionPtr
newCallback_Shape_setVersion(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_setVersion<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Shape_setVersionPtr
newCallback_Shape_setVersion(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_setVersion<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Shape_setVersionPtr
newCallback_Shape_setVersion(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_setVersion<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Shape_setVersion : public Callback_Shape_setVersion_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Shape_setVersion(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_Shape_setVersionPtr
newCallback_Shape_setVersion(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_setVersion<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Shape_setVersionPtr
newCallback_Shape_setVersion(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_setVersion<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Shape_setVersionPtr
newCallback_Shape_setVersion(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_setVersion<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Shape_setVersionPtr
newCallback_Shape_setVersion(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_setVersion<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Shape_getTheZ : public Callback_Shape_getTheZ_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::RIntPtr&);

    CallbackNC_Shape_getTheZ(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::ShapePrx __proxy = ::omero::model::ShapePrx::uncheckedCast(__result->getProxy());
        ::omero::RIntPtr __ret;
        try
        {
            __ret = __proxy->end_getTheZ(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_Shape_getTheZPtr
newCallback_Shape_getTheZ(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RIntPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_getTheZ<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Shape_getTheZPtr
newCallback_Shape_getTheZ(T* instance, void (T::*cb)(const ::omero::RIntPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_getTheZ<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Shape_getTheZ : public Callback_Shape_getTheZ_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::RIntPtr&, const CT&);

    Callback_Shape_getTheZ(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::ShapePrx __proxy = ::omero::model::ShapePrx::uncheckedCast(__result->getProxy());
        ::omero::RIntPtr __ret;
        try
        {
            __ret = __proxy->end_getTheZ(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Shape_getTheZPtr
newCallback_Shape_getTheZ(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RIntPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_getTheZ<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Shape_getTheZPtr
newCallback_Shape_getTheZ(T* instance, void (T::*cb)(const ::omero::RIntPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_getTheZ<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Shape_setTheZ : public Callback_Shape_setTheZ_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Shape_setTheZ(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_Shape_setTheZPtr
newCallback_Shape_setTheZ(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_setTheZ<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Shape_setTheZPtr
newCallback_Shape_setTheZ(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_setTheZ<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Shape_setTheZPtr
newCallback_Shape_setTheZ(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_setTheZ<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Shape_setTheZPtr
newCallback_Shape_setTheZ(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_setTheZ<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Shape_setTheZ : public Callback_Shape_setTheZ_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Shape_setTheZ(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_Shape_setTheZPtr
newCallback_Shape_setTheZ(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_setTheZ<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Shape_setTheZPtr
newCallback_Shape_setTheZ(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_setTheZ<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Shape_setTheZPtr
newCallback_Shape_setTheZ(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_setTheZ<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Shape_setTheZPtr
newCallback_Shape_setTheZ(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_setTheZ<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Shape_getTheT : public Callback_Shape_getTheT_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::RIntPtr&);

    CallbackNC_Shape_getTheT(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::ShapePrx __proxy = ::omero::model::ShapePrx::uncheckedCast(__result->getProxy());
        ::omero::RIntPtr __ret;
        try
        {
            __ret = __proxy->end_getTheT(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_Shape_getTheTPtr
newCallback_Shape_getTheT(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RIntPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_getTheT<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Shape_getTheTPtr
newCallback_Shape_getTheT(T* instance, void (T::*cb)(const ::omero::RIntPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_getTheT<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Shape_getTheT : public Callback_Shape_getTheT_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::RIntPtr&, const CT&);

    Callback_Shape_getTheT(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::ShapePrx __proxy = ::omero::model::ShapePrx::uncheckedCast(__result->getProxy());
        ::omero::RIntPtr __ret;
        try
        {
            __ret = __proxy->end_getTheT(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Shape_getTheTPtr
newCallback_Shape_getTheT(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RIntPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_getTheT<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Shape_getTheTPtr
newCallback_Shape_getTheT(T* instance, void (T::*cb)(const ::omero::RIntPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_getTheT<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Shape_setTheT : public Callback_Shape_setTheT_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Shape_setTheT(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_Shape_setTheTPtr
newCallback_Shape_setTheT(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_setTheT<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Shape_setTheTPtr
newCallback_Shape_setTheT(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_setTheT<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Shape_setTheTPtr
newCallback_Shape_setTheT(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_setTheT<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Shape_setTheTPtr
newCallback_Shape_setTheT(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_setTheT<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Shape_setTheT : public Callback_Shape_setTheT_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Shape_setTheT(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_Shape_setTheTPtr
newCallback_Shape_setTheT(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_setTheT<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Shape_setTheTPtr
newCallback_Shape_setTheT(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_setTheT<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Shape_setTheTPtr
newCallback_Shape_setTheT(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_setTheT<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Shape_setTheTPtr
newCallback_Shape_setTheT(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_setTheT<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Shape_getTheC : public Callback_Shape_getTheC_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::RIntPtr&);

    CallbackNC_Shape_getTheC(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::ShapePrx __proxy = ::omero::model::ShapePrx::uncheckedCast(__result->getProxy());
        ::omero::RIntPtr __ret;
        try
        {
            __ret = __proxy->end_getTheC(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_Shape_getTheCPtr
newCallback_Shape_getTheC(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RIntPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_getTheC<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Shape_getTheCPtr
newCallback_Shape_getTheC(T* instance, void (T::*cb)(const ::omero::RIntPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_getTheC<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Shape_getTheC : public Callback_Shape_getTheC_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::RIntPtr&, const CT&);

    Callback_Shape_getTheC(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::ShapePrx __proxy = ::omero::model::ShapePrx::uncheckedCast(__result->getProxy());
        ::omero::RIntPtr __ret;
        try
        {
            __ret = __proxy->end_getTheC(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Shape_getTheCPtr
newCallback_Shape_getTheC(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RIntPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_getTheC<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Shape_getTheCPtr
newCallback_Shape_getTheC(T* instance, void (T::*cb)(const ::omero::RIntPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_getTheC<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Shape_setTheC : public Callback_Shape_setTheC_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Shape_setTheC(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_Shape_setTheCPtr
newCallback_Shape_setTheC(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_setTheC<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Shape_setTheCPtr
newCallback_Shape_setTheC(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_setTheC<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Shape_setTheCPtr
newCallback_Shape_setTheC(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_setTheC<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Shape_setTheCPtr
newCallback_Shape_setTheC(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_setTheC<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Shape_setTheC : public Callback_Shape_setTheC_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Shape_setTheC(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_Shape_setTheCPtr
newCallback_Shape_setTheC(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_setTheC<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Shape_setTheCPtr
newCallback_Shape_setTheC(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_setTheC<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Shape_setTheCPtr
newCallback_Shape_setTheC(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_setTheC<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Shape_setTheCPtr
newCallback_Shape_setTheC(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_setTheC<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Shape_getRoi : public Callback_Shape_getRoi_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::model::RoiPtr&);

    CallbackNC_Shape_getRoi(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::ShapePrx __proxy = ::omero::model::ShapePrx::uncheckedCast(__result->getProxy());
        ::omero::model::RoiPtr __ret;
        try
        {
            __ret = __proxy->end_getRoi(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_Shape_getRoiPtr
newCallback_Shape_getRoi(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::RoiPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_getRoi<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Shape_getRoiPtr
newCallback_Shape_getRoi(T* instance, void (T::*cb)(const ::omero::model::RoiPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_getRoi<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Shape_getRoi : public Callback_Shape_getRoi_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::model::RoiPtr&, const CT&);

    Callback_Shape_getRoi(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::ShapePrx __proxy = ::omero::model::ShapePrx::uncheckedCast(__result->getProxy());
        ::omero::model::RoiPtr __ret;
        try
        {
            __ret = __proxy->end_getRoi(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Shape_getRoiPtr
newCallback_Shape_getRoi(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::RoiPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_getRoi<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Shape_getRoiPtr
newCallback_Shape_getRoi(T* instance, void (T::*cb)(const ::omero::model::RoiPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_getRoi<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Shape_setRoi : public Callback_Shape_setRoi_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Shape_setRoi(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_Shape_setRoiPtr
newCallback_Shape_setRoi(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_setRoi<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Shape_setRoiPtr
newCallback_Shape_setRoi(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_setRoi<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Shape_setRoiPtr
newCallback_Shape_setRoi(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_setRoi<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Shape_setRoiPtr
newCallback_Shape_setRoi(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_setRoi<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Shape_setRoi : public Callback_Shape_setRoi_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Shape_setRoi(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_Shape_setRoiPtr
newCallback_Shape_setRoi(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_setRoi<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Shape_setRoiPtr
newCallback_Shape_setRoi(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_setRoi<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Shape_setRoiPtr
newCallback_Shape_setRoi(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_setRoi<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Shape_setRoiPtr
newCallback_Shape_setRoi(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_setRoi<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Shape_getLocked : public Callback_Shape_getLocked_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::RBoolPtr&);

    CallbackNC_Shape_getLocked(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::ShapePrx __proxy = ::omero::model::ShapePrx::uncheckedCast(__result->getProxy());
        ::omero::RBoolPtr __ret;
        try
        {
            __ret = __proxy->end_getLocked(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_Shape_getLockedPtr
newCallback_Shape_getLocked(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RBoolPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_getLocked<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Shape_getLockedPtr
newCallback_Shape_getLocked(T* instance, void (T::*cb)(const ::omero::RBoolPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_getLocked<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Shape_getLocked : public Callback_Shape_getLocked_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::RBoolPtr&, const CT&);

    Callback_Shape_getLocked(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::ShapePrx __proxy = ::omero::model::ShapePrx::uncheckedCast(__result->getProxy());
        ::omero::RBoolPtr __ret;
        try
        {
            __ret = __proxy->end_getLocked(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Shape_getLockedPtr
newCallback_Shape_getLocked(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RBoolPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_getLocked<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Shape_getLockedPtr
newCallback_Shape_getLocked(T* instance, void (T::*cb)(const ::omero::RBoolPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_getLocked<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Shape_setLocked : public Callback_Shape_setLocked_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Shape_setLocked(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_Shape_setLockedPtr
newCallback_Shape_setLocked(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_setLocked<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Shape_setLockedPtr
newCallback_Shape_setLocked(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_setLocked<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Shape_setLockedPtr
newCallback_Shape_setLocked(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_setLocked<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Shape_setLockedPtr
newCallback_Shape_setLocked(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_setLocked<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Shape_setLocked : public Callback_Shape_setLocked_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Shape_setLocked(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_Shape_setLockedPtr
newCallback_Shape_setLocked(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_setLocked<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Shape_setLockedPtr
newCallback_Shape_setLocked(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_setLocked<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Shape_setLockedPtr
newCallback_Shape_setLocked(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_setLocked<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Shape_setLockedPtr
newCallback_Shape_setLocked(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_setLocked<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Shape_getG : public Callback_Shape_getG_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::RStringPtr&);

    CallbackNC_Shape_getG(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::ShapePrx __proxy = ::omero::model::ShapePrx::uncheckedCast(__result->getProxy());
        ::omero::RStringPtr __ret;
        try
        {
            __ret = __proxy->end_getG(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_Shape_getGPtr
newCallback_Shape_getG(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RStringPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_getG<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Shape_getGPtr
newCallback_Shape_getG(T* instance, void (T::*cb)(const ::omero::RStringPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_getG<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Shape_getG : public Callback_Shape_getG_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::RStringPtr&, const CT&);

    Callback_Shape_getG(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::ShapePrx __proxy = ::omero::model::ShapePrx::uncheckedCast(__result->getProxy());
        ::omero::RStringPtr __ret;
        try
        {
            __ret = __proxy->end_getG(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Shape_getGPtr
newCallback_Shape_getG(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RStringPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_getG<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Shape_getGPtr
newCallback_Shape_getG(T* instance, void (T::*cb)(const ::omero::RStringPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_getG<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Shape_setG : public Callback_Shape_setG_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Shape_setG(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_Shape_setGPtr
newCallback_Shape_setG(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_setG<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Shape_setGPtr
newCallback_Shape_setG(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_setG<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Shape_setGPtr
newCallback_Shape_setG(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_setG<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Shape_setGPtr
newCallback_Shape_setG(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_setG<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Shape_setG : public Callback_Shape_setG_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Shape_setG(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_Shape_setGPtr
newCallback_Shape_setG(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_setG<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Shape_setGPtr
newCallback_Shape_setG(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_setG<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Shape_setGPtr
newCallback_Shape_setG(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_setG<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Shape_setGPtr
newCallback_Shape_setG(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_setG<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Shape_getTransform : public Callback_Shape_getTransform_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::RStringPtr&);

    CallbackNC_Shape_getTransform(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::ShapePrx __proxy = ::omero::model::ShapePrx::uncheckedCast(__result->getProxy());
        ::omero::RStringPtr __ret;
        try
        {
            __ret = __proxy->end_getTransform(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_Shape_getTransformPtr
newCallback_Shape_getTransform(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RStringPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_getTransform<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Shape_getTransformPtr
newCallback_Shape_getTransform(T* instance, void (T::*cb)(const ::omero::RStringPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_getTransform<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Shape_getTransform : public Callback_Shape_getTransform_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::RStringPtr&, const CT&);

    Callback_Shape_getTransform(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::ShapePrx __proxy = ::omero::model::ShapePrx::uncheckedCast(__result->getProxy());
        ::omero::RStringPtr __ret;
        try
        {
            __ret = __proxy->end_getTransform(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Shape_getTransformPtr
newCallback_Shape_getTransform(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RStringPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_getTransform<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Shape_getTransformPtr
newCallback_Shape_getTransform(T* instance, void (T::*cb)(const ::omero::RStringPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_getTransform<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Shape_setTransform : public Callback_Shape_setTransform_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Shape_setTransform(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_Shape_setTransformPtr
newCallback_Shape_setTransform(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_setTransform<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Shape_setTransformPtr
newCallback_Shape_setTransform(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_setTransform<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Shape_setTransformPtr
newCallback_Shape_setTransform(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_setTransform<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Shape_setTransformPtr
newCallback_Shape_setTransform(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_setTransform<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Shape_setTransform : public Callback_Shape_setTransform_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Shape_setTransform(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_Shape_setTransformPtr
newCallback_Shape_setTransform(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_setTransform<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Shape_setTransformPtr
newCallback_Shape_setTransform(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_setTransform<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Shape_setTransformPtr
newCallback_Shape_setTransform(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_setTransform<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Shape_setTransformPtr
newCallback_Shape_setTransform(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_setTransform<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Shape_getVectorEffect : public Callback_Shape_getVectorEffect_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::RStringPtr&);

    CallbackNC_Shape_getVectorEffect(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::ShapePrx __proxy = ::omero::model::ShapePrx::uncheckedCast(__result->getProxy());
        ::omero::RStringPtr __ret;
        try
        {
            __ret = __proxy->end_getVectorEffect(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_Shape_getVectorEffectPtr
newCallback_Shape_getVectorEffect(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RStringPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_getVectorEffect<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Shape_getVectorEffectPtr
newCallback_Shape_getVectorEffect(T* instance, void (T::*cb)(const ::omero::RStringPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_getVectorEffect<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Shape_getVectorEffect : public Callback_Shape_getVectorEffect_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::RStringPtr&, const CT&);

    Callback_Shape_getVectorEffect(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::ShapePrx __proxy = ::omero::model::ShapePrx::uncheckedCast(__result->getProxy());
        ::omero::RStringPtr __ret;
        try
        {
            __ret = __proxy->end_getVectorEffect(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Shape_getVectorEffectPtr
newCallback_Shape_getVectorEffect(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RStringPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_getVectorEffect<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Shape_getVectorEffectPtr
newCallback_Shape_getVectorEffect(T* instance, void (T::*cb)(const ::omero::RStringPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_getVectorEffect<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Shape_setVectorEffect : public Callback_Shape_setVectorEffect_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Shape_setVectorEffect(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_Shape_setVectorEffectPtr
newCallback_Shape_setVectorEffect(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_setVectorEffect<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Shape_setVectorEffectPtr
newCallback_Shape_setVectorEffect(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_setVectorEffect<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Shape_setVectorEffectPtr
newCallback_Shape_setVectorEffect(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_setVectorEffect<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Shape_setVectorEffectPtr
newCallback_Shape_setVectorEffect(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_setVectorEffect<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Shape_setVectorEffect : public Callback_Shape_setVectorEffect_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Shape_setVectorEffect(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_Shape_setVectorEffectPtr
newCallback_Shape_setVectorEffect(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_setVectorEffect<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Shape_setVectorEffectPtr
newCallback_Shape_setVectorEffect(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_setVectorEffect<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Shape_setVectorEffectPtr
newCallback_Shape_setVectorEffect(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_setVectorEffect<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Shape_setVectorEffectPtr
newCallback_Shape_setVectorEffect(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_setVectorEffect<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Shape_getVisibility : public Callback_Shape_getVisibility_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::RBoolPtr&);

    CallbackNC_Shape_getVisibility(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::ShapePrx __proxy = ::omero::model::ShapePrx::uncheckedCast(__result->getProxy());
        ::omero::RBoolPtr __ret;
        try
        {
            __ret = __proxy->end_getVisibility(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_Shape_getVisibilityPtr
newCallback_Shape_getVisibility(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RBoolPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_getVisibility<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Shape_getVisibilityPtr
newCallback_Shape_getVisibility(T* instance, void (T::*cb)(const ::omero::RBoolPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_getVisibility<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Shape_getVisibility : public Callback_Shape_getVisibility_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::RBoolPtr&, const CT&);

    Callback_Shape_getVisibility(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::ShapePrx __proxy = ::omero::model::ShapePrx::uncheckedCast(__result->getProxy());
        ::omero::RBoolPtr __ret;
        try
        {
            __ret = __proxy->end_getVisibility(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Shape_getVisibilityPtr
newCallback_Shape_getVisibility(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RBoolPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_getVisibility<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Shape_getVisibilityPtr
newCallback_Shape_getVisibility(T* instance, void (T::*cb)(const ::omero::RBoolPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_getVisibility<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Shape_setVisibility : public Callback_Shape_setVisibility_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Shape_setVisibility(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_Shape_setVisibilityPtr
newCallback_Shape_setVisibility(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_setVisibility<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Shape_setVisibilityPtr
newCallback_Shape_setVisibility(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_setVisibility<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Shape_setVisibilityPtr
newCallback_Shape_setVisibility(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_setVisibility<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Shape_setVisibilityPtr
newCallback_Shape_setVisibility(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_setVisibility<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Shape_setVisibility : public Callback_Shape_setVisibility_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Shape_setVisibility(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_Shape_setVisibilityPtr
newCallback_Shape_setVisibility(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_setVisibility<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Shape_setVisibilityPtr
newCallback_Shape_setVisibility(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_setVisibility<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Shape_setVisibilityPtr
newCallback_Shape_setVisibility(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_setVisibility<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Shape_setVisibilityPtr
newCallback_Shape_setVisibility(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_setVisibility<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Shape_getFillColor : public Callback_Shape_getFillColor_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::RIntPtr&);

    CallbackNC_Shape_getFillColor(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::ShapePrx __proxy = ::omero::model::ShapePrx::uncheckedCast(__result->getProxy());
        ::omero::RIntPtr __ret;
        try
        {
            __ret = __proxy->end_getFillColor(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_Shape_getFillColorPtr
newCallback_Shape_getFillColor(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RIntPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_getFillColor<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Shape_getFillColorPtr
newCallback_Shape_getFillColor(T* instance, void (T::*cb)(const ::omero::RIntPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_getFillColor<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Shape_getFillColor : public Callback_Shape_getFillColor_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::RIntPtr&, const CT&);

    Callback_Shape_getFillColor(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::ShapePrx __proxy = ::omero::model::ShapePrx::uncheckedCast(__result->getProxy());
        ::omero::RIntPtr __ret;
        try
        {
            __ret = __proxy->end_getFillColor(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Shape_getFillColorPtr
newCallback_Shape_getFillColor(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RIntPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_getFillColor<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Shape_getFillColorPtr
newCallback_Shape_getFillColor(T* instance, void (T::*cb)(const ::omero::RIntPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_getFillColor<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Shape_setFillColor : public Callback_Shape_setFillColor_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Shape_setFillColor(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_Shape_setFillColorPtr
newCallback_Shape_setFillColor(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_setFillColor<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Shape_setFillColorPtr
newCallback_Shape_setFillColor(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_setFillColor<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Shape_setFillColorPtr
newCallback_Shape_setFillColor(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_setFillColor<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Shape_setFillColorPtr
newCallback_Shape_setFillColor(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_setFillColor<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Shape_setFillColor : public Callback_Shape_setFillColor_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Shape_setFillColor(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_Shape_setFillColorPtr
newCallback_Shape_setFillColor(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_setFillColor<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Shape_setFillColorPtr
newCallback_Shape_setFillColor(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_setFillColor<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Shape_setFillColorPtr
newCallback_Shape_setFillColor(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_setFillColor<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Shape_setFillColorPtr
newCallback_Shape_setFillColor(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_setFillColor<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Shape_getFillRule : public Callback_Shape_getFillRule_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::RStringPtr&);

    CallbackNC_Shape_getFillRule(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::ShapePrx __proxy = ::omero::model::ShapePrx::uncheckedCast(__result->getProxy());
        ::omero::RStringPtr __ret;
        try
        {
            __ret = __proxy->end_getFillRule(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_Shape_getFillRulePtr
newCallback_Shape_getFillRule(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RStringPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_getFillRule<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Shape_getFillRulePtr
newCallback_Shape_getFillRule(T* instance, void (T::*cb)(const ::omero::RStringPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_getFillRule<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Shape_getFillRule : public Callback_Shape_getFillRule_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::RStringPtr&, const CT&);

    Callback_Shape_getFillRule(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::ShapePrx __proxy = ::omero::model::ShapePrx::uncheckedCast(__result->getProxy());
        ::omero::RStringPtr __ret;
        try
        {
            __ret = __proxy->end_getFillRule(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Shape_getFillRulePtr
newCallback_Shape_getFillRule(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RStringPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_getFillRule<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Shape_getFillRulePtr
newCallback_Shape_getFillRule(T* instance, void (T::*cb)(const ::omero::RStringPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_getFillRule<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Shape_setFillRule : public Callback_Shape_setFillRule_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Shape_setFillRule(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_Shape_setFillRulePtr
newCallback_Shape_setFillRule(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_setFillRule<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Shape_setFillRulePtr
newCallback_Shape_setFillRule(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_setFillRule<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Shape_setFillRulePtr
newCallback_Shape_setFillRule(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_setFillRule<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Shape_setFillRulePtr
newCallback_Shape_setFillRule(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_setFillRule<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Shape_setFillRule : public Callback_Shape_setFillRule_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Shape_setFillRule(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_Shape_setFillRulePtr
newCallback_Shape_setFillRule(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_setFillRule<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Shape_setFillRulePtr
newCallback_Shape_setFillRule(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_setFillRule<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Shape_setFillRulePtr
newCallback_Shape_setFillRule(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_setFillRule<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Shape_setFillRulePtr
newCallback_Shape_setFillRule(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_setFillRule<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Shape_getStrokeColor : public Callback_Shape_getStrokeColor_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::RIntPtr&);

    CallbackNC_Shape_getStrokeColor(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::ShapePrx __proxy = ::omero::model::ShapePrx::uncheckedCast(__result->getProxy());
        ::omero::RIntPtr __ret;
        try
        {
            __ret = __proxy->end_getStrokeColor(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_Shape_getStrokeColorPtr
newCallback_Shape_getStrokeColor(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RIntPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_getStrokeColor<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Shape_getStrokeColorPtr
newCallback_Shape_getStrokeColor(T* instance, void (T::*cb)(const ::omero::RIntPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_getStrokeColor<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Shape_getStrokeColor : public Callback_Shape_getStrokeColor_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::RIntPtr&, const CT&);

    Callback_Shape_getStrokeColor(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::ShapePrx __proxy = ::omero::model::ShapePrx::uncheckedCast(__result->getProxy());
        ::omero::RIntPtr __ret;
        try
        {
            __ret = __proxy->end_getStrokeColor(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Shape_getStrokeColorPtr
newCallback_Shape_getStrokeColor(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RIntPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_getStrokeColor<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Shape_getStrokeColorPtr
newCallback_Shape_getStrokeColor(T* instance, void (T::*cb)(const ::omero::RIntPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_getStrokeColor<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Shape_setStrokeColor : public Callback_Shape_setStrokeColor_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Shape_setStrokeColor(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_Shape_setStrokeColorPtr
newCallback_Shape_setStrokeColor(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_setStrokeColor<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Shape_setStrokeColorPtr
newCallback_Shape_setStrokeColor(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_setStrokeColor<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Shape_setStrokeColorPtr
newCallback_Shape_setStrokeColor(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_setStrokeColor<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Shape_setStrokeColorPtr
newCallback_Shape_setStrokeColor(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_setStrokeColor<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Shape_setStrokeColor : public Callback_Shape_setStrokeColor_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Shape_setStrokeColor(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_Shape_setStrokeColorPtr
newCallback_Shape_setStrokeColor(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_setStrokeColor<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Shape_setStrokeColorPtr
newCallback_Shape_setStrokeColor(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_setStrokeColor<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Shape_setStrokeColorPtr
newCallback_Shape_setStrokeColor(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_setStrokeColor<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Shape_setStrokeColorPtr
newCallback_Shape_setStrokeColor(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_setStrokeColor<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Shape_getStrokeDashArray : public Callback_Shape_getStrokeDashArray_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::RStringPtr&);

    CallbackNC_Shape_getStrokeDashArray(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::ShapePrx __proxy = ::omero::model::ShapePrx::uncheckedCast(__result->getProxy());
        ::omero::RStringPtr __ret;
        try
        {
            __ret = __proxy->end_getStrokeDashArray(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_Shape_getStrokeDashArrayPtr
newCallback_Shape_getStrokeDashArray(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RStringPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_getStrokeDashArray<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Shape_getStrokeDashArrayPtr
newCallback_Shape_getStrokeDashArray(T* instance, void (T::*cb)(const ::omero::RStringPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_getStrokeDashArray<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Shape_getStrokeDashArray : public Callback_Shape_getStrokeDashArray_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::RStringPtr&, const CT&);

    Callback_Shape_getStrokeDashArray(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::ShapePrx __proxy = ::omero::model::ShapePrx::uncheckedCast(__result->getProxy());
        ::omero::RStringPtr __ret;
        try
        {
            __ret = __proxy->end_getStrokeDashArray(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Shape_getStrokeDashArrayPtr
newCallback_Shape_getStrokeDashArray(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RStringPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_getStrokeDashArray<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Shape_getStrokeDashArrayPtr
newCallback_Shape_getStrokeDashArray(T* instance, void (T::*cb)(const ::omero::RStringPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_getStrokeDashArray<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Shape_setStrokeDashArray : public Callback_Shape_setStrokeDashArray_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Shape_setStrokeDashArray(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_Shape_setStrokeDashArrayPtr
newCallback_Shape_setStrokeDashArray(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_setStrokeDashArray<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Shape_setStrokeDashArrayPtr
newCallback_Shape_setStrokeDashArray(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_setStrokeDashArray<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Shape_setStrokeDashArrayPtr
newCallback_Shape_setStrokeDashArray(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_setStrokeDashArray<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Shape_setStrokeDashArrayPtr
newCallback_Shape_setStrokeDashArray(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_setStrokeDashArray<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Shape_setStrokeDashArray : public Callback_Shape_setStrokeDashArray_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Shape_setStrokeDashArray(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_Shape_setStrokeDashArrayPtr
newCallback_Shape_setStrokeDashArray(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_setStrokeDashArray<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Shape_setStrokeDashArrayPtr
newCallback_Shape_setStrokeDashArray(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_setStrokeDashArray<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Shape_setStrokeDashArrayPtr
newCallback_Shape_setStrokeDashArray(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_setStrokeDashArray<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Shape_setStrokeDashArrayPtr
newCallback_Shape_setStrokeDashArray(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_setStrokeDashArray<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Shape_getStrokeDashOffset : public Callback_Shape_getStrokeDashOffset_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::RIntPtr&);

    CallbackNC_Shape_getStrokeDashOffset(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::ShapePrx __proxy = ::omero::model::ShapePrx::uncheckedCast(__result->getProxy());
        ::omero::RIntPtr __ret;
        try
        {
            __ret = __proxy->end_getStrokeDashOffset(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_Shape_getStrokeDashOffsetPtr
newCallback_Shape_getStrokeDashOffset(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RIntPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_getStrokeDashOffset<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Shape_getStrokeDashOffsetPtr
newCallback_Shape_getStrokeDashOffset(T* instance, void (T::*cb)(const ::omero::RIntPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_getStrokeDashOffset<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Shape_getStrokeDashOffset : public Callback_Shape_getStrokeDashOffset_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::RIntPtr&, const CT&);

    Callback_Shape_getStrokeDashOffset(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::ShapePrx __proxy = ::omero::model::ShapePrx::uncheckedCast(__result->getProxy());
        ::omero::RIntPtr __ret;
        try
        {
            __ret = __proxy->end_getStrokeDashOffset(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Shape_getStrokeDashOffsetPtr
newCallback_Shape_getStrokeDashOffset(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RIntPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_getStrokeDashOffset<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Shape_getStrokeDashOffsetPtr
newCallback_Shape_getStrokeDashOffset(T* instance, void (T::*cb)(const ::omero::RIntPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_getStrokeDashOffset<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Shape_setStrokeDashOffset : public Callback_Shape_setStrokeDashOffset_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Shape_setStrokeDashOffset(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_Shape_setStrokeDashOffsetPtr
newCallback_Shape_setStrokeDashOffset(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_setStrokeDashOffset<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Shape_setStrokeDashOffsetPtr
newCallback_Shape_setStrokeDashOffset(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_setStrokeDashOffset<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Shape_setStrokeDashOffsetPtr
newCallback_Shape_setStrokeDashOffset(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_setStrokeDashOffset<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Shape_setStrokeDashOffsetPtr
newCallback_Shape_setStrokeDashOffset(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_setStrokeDashOffset<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Shape_setStrokeDashOffset : public Callback_Shape_setStrokeDashOffset_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Shape_setStrokeDashOffset(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_Shape_setStrokeDashOffsetPtr
newCallback_Shape_setStrokeDashOffset(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_setStrokeDashOffset<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Shape_setStrokeDashOffsetPtr
newCallback_Shape_setStrokeDashOffset(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_setStrokeDashOffset<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Shape_setStrokeDashOffsetPtr
newCallback_Shape_setStrokeDashOffset(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_setStrokeDashOffset<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Shape_setStrokeDashOffsetPtr
newCallback_Shape_setStrokeDashOffset(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_setStrokeDashOffset<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Shape_getStrokeLineCap : public Callback_Shape_getStrokeLineCap_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::RStringPtr&);

    CallbackNC_Shape_getStrokeLineCap(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::ShapePrx __proxy = ::omero::model::ShapePrx::uncheckedCast(__result->getProxy());
        ::omero::RStringPtr __ret;
        try
        {
            __ret = __proxy->end_getStrokeLineCap(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_Shape_getStrokeLineCapPtr
newCallback_Shape_getStrokeLineCap(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RStringPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_getStrokeLineCap<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Shape_getStrokeLineCapPtr
newCallback_Shape_getStrokeLineCap(T* instance, void (T::*cb)(const ::omero::RStringPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_getStrokeLineCap<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Shape_getStrokeLineCap : public Callback_Shape_getStrokeLineCap_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::RStringPtr&, const CT&);

    Callback_Shape_getStrokeLineCap(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::ShapePrx __proxy = ::omero::model::ShapePrx::uncheckedCast(__result->getProxy());
        ::omero::RStringPtr __ret;
        try
        {
            __ret = __proxy->end_getStrokeLineCap(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Shape_getStrokeLineCapPtr
newCallback_Shape_getStrokeLineCap(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RStringPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_getStrokeLineCap<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Shape_getStrokeLineCapPtr
newCallback_Shape_getStrokeLineCap(T* instance, void (T::*cb)(const ::omero::RStringPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_getStrokeLineCap<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Shape_setStrokeLineCap : public Callback_Shape_setStrokeLineCap_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Shape_setStrokeLineCap(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_Shape_setStrokeLineCapPtr
newCallback_Shape_setStrokeLineCap(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_setStrokeLineCap<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Shape_setStrokeLineCapPtr
newCallback_Shape_setStrokeLineCap(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_setStrokeLineCap<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Shape_setStrokeLineCapPtr
newCallback_Shape_setStrokeLineCap(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_setStrokeLineCap<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Shape_setStrokeLineCapPtr
newCallback_Shape_setStrokeLineCap(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_setStrokeLineCap<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Shape_setStrokeLineCap : public Callback_Shape_setStrokeLineCap_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Shape_setStrokeLineCap(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_Shape_setStrokeLineCapPtr
newCallback_Shape_setStrokeLineCap(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_setStrokeLineCap<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Shape_setStrokeLineCapPtr
newCallback_Shape_setStrokeLineCap(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_setStrokeLineCap<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Shape_setStrokeLineCapPtr
newCallback_Shape_setStrokeLineCap(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_setStrokeLineCap<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Shape_setStrokeLineCapPtr
newCallback_Shape_setStrokeLineCap(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_setStrokeLineCap<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Shape_getStrokeLineJoin : public Callback_Shape_getStrokeLineJoin_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::RStringPtr&);

    CallbackNC_Shape_getStrokeLineJoin(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::ShapePrx __proxy = ::omero::model::ShapePrx::uncheckedCast(__result->getProxy());
        ::omero::RStringPtr __ret;
        try
        {
            __ret = __proxy->end_getStrokeLineJoin(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_Shape_getStrokeLineJoinPtr
newCallback_Shape_getStrokeLineJoin(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RStringPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_getStrokeLineJoin<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Shape_getStrokeLineJoinPtr
newCallback_Shape_getStrokeLineJoin(T* instance, void (T::*cb)(const ::omero::RStringPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_getStrokeLineJoin<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Shape_getStrokeLineJoin : public Callback_Shape_getStrokeLineJoin_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::RStringPtr&, const CT&);

    Callback_Shape_getStrokeLineJoin(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::ShapePrx __proxy = ::omero::model::ShapePrx::uncheckedCast(__result->getProxy());
        ::omero::RStringPtr __ret;
        try
        {
            __ret = __proxy->end_getStrokeLineJoin(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Shape_getStrokeLineJoinPtr
newCallback_Shape_getStrokeLineJoin(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RStringPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_getStrokeLineJoin<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Shape_getStrokeLineJoinPtr
newCallback_Shape_getStrokeLineJoin(T* instance, void (T::*cb)(const ::omero::RStringPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_getStrokeLineJoin<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Shape_setStrokeLineJoin : public Callback_Shape_setStrokeLineJoin_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Shape_setStrokeLineJoin(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_Shape_setStrokeLineJoinPtr
newCallback_Shape_setStrokeLineJoin(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_setStrokeLineJoin<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Shape_setStrokeLineJoinPtr
newCallback_Shape_setStrokeLineJoin(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_setStrokeLineJoin<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Shape_setStrokeLineJoinPtr
newCallback_Shape_setStrokeLineJoin(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_setStrokeLineJoin<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Shape_setStrokeLineJoinPtr
newCallback_Shape_setStrokeLineJoin(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_setStrokeLineJoin<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Shape_setStrokeLineJoin : public Callback_Shape_setStrokeLineJoin_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Shape_setStrokeLineJoin(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_Shape_setStrokeLineJoinPtr
newCallback_Shape_setStrokeLineJoin(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_setStrokeLineJoin<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Shape_setStrokeLineJoinPtr
newCallback_Shape_setStrokeLineJoin(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_setStrokeLineJoin<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Shape_setStrokeLineJoinPtr
newCallback_Shape_setStrokeLineJoin(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_setStrokeLineJoin<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Shape_setStrokeLineJoinPtr
newCallback_Shape_setStrokeLineJoin(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_setStrokeLineJoin<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Shape_getStrokeMiterLimit : public Callback_Shape_getStrokeMiterLimit_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::RIntPtr&);

    CallbackNC_Shape_getStrokeMiterLimit(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::ShapePrx __proxy = ::omero::model::ShapePrx::uncheckedCast(__result->getProxy());
        ::omero::RIntPtr __ret;
        try
        {
            __ret = __proxy->end_getStrokeMiterLimit(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_Shape_getStrokeMiterLimitPtr
newCallback_Shape_getStrokeMiterLimit(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RIntPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_getStrokeMiterLimit<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Shape_getStrokeMiterLimitPtr
newCallback_Shape_getStrokeMiterLimit(T* instance, void (T::*cb)(const ::omero::RIntPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_getStrokeMiterLimit<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Shape_getStrokeMiterLimit : public Callback_Shape_getStrokeMiterLimit_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::RIntPtr&, const CT&);

    Callback_Shape_getStrokeMiterLimit(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::ShapePrx __proxy = ::omero::model::ShapePrx::uncheckedCast(__result->getProxy());
        ::omero::RIntPtr __ret;
        try
        {
            __ret = __proxy->end_getStrokeMiterLimit(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Shape_getStrokeMiterLimitPtr
newCallback_Shape_getStrokeMiterLimit(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RIntPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_getStrokeMiterLimit<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Shape_getStrokeMiterLimitPtr
newCallback_Shape_getStrokeMiterLimit(T* instance, void (T::*cb)(const ::omero::RIntPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_getStrokeMiterLimit<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Shape_setStrokeMiterLimit : public Callback_Shape_setStrokeMiterLimit_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Shape_setStrokeMiterLimit(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_Shape_setStrokeMiterLimitPtr
newCallback_Shape_setStrokeMiterLimit(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_setStrokeMiterLimit<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Shape_setStrokeMiterLimitPtr
newCallback_Shape_setStrokeMiterLimit(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_setStrokeMiterLimit<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Shape_setStrokeMiterLimitPtr
newCallback_Shape_setStrokeMiterLimit(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_setStrokeMiterLimit<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Shape_setStrokeMiterLimitPtr
newCallback_Shape_setStrokeMiterLimit(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_setStrokeMiterLimit<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Shape_setStrokeMiterLimit : public Callback_Shape_setStrokeMiterLimit_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Shape_setStrokeMiterLimit(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_Shape_setStrokeMiterLimitPtr
newCallback_Shape_setStrokeMiterLimit(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_setStrokeMiterLimit<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Shape_setStrokeMiterLimitPtr
newCallback_Shape_setStrokeMiterLimit(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_setStrokeMiterLimit<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Shape_setStrokeMiterLimitPtr
newCallback_Shape_setStrokeMiterLimit(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_setStrokeMiterLimit<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Shape_setStrokeMiterLimitPtr
newCallback_Shape_setStrokeMiterLimit(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_setStrokeMiterLimit<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Shape_getStrokeWidth : public Callback_Shape_getStrokeWidth_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::RIntPtr&);

    CallbackNC_Shape_getStrokeWidth(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::ShapePrx __proxy = ::omero::model::ShapePrx::uncheckedCast(__result->getProxy());
        ::omero::RIntPtr __ret;
        try
        {
            __ret = __proxy->end_getStrokeWidth(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_Shape_getStrokeWidthPtr
newCallback_Shape_getStrokeWidth(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RIntPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_getStrokeWidth<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Shape_getStrokeWidthPtr
newCallback_Shape_getStrokeWidth(T* instance, void (T::*cb)(const ::omero::RIntPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_getStrokeWidth<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Shape_getStrokeWidth : public Callback_Shape_getStrokeWidth_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::RIntPtr&, const CT&);

    Callback_Shape_getStrokeWidth(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::ShapePrx __proxy = ::omero::model::ShapePrx::uncheckedCast(__result->getProxy());
        ::omero::RIntPtr __ret;
        try
        {
            __ret = __proxy->end_getStrokeWidth(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Shape_getStrokeWidthPtr
newCallback_Shape_getStrokeWidth(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RIntPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_getStrokeWidth<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Shape_getStrokeWidthPtr
newCallback_Shape_getStrokeWidth(T* instance, void (T::*cb)(const ::omero::RIntPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_getStrokeWidth<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Shape_setStrokeWidth : public Callback_Shape_setStrokeWidth_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Shape_setStrokeWidth(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_Shape_setStrokeWidthPtr
newCallback_Shape_setStrokeWidth(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_setStrokeWidth<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Shape_setStrokeWidthPtr
newCallback_Shape_setStrokeWidth(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_setStrokeWidth<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Shape_setStrokeWidthPtr
newCallback_Shape_setStrokeWidth(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_setStrokeWidth<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Shape_setStrokeWidthPtr
newCallback_Shape_setStrokeWidth(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_setStrokeWidth<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Shape_setStrokeWidth : public Callback_Shape_setStrokeWidth_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Shape_setStrokeWidth(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_Shape_setStrokeWidthPtr
newCallback_Shape_setStrokeWidth(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_setStrokeWidth<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Shape_setStrokeWidthPtr
newCallback_Shape_setStrokeWidth(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_setStrokeWidth<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Shape_setStrokeWidthPtr
newCallback_Shape_setStrokeWidth(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_setStrokeWidth<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Shape_setStrokeWidthPtr
newCallback_Shape_setStrokeWidth(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_setStrokeWidth<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Shape_getFontFamily : public Callback_Shape_getFontFamily_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::RStringPtr&);

    CallbackNC_Shape_getFontFamily(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::ShapePrx __proxy = ::omero::model::ShapePrx::uncheckedCast(__result->getProxy());
        ::omero::RStringPtr __ret;
        try
        {
            __ret = __proxy->end_getFontFamily(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_Shape_getFontFamilyPtr
newCallback_Shape_getFontFamily(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RStringPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_getFontFamily<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Shape_getFontFamilyPtr
newCallback_Shape_getFontFamily(T* instance, void (T::*cb)(const ::omero::RStringPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_getFontFamily<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Shape_getFontFamily : public Callback_Shape_getFontFamily_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::RStringPtr&, const CT&);

    Callback_Shape_getFontFamily(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::ShapePrx __proxy = ::omero::model::ShapePrx::uncheckedCast(__result->getProxy());
        ::omero::RStringPtr __ret;
        try
        {
            __ret = __proxy->end_getFontFamily(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Shape_getFontFamilyPtr
newCallback_Shape_getFontFamily(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RStringPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_getFontFamily<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Shape_getFontFamilyPtr
newCallback_Shape_getFontFamily(T* instance, void (T::*cb)(const ::omero::RStringPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_getFontFamily<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Shape_setFontFamily : public Callback_Shape_setFontFamily_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Shape_setFontFamily(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_Shape_setFontFamilyPtr
newCallback_Shape_setFontFamily(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_setFontFamily<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Shape_setFontFamilyPtr
newCallback_Shape_setFontFamily(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_setFontFamily<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Shape_setFontFamilyPtr
newCallback_Shape_setFontFamily(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_setFontFamily<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Shape_setFontFamilyPtr
newCallback_Shape_setFontFamily(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_setFontFamily<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Shape_setFontFamily : public Callback_Shape_setFontFamily_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Shape_setFontFamily(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_Shape_setFontFamilyPtr
newCallback_Shape_setFontFamily(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_setFontFamily<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Shape_setFontFamilyPtr
newCallback_Shape_setFontFamily(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_setFontFamily<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Shape_setFontFamilyPtr
newCallback_Shape_setFontFamily(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_setFontFamily<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Shape_setFontFamilyPtr
newCallback_Shape_setFontFamily(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_setFontFamily<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Shape_getFontSize : public Callback_Shape_getFontSize_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::RIntPtr&);

    CallbackNC_Shape_getFontSize(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::ShapePrx __proxy = ::omero::model::ShapePrx::uncheckedCast(__result->getProxy());
        ::omero::RIntPtr __ret;
        try
        {
            __ret = __proxy->end_getFontSize(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_Shape_getFontSizePtr
newCallback_Shape_getFontSize(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RIntPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_getFontSize<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Shape_getFontSizePtr
newCallback_Shape_getFontSize(T* instance, void (T::*cb)(const ::omero::RIntPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_getFontSize<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Shape_getFontSize : public Callback_Shape_getFontSize_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::RIntPtr&, const CT&);

    Callback_Shape_getFontSize(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::ShapePrx __proxy = ::omero::model::ShapePrx::uncheckedCast(__result->getProxy());
        ::omero::RIntPtr __ret;
        try
        {
            __ret = __proxy->end_getFontSize(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Shape_getFontSizePtr
newCallback_Shape_getFontSize(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RIntPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_getFontSize<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Shape_getFontSizePtr
newCallback_Shape_getFontSize(T* instance, void (T::*cb)(const ::omero::RIntPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_getFontSize<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Shape_setFontSize : public Callback_Shape_setFontSize_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Shape_setFontSize(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_Shape_setFontSizePtr
newCallback_Shape_setFontSize(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_setFontSize<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Shape_setFontSizePtr
newCallback_Shape_setFontSize(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_setFontSize<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Shape_setFontSizePtr
newCallback_Shape_setFontSize(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_setFontSize<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Shape_setFontSizePtr
newCallback_Shape_setFontSize(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_setFontSize<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Shape_setFontSize : public Callback_Shape_setFontSize_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Shape_setFontSize(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_Shape_setFontSizePtr
newCallback_Shape_setFontSize(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_setFontSize<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Shape_setFontSizePtr
newCallback_Shape_setFontSize(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_setFontSize<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Shape_setFontSizePtr
newCallback_Shape_setFontSize(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_setFontSize<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Shape_setFontSizePtr
newCallback_Shape_setFontSize(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_setFontSize<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Shape_getFontStretch : public Callback_Shape_getFontStretch_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::RStringPtr&);

    CallbackNC_Shape_getFontStretch(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::ShapePrx __proxy = ::omero::model::ShapePrx::uncheckedCast(__result->getProxy());
        ::omero::RStringPtr __ret;
        try
        {
            __ret = __proxy->end_getFontStretch(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_Shape_getFontStretchPtr
newCallback_Shape_getFontStretch(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RStringPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_getFontStretch<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Shape_getFontStretchPtr
newCallback_Shape_getFontStretch(T* instance, void (T::*cb)(const ::omero::RStringPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_getFontStretch<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Shape_getFontStretch : public Callback_Shape_getFontStretch_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::RStringPtr&, const CT&);

    Callback_Shape_getFontStretch(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::ShapePrx __proxy = ::omero::model::ShapePrx::uncheckedCast(__result->getProxy());
        ::omero::RStringPtr __ret;
        try
        {
            __ret = __proxy->end_getFontStretch(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Shape_getFontStretchPtr
newCallback_Shape_getFontStretch(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RStringPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_getFontStretch<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Shape_getFontStretchPtr
newCallback_Shape_getFontStretch(T* instance, void (T::*cb)(const ::omero::RStringPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_getFontStretch<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Shape_setFontStretch : public Callback_Shape_setFontStretch_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Shape_setFontStretch(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_Shape_setFontStretchPtr
newCallback_Shape_setFontStretch(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_setFontStretch<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Shape_setFontStretchPtr
newCallback_Shape_setFontStretch(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_setFontStretch<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Shape_setFontStretchPtr
newCallback_Shape_setFontStretch(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_setFontStretch<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Shape_setFontStretchPtr
newCallback_Shape_setFontStretch(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_setFontStretch<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Shape_setFontStretch : public Callback_Shape_setFontStretch_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Shape_setFontStretch(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_Shape_setFontStretchPtr
newCallback_Shape_setFontStretch(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_setFontStretch<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Shape_setFontStretchPtr
newCallback_Shape_setFontStretch(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_setFontStretch<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Shape_setFontStretchPtr
newCallback_Shape_setFontStretch(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_setFontStretch<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Shape_setFontStretchPtr
newCallback_Shape_setFontStretch(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_setFontStretch<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Shape_getFontStyle : public Callback_Shape_getFontStyle_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::RStringPtr&);

    CallbackNC_Shape_getFontStyle(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::ShapePrx __proxy = ::omero::model::ShapePrx::uncheckedCast(__result->getProxy());
        ::omero::RStringPtr __ret;
        try
        {
            __ret = __proxy->end_getFontStyle(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_Shape_getFontStylePtr
newCallback_Shape_getFontStyle(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RStringPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_getFontStyle<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Shape_getFontStylePtr
newCallback_Shape_getFontStyle(T* instance, void (T::*cb)(const ::omero::RStringPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_getFontStyle<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Shape_getFontStyle : public Callback_Shape_getFontStyle_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::RStringPtr&, const CT&);

    Callback_Shape_getFontStyle(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::ShapePrx __proxy = ::omero::model::ShapePrx::uncheckedCast(__result->getProxy());
        ::omero::RStringPtr __ret;
        try
        {
            __ret = __proxy->end_getFontStyle(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Shape_getFontStylePtr
newCallback_Shape_getFontStyle(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RStringPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_getFontStyle<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Shape_getFontStylePtr
newCallback_Shape_getFontStyle(T* instance, void (T::*cb)(const ::omero::RStringPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_getFontStyle<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Shape_setFontStyle : public Callback_Shape_setFontStyle_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Shape_setFontStyle(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_Shape_setFontStylePtr
newCallback_Shape_setFontStyle(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_setFontStyle<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Shape_setFontStylePtr
newCallback_Shape_setFontStyle(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_setFontStyle<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Shape_setFontStylePtr
newCallback_Shape_setFontStyle(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_setFontStyle<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Shape_setFontStylePtr
newCallback_Shape_setFontStyle(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_setFontStyle<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Shape_setFontStyle : public Callback_Shape_setFontStyle_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Shape_setFontStyle(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_Shape_setFontStylePtr
newCallback_Shape_setFontStyle(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_setFontStyle<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Shape_setFontStylePtr
newCallback_Shape_setFontStyle(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_setFontStyle<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Shape_setFontStylePtr
newCallback_Shape_setFontStyle(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_setFontStyle<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Shape_setFontStylePtr
newCallback_Shape_setFontStyle(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_setFontStyle<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Shape_getFontVariant : public Callback_Shape_getFontVariant_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::RStringPtr&);

    CallbackNC_Shape_getFontVariant(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::ShapePrx __proxy = ::omero::model::ShapePrx::uncheckedCast(__result->getProxy());
        ::omero::RStringPtr __ret;
        try
        {
            __ret = __proxy->end_getFontVariant(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_Shape_getFontVariantPtr
newCallback_Shape_getFontVariant(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RStringPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_getFontVariant<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Shape_getFontVariantPtr
newCallback_Shape_getFontVariant(T* instance, void (T::*cb)(const ::omero::RStringPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_getFontVariant<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Shape_getFontVariant : public Callback_Shape_getFontVariant_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::RStringPtr&, const CT&);

    Callback_Shape_getFontVariant(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::ShapePrx __proxy = ::omero::model::ShapePrx::uncheckedCast(__result->getProxy());
        ::omero::RStringPtr __ret;
        try
        {
            __ret = __proxy->end_getFontVariant(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Shape_getFontVariantPtr
newCallback_Shape_getFontVariant(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RStringPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_getFontVariant<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Shape_getFontVariantPtr
newCallback_Shape_getFontVariant(T* instance, void (T::*cb)(const ::omero::RStringPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_getFontVariant<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Shape_setFontVariant : public Callback_Shape_setFontVariant_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Shape_setFontVariant(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_Shape_setFontVariantPtr
newCallback_Shape_setFontVariant(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_setFontVariant<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Shape_setFontVariantPtr
newCallback_Shape_setFontVariant(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_setFontVariant<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Shape_setFontVariantPtr
newCallback_Shape_setFontVariant(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_setFontVariant<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Shape_setFontVariantPtr
newCallback_Shape_setFontVariant(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_setFontVariant<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Shape_setFontVariant : public Callback_Shape_setFontVariant_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Shape_setFontVariant(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_Shape_setFontVariantPtr
newCallback_Shape_setFontVariant(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_setFontVariant<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Shape_setFontVariantPtr
newCallback_Shape_setFontVariant(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_setFontVariant<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Shape_setFontVariantPtr
newCallback_Shape_setFontVariant(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_setFontVariant<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Shape_setFontVariantPtr
newCallback_Shape_setFontVariant(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_setFontVariant<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Shape_getFontWeight : public Callback_Shape_getFontWeight_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::RStringPtr&);

    CallbackNC_Shape_getFontWeight(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::ShapePrx __proxy = ::omero::model::ShapePrx::uncheckedCast(__result->getProxy());
        ::omero::RStringPtr __ret;
        try
        {
            __ret = __proxy->end_getFontWeight(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_Shape_getFontWeightPtr
newCallback_Shape_getFontWeight(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RStringPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_getFontWeight<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Shape_getFontWeightPtr
newCallback_Shape_getFontWeight(T* instance, void (T::*cb)(const ::omero::RStringPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_getFontWeight<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Shape_getFontWeight : public Callback_Shape_getFontWeight_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::RStringPtr&, const CT&);

    Callback_Shape_getFontWeight(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::ShapePrx __proxy = ::omero::model::ShapePrx::uncheckedCast(__result->getProxy());
        ::omero::RStringPtr __ret;
        try
        {
            __ret = __proxy->end_getFontWeight(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Shape_getFontWeightPtr
newCallback_Shape_getFontWeight(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RStringPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_getFontWeight<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Shape_getFontWeightPtr
newCallback_Shape_getFontWeight(T* instance, void (T::*cb)(const ::omero::RStringPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_getFontWeight<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Shape_setFontWeight : public Callback_Shape_setFontWeight_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Shape_setFontWeight(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_Shape_setFontWeightPtr
newCallback_Shape_setFontWeight(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_setFontWeight<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Shape_setFontWeightPtr
newCallback_Shape_setFontWeight(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_setFontWeight<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Shape_setFontWeightPtr
newCallback_Shape_setFontWeight(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_setFontWeight<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Shape_setFontWeightPtr
newCallback_Shape_setFontWeight(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Shape_setFontWeight<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Shape_setFontWeight : public Callback_Shape_setFontWeight_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Shape_setFontWeight(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_Shape_setFontWeightPtr
newCallback_Shape_setFontWeight(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_setFontWeight<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Shape_setFontWeightPtr
newCallback_Shape_setFontWeight(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_setFontWeight<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Shape_setFontWeightPtr
newCallback_Shape_setFontWeight(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_setFontWeight<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Shape_setFontWeightPtr
newCallback_Shape_setFontWeight(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Shape_setFontWeight<T, CT>(instance, 0, excb, sentcb);
}

}

}

#endif
