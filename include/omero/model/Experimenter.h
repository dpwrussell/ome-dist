// **********************************************************************
//
// Copyright (c) 2003-2011 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.4.2
//
// <auto-generated>
//
// Generated from file `Experimenter.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __omero_model__opt_hudson_workspace_OMERO_5_0_release_src_components_blitz_generated_omero_model_Experimenter_h__
#define __omero_model__opt_hudson_workspace_OMERO_5_0_release_src_components_blitz_generated_omero_model_Experimenter_h__

#include <Ice/LocalObjectF.h>
#include <Ice/ProxyF.h>
#include <Ice/ObjectF.h>
#include <Ice/Exception.h>
#include <Ice/LocalObject.h>
#include <Ice/Proxy.h>
#include <Ice/Object.h>
#include <Ice/Outgoing.h>
#include <Ice/OutgoingAsync.h>
#include <Ice/Incoming.h>
#include <Ice/Direct.h>
#include <Ice/FactoryTableInit.h>
#include <IceUtil/ScopedArray.h>
#include <Ice/StreamF.h>
#include <omero/model/IObject.h>
#include <omero/RTypes.h>
#include <omero/System.h>
#include <omero/Collections.h>
#include <Ice/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 304
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 > 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 2
#       error Ice patch level mismatch!
#   endif
#endif

namespace IceProxy
{

namespace omero
{

namespace model
{

class GroupExperimenterMap;

class ExperimenterGroup;

class ExperimenterAnnotationLink;

class Annotation;

class Details;

class Experimenter;

}

}

}

namespace omero
{

namespace model
{

class GroupExperimenterMap;
bool operator==(const GroupExperimenterMap&, const GroupExperimenterMap&);
bool operator<(const GroupExperimenterMap&, const GroupExperimenterMap&);

class ExperimenterGroup;
bool operator==(const ExperimenterGroup&, const ExperimenterGroup&);
bool operator<(const ExperimenterGroup&, const ExperimenterGroup&);

class ExperimenterAnnotationLink;
bool operator==(const ExperimenterAnnotationLink&, const ExperimenterAnnotationLink&);
bool operator<(const ExperimenterAnnotationLink&, const ExperimenterAnnotationLink&);

class Annotation;
bool operator==(const Annotation&, const Annotation&);
bool operator<(const Annotation&, const Annotation&);

class Details;
bool operator==(const Details&, const Details&);
bool operator<(const Details&, const Details&);

class Experimenter;
bool operator==(const Experimenter&, const Experimenter&);
bool operator<(const Experimenter&, const Experimenter&);

}

}

namespace IceInternal
{

::Ice::Object* upCast(::omero::model::GroupExperimenterMap*);
::IceProxy::Ice::Object* upCast(::IceProxy::omero::model::GroupExperimenterMap*);

::Ice::Object* upCast(::omero::model::ExperimenterGroup*);
::IceProxy::Ice::Object* upCast(::IceProxy::omero::model::ExperimenterGroup*);

::Ice::Object* upCast(::omero::model::ExperimenterAnnotationLink*);
::IceProxy::Ice::Object* upCast(::IceProxy::omero::model::ExperimenterAnnotationLink*);

::Ice::Object* upCast(::omero::model::Annotation*);
::IceProxy::Ice::Object* upCast(::IceProxy::omero::model::Annotation*);

::Ice::Object* upCast(::omero::model::Details*);
::IceProxy::Ice::Object* upCast(::IceProxy::omero::model::Details*);

::Ice::Object* upCast(::omero::model::Experimenter*);
::IceProxy::Ice::Object* upCast(::IceProxy::omero::model::Experimenter*);

}

namespace omero
{

namespace model
{

typedef ::IceInternal::Handle< ::omero::model::GroupExperimenterMap> GroupExperimenterMapPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::omero::model::GroupExperimenterMap> GroupExperimenterMapPrx;

void __read(::IceInternal::BasicStream*, GroupExperimenterMapPrx&);
void __patch__GroupExperimenterMapPtr(void*, ::Ice::ObjectPtr&);

typedef ::IceInternal::Handle< ::omero::model::ExperimenterGroup> ExperimenterGroupPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::omero::model::ExperimenterGroup> ExperimenterGroupPrx;

void __read(::IceInternal::BasicStream*, ExperimenterGroupPrx&);
void __patch__ExperimenterGroupPtr(void*, ::Ice::ObjectPtr&);

typedef ::IceInternal::Handle< ::omero::model::ExperimenterAnnotationLink> ExperimenterAnnotationLinkPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::omero::model::ExperimenterAnnotationLink> ExperimenterAnnotationLinkPrx;

void __read(::IceInternal::BasicStream*, ExperimenterAnnotationLinkPrx&);
void __patch__ExperimenterAnnotationLinkPtr(void*, ::Ice::ObjectPtr&);

typedef ::IceInternal::Handle< ::omero::model::Annotation> AnnotationPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::omero::model::Annotation> AnnotationPrx;

void __read(::IceInternal::BasicStream*, AnnotationPrx&);
void __patch__AnnotationPtr(void*, ::Ice::ObjectPtr&);

typedef ::IceInternal::Handle< ::omero::model::Details> DetailsPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::omero::model::Details> DetailsPrx;

void __read(::IceInternal::BasicStream*, DetailsPrx&);
void __patch__DetailsPtr(void*, ::Ice::ObjectPtr&);

typedef ::IceInternal::Handle< ::omero::model::Experimenter> ExperimenterPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::omero::model::Experimenter> ExperimenterPrx;

void __read(::IceInternal::BasicStream*, ExperimenterPrx&);
void __patch__ExperimenterPtr(void*, ::Ice::ObjectPtr&);

}

}

namespace omero
{

namespace model
{

typedef ::std::vector< ::omero::model::GroupExperimenterMapPtr> ExperimenterGroupExperimenterMapSeq;
void __writeExperimenterGroupExperimenterMapSeq(::IceInternal::BasicStream*, const ::omero::model::GroupExperimenterMapPtr*, const ::omero::model::GroupExperimenterMapPtr*);
void __readExperimenterGroupExperimenterMapSeq(::IceInternal::BasicStream*, ExperimenterGroupExperimenterMapSeq&);

typedef ::std::vector< ::omero::model::ExperimenterGroupPtr> ExperimenterLinkedExperimenterGroupSeq;
void __writeExperimenterLinkedExperimenterGroupSeq(::IceInternal::BasicStream*, const ::omero::model::ExperimenterGroupPtr*, const ::omero::model::ExperimenterGroupPtr*);
void __readExperimenterLinkedExperimenterGroupSeq(::IceInternal::BasicStream*, ExperimenterLinkedExperimenterGroupSeq&);

typedef ::std::vector< ::omero::model::ExperimenterAnnotationLinkPtr> ExperimenterAnnotationLinksSeq;
void __writeExperimenterAnnotationLinksSeq(::IceInternal::BasicStream*, const ::omero::model::ExperimenterAnnotationLinkPtr*, const ::omero::model::ExperimenterAnnotationLinkPtr*);
void __readExperimenterAnnotationLinksSeq(::IceInternal::BasicStream*, ExperimenterAnnotationLinksSeq&);

typedef ::std::vector< ::omero::model::AnnotationPtr> ExperimenterLinkedAnnotationSeq;
void __writeExperimenterLinkedAnnotationSeq(::IceInternal::BasicStream*, const ::omero::model::AnnotationPtr*, const ::omero::model::AnnotationPtr*);
void __readExperimenterLinkedAnnotationSeq(::IceInternal::BasicStream*, ExperimenterLinkedAnnotationSeq&);

}

}

namespace omero
{

namespace model
{

class Callback_Experimenter_getVersion_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Experimenter_getVersion_Base> Callback_Experimenter_getVersionPtr;

class Callback_Experimenter_setVersion_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Experimenter_setVersion_Base> Callback_Experimenter_setVersionPtr;

class Callback_Experimenter_unloadGroupExperimenterMap_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Experimenter_unloadGroupExperimenterMap_Base> Callback_Experimenter_unloadGroupExperimenterMapPtr;

class Callback_Experimenter_sizeOfGroupExperimenterMap_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Experimenter_sizeOfGroupExperimenterMap_Base> Callback_Experimenter_sizeOfGroupExperimenterMapPtr;

class Callback_Experimenter_copyGroupExperimenterMap_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Experimenter_copyGroupExperimenterMap_Base> Callback_Experimenter_copyGroupExperimenterMapPtr;

class Callback_Experimenter_addGroupExperimenterMap_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Experimenter_addGroupExperimenterMap_Base> Callback_Experimenter_addGroupExperimenterMapPtr;

class Callback_Experimenter_addAllGroupExperimenterMapSet_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Experimenter_addAllGroupExperimenterMapSet_Base> Callback_Experimenter_addAllGroupExperimenterMapSetPtr;

class Callback_Experimenter_removeGroupExperimenterMap_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Experimenter_removeGroupExperimenterMap_Base> Callback_Experimenter_removeGroupExperimenterMapPtr;

class Callback_Experimenter_removeAllGroupExperimenterMapSet_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Experimenter_removeAllGroupExperimenterMapSet_Base> Callback_Experimenter_removeAllGroupExperimenterMapSetPtr;

class Callback_Experimenter_clearGroupExperimenterMap_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Experimenter_clearGroupExperimenterMap_Base> Callback_Experimenter_clearGroupExperimenterMapPtr;

class Callback_Experimenter_reloadGroupExperimenterMap_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Experimenter_reloadGroupExperimenterMap_Base> Callback_Experimenter_reloadGroupExperimenterMapPtr;

class Callback_Experimenter_getGroupExperimenterMap_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Experimenter_getGroupExperimenterMap_Base> Callback_Experimenter_getGroupExperimenterMapPtr;

class Callback_Experimenter_setGroupExperimenterMap_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Experimenter_setGroupExperimenterMap_Base> Callback_Experimenter_setGroupExperimenterMapPtr;

class Callback_Experimenter_getPrimaryGroupExperimenterMap_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Experimenter_getPrimaryGroupExperimenterMap_Base> Callback_Experimenter_getPrimaryGroupExperimenterMapPtr;

class Callback_Experimenter_setPrimaryGroupExperimenterMap_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Experimenter_setPrimaryGroupExperimenterMap_Base> Callback_Experimenter_setPrimaryGroupExperimenterMapPtr;

class Callback_Experimenter_linkExperimenterGroup_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Experimenter_linkExperimenterGroup_Base> Callback_Experimenter_linkExperimenterGroupPtr;

class Callback_Experimenter_addGroupExperimenterMapToBoth_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Experimenter_addGroupExperimenterMapToBoth_Base> Callback_Experimenter_addGroupExperimenterMapToBothPtr;

class Callback_Experimenter_findGroupExperimenterMap_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Experimenter_findGroupExperimenterMap_Base> Callback_Experimenter_findGroupExperimenterMapPtr;

class Callback_Experimenter_unlinkExperimenterGroup_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Experimenter_unlinkExperimenterGroup_Base> Callback_Experimenter_unlinkExperimenterGroupPtr;

class Callback_Experimenter_removeGroupExperimenterMapFromBoth_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Experimenter_removeGroupExperimenterMapFromBoth_Base> Callback_Experimenter_removeGroupExperimenterMapFromBothPtr;

class Callback_Experimenter_linkedExperimenterGroupList_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Experimenter_linkedExperimenterGroupList_Base> Callback_Experimenter_linkedExperimenterGroupListPtr;

class Callback_Experimenter_getOmeName_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Experimenter_getOmeName_Base> Callback_Experimenter_getOmeNamePtr;

class Callback_Experimenter_setOmeName_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Experimenter_setOmeName_Base> Callback_Experimenter_setOmeNamePtr;

class Callback_Experimenter_getFirstName_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Experimenter_getFirstName_Base> Callback_Experimenter_getFirstNamePtr;

class Callback_Experimenter_setFirstName_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Experimenter_setFirstName_Base> Callback_Experimenter_setFirstNamePtr;

class Callback_Experimenter_getMiddleName_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Experimenter_getMiddleName_Base> Callback_Experimenter_getMiddleNamePtr;

class Callback_Experimenter_setMiddleName_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Experimenter_setMiddleName_Base> Callback_Experimenter_setMiddleNamePtr;

class Callback_Experimenter_getLastName_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Experimenter_getLastName_Base> Callback_Experimenter_getLastNamePtr;

class Callback_Experimenter_setLastName_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Experimenter_setLastName_Base> Callback_Experimenter_setLastNamePtr;

class Callback_Experimenter_getInstitution_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Experimenter_getInstitution_Base> Callback_Experimenter_getInstitutionPtr;

class Callback_Experimenter_setInstitution_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Experimenter_setInstitution_Base> Callback_Experimenter_setInstitutionPtr;

class Callback_Experimenter_getEmail_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Experimenter_getEmail_Base> Callback_Experimenter_getEmailPtr;

class Callback_Experimenter_setEmail_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Experimenter_setEmail_Base> Callback_Experimenter_setEmailPtr;

class Callback_Experimenter_unloadAnnotationLinks_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Experimenter_unloadAnnotationLinks_Base> Callback_Experimenter_unloadAnnotationLinksPtr;

class Callback_Experimenter_sizeOfAnnotationLinks_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Experimenter_sizeOfAnnotationLinks_Base> Callback_Experimenter_sizeOfAnnotationLinksPtr;

class Callback_Experimenter_copyAnnotationLinks_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Experimenter_copyAnnotationLinks_Base> Callback_Experimenter_copyAnnotationLinksPtr;

class Callback_Experimenter_addExperimenterAnnotationLink_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Experimenter_addExperimenterAnnotationLink_Base> Callback_Experimenter_addExperimenterAnnotationLinkPtr;

class Callback_Experimenter_addAllExperimenterAnnotationLinkSet_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Experimenter_addAllExperimenterAnnotationLinkSet_Base> Callback_Experimenter_addAllExperimenterAnnotationLinkSetPtr;

class Callback_Experimenter_removeExperimenterAnnotationLink_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Experimenter_removeExperimenterAnnotationLink_Base> Callback_Experimenter_removeExperimenterAnnotationLinkPtr;

class Callback_Experimenter_removeAllExperimenterAnnotationLinkSet_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Experimenter_removeAllExperimenterAnnotationLinkSet_Base> Callback_Experimenter_removeAllExperimenterAnnotationLinkSetPtr;

class Callback_Experimenter_clearAnnotationLinks_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Experimenter_clearAnnotationLinks_Base> Callback_Experimenter_clearAnnotationLinksPtr;

class Callback_Experimenter_reloadAnnotationLinks_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Experimenter_reloadAnnotationLinks_Base> Callback_Experimenter_reloadAnnotationLinksPtr;

class Callback_Experimenter_getAnnotationLinksCountPerOwner_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Experimenter_getAnnotationLinksCountPerOwner_Base> Callback_Experimenter_getAnnotationLinksCountPerOwnerPtr;

class Callback_Experimenter_linkAnnotation_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Experimenter_linkAnnotation_Base> Callback_Experimenter_linkAnnotationPtr;

class Callback_Experimenter_addExperimenterAnnotationLinkToBoth_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Experimenter_addExperimenterAnnotationLinkToBoth_Base> Callback_Experimenter_addExperimenterAnnotationLinkToBothPtr;

class Callback_Experimenter_findExperimenterAnnotationLink_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Experimenter_findExperimenterAnnotationLink_Base> Callback_Experimenter_findExperimenterAnnotationLinkPtr;

class Callback_Experimenter_unlinkAnnotation_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Experimenter_unlinkAnnotation_Base> Callback_Experimenter_unlinkAnnotationPtr;

class Callback_Experimenter_removeExperimenterAnnotationLinkFromBoth_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Experimenter_removeExperimenterAnnotationLinkFromBoth_Base> Callback_Experimenter_removeExperimenterAnnotationLinkFromBothPtr;

class Callback_Experimenter_linkedAnnotationList_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Experimenter_linkedAnnotationList_Base> Callback_Experimenter_linkedAnnotationListPtr;

}

}

namespace IceProxy
{

namespace omero
{

namespace model
{

class Experimenter : virtual public ::IceProxy::omero::model::IObject
{
public:

    ::omero::RIntPtr getVersion()
    {
        return getVersion(0);
    }
    ::omero::RIntPtr getVersion(const ::Ice::Context& __ctx)
    {
        return getVersion(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getVersion()
    {
        return begin_getVersion(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getVersion(const ::Ice::Context& __ctx)
    {
        return begin_getVersion(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getVersion(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getVersion(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getVersion(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getVersion(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getVersion(const ::omero::model::Callback_Experimenter_getVersionPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getVersion(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getVersion(const ::Ice::Context& __ctx, const ::omero::model::Callback_Experimenter_getVersionPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getVersion(&__ctx, __del, __cookie);
    }

    ::omero::RIntPtr end_getVersion(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::RIntPtr getVersion(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getVersion(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setVersion(const ::omero::RIntPtr& theVersion)
    {
        setVersion(theVersion, 0);
    }
    void setVersion(const ::omero::RIntPtr& theVersion, const ::Ice::Context& __ctx)
    {
        setVersion(theVersion, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setVersion(const ::omero::RIntPtr& theVersion)
    {
        return begin_setVersion(theVersion, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setVersion(const ::omero::RIntPtr& theVersion, const ::Ice::Context& __ctx)
    {
        return begin_setVersion(theVersion, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setVersion(const ::omero::RIntPtr& theVersion, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setVersion(theVersion, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setVersion(const ::omero::RIntPtr& theVersion, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setVersion(theVersion, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setVersion(const ::omero::RIntPtr& theVersion, const ::omero::model::Callback_Experimenter_setVersionPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setVersion(theVersion, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setVersion(const ::omero::RIntPtr& theVersion, const ::Ice::Context& __ctx, const ::omero::model::Callback_Experimenter_setVersionPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setVersion(theVersion, &__ctx, __del, __cookie);
    }

    void end_setVersion(const ::Ice::AsyncResultPtr&);
    
private:

    void setVersion(const ::omero::RIntPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setVersion(const ::omero::RIntPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void unloadGroupExperimenterMap()
    {
        unloadGroupExperimenterMap(0);
    }
    void unloadGroupExperimenterMap(const ::Ice::Context& __ctx)
    {
        unloadGroupExperimenterMap(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_unloadGroupExperimenterMap()
    {
        return begin_unloadGroupExperimenterMap(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_unloadGroupExperimenterMap(const ::Ice::Context& __ctx)
    {
        return begin_unloadGroupExperimenterMap(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_unloadGroupExperimenterMap(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_unloadGroupExperimenterMap(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_unloadGroupExperimenterMap(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_unloadGroupExperimenterMap(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_unloadGroupExperimenterMap(const ::omero::model::Callback_Experimenter_unloadGroupExperimenterMapPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_unloadGroupExperimenterMap(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_unloadGroupExperimenterMap(const ::Ice::Context& __ctx, const ::omero::model::Callback_Experimenter_unloadGroupExperimenterMapPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_unloadGroupExperimenterMap(&__ctx, __del, __cookie);
    }

    void end_unloadGroupExperimenterMap(const ::Ice::AsyncResultPtr&);
    
private:

    void unloadGroupExperimenterMap(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_unloadGroupExperimenterMap(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Int sizeOfGroupExperimenterMap()
    {
        return sizeOfGroupExperimenterMap(0);
    }
    ::Ice::Int sizeOfGroupExperimenterMap(const ::Ice::Context& __ctx)
    {
        return sizeOfGroupExperimenterMap(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_sizeOfGroupExperimenterMap()
    {
        return begin_sizeOfGroupExperimenterMap(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_sizeOfGroupExperimenterMap(const ::Ice::Context& __ctx)
    {
        return begin_sizeOfGroupExperimenterMap(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_sizeOfGroupExperimenterMap(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_sizeOfGroupExperimenterMap(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_sizeOfGroupExperimenterMap(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_sizeOfGroupExperimenterMap(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_sizeOfGroupExperimenterMap(const ::omero::model::Callback_Experimenter_sizeOfGroupExperimenterMapPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_sizeOfGroupExperimenterMap(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_sizeOfGroupExperimenterMap(const ::Ice::Context& __ctx, const ::omero::model::Callback_Experimenter_sizeOfGroupExperimenterMapPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_sizeOfGroupExperimenterMap(&__ctx, __del, __cookie);
    }

    ::Ice::Int end_sizeOfGroupExperimenterMap(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int sizeOfGroupExperimenterMap(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_sizeOfGroupExperimenterMap(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::model::ExperimenterGroupExperimenterMapSeq copyGroupExperimenterMap()
    {
        return copyGroupExperimenterMap(0);
    }
    ::omero::model::ExperimenterGroupExperimenterMapSeq copyGroupExperimenterMap(const ::Ice::Context& __ctx)
    {
        return copyGroupExperimenterMap(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_copyGroupExperimenterMap()
    {
        return begin_copyGroupExperimenterMap(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_copyGroupExperimenterMap(const ::Ice::Context& __ctx)
    {
        return begin_copyGroupExperimenterMap(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_copyGroupExperimenterMap(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_copyGroupExperimenterMap(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_copyGroupExperimenterMap(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_copyGroupExperimenterMap(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_copyGroupExperimenterMap(const ::omero::model::Callback_Experimenter_copyGroupExperimenterMapPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_copyGroupExperimenterMap(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_copyGroupExperimenterMap(const ::Ice::Context& __ctx, const ::omero::model::Callback_Experimenter_copyGroupExperimenterMapPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_copyGroupExperimenterMap(&__ctx, __del, __cookie);
    }

    ::omero::model::ExperimenterGroupExperimenterMapSeq end_copyGroupExperimenterMap(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::model::ExperimenterGroupExperimenterMapSeq copyGroupExperimenterMap(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_copyGroupExperimenterMap(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void addGroupExperimenterMap(const ::omero::model::GroupExperimenterMapPtr& target)
    {
        addGroupExperimenterMap(target, 0);
    }
    void addGroupExperimenterMap(const ::omero::model::GroupExperimenterMapPtr& target, const ::Ice::Context& __ctx)
    {
        addGroupExperimenterMap(target, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_addGroupExperimenterMap(const ::omero::model::GroupExperimenterMapPtr& target)
    {
        return begin_addGroupExperimenterMap(target, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_addGroupExperimenterMap(const ::omero::model::GroupExperimenterMapPtr& target, const ::Ice::Context& __ctx)
    {
        return begin_addGroupExperimenterMap(target, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_addGroupExperimenterMap(const ::omero::model::GroupExperimenterMapPtr& target, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_addGroupExperimenterMap(target, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_addGroupExperimenterMap(const ::omero::model::GroupExperimenterMapPtr& target, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_addGroupExperimenterMap(target, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_addGroupExperimenterMap(const ::omero::model::GroupExperimenterMapPtr& target, const ::omero::model::Callback_Experimenter_addGroupExperimenterMapPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_addGroupExperimenterMap(target, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_addGroupExperimenterMap(const ::omero::model::GroupExperimenterMapPtr& target, const ::Ice::Context& __ctx, const ::omero::model::Callback_Experimenter_addGroupExperimenterMapPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_addGroupExperimenterMap(target, &__ctx, __del, __cookie);
    }

    void end_addGroupExperimenterMap(const ::Ice::AsyncResultPtr&);
    
private:

    void addGroupExperimenterMap(const ::omero::model::GroupExperimenterMapPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_addGroupExperimenterMap(const ::omero::model::GroupExperimenterMapPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void addAllGroupExperimenterMapSet(const ::omero::model::ExperimenterGroupExperimenterMapSeq& targets)
    {
        addAllGroupExperimenterMapSet(targets, 0);
    }
    void addAllGroupExperimenterMapSet(const ::omero::model::ExperimenterGroupExperimenterMapSeq& targets, const ::Ice::Context& __ctx)
    {
        addAllGroupExperimenterMapSet(targets, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_addAllGroupExperimenterMapSet(const ::omero::model::ExperimenterGroupExperimenterMapSeq& targets)
    {
        return begin_addAllGroupExperimenterMapSet(targets, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_addAllGroupExperimenterMapSet(const ::omero::model::ExperimenterGroupExperimenterMapSeq& targets, const ::Ice::Context& __ctx)
    {
        return begin_addAllGroupExperimenterMapSet(targets, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_addAllGroupExperimenterMapSet(const ::omero::model::ExperimenterGroupExperimenterMapSeq& targets, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_addAllGroupExperimenterMapSet(targets, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_addAllGroupExperimenterMapSet(const ::omero::model::ExperimenterGroupExperimenterMapSeq& targets, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_addAllGroupExperimenterMapSet(targets, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_addAllGroupExperimenterMapSet(const ::omero::model::ExperimenterGroupExperimenterMapSeq& targets, const ::omero::model::Callback_Experimenter_addAllGroupExperimenterMapSetPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_addAllGroupExperimenterMapSet(targets, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_addAllGroupExperimenterMapSet(const ::omero::model::ExperimenterGroupExperimenterMapSeq& targets, const ::Ice::Context& __ctx, const ::omero::model::Callback_Experimenter_addAllGroupExperimenterMapSetPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_addAllGroupExperimenterMapSet(targets, &__ctx, __del, __cookie);
    }

    void end_addAllGroupExperimenterMapSet(const ::Ice::AsyncResultPtr&);
    
private:

    void addAllGroupExperimenterMapSet(const ::omero::model::ExperimenterGroupExperimenterMapSeq&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_addAllGroupExperimenterMapSet(const ::omero::model::ExperimenterGroupExperimenterMapSeq&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void removeGroupExperimenterMap(const ::omero::model::GroupExperimenterMapPtr& theTarget)
    {
        removeGroupExperimenterMap(theTarget, 0);
    }
    void removeGroupExperimenterMap(const ::omero::model::GroupExperimenterMapPtr& theTarget, const ::Ice::Context& __ctx)
    {
        removeGroupExperimenterMap(theTarget, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_removeGroupExperimenterMap(const ::omero::model::GroupExperimenterMapPtr& theTarget)
    {
        return begin_removeGroupExperimenterMap(theTarget, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_removeGroupExperimenterMap(const ::omero::model::GroupExperimenterMapPtr& theTarget, const ::Ice::Context& __ctx)
    {
        return begin_removeGroupExperimenterMap(theTarget, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_removeGroupExperimenterMap(const ::omero::model::GroupExperimenterMapPtr& theTarget, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_removeGroupExperimenterMap(theTarget, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_removeGroupExperimenterMap(const ::omero::model::GroupExperimenterMapPtr& theTarget, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_removeGroupExperimenterMap(theTarget, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_removeGroupExperimenterMap(const ::omero::model::GroupExperimenterMapPtr& theTarget, const ::omero::model::Callback_Experimenter_removeGroupExperimenterMapPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_removeGroupExperimenterMap(theTarget, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_removeGroupExperimenterMap(const ::omero::model::GroupExperimenterMapPtr& theTarget, const ::Ice::Context& __ctx, const ::omero::model::Callback_Experimenter_removeGroupExperimenterMapPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_removeGroupExperimenterMap(theTarget, &__ctx, __del, __cookie);
    }

    void end_removeGroupExperimenterMap(const ::Ice::AsyncResultPtr&);
    
private:

    void removeGroupExperimenterMap(const ::omero::model::GroupExperimenterMapPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_removeGroupExperimenterMap(const ::omero::model::GroupExperimenterMapPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void removeAllGroupExperimenterMapSet(const ::omero::model::ExperimenterGroupExperimenterMapSeq& targets)
    {
        removeAllGroupExperimenterMapSet(targets, 0);
    }
    void removeAllGroupExperimenterMapSet(const ::omero::model::ExperimenterGroupExperimenterMapSeq& targets, const ::Ice::Context& __ctx)
    {
        removeAllGroupExperimenterMapSet(targets, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_removeAllGroupExperimenterMapSet(const ::omero::model::ExperimenterGroupExperimenterMapSeq& targets)
    {
        return begin_removeAllGroupExperimenterMapSet(targets, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_removeAllGroupExperimenterMapSet(const ::omero::model::ExperimenterGroupExperimenterMapSeq& targets, const ::Ice::Context& __ctx)
    {
        return begin_removeAllGroupExperimenterMapSet(targets, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_removeAllGroupExperimenterMapSet(const ::omero::model::ExperimenterGroupExperimenterMapSeq& targets, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_removeAllGroupExperimenterMapSet(targets, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_removeAllGroupExperimenterMapSet(const ::omero::model::ExperimenterGroupExperimenterMapSeq& targets, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_removeAllGroupExperimenterMapSet(targets, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_removeAllGroupExperimenterMapSet(const ::omero::model::ExperimenterGroupExperimenterMapSeq& targets, const ::omero::model::Callback_Experimenter_removeAllGroupExperimenterMapSetPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_removeAllGroupExperimenterMapSet(targets, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_removeAllGroupExperimenterMapSet(const ::omero::model::ExperimenterGroupExperimenterMapSeq& targets, const ::Ice::Context& __ctx, const ::omero::model::Callback_Experimenter_removeAllGroupExperimenterMapSetPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_removeAllGroupExperimenterMapSet(targets, &__ctx, __del, __cookie);
    }

    void end_removeAllGroupExperimenterMapSet(const ::Ice::AsyncResultPtr&);
    
private:

    void removeAllGroupExperimenterMapSet(const ::omero::model::ExperimenterGroupExperimenterMapSeq&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_removeAllGroupExperimenterMapSet(const ::omero::model::ExperimenterGroupExperimenterMapSeq&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void clearGroupExperimenterMap()
    {
        clearGroupExperimenterMap(0);
    }
    void clearGroupExperimenterMap(const ::Ice::Context& __ctx)
    {
        clearGroupExperimenterMap(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_clearGroupExperimenterMap()
    {
        return begin_clearGroupExperimenterMap(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_clearGroupExperimenterMap(const ::Ice::Context& __ctx)
    {
        return begin_clearGroupExperimenterMap(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_clearGroupExperimenterMap(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_clearGroupExperimenterMap(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_clearGroupExperimenterMap(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_clearGroupExperimenterMap(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_clearGroupExperimenterMap(const ::omero::model::Callback_Experimenter_clearGroupExperimenterMapPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_clearGroupExperimenterMap(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_clearGroupExperimenterMap(const ::Ice::Context& __ctx, const ::omero::model::Callback_Experimenter_clearGroupExperimenterMapPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_clearGroupExperimenterMap(&__ctx, __del, __cookie);
    }

    void end_clearGroupExperimenterMap(const ::Ice::AsyncResultPtr&);
    
private:

    void clearGroupExperimenterMap(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_clearGroupExperimenterMap(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void reloadGroupExperimenterMap(const ::omero::model::ExperimenterPtr& toCopy)
    {
        reloadGroupExperimenterMap(toCopy, 0);
    }
    void reloadGroupExperimenterMap(const ::omero::model::ExperimenterPtr& toCopy, const ::Ice::Context& __ctx)
    {
        reloadGroupExperimenterMap(toCopy, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_reloadGroupExperimenterMap(const ::omero::model::ExperimenterPtr& toCopy)
    {
        return begin_reloadGroupExperimenterMap(toCopy, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_reloadGroupExperimenterMap(const ::omero::model::ExperimenterPtr& toCopy, const ::Ice::Context& __ctx)
    {
        return begin_reloadGroupExperimenterMap(toCopy, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_reloadGroupExperimenterMap(const ::omero::model::ExperimenterPtr& toCopy, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_reloadGroupExperimenterMap(toCopy, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_reloadGroupExperimenterMap(const ::omero::model::ExperimenterPtr& toCopy, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_reloadGroupExperimenterMap(toCopy, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_reloadGroupExperimenterMap(const ::omero::model::ExperimenterPtr& toCopy, const ::omero::model::Callback_Experimenter_reloadGroupExperimenterMapPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_reloadGroupExperimenterMap(toCopy, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_reloadGroupExperimenterMap(const ::omero::model::ExperimenterPtr& toCopy, const ::Ice::Context& __ctx, const ::omero::model::Callback_Experimenter_reloadGroupExperimenterMapPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_reloadGroupExperimenterMap(toCopy, &__ctx, __del, __cookie);
    }

    void end_reloadGroupExperimenterMap(const ::Ice::AsyncResultPtr&);
    
private:

    void reloadGroupExperimenterMap(const ::omero::model::ExperimenterPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_reloadGroupExperimenterMap(const ::omero::model::ExperimenterPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::model::GroupExperimenterMapPtr getGroupExperimenterMap(::Ice::Int index)
    {
        return getGroupExperimenterMap(index, 0);
    }
    ::omero::model::GroupExperimenterMapPtr getGroupExperimenterMap(::Ice::Int index, const ::Ice::Context& __ctx)
    {
        return getGroupExperimenterMap(index, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_getGroupExperimenterMap(::Ice::Int index)
    {
        return begin_getGroupExperimenterMap(index, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getGroupExperimenterMap(::Ice::Int index, const ::Ice::Context& __ctx)
    {
        return begin_getGroupExperimenterMap(index, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getGroupExperimenterMap(::Ice::Int index, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getGroupExperimenterMap(index, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getGroupExperimenterMap(::Ice::Int index, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getGroupExperimenterMap(index, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getGroupExperimenterMap(::Ice::Int index, const ::omero::model::Callback_Experimenter_getGroupExperimenterMapPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getGroupExperimenterMap(index, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getGroupExperimenterMap(::Ice::Int index, const ::Ice::Context& __ctx, const ::omero::model::Callback_Experimenter_getGroupExperimenterMapPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getGroupExperimenterMap(index, &__ctx, __del, __cookie);
    }

    ::omero::model::GroupExperimenterMapPtr end_getGroupExperimenterMap(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::model::GroupExperimenterMapPtr getGroupExperimenterMap(::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getGroupExperimenterMap(::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::model::GroupExperimenterMapPtr setGroupExperimenterMap(::Ice::Int index, const ::omero::model::GroupExperimenterMapPtr& theElement)
    {
        return setGroupExperimenterMap(index, theElement, 0);
    }
    ::omero::model::GroupExperimenterMapPtr setGroupExperimenterMap(::Ice::Int index, const ::omero::model::GroupExperimenterMapPtr& theElement, const ::Ice::Context& __ctx)
    {
        return setGroupExperimenterMap(index, theElement, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setGroupExperimenterMap(::Ice::Int index, const ::omero::model::GroupExperimenterMapPtr& theElement)
    {
        return begin_setGroupExperimenterMap(index, theElement, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setGroupExperimenterMap(::Ice::Int index, const ::omero::model::GroupExperimenterMapPtr& theElement, const ::Ice::Context& __ctx)
    {
        return begin_setGroupExperimenterMap(index, theElement, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setGroupExperimenterMap(::Ice::Int index, const ::omero::model::GroupExperimenterMapPtr& theElement, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setGroupExperimenterMap(index, theElement, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setGroupExperimenterMap(::Ice::Int index, const ::omero::model::GroupExperimenterMapPtr& theElement, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setGroupExperimenterMap(index, theElement, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setGroupExperimenterMap(::Ice::Int index, const ::omero::model::GroupExperimenterMapPtr& theElement, const ::omero::model::Callback_Experimenter_setGroupExperimenterMapPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setGroupExperimenterMap(index, theElement, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setGroupExperimenterMap(::Ice::Int index, const ::omero::model::GroupExperimenterMapPtr& theElement, const ::Ice::Context& __ctx, const ::omero::model::Callback_Experimenter_setGroupExperimenterMapPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setGroupExperimenterMap(index, theElement, &__ctx, __del, __cookie);
    }

    ::omero::model::GroupExperimenterMapPtr end_setGroupExperimenterMap(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::model::GroupExperimenterMapPtr setGroupExperimenterMap(::Ice::Int, const ::omero::model::GroupExperimenterMapPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setGroupExperimenterMap(::Ice::Int, const ::omero::model::GroupExperimenterMapPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::model::GroupExperimenterMapPtr getPrimaryGroupExperimenterMap()
    {
        return getPrimaryGroupExperimenterMap(0);
    }
    ::omero::model::GroupExperimenterMapPtr getPrimaryGroupExperimenterMap(const ::Ice::Context& __ctx)
    {
        return getPrimaryGroupExperimenterMap(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getPrimaryGroupExperimenterMap()
    {
        return begin_getPrimaryGroupExperimenterMap(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getPrimaryGroupExperimenterMap(const ::Ice::Context& __ctx)
    {
        return begin_getPrimaryGroupExperimenterMap(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getPrimaryGroupExperimenterMap(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getPrimaryGroupExperimenterMap(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getPrimaryGroupExperimenterMap(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getPrimaryGroupExperimenterMap(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getPrimaryGroupExperimenterMap(const ::omero::model::Callback_Experimenter_getPrimaryGroupExperimenterMapPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getPrimaryGroupExperimenterMap(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getPrimaryGroupExperimenterMap(const ::Ice::Context& __ctx, const ::omero::model::Callback_Experimenter_getPrimaryGroupExperimenterMapPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getPrimaryGroupExperimenterMap(&__ctx, __del, __cookie);
    }

    ::omero::model::GroupExperimenterMapPtr end_getPrimaryGroupExperimenterMap(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::model::GroupExperimenterMapPtr getPrimaryGroupExperimenterMap(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getPrimaryGroupExperimenterMap(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::model::GroupExperimenterMapPtr setPrimaryGroupExperimenterMap(const ::omero::model::GroupExperimenterMapPtr& theElement)
    {
        return setPrimaryGroupExperimenterMap(theElement, 0);
    }
    ::omero::model::GroupExperimenterMapPtr setPrimaryGroupExperimenterMap(const ::omero::model::GroupExperimenterMapPtr& theElement, const ::Ice::Context& __ctx)
    {
        return setPrimaryGroupExperimenterMap(theElement, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setPrimaryGroupExperimenterMap(const ::omero::model::GroupExperimenterMapPtr& theElement)
    {
        return begin_setPrimaryGroupExperimenterMap(theElement, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setPrimaryGroupExperimenterMap(const ::omero::model::GroupExperimenterMapPtr& theElement, const ::Ice::Context& __ctx)
    {
        return begin_setPrimaryGroupExperimenterMap(theElement, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setPrimaryGroupExperimenterMap(const ::omero::model::GroupExperimenterMapPtr& theElement, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setPrimaryGroupExperimenterMap(theElement, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setPrimaryGroupExperimenterMap(const ::omero::model::GroupExperimenterMapPtr& theElement, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setPrimaryGroupExperimenterMap(theElement, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setPrimaryGroupExperimenterMap(const ::omero::model::GroupExperimenterMapPtr& theElement, const ::omero::model::Callback_Experimenter_setPrimaryGroupExperimenterMapPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setPrimaryGroupExperimenterMap(theElement, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setPrimaryGroupExperimenterMap(const ::omero::model::GroupExperimenterMapPtr& theElement, const ::Ice::Context& __ctx, const ::omero::model::Callback_Experimenter_setPrimaryGroupExperimenterMapPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setPrimaryGroupExperimenterMap(theElement, &__ctx, __del, __cookie);
    }

    ::omero::model::GroupExperimenterMapPtr end_setPrimaryGroupExperimenterMap(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::model::GroupExperimenterMapPtr setPrimaryGroupExperimenterMap(const ::omero::model::GroupExperimenterMapPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setPrimaryGroupExperimenterMap(const ::omero::model::GroupExperimenterMapPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::model::GroupExperimenterMapPtr linkExperimenterGroup(const ::omero::model::ExperimenterGroupPtr& addition)
    {
        return linkExperimenterGroup(addition, 0);
    }
    ::omero::model::GroupExperimenterMapPtr linkExperimenterGroup(const ::omero::model::ExperimenterGroupPtr& addition, const ::Ice::Context& __ctx)
    {
        return linkExperimenterGroup(addition, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_linkExperimenterGroup(const ::omero::model::ExperimenterGroupPtr& addition)
    {
        return begin_linkExperimenterGroup(addition, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_linkExperimenterGroup(const ::omero::model::ExperimenterGroupPtr& addition, const ::Ice::Context& __ctx)
    {
        return begin_linkExperimenterGroup(addition, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_linkExperimenterGroup(const ::omero::model::ExperimenterGroupPtr& addition, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_linkExperimenterGroup(addition, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_linkExperimenterGroup(const ::omero::model::ExperimenterGroupPtr& addition, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_linkExperimenterGroup(addition, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_linkExperimenterGroup(const ::omero::model::ExperimenterGroupPtr& addition, const ::omero::model::Callback_Experimenter_linkExperimenterGroupPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_linkExperimenterGroup(addition, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_linkExperimenterGroup(const ::omero::model::ExperimenterGroupPtr& addition, const ::Ice::Context& __ctx, const ::omero::model::Callback_Experimenter_linkExperimenterGroupPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_linkExperimenterGroup(addition, &__ctx, __del, __cookie);
    }

    ::omero::model::GroupExperimenterMapPtr end_linkExperimenterGroup(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::model::GroupExperimenterMapPtr linkExperimenterGroup(const ::omero::model::ExperimenterGroupPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_linkExperimenterGroup(const ::omero::model::ExperimenterGroupPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void addGroupExperimenterMapToBoth(const ::omero::model::GroupExperimenterMapPtr& link, bool bothSides)
    {
        addGroupExperimenterMapToBoth(link, bothSides, 0);
    }
    void addGroupExperimenterMapToBoth(const ::omero::model::GroupExperimenterMapPtr& link, bool bothSides, const ::Ice::Context& __ctx)
    {
        addGroupExperimenterMapToBoth(link, bothSides, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_addGroupExperimenterMapToBoth(const ::omero::model::GroupExperimenterMapPtr& link, bool bothSides)
    {
        return begin_addGroupExperimenterMapToBoth(link, bothSides, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_addGroupExperimenterMapToBoth(const ::omero::model::GroupExperimenterMapPtr& link, bool bothSides, const ::Ice::Context& __ctx)
    {
        return begin_addGroupExperimenterMapToBoth(link, bothSides, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_addGroupExperimenterMapToBoth(const ::omero::model::GroupExperimenterMapPtr& link, bool bothSides, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_addGroupExperimenterMapToBoth(link, bothSides, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_addGroupExperimenterMapToBoth(const ::omero::model::GroupExperimenterMapPtr& link, bool bothSides, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_addGroupExperimenterMapToBoth(link, bothSides, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_addGroupExperimenterMapToBoth(const ::omero::model::GroupExperimenterMapPtr& link, bool bothSides, const ::omero::model::Callback_Experimenter_addGroupExperimenterMapToBothPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_addGroupExperimenterMapToBoth(link, bothSides, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_addGroupExperimenterMapToBoth(const ::omero::model::GroupExperimenterMapPtr& link, bool bothSides, const ::Ice::Context& __ctx, const ::omero::model::Callback_Experimenter_addGroupExperimenterMapToBothPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_addGroupExperimenterMapToBoth(link, bothSides, &__ctx, __del, __cookie);
    }

    void end_addGroupExperimenterMapToBoth(const ::Ice::AsyncResultPtr&);
    
private:

    void addGroupExperimenterMapToBoth(const ::omero::model::GroupExperimenterMapPtr&, bool, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_addGroupExperimenterMapToBoth(const ::omero::model::GroupExperimenterMapPtr&, bool, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::model::ExperimenterGroupExperimenterMapSeq findGroupExperimenterMap(const ::omero::model::ExperimenterGroupPtr& removal)
    {
        return findGroupExperimenterMap(removal, 0);
    }
    ::omero::model::ExperimenterGroupExperimenterMapSeq findGroupExperimenterMap(const ::omero::model::ExperimenterGroupPtr& removal, const ::Ice::Context& __ctx)
    {
        return findGroupExperimenterMap(removal, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_findGroupExperimenterMap(const ::omero::model::ExperimenterGroupPtr& removal)
    {
        return begin_findGroupExperimenterMap(removal, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_findGroupExperimenterMap(const ::omero::model::ExperimenterGroupPtr& removal, const ::Ice::Context& __ctx)
    {
        return begin_findGroupExperimenterMap(removal, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_findGroupExperimenterMap(const ::omero::model::ExperimenterGroupPtr& removal, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_findGroupExperimenterMap(removal, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_findGroupExperimenterMap(const ::omero::model::ExperimenterGroupPtr& removal, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_findGroupExperimenterMap(removal, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_findGroupExperimenterMap(const ::omero::model::ExperimenterGroupPtr& removal, const ::omero::model::Callback_Experimenter_findGroupExperimenterMapPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_findGroupExperimenterMap(removal, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_findGroupExperimenterMap(const ::omero::model::ExperimenterGroupPtr& removal, const ::Ice::Context& __ctx, const ::omero::model::Callback_Experimenter_findGroupExperimenterMapPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_findGroupExperimenterMap(removal, &__ctx, __del, __cookie);
    }

    ::omero::model::ExperimenterGroupExperimenterMapSeq end_findGroupExperimenterMap(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::model::ExperimenterGroupExperimenterMapSeq findGroupExperimenterMap(const ::omero::model::ExperimenterGroupPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_findGroupExperimenterMap(const ::omero::model::ExperimenterGroupPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void unlinkExperimenterGroup(const ::omero::model::ExperimenterGroupPtr& removal)
    {
        unlinkExperimenterGroup(removal, 0);
    }
    void unlinkExperimenterGroup(const ::omero::model::ExperimenterGroupPtr& removal, const ::Ice::Context& __ctx)
    {
        unlinkExperimenterGroup(removal, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_unlinkExperimenterGroup(const ::omero::model::ExperimenterGroupPtr& removal)
    {
        return begin_unlinkExperimenterGroup(removal, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_unlinkExperimenterGroup(const ::omero::model::ExperimenterGroupPtr& removal, const ::Ice::Context& __ctx)
    {
        return begin_unlinkExperimenterGroup(removal, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_unlinkExperimenterGroup(const ::omero::model::ExperimenterGroupPtr& removal, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_unlinkExperimenterGroup(removal, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_unlinkExperimenterGroup(const ::omero::model::ExperimenterGroupPtr& removal, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_unlinkExperimenterGroup(removal, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_unlinkExperimenterGroup(const ::omero::model::ExperimenterGroupPtr& removal, const ::omero::model::Callback_Experimenter_unlinkExperimenterGroupPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_unlinkExperimenterGroup(removal, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_unlinkExperimenterGroup(const ::omero::model::ExperimenterGroupPtr& removal, const ::Ice::Context& __ctx, const ::omero::model::Callback_Experimenter_unlinkExperimenterGroupPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_unlinkExperimenterGroup(removal, &__ctx, __del, __cookie);
    }

    void end_unlinkExperimenterGroup(const ::Ice::AsyncResultPtr&);
    
private:

    void unlinkExperimenterGroup(const ::omero::model::ExperimenterGroupPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_unlinkExperimenterGroup(const ::omero::model::ExperimenterGroupPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void removeGroupExperimenterMapFromBoth(const ::omero::model::GroupExperimenterMapPtr& link, bool bothSides)
    {
        removeGroupExperimenterMapFromBoth(link, bothSides, 0);
    }
    void removeGroupExperimenterMapFromBoth(const ::omero::model::GroupExperimenterMapPtr& link, bool bothSides, const ::Ice::Context& __ctx)
    {
        removeGroupExperimenterMapFromBoth(link, bothSides, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_removeGroupExperimenterMapFromBoth(const ::omero::model::GroupExperimenterMapPtr& link, bool bothSides)
    {
        return begin_removeGroupExperimenterMapFromBoth(link, bothSides, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_removeGroupExperimenterMapFromBoth(const ::omero::model::GroupExperimenterMapPtr& link, bool bothSides, const ::Ice::Context& __ctx)
    {
        return begin_removeGroupExperimenterMapFromBoth(link, bothSides, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_removeGroupExperimenterMapFromBoth(const ::omero::model::GroupExperimenterMapPtr& link, bool bothSides, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_removeGroupExperimenterMapFromBoth(link, bothSides, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_removeGroupExperimenterMapFromBoth(const ::omero::model::GroupExperimenterMapPtr& link, bool bothSides, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_removeGroupExperimenterMapFromBoth(link, bothSides, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_removeGroupExperimenterMapFromBoth(const ::omero::model::GroupExperimenterMapPtr& link, bool bothSides, const ::omero::model::Callback_Experimenter_removeGroupExperimenterMapFromBothPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_removeGroupExperimenterMapFromBoth(link, bothSides, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_removeGroupExperimenterMapFromBoth(const ::omero::model::GroupExperimenterMapPtr& link, bool bothSides, const ::Ice::Context& __ctx, const ::omero::model::Callback_Experimenter_removeGroupExperimenterMapFromBothPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_removeGroupExperimenterMapFromBoth(link, bothSides, &__ctx, __del, __cookie);
    }

    void end_removeGroupExperimenterMapFromBoth(const ::Ice::AsyncResultPtr&);
    
private:

    void removeGroupExperimenterMapFromBoth(const ::omero::model::GroupExperimenterMapPtr&, bool, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_removeGroupExperimenterMapFromBoth(const ::omero::model::GroupExperimenterMapPtr&, bool, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::model::ExperimenterLinkedExperimenterGroupSeq linkedExperimenterGroupList()
    {
        return linkedExperimenterGroupList(0);
    }
    ::omero::model::ExperimenterLinkedExperimenterGroupSeq linkedExperimenterGroupList(const ::Ice::Context& __ctx)
    {
        return linkedExperimenterGroupList(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_linkedExperimenterGroupList()
    {
        return begin_linkedExperimenterGroupList(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_linkedExperimenterGroupList(const ::Ice::Context& __ctx)
    {
        return begin_linkedExperimenterGroupList(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_linkedExperimenterGroupList(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_linkedExperimenterGroupList(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_linkedExperimenterGroupList(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_linkedExperimenterGroupList(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_linkedExperimenterGroupList(const ::omero::model::Callback_Experimenter_linkedExperimenterGroupListPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_linkedExperimenterGroupList(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_linkedExperimenterGroupList(const ::Ice::Context& __ctx, const ::omero::model::Callback_Experimenter_linkedExperimenterGroupListPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_linkedExperimenterGroupList(&__ctx, __del, __cookie);
    }

    ::omero::model::ExperimenterLinkedExperimenterGroupSeq end_linkedExperimenterGroupList(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::model::ExperimenterLinkedExperimenterGroupSeq linkedExperimenterGroupList(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_linkedExperimenterGroupList(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::RStringPtr getOmeName()
    {
        return getOmeName(0);
    }
    ::omero::RStringPtr getOmeName(const ::Ice::Context& __ctx)
    {
        return getOmeName(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getOmeName()
    {
        return begin_getOmeName(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getOmeName(const ::Ice::Context& __ctx)
    {
        return begin_getOmeName(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getOmeName(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getOmeName(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getOmeName(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getOmeName(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getOmeName(const ::omero::model::Callback_Experimenter_getOmeNamePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getOmeName(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getOmeName(const ::Ice::Context& __ctx, const ::omero::model::Callback_Experimenter_getOmeNamePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getOmeName(&__ctx, __del, __cookie);
    }

    ::omero::RStringPtr end_getOmeName(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::RStringPtr getOmeName(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getOmeName(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setOmeName(const ::omero::RStringPtr& theOmeName)
    {
        setOmeName(theOmeName, 0);
    }
    void setOmeName(const ::omero::RStringPtr& theOmeName, const ::Ice::Context& __ctx)
    {
        setOmeName(theOmeName, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setOmeName(const ::omero::RStringPtr& theOmeName)
    {
        return begin_setOmeName(theOmeName, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setOmeName(const ::omero::RStringPtr& theOmeName, const ::Ice::Context& __ctx)
    {
        return begin_setOmeName(theOmeName, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setOmeName(const ::omero::RStringPtr& theOmeName, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setOmeName(theOmeName, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setOmeName(const ::omero::RStringPtr& theOmeName, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setOmeName(theOmeName, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setOmeName(const ::omero::RStringPtr& theOmeName, const ::omero::model::Callback_Experimenter_setOmeNamePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setOmeName(theOmeName, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setOmeName(const ::omero::RStringPtr& theOmeName, const ::Ice::Context& __ctx, const ::omero::model::Callback_Experimenter_setOmeNamePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setOmeName(theOmeName, &__ctx, __del, __cookie);
    }

    void end_setOmeName(const ::Ice::AsyncResultPtr&);
    
private:

    void setOmeName(const ::omero::RStringPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setOmeName(const ::omero::RStringPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::RStringPtr getFirstName()
    {
        return getFirstName(0);
    }
    ::omero::RStringPtr getFirstName(const ::Ice::Context& __ctx)
    {
        return getFirstName(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getFirstName()
    {
        return begin_getFirstName(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getFirstName(const ::Ice::Context& __ctx)
    {
        return begin_getFirstName(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getFirstName(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getFirstName(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getFirstName(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getFirstName(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getFirstName(const ::omero::model::Callback_Experimenter_getFirstNamePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getFirstName(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getFirstName(const ::Ice::Context& __ctx, const ::omero::model::Callback_Experimenter_getFirstNamePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getFirstName(&__ctx, __del, __cookie);
    }

    ::omero::RStringPtr end_getFirstName(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::RStringPtr getFirstName(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getFirstName(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setFirstName(const ::omero::RStringPtr& theFirstName)
    {
        setFirstName(theFirstName, 0);
    }
    void setFirstName(const ::omero::RStringPtr& theFirstName, const ::Ice::Context& __ctx)
    {
        setFirstName(theFirstName, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setFirstName(const ::omero::RStringPtr& theFirstName)
    {
        return begin_setFirstName(theFirstName, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setFirstName(const ::omero::RStringPtr& theFirstName, const ::Ice::Context& __ctx)
    {
        return begin_setFirstName(theFirstName, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setFirstName(const ::omero::RStringPtr& theFirstName, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setFirstName(theFirstName, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setFirstName(const ::omero::RStringPtr& theFirstName, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setFirstName(theFirstName, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setFirstName(const ::omero::RStringPtr& theFirstName, const ::omero::model::Callback_Experimenter_setFirstNamePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setFirstName(theFirstName, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setFirstName(const ::omero::RStringPtr& theFirstName, const ::Ice::Context& __ctx, const ::omero::model::Callback_Experimenter_setFirstNamePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setFirstName(theFirstName, &__ctx, __del, __cookie);
    }

    void end_setFirstName(const ::Ice::AsyncResultPtr&);
    
private:

    void setFirstName(const ::omero::RStringPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setFirstName(const ::omero::RStringPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::RStringPtr getMiddleName()
    {
        return getMiddleName(0);
    }
    ::omero::RStringPtr getMiddleName(const ::Ice::Context& __ctx)
    {
        return getMiddleName(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getMiddleName()
    {
        return begin_getMiddleName(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getMiddleName(const ::Ice::Context& __ctx)
    {
        return begin_getMiddleName(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getMiddleName(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getMiddleName(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getMiddleName(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getMiddleName(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getMiddleName(const ::omero::model::Callback_Experimenter_getMiddleNamePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getMiddleName(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getMiddleName(const ::Ice::Context& __ctx, const ::omero::model::Callback_Experimenter_getMiddleNamePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getMiddleName(&__ctx, __del, __cookie);
    }

    ::omero::RStringPtr end_getMiddleName(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::RStringPtr getMiddleName(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getMiddleName(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setMiddleName(const ::omero::RStringPtr& theMiddleName)
    {
        setMiddleName(theMiddleName, 0);
    }
    void setMiddleName(const ::omero::RStringPtr& theMiddleName, const ::Ice::Context& __ctx)
    {
        setMiddleName(theMiddleName, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setMiddleName(const ::omero::RStringPtr& theMiddleName)
    {
        return begin_setMiddleName(theMiddleName, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setMiddleName(const ::omero::RStringPtr& theMiddleName, const ::Ice::Context& __ctx)
    {
        return begin_setMiddleName(theMiddleName, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setMiddleName(const ::omero::RStringPtr& theMiddleName, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setMiddleName(theMiddleName, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setMiddleName(const ::omero::RStringPtr& theMiddleName, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setMiddleName(theMiddleName, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setMiddleName(const ::omero::RStringPtr& theMiddleName, const ::omero::model::Callback_Experimenter_setMiddleNamePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setMiddleName(theMiddleName, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setMiddleName(const ::omero::RStringPtr& theMiddleName, const ::Ice::Context& __ctx, const ::omero::model::Callback_Experimenter_setMiddleNamePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setMiddleName(theMiddleName, &__ctx, __del, __cookie);
    }

    void end_setMiddleName(const ::Ice::AsyncResultPtr&);
    
private:

    void setMiddleName(const ::omero::RStringPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setMiddleName(const ::omero::RStringPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::RStringPtr getLastName()
    {
        return getLastName(0);
    }
    ::omero::RStringPtr getLastName(const ::Ice::Context& __ctx)
    {
        return getLastName(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getLastName()
    {
        return begin_getLastName(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getLastName(const ::Ice::Context& __ctx)
    {
        return begin_getLastName(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getLastName(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getLastName(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getLastName(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getLastName(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getLastName(const ::omero::model::Callback_Experimenter_getLastNamePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getLastName(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getLastName(const ::Ice::Context& __ctx, const ::omero::model::Callback_Experimenter_getLastNamePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getLastName(&__ctx, __del, __cookie);
    }

    ::omero::RStringPtr end_getLastName(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::RStringPtr getLastName(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getLastName(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setLastName(const ::omero::RStringPtr& theLastName)
    {
        setLastName(theLastName, 0);
    }
    void setLastName(const ::omero::RStringPtr& theLastName, const ::Ice::Context& __ctx)
    {
        setLastName(theLastName, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setLastName(const ::omero::RStringPtr& theLastName)
    {
        return begin_setLastName(theLastName, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setLastName(const ::omero::RStringPtr& theLastName, const ::Ice::Context& __ctx)
    {
        return begin_setLastName(theLastName, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setLastName(const ::omero::RStringPtr& theLastName, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setLastName(theLastName, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setLastName(const ::omero::RStringPtr& theLastName, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setLastName(theLastName, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setLastName(const ::omero::RStringPtr& theLastName, const ::omero::model::Callback_Experimenter_setLastNamePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setLastName(theLastName, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setLastName(const ::omero::RStringPtr& theLastName, const ::Ice::Context& __ctx, const ::omero::model::Callback_Experimenter_setLastNamePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setLastName(theLastName, &__ctx, __del, __cookie);
    }

    void end_setLastName(const ::Ice::AsyncResultPtr&);
    
private:

    void setLastName(const ::omero::RStringPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setLastName(const ::omero::RStringPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::RStringPtr getInstitution()
    {
        return getInstitution(0);
    }
    ::omero::RStringPtr getInstitution(const ::Ice::Context& __ctx)
    {
        return getInstitution(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getInstitution()
    {
        return begin_getInstitution(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getInstitution(const ::Ice::Context& __ctx)
    {
        return begin_getInstitution(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getInstitution(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getInstitution(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getInstitution(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getInstitution(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getInstitution(const ::omero::model::Callback_Experimenter_getInstitutionPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getInstitution(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getInstitution(const ::Ice::Context& __ctx, const ::omero::model::Callback_Experimenter_getInstitutionPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getInstitution(&__ctx, __del, __cookie);
    }

    ::omero::RStringPtr end_getInstitution(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::RStringPtr getInstitution(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getInstitution(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setInstitution(const ::omero::RStringPtr& theInstitution)
    {
        setInstitution(theInstitution, 0);
    }
    void setInstitution(const ::omero::RStringPtr& theInstitution, const ::Ice::Context& __ctx)
    {
        setInstitution(theInstitution, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setInstitution(const ::omero::RStringPtr& theInstitution)
    {
        return begin_setInstitution(theInstitution, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setInstitution(const ::omero::RStringPtr& theInstitution, const ::Ice::Context& __ctx)
    {
        return begin_setInstitution(theInstitution, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setInstitution(const ::omero::RStringPtr& theInstitution, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setInstitution(theInstitution, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setInstitution(const ::omero::RStringPtr& theInstitution, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setInstitution(theInstitution, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setInstitution(const ::omero::RStringPtr& theInstitution, const ::omero::model::Callback_Experimenter_setInstitutionPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setInstitution(theInstitution, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setInstitution(const ::omero::RStringPtr& theInstitution, const ::Ice::Context& __ctx, const ::omero::model::Callback_Experimenter_setInstitutionPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setInstitution(theInstitution, &__ctx, __del, __cookie);
    }

    void end_setInstitution(const ::Ice::AsyncResultPtr&);
    
private:

    void setInstitution(const ::omero::RStringPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setInstitution(const ::omero::RStringPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::RStringPtr getEmail()
    {
        return getEmail(0);
    }
    ::omero::RStringPtr getEmail(const ::Ice::Context& __ctx)
    {
        return getEmail(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getEmail()
    {
        return begin_getEmail(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getEmail(const ::Ice::Context& __ctx)
    {
        return begin_getEmail(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getEmail(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getEmail(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getEmail(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getEmail(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getEmail(const ::omero::model::Callback_Experimenter_getEmailPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getEmail(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getEmail(const ::Ice::Context& __ctx, const ::omero::model::Callback_Experimenter_getEmailPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getEmail(&__ctx, __del, __cookie);
    }

    ::omero::RStringPtr end_getEmail(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::RStringPtr getEmail(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getEmail(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setEmail(const ::omero::RStringPtr& theEmail)
    {
        setEmail(theEmail, 0);
    }
    void setEmail(const ::omero::RStringPtr& theEmail, const ::Ice::Context& __ctx)
    {
        setEmail(theEmail, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setEmail(const ::omero::RStringPtr& theEmail)
    {
        return begin_setEmail(theEmail, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setEmail(const ::omero::RStringPtr& theEmail, const ::Ice::Context& __ctx)
    {
        return begin_setEmail(theEmail, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setEmail(const ::omero::RStringPtr& theEmail, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setEmail(theEmail, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setEmail(const ::omero::RStringPtr& theEmail, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setEmail(theEmail, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setEmail(const ::omero::RStringPtr& theEmail, const ::omero::model::Callback_Experimenter_setEmailPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setEmail(theEmail, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setEmail(const ::omero::RStringPtr& theEmail, const ::Ice::Context& __ctx, const ::omero::model::Callback_Experimenter_setEmailPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setEmail(theEmail, &__ctx, __del, __cookie);
    }

    void end_setEmail(const ::Ice::AsyncResultPtr&);
    
private:

    void setEmail(const ::omero::RStringPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setEmail(const ::omero::RStringPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void unloadAnnotationLinks()
    {
        unloadAnnotationLinks(0);
    }
    void unloadAnnotationLinks(const ::Ice::Context& __ctx)
    {
        unloadAnnotationLinks(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_unloadAnnotationLinks()
    {
        return begin_unloadAnnotationLinks(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_unloadAnnotationLinks(const ::Ice::Context& __ctx)
    {
        return begin_unloadAnnotationLinks(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_unloadAnnotationLinks(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_unloadAnnotationLinks(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_unloadAnnotationLinks(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_unloadAnnotationLinks(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_unloadAnnotationLinks(const ::omero::model::Callback_Experimenter_unloadAnnotationLinksPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_unloadAnnotationLinks(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_unloadAnnotationLinks(const ::Ice::Context& __ctx, const ::omero::model::Callback_Experimenter_unloadAnnotationLinksPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_unloadAnnotationLinks(&__ctx, __del, __cookie);
    }

    void end_unloadAnnotationLinks(const ::Ice::AsyncResultPtr&);
    
private:

    void unloadAnnotationLinks(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_unloadAnnotationLinks(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Int sizeOfAnnotationLinks()
    {
        return sizeOfAnnotationLinks(0);
    }
    ::Ice::Int sizeOfAnnotationLinks(const ::Ice::Context& __ctx)
    {
        return sizeOfAnnotationLinks(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_sizeOfAnnotationLinks()
    {
        return begin_sizeOfAnnotationLinks(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_sizeOfAnnotationLinks(const ::Ice::Context& __ctx)
    {
        return begin_sizeOfAnnotationLinks(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_sizeOfAnnotationLinks(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_sizeOfAnnotationLinks(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_sizeOfAnnotationLinks(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_sizeOfAnnotationLinks(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_sizeOfAnnotationLinks(const ::omero::model::Callback_Experimenter_sizeOfAnnotationLinksPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_sizeOfAnnotationLinks(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_sizeOfAnnotationLinks(const ::Ice::Context& __ctx, const ::omero::model::Callback_Experimenter_sizeOfAnnotationLinksPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_sizeOfAnnotationLinks(&__ctx, __del, __cookie);
    }

    ::Ice::Int end_sizeOfAnnotationLinks(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int sizeOfAnnotationLinks(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_sizeOfAnnotationLinks(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::model::ExperimenterAnnotationLinksSeq copyAnnotationLinks()
    {
        return copyAnnotationLinks(0);
    }
    ::omero::model::ExperimenterAnnotationLinksSeq copyAnnotationLinks(const ::Ice::Context& __ctx)
    {
        return copyAnnotationLinks(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_copyAnnotationLinks()
    {
        return begin_copyAnnotationLinks(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_copyAnnotationLinks(const ::Ice::Context& __ctx)
    {
        return begin_copyAnnotationLinks(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_copyAnnotationLinks(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_copyAnnotationLinks(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_copyAnnotationLinks(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_copyAnnotationLinks(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_copyAnnotationLinks(const ::omero::model::Callback_Experimenter_copyAnnotationLinksPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_copyAnnotationLinks(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_copyAnnotationLinks(const ::Ice::Context& __ctx, const ::omero::model::Callback_Experimenter_copyAnnotationLinksPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_copyAnnotationLinks(&__ctx, __del, __cookie);
    }

    ::omero::model::ExperimenterAnnotationLinksSeq end_copyAnnotationLinks(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::model::ExperimenterAnnotationLinksSeq copyAnnotationLinks(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_copyAnnotationLinks(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void addExperimenterAnnotationLink(const ::omero::model::ExperimenterAnnotationLinkPtr& target)
    {
        addExperimenterAnnotationLink(target, 0);
    }
    void addExperimenterAnnotationLink(const ::omero::model::ExperimenterAnnotationLinkPtr& target, const ::Ice::Context& __ctx)
    {
        addExperimenterAnnotationLink(target, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_addExperimenterAnnotationLink(const ::omero::model::ExperimenterAnnotationLinkPtr& target)
    {
        return begin_addExperimenterAnnotationLink(target, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_addExperimenterAnnotationLink(const ::omero::model::ExperimenterAnnotationLinkPtr& target, const ::Ice::Context& __ctx)
    {
        return begin_addExperimenterAnnotationLink(target, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_addExperimenterAnnotationLink(const ::omero::model::ExperimenterAnnotationLinkPtr& target, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_addExperimenterAnnotationLink(target, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_addExperimenterAnnotationLink(const ::omero::model::ExperimenterAnnotationLinkPtr& target, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_addExperimenterAnnotationLink(target, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_addExperimenterAnnotationLink(const ::omero::model::ExperimenterAnnotationLinkPtr& target, const ::omero::model::Callback_Experimenter_addExperimenterAnnotationLinkPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_addExperimenterAnnotationLink(target, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_addExperimenterAnnotationLink(const ::omero::model::ExperimenterAnnotationLinkPtr& target, const ::Ice::Context& __ctx, const ::omero::model::Callback_Experimenter_addExperimenterAnnotationLinkPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_addExperimenterAnnotationLink(target, &__ctx, __del, __cookie);
    }

    void end_addExperimenterAnnotationLink(const ::Ice::AsyncResultPtr&);
    
private:

    void addExperimenterAnnotationLink(const ::omero::model::ExperimenterAnnotationLinkPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_addExperimenterAnnotationLink(const ::omero::model::ExperimenterAnnotationLinkPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void addAllExperimenterAnnotationLinkSet(const ::omero::model::ExperimenterAnnotationLinksSeq& targets)
    {
        addAllExperimenterAnnotationLinkSet(targets, 0);
    }
    void addAllExperimenterAnnotationLinkSet(const ::omero::model::ExperimenterAnnotationLinksSeq& targets, const ::Ice::Context& __ctx)
    {
        addAllExperimenterAnnotationLinkSet(targets, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_addAllExperimenterAnnotationLinkSet(const ::omero::model::ExperimenterAnnotationLinksSeq& targets)
    {
        return begin_addAllExperimenterAnnotationLinkSet(targets, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_addAllExperimenterAnnotationLinkSet(const ::omero::model::ExperimenterAnnotationLinksSeq& targets, const ::Ice::Context& __ctx)
    {
        return begin_addAllExperimenterAnnotationLinkSet(targets, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_addAllExperimenterAnnotationLinkSet(const ::omero::model::ExperimenterAnnotationLinksSeq& targets, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_addAllExperimenterAnnotationLinkSet(targets, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_addAllExperimenterAnnotationLinkSet(const ::omero::model::ExperimenterAnnotationLinksSeq& targets, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_addAllExperimenterAnnotationLinkSet(targets, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_addAllExperimenterAnnotationLinkSet(const ::omero::model::ExperimenterAnnotationLinksSeq& targets, const ::omero::model::Callback_Experimenter_addAllExperimenterAnnotationLinkSetPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_addAllExperimenterAnnotationLinkSet(targets, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_addAllExperimenterAnnotationLinkSet(const ::omero::model::ExperimenterAnnotationLinksSeq& targets, const ::Ice::Context& __ctx, const ::omero::model::Callback_Experimenter_addAllExperimenterAnnotationLinkSetPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_addAllExperimenterAnnotationLinkSet(targets, &__ctx, __del, __cookie);
    }

    void end_addAllExperimenterAnnotationLinkSet(const ::Ice::AsyncResultPtr&);
    
private:

    void addAllExperimenterAnnotationLinkSet(const ::omero::model::ExperimenterAnnotationLinksSeq&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_addAllExperimenterAnnotationLinkSet(const ::omero::model::ExperimenterAnnotationLinksSeq&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void removeExperimenterAnnotationLink(const ::omero::model::ExperimenterAnnotationLinkPtr& theTarget)
    {
        removeExperimenterAnnotationLink(theTarget, 0);
    }
    void removeExperimenterAnnotationLink(const ::omero::model::ExperimenterAnnotationLinkPtr& theTarget, const ::Ice::Context& __ctx)
    {
        removeExperimenterAnnotationLink(theTarget, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_removeExperimenterAnnotationLink(const ::omero::model::ExperimenterAnnotationLinkPtr& theTarget)
    {
        return begin_removeExperimenterAnnotationLink(theTarget, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_removeExperimenterAnnotationLink(const ::omero::model::ExperimenterAnnotationLinkPtr& theTarget, const ::Ice::Context& __ctx)
    {
        return begin_removeExperimenterAnnotationLink(theTarget, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_removeExperimenterAnnotationLink(const ::omero::model::ExperimenterAnnotationLinkPtr& theTarget, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_removeExperimenterAnnotationLink(theTarget, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_removeExperimenterAnnotationLink(const ::omero::model::ExperimenterAnnotationLinkPtr& theTarget, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_removeExperimenterAnnotationLink(theTarget, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_removeExperimenterAnnotationLink(const ::omero::model::ExperimenterAnnotationLinkPtr& theTarget, const ::omero::model::Callback_Experimenter_removeExperimenterAnnotationLinkPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_removeExperimenterAnnotationLink(theTarget, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_removeExperimenterAnnotationLink(const ::omero::model::ExperimenterAnnotationLinkPtr& theTarget, const ::Ice::Context& __ctx, const ::omero::model::Callback_Experimenter_removeExperimenterAnnotationLinkPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_removeExperimenterAnnotationLink(theTarget, &__ctx, __del, __cookie);
    }

    void end_removeExperimenterAnnotationLink(const ::Ice::AsyncResultPtr&);
    
private:

    void removeExperimenterAnnotationLink(const ::omero::model::ExperimenterAnnotationLinkPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_removeExperimenterAnnotationLink(const ::omero::model::ExperimenterAnnotationLinkPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void removeAllExperimenterAnnotationLinkSet(const ::omero::model::ExperimenterAnnotationLinksSeq& targets)
    {
        removeAllExperimenterAnnotationLinkSet(targets, 0);
    }
    void removeAllExperimenterAnnotationLinkSet(const ::omero::model::ExperimenterAnnotationLinksSeq& targets, const ::Ice::Context& __ctx)
    {
        removeAllExperimenterAnnotationLinkSet(targets, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_removeAllExperimenterAnnotationLinkSet(const ::omero::model::ExperimenterAnnotationLinksSeq& targets)
    {
        return begin_removeAllExperimenterAnnotationLinkSet(targets, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_removeAllExperimenterAnnotationLinkSet(const ::omero::model::ExperimenterAnnotationLinksSeq& targets, const ::Ice::Context& __ctx)
    {
        return begin_removeAllExperimenterAnnotationLinkSet(targets, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_removeAllExperimenterAnnotationLinkSet(const ::omero::model::ExperimenterAnnotationLinksSeq& targets, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_removeAllExperimenterAnnotationLinkSet(targets, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_removeAllExperimenterAnnotationLinkSet(const ::omero::model::ExperimenterAnnotationLinksSeq& targets, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_removeAllExperimenterAnnotationLinkSet(targets, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_removeAllExperimenterAnnotationLinkSet(const ::omero::model::ExperimenterAnnotationLinksSeq& targets, const ::omero::model::Callback_Experimenter_removeAllExperimenterAnnotationLinkSetPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_removeAllExperimenterAnnotationLinkSet(targets, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_removeAllExperimenterAnnotationLinkSet(const ::omero::model::ExperimenterAnnotationLinksSeq& targets, const ::Ice::Context& __ctx, const ::omero::model::Callback_Experimenter_removeAllExperimenterAnnotationLinkSetPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_removeAllExperimenterAnnotationLinkSet(targets, &__ctx, __del, __cookie);
    }

    void end_removeAllExperimenterAnnotationLinkSet(const ::Ice::AsyncResultPtr&);
    
private:

    void removeAllExperimenterAnnotationLinkSet(const ::omero::model::ExperimenterAnnotationLinksSeq&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_removeAllExperimenterAnnotationLinkSet(const ::omero::model::ExperimenterAnnotationLinksSeq&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void clearAnnotationLinks()
    {
        clearAnnotationLinks(0);
    }
    void clearAnnotationLinks(const ::Ice::Context& __ctx)
    {
        clearAnnotationLinks(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_clearAnnotationLinks()
    {
        return begin_clearAnnotationLinks(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_clearAnnotationLinks(const ::Ice::Context& __ctx)
    {
        return begin_clearAnnotationLinks(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_clearAnnotationLinks(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_clearAnnotationLinks(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_clearAnnotationLinks(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_clearAnnotationLinks(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_clearAnnotationLinks(const ::omero::model::Callback_Experimenter_clearAnnotationLinksPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_clearAnnotationLinks(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_clearAnnotationLinks(const ::Ice::Context& __ctx, const ::omero::model::Callback_Experimenter_clearAnnotationLinksPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_clearAnnotationLinks(&__ctx, __del, __cookie);
    }

    void end_clearAnnotationLinks(const ::Ice::AsyncResultPtr&);
    
private:

    void clearAnnotationLinks(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_clearAnnotationLinks(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void reloadAnnotationLinks(const ::omero::model::ExperimenterPtr& toCopy)
    {
        reloadAnnotationLinks(toCopy, 0);
    }
    void reloadAnnotationLinks(const ::omero::model::ExperimenterPtr& toCopy, const ::Ice::Context& __ctx)
    {
        reloadAnnotationLinks(toCopy, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_reloadAnnotationLinks(const ::omero::model::ExperimenterPtr& toCopy)
    {
        return begin_reloadAnnotationLinks(toCopy, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_reloadAnnotationLinks(const ::omero::model::ExperimenterPtr& toCopy, const ::Ice::Context& __ctx)
    {
        return begin_reloadAnnotationLinks(toCopy, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_reloadAnnotationLinks(const ::omero::model::ExperimenterPtr& toCopy, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_reloadAnnotationLinks(toCopy, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_reloadAnnotationLinks(const ::omero::model::ExperimenterPtr& toCopy, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_reloadAnnotationLinks(toCopy, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_reloadAnnotationLinks(const ::omero::model::ExperimenterPtr& toCopy, const ::omero::model::Callback_Experimenter_reloadAnnotationLinksPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_reloadAnnotationLinks(toCopy, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_reloadAnnotationLinks(const ::omero::model::ExperimenterPtr& toCopy, const ::Ice::Context& __ctx, const ::omero::model::Callback_Experimenter_reloadAnnotationLinksPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_reloadAnnotationLinks(toCopy, &__ctx, __del, __cookie);
    }

    void end_reloadAnnotationLinks(const ::Ice::AsyncResultPtr&);
    
private:

    void reloadAnnotationLinks(const ::omero::model::ExperimenterPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_reloadAnnotationLinks(const ::omero::model::ExperimenterPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::sys::CountMap getAnnotationLinksCountPerOwner()
    {
        return getAnnotationLinksCountPerOwner(0);
    }
    ::omero::sys::CountMap getAnnotationLinksCountPerOwner(const ::Ice::Context& __ctx)
    {
        return getAnnotationLinksCountPerOwner(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getAnnotationLinksCountPerOwner()
    {
        return begin_getAnnotationLinksCountPerOwner(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getAnnotationLinksCountPerOwner(const ::Ice::Context& __ctx)
    {
        return begin_getAnnotationLinksCountPerOwner(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getAnnotationLinksCountPerOwner(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getAnnotationLinksCountPerOwner(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getAnnotationLinksCountPerOwner(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getAnnotationLinksCountPerOwner(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getAnnotationLinksCountPerOwner(const ::omero::model::Callback_Experimenter_getAnnotationLinksCountPerOwnerPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getAnnotationLinksCountPerOwner(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getAnnotationLinksCountPerOwner(const ::Ice::Context& __ctx, const ::omero::model::Callback_Experimenter_getAnnotationLinksCountPerOwnerPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getAnnotationLinksCountPerOwner(&__ctx, __del, __cookie);
    }

    ::omero::sys::CountMap end_getAnnotationLinksCountPerOwner(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::sys::CountMap getAnnotationLinksCountPerOwner(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getAnnotationLinksCountPerOwner(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::model::ExperimenterAnnotationLinkPtr linkAnnotation(const ::omero::model::AnnotationPtr& addition)
    {
        return linkAnnotation(addition, 0);
    }
    ::omero::model::ExperimenterAnnotationLinkPtr linkAnnotation(const ::omero::model::AnnotationPtr& addition, const ::Ice::Context& __ctx)
    {
        return linkAnnotation(addition, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_linkAnnotation(const ::omero::model::AnnotationPtr& addition)
    {
        return begin_linkAnnotation(addition, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_linkAnnotation(const ::omero::model::AnnotationPtr& addition, const ::Ice::Context& __ctx)
    {
        return begin_linkAnnotation(addition, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_linkAnnotation(const ::omero::model::AnnotationPtr& addition, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_linkAnnotation(addition, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_linkAnnotation(const ::omero::model::AnnotationPtr& addition, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_linkAnnotation(addition, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_linkAnnotation(const ::omero::model::AnnotationPtr& addition, const ::omero::model::Callback_Experimenter_linkAnnotationPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_linkAnnotation(addition, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_linkAnnotation(const ::omero::model::AnnotationPtr& addition, const ::Ice::Context& __ctx, const ::omero::model::Callback_Experimenter_linkAnnotationPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_linkAnnotation(addition, &__ctx, __del, __cookie);
    }

    ::omero::model::ExperimenterAnnotationLinkPtr end_linkAnnotation(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::model::ExperimenterAnnotationLinkPtr linkAnnotation(const ::omero::model::AnnotationPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_linkAnnotation(const ::omero::model::AnnotationPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void addExperimenterAnnotationLinkToBoth(const ::omero::model::ExperimenterAnnotationLinkPtr& link, bool bothSides)
    {
        addExperimenterAnnotationLinkToBoth(link, bothSides, 0);
    }
    void addExperimenterAnnotationLinkToBoth(const ::omero::model::ExperimenterAnnotationLinkPtr& link, bool bothSides, const ::Ice::Context& __ctx)
    {
        addExperimenterAnnotationLinkToBoth(link, bothSides, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_addExperimenterAnnotationLinkToBoth(const ::omero::model::ExperimenterAnnotationLinkPtr& link, bool bothSides)
    {
        return begin_addExperimenterAnnotationLinkToBoth(link, bothSides, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_addExperimenterAnnotationLinkToBoth(const ::omero::model::ExperimenterAnnotationLinkPtr& link, bool bothSides, const ::Ice::Context& __ctx)
    {
        return begin_addExperimenterAnnotationLinkToBoth(link, bothSides, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_addExperimenterAnnotationLinkToBoth(const ::omero::model::ExperimenterAnnotationLinkPtr& link, bool bothSides, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_addExperimenterAnnotationLinkToBoth(link, bothSides, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_addExperimenterAnnotationLinkToBoth(const ::omero::model::ExperimenterAnnotationLinkPtr& link, bool bothSides, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_addExperimenterAnnotationLinkToBoth(link, bothSides, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_addExperimenterAnnotationLinkToBoth(const ::omero::model::ExperimenterAnnotationLinkPtr& link, bool bothSides, const ::omero::model::Callback_Experimenter_addExperimenterAnnotationLinkToBothPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_addExperimenterAnnotationLinkToBoth(link, bothSides, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_addExperimenterAnnotationLinkToBoth(const ::omero::model::ExperimenterAnnotationLinkPtr& link, bool bothSides, const ::Ice::Context& __ctx, const ::omero::model::Callback_Experimenter_addExperimenterAnnotationLinkToBothPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_addExperimenterAnnotationLinkToBoth(link, bothSides, &__ctx, __del, __cookie);
    }

    void end_addExperimenterAnnotationLinkToBoth(const ::Ice::AsyncResultPtr&);
    
private:

    void addExperimenterAnnotationLinkToBoth(const ::omero::model::ExperimenterAnnotationLinkPtr&, bool, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_addExperimenterAnnotationLinkToBoth(const ::omero::model::ExperimenterAnnotationLinkPtr&, bool, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::model::ExperimenterAnnotationLinksSeq findExperimenterAnnotationLink(const ::omero::model::AnnotationPtr& removal)
    {
        return findExperimenterAnnotationLink(removal, 0);
    }
    ::omero::model::ExperimenterAnnotationLinksSeq findExperimenterAnnotationLink(const ::omero::model::AnnotationPtr& removal, const ::Ice::Context& __ctx)
    {
        return findExperimenterAnnotationLink(removal, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_findExperimenterAnnotationLink(const ::omero::model::AnnotationPtr& removal)
    {
        return begin_findExperimenterAnnotationLink(removal, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_findExperimenterAnnotationLink(const ::omero::model::AnnotationPtr& removal, const ::Ice::Context& __ctx)
    {
        return begin_findExperimenterAnnotationLink(removal, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_findExperimenterAnnotationLink(const ::omero::model::AnnotationPtr& removal, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_findExperimenterAnnotationLink(removal, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_findExperimenterAnnotationLink(const ::omero::model::AnnotationPtr& removal, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_findExperimenterAnnotationLink(removal, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_findExperimenterAnnotationLink(const ::omero::model::AnnotationPtr& removal, const ::omero::model::Callback_Experimenter_findExperimenterAnnotationLinkPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_findExperimenterAnnotationLink(removal, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_findExperimenterAnnotationLink(const ::omero::model::AnnotationPtr& removal, const ::Ice::Context& __ctx, const ::omero::model::Callback_Experimenter_findExperimenterAnnotationLinkPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_findExperimenterAnnotationLink(removal, &__ctx, __del, __cookie);
    }

    ::omero::model::ExperimenterAnnotationLinksSeq end_findExperimenterAnnotationLink(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::model::ExperimenterAnnotationLinksSeq findExperimenterAnnotationLink(const ::omero::model::AnnotationPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_findExperimenterAnnotationLink(const ::omero::model::AnnotationPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void unlinkAnnotation(const ::omero::model::AnnotationPtr& removal)
    {
        unlinkAnnotation(removal, 0);
    }
    void unlinkAnnotation(const ::omero::model::AnnotationPtr& removal, const ::Ice::Context& __ctx)
    {
        unlinkAnnotation(removal, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_unlinkAnnotation(const ::omero::model::AnnotationPtr& removal)
    {
        return begin_unlinkAnnotation(removal, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_unlinkAnnotation(const ::omero::model::AnnotationPtr& removal, const ::Ice::Context& __ctx)
    {
        return begin_unlinkAnnotation(removal, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_unlinkAnnotation(const ::omero::model::AnnotationPtr& removal, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_unlinkAnnotation(removal, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_unlinkAnnotation(const ::omero::model::AnnotationPtr& removal, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_unlinkAnnotation(removal, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_unlinkAnnotation(const ::omero::model::AnnotationPtr& removal, const ::omero::model::Callback_Experimenter_unlinkAnnotationPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_unlinkAnnotation(removal, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_unlinkAnnotation(const ::omero::model::AnnotationPtr& removal, const ::Ice::Context& __ctx, const ::omero::model::Callback_Experimenter_unlinkAnnotationPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_unlinkAnnotation(removal, &__ctx, __del, __cookie);
    }

    void end_unlinkAnnotation(const ::Ice::AsyncResultPtr&);
    
private:

    void unlinkAnnotation(const ::omero::model::AnnotationPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_unlinkAnnotation(const ::omero::model::AnnotationPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void removeExperimenterAnnotationLinkFromBoth(const ::omero::model::ExperimenterAnnotationLinkPtr& link, bool bothSides)
    {
        removeExperimenterAnnotationLinkFromBoth(link, bothSides, 0);
    }
    void removeExperimenterAnnotationLinkFromBoth(const ::omero::model::ExperimenterAnnotationLinkPtr& link, bool bothSides, const ::Ice::Context& __ctx)
    {
        removeExperimenterAnnotationLinkFromBoth(link, bothSides, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_removeExperimenterAnnotationLinkFromBoth(const ::omero::model::ExperimenterAnnotationLinkPtr& link, bool bothSides)
    {
        return begin_removeExperimenterAnnotationLinkFromBoth(link, bothSides, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_removeExperimenterAnnotationLinkFromBoth(const ::omero::model::ExperimenterAnnotationLinkPtr& link, bool bothSides, const ::Ice::Context& __ctx)
    {
        return begin_removeExperimenterAnnotationLinkFromBoth(link, bothSides, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_removeExperimenterAnnotationLinkFromBoth(const ::omero::model::ExperimenterAnnotationLinkPtr& link, bool bothSides, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_removeExperimenterAnnotationLinkFromBoth(link, bothSides, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_removeExperimenterAnnotationLinkFromBoth(const ::omero::model::ExperimenterAnnotationLinkPtr& link, bool bothSides, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_removeExperimenterAnnotationLinkFromBoth(link, bothSides, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_removeExperimenterAnnotationLinkFromBoth(const ::omero::model::ExperimenterAnnotationLinkPtr& link, bool bothSides, const ::omero::model::Callback_Experimenter_removeExperimenterAnnotationLinkFromBothPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_removeExperimenterAnnotationLinkFromBoth(link, bothSides, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_removeExperimenterAnnotationLinkFromBoth(const ::omero::model::ExperimenterAnnotationLinkPtr& link, bool bothSides, const ::Ice::Context& __ctx, const ::omero::model::Callback_Experimenter_removeExperimenterAnnotationLinkFromBothPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_removeExperimenterAnnotationLinkFromBoth(link, bothSides, &__ctx, __del, __cookie);
    }

    void end_removeExperimenterAnnotationLinkFromBoth(const ::Ice::AsyncResultPtr&);
    
private:

    void removeExperimenterAnnotationLinkFromBoth(const ::omero::model::ExperimenterAnnotationLinkPtr&, bool, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_removeExperimenterAnnotationLinkFromBoth(const ::omero::model::ExperimenterAnnotationLinkPtr&, bool, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::model::ExperimenterLinkedAnnotationSeq linkedAnnotationList()
    {
        return linkedAnnotationList(0);
    }
    ::omero::model::ExperimenterLinkedAnnotationSeq linkedAnnotationList(const ::Ice::Context& __ctx)
    {
        return linkedAnnotationList(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_linkedAnnotationList()
    {
        return begin_linkedAnnotationList(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_linkedAnnotationList(const ::Ice::Context& __ctx)
    {
        return begin_linkedAnnotationList(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_linkedAnnotationList(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_linkedAnnotationList(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_linkedAnnotationList(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_linkedAnnotationList(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_linkedAnnotationList(const ::omero::model::Callback_Experimenter_linkedAnnotationListPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_linkedAnnotationList(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_linkedAnnotationList(const ::Ice::Context& __ctx, const ::omero::model::Callback_Experimenter_linkedAnnotationListPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_linkedAnnotationList(&__ctx, __del, __cookie);
    }

    ::omero::model::ExperimenterLinkedAnnotationSeq end_linkedAnnotationList(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::model::ExperimenterLinkedAnnotationSeq linkedAnnotationList(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_linkedAnnotationList(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    
    ::IceInternal::ProxyHandle<Experimenter> ice_context(const ::Ice::Context& __context) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Experimenter*>(_Base::ice_context(__context).get());
    #else
        return dynamic_cast<Experimenter*>(::IceProxy::Ice::Object::ice_context(__context).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Experimenter> ice_adapterId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Experimenter*>(_Base::ice_adapterId(__id).get());
    #else
        return dynamic_cast<Experimenter*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Experimenter> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Experimenter*>(_Base::ice_endpoints(__endpoints).get());
    #else
        return dynamic_cast<Experimenter*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Experimenter> ice_locatorCacheTimeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Experimenter*>(_Base::ice_locatorCacheTimeout(__timeout).get());
    #else
        return dynamic_cast<Experimenter*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Experimenter> ice_connectionCached(bool __cached) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Experimenter*>(_Base::ice_connectionCached(__cached).get());
    #else
        return dynamic_cast<Experimenter*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Experimenter> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Experimenter*>(_Base::ice_endpointSelection(__est).get());
    #else
        return dynamic_cast<Experimenter*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Experimenter> ice_secure(bool __secure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Experimenter*>(_Base::ice_secure(__secure).get());
    #else
        return dynamic_cast<Experimenter*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Experimenter> ice_preferSecure(bool __preferSecure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Experimenter*>(_Base::ice_preferSecure(__preferSecure).get());
    #else
        return dynamic_cast<Experimenter*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Experimenter> ice_router(const ::Ice::RouterPrx& __router) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Experimenter*>(_Base::ice_router(__router).get());
    #else
        return dynamic_cast<Experimenter*>(::IceProxy::Ice::Object::ice_router(__router).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Experimenter> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Experimenter*>(_Base::ice_locator(__locator).get());
    #else
        return dynamic_cast<Experimenter*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Experimenter> ice_collocationOptimized(bool __co) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Experimenter*>(_Base::ice_collocationOptimized(__co).get());
    #else
        return dynamic_cast<Experimenter*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Experimenter> ice_twoway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Experimenter*>(_Base::ice_twoway().get());
    #else
        return dynamic_cast<Experimenter*>(::IceProxy::Ice::Object::ice_twoway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Experimenter> ice_oneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Experimenter*>(_Base::ice_oneway().get());
    #else
        return dynamic_cast<Experimenter*>(::IceProxy::Ice::Object::ice_oneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Experimenter> ice_batchOneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Experimenter*>(_Base::ice_batchOneway().get());
    #else
        return dynamic_cast<Experimenter*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Experimenter> ice_datagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Experimenter*>(_Base::ice_datagram().get());
    #else
        return dynamic_cast<Experimenter*>(::IceProxy::Ice::Object::ice_datagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Experimenter> ice_batchDatagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Experimenter*>(_Base::ice_batchDatagram().get());
    #else
        return dynamic_cast<Experimenter*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Experimenter> ice_compress(bool __compress) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Experimenter*>(_Base::ice_compress(__compress).get());
    #else
        return dynamic_cast<Experimenter*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Experimenter> ice_timeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Experimenter*>(_Base::ice_timeout(__timeout).get());
    #else
        return dynamic_cast<Experimenter*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Experimenter> ice_connectionId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Experimenter*>(_Base::ice_connectionId(__id).get());
    #else
        return dynamic_cast<Experimenter*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    #endif
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

}

}

}

namespace IceDelegate
{

namespace omero
{

namespace model
{

class Experimenter : virtual public ::IceDelegate::omero::model::IObject
{
public:

    virtual ::omero::RIntPtr getVersion(const ::Ice::Context*) = 0;

    virtual void setVersion(const ::omero::RIntPtr&, const ::Ice::Context*) = 0;

    virtual void unloadGroupExperimenterMap(const ::Ice::Context*) = 0;

    virtual ::Ice::Int sizeOfGroupExperimenterMap(const ::Ice::Context*) = 0;

    virtual ::omero::model::ExperimenterGroupExperimenterMapSeq copyGroupExperimenterMap(const ::Ice::Context*) = 0;

    virtual void addGroupExperimenterMap(const ::omero::model::GroupExperimenterMapPtr&, const ::Ice::Context*) = 0;

    virtual void addAllGroupExperimenterMapSet(const ::omero::model::ExperimenterGroupExperimenterMapSeq&, const ::Ice::Context*) = 0;

    virtual void removeGroupExperimenterMap(const ::omero::model::GroupExperimenterMapPtr&, const ::Ice::Context*) = 0;

    virtual void removeAllGroupExperimenterMapSet(const ::omero::model::ExperimenterGroupExperimenterMapSeq&, const ::Ice::Context*) = 0;

    virtual void clearGroupExperimenterMap(const ::Ice::Context*) = 0;

    virtual void reloadGroupExperimenterMap(const ::omero::model::ExperimenterPtr&, const ::Ice::Context*) = 0;

    virtual ::omero::model::GroupExperimenterMapPtr getGroupExperimenterMap(::Ice::Int, const ::Ice::Context*) = 0;

    virtual ::omero::model::GroupExperimenterMapPtr setGroupExperimenterMap(::Ice::Int, const ::omero::model::GroupExperimenterMapPtr&, const ::Ice::Context*) = 0;

    virtual ::omero::model::GroupExperimenterMapPtr getPrimaryGroupExperimenterMap(const ::Ice::Context*) = 0;

    virtual ::omero::model::GroupExperimenterMapPtr setPrimaryGroupExperimenterMap(const ::omero::model::GroupExperimenterMapPtr&, const ::Ice::Context*) = 0;

    virtual ::omero::model::GroupExperimenterMapPtr linkExperimenterGroup(const ::omero::model::ExperimenterGroupPtr&, const ::Ice::Context*) = 0;

    virtual void addGroupExperimenterMapToBoth(const ::omero::model::GroupExperimenterMapPtr&, bool, const ::Ice::Context*) = 0;

    virtual ::omero::model::ExperimenterGroupExperimenterMapSeq findGroupExperimenterMap(const ::omero::model::ExperimenterGroupPtr&, const ::Ice::Context*) = 0;

    virtual void unlinkExperimenterGroup(const ::omero::model::ExperimenterGroupPtr&, const ::Ice::Context*) = 0;

    virtual void removeGroupExperimenterMapFromBoth(const ::omero::model::GroupExperimenterMapPtr&, bool, const ::Ice::Context*) = 0;

    virtual ::omero::model::ExperimenterLinkedExperimenterGroupSeq linkedExperimenterGroupList(const ::Ice::Context*) = 0;

    virtual ::omero::RStringPtr getOmeName(const ::Ice::Context*) = 0;

    virtual void setOmeName(const ::omero::RStringPtr&, const ::Ice::Context*) = 0;

    virtual ::omero::RStringPtr getFirstName(const ::Ice::Context*) = 0;

    virtual void setFirstName(const ::omero::RStringPtr&, const ::Ice::Context*) = 0;

    virtual ::omero::RStringPtr getMiddleName(const ::Ice::Context*) = 0;

    virtual void setMiddleName(const ::omero::RStringPtr&, const ::Ice::Context*) = 0;

    virtual ::omero::RStringPtr getLastName(const ::Ice::Context*) = 0;

    virtual void setLastName(const ::omero::RStringPtr&, const ::Ice::Context*) = 0;

    virtual ::omero::RStringPtr getInstitution(const ::Ice::Context*) = 0;

    virtual void setInstitution(const ::omero::RStringPtr&, const ::Ice::Context*) = 0;

    virtual ::omero::RStringPtr getEmail(const ::Ice::Context*) = 0;

    virtual void setEmail(const ::omero::RStringPtr&, const ::Ice::Context*) = 0;

    virtual void unloadAnnotationLinks(const ::Ice::Context*) = 0;

    virtual ::Ice::Int sizeOfAnnotationLinks(const ::Ice::Context*) = 0;

    virtual ::omero::model::ExperimenterAnnotationLinksSeq copyAnnotationLinks(const ::Ice::Context*) = 0;

    virtual void addExperimenterAnnotationLink(const ::omero::model::ExperimenterAnnotationLinkPtr&, const ::Ice::Context*) = 0;

    virtual void addAllExperimenterAnnotationLinkSet(const ::omero::model::ExperimenterAnnotationLinksSeq&, const ::Ice::Context*) = 0;

    virtual void removeExperimenterAnnotationLink(const ::omero::model::ExperimenterAnnotationLinkPtr&, const ::Ice::Context*) = 0;

    virtual void removeAllExperimenterAnnotationLinkSet(const ::omero::model::ExperimenterAnnotationLinksSeq&, const ::Ice::Context*) = 0;

    virtual void clearAnnotationLinks(const ::Ice::Context*) = 0;

    virtual void reloadAnnotationLinks(const ::omero::model::ExperimenterPtr&, const ::Ice::Context*) = 0;

    virtual ::omero::sys::CountMap getAnnotationLinksCountPerOwner(const ::Ice::Context*) = 0;

    virtual ::omero::model::ExperimenterAnnotationLinkPtr linkAnnotation(const ::omero::model::AnnotationPtr&, const ::Ice::Context*) = 0;

    virtual void addExperimenterAnnotationLinkToBoth(const ::omero::model::ExperimenterAnnotationLinkPtr&, bool, const ::Ice::Context*) = 0;

    virtual ::omero::model::ExperimenterAnnotationLinksSeq findExperimenterAnnotationLink(const ::omero::model::AnnotationPtr&, const ::Ice::Context*) = 0;

    virtual void unlinkAnnotation(const ::omero::model::AnnotationPtr&, const ::Ice::Context*) = 0;

    virtual void removeExperimenterAnnotationLinkFromBoth(const ::omero::model::ExperimenterAnnotationLinkPtr&, bool, const ::Ice::Context*) = 0;

    virtual ::omero::model::ExperimenterLinkedAnnotationSeq linkedAnnotationList(const ::Ice::Context*) = 0;
};

}

}

}

namespace IceDelegateM
{

namespace omero
{

namespace model
{

class Experimenter : virtual public ::IceDelegate::omero::model::Experimenter,
                     virtual public ::IceDelegateM::omero::model::IObject
{
public:

    virtual ::omero::RIntPtr getVersion(const ::Ice::Context*);

    virtual void setVersion(const ::omero::RIntPtr&, const ::Ice::Context*);

    virtual void unloadGroupExperimenterMap(const ::Ice::Context*);

    virtual ::Ice::Int sizeOfGroupExperimenterMap(const ::Ice::Context*);

    virtual ::omero::model::ExperimenterGroupExperimenterMapSeq copyGroupExperimenterMap(const ::Ice::Context*);

    virtual void addGroupExperimenterMap(const ::omero::model::GroupExperimenterMapPtr&, const ::Ice::Context*);

    virtual void addAllGroupExperimenterMapSet(const ::omero::model::ExperimenterGroupExperimenterMapSeq&, const ::Ice::Context*);

    virtual void removeGroupExperimenterMap(const ::omero::model::GroupExperimenterMapPtr&, const ::Ice::Context*);

    virtual void removeAllGroupExperimenterMapSet(const ::omero::model::ExperimenterGroupExperimenterMapSeq&, const ::Ice::Context*);

    virtual void clearGroupExperimenterMap(const ::Ice::Context*);

    virtual void reloadGroupExperimenterMap(const ::omero::model::ExperimenterPtr&, const ::Ice::Context*);

    virtual ::omero::model::GroupExperimenterMapPtr getGroupExperimenterMap(::Ice::Int, const ::Ice::Context*);

    virtual ::omero::model::GroupExperimenterMapPtr setGroupExperimenterMap(::Ice::Int, const ::omero::model::GroupExperimenterMapPtr&, const ::Ice::Context*);

    virtual ::omero::model::GroupExperimenterMapPtr getPrimaryGroupExperimenterMap(const ::Ice::Context*);

    virtual ::omero::model::GroupExperimenterMapPtr setPrimaryGroupExperimenterMap(const ::omero::model::GroupExperimenterMapPtr&, const ::Ice::Context*);

    virtual ::omero::model::GroupExperimenterMapPtr linkExperimenterGroup(const ::omero::model::ExperimenterGroupPtr&, const ::Ice::Context*);

    virtual void addGroupExperimenterMapToBoth(const ::omero::model::GroupExperimenterMapPtr&, bool, const ::Ice::Context*);

    virtual ::omero::model::ExperimenterGroupExperimenterMapSeq findGroupExperimenterMap(const ::omero::model::ExperimenterGroupPtr&, const ::Ice::Context*);

    virtual void unlinkExperimenterGroup(const ::omero::model::ExperimenterGroupPtr&, const ::Ice::Context*);

    virtual void removeGroupExperimenterMapFromBoth(const ::omero::model::GroupExperimenterMapPtr&, bool, const ::Ice::Context*);

    virtual ::omero::model::ExperimenterLinkedExperimenterGroupSeq linkedExperimenterGroupList(const ::Ice::Context*);

    virtual ::omero::RStringPtr getOmeName(const ::Ice::Context*);

    virtual void setOmeName(const ::omero::RStringPtr&, const ::Ice::Context*);

    virtual ::omero::RStringPtr getFirstName(const ::Ice::Context*);

    virtual void setFirstName(const ::omero::RStringPtr&, const ::Ice::Context*);

    virtual ::omero::RStringPtr getMiddleName(const ::Ice::Context*);

    virtual void setMiddleName(const ::omero::RStringPtr&, const ::Ice::Context*);

    virtual ::omero::RStringPtr getLastName(const ::Ice::Context*);

    virtual void setLastName(const ::omero::RStringPtr&, const ::Ice::Context*);

    virtual ::omero::RStringPtr getInstitution(const ::Ice::Context*);

    virtual void setInstitution(const ::omero::RStringPtr&, const ::Ice::Context*);

    virtual ::omero::RStringPtr getEmail(const ::Ice::Context*);

    virtual void setEmail(const ::omero::RStringPtr&, const ::Ice::Context*);

    virtual void unloadAnnotationLinks(const ::Ice::Context*);

    virtual ::Ice::Int sizeOfAnnotationLinks(const ::Ice::Context*);

    virtual ::omero::model::ExperimenterAnnotationLinksSeq copyAnnotationLinks(const ::Ice::Context*);

    virtual void addExperimenterAnnotationLink(const ::omero::model::ExperimenterAnnotationLinkPtr&, const ::Ice::Context*);

    virtual void addAllExperimenterAnnotationLinkSet(const ::omero::model::ExperimenterAnnotationLinksSeq&, const ::Ice::Context*);

    virtual void removeExperimenterAnnotationLink(const ::omero::model::ExperimenterAnnotationLinkPtr&, const ::Ice::Context*);

    virtual void removeAllExperimenterAnnotationLinkSet(const ::omero::model::ExperimenterAnnotationLinksSeq&, const ::Ice::Context*);

    virtual void clearAnnotationLinks(const ::Ice::Context*);

    virtual void reloadAnnotationLinks(const ::omero::model::ExperimenterPtr&, const ::Ice::Context*);

    virtual ::omero::sys::CountMap getAnnotationLinksCountPerOwner(const ::Ice::Context*);

    virtual ::omero::model::ExperimenterAnnotationLinkPtr linkAnnotation(const ::omero::model::AnnotationPtr&, const ::Ice::Context*);

    virtual void addExperimenterAnnotationLinkToBoth(const ::omero::model::ExperimenterAnnotationLinkPtr&, bool, const ::Ice::Context*);

    virtual ::omero::model::ExperimenterAnnotationLinksSeq findExperimenterAnnotationLink(const ::omero::model::AnnotationPtr&, const ::Ice::Context*);

    virtual void unlinkAnnotation(const ::omero::model::AnnotationPtr&, const ::Ice::Context*);

    virtual void removeExperimenterAnnotationLinkFromBoth(const ::omero::model::ExperimenterAnnotationLinkPtr&, bool, const ::Ice::Context*);

    virtual ::omero::model::ExperimenterLinkedAnnotationSeq linkedAnnotationList(const ::Ice::Context*);
};

}

}

}

namespace IceDelegateD
{

namespace omero
{

namespace model
{

class Experimenter : virtual public ::IceDelegate::omero::model::Experimenter,
                     virtual public ::IceDelegateD::omero::model::IObject
{
public:

    virtual ::omero::RIntPtr getVersion(const ::Ice::Context*);

    virtual void setVersion(const ::omero::RIntPtr&, const ::Ice::Context*);

    virtual void unloadGroupExperimenterMap(const ::Ice::Context*);

    virtual ::Ice::Int sizeOfGroupExperimenterMap(const ::Ice::Context*);

    virtual ::omero::model::ExperimenterGroupExperimenterMapSeq copyGroupExperimenterMap(const ::Ice::Context*);

    virtual void addGroupExperimenterMap(const ::omero::model::GroupExperimenterMapPtr&, const ::Ice::Context*);

    virtual void addAllGroupExperimenterMapSet(const ::omero::model::ExperimenterGroupExperimenterMapSeq&, const ::Ice::Context*);

    virtual void removeGroupExperimenterMap(const ::omero::model::GroupExperimenterMapPtr&, const ::Ice::Context*);

    virtual void removeAllGroupExperimenterMapSet(const ::omero::model::ExperimenterGroupExperimenterMapSeq&, const ::Ice::Context*);

    virtual void clearGroupExperimenterMap(const ::Ice::Context*);

    virtual void reloadGroupExperimenterMap(const ::omero::model::ExperimenterPtr&, const ::Ice::Context*);

    virtual ::omero::model::GroupExperimenterMapPtr getGroupExperimenterMap(::Ice::Int, const ::Ice::Context*);

    virtual ::omero::model::GroupExperimenterMapPtr setGroupExperimenterMap(::Ice::Int, const ::omero::model::GroupExperimenterMapPtr&, const ::Ice::Context*);

    virtual ::omero::model::GroupExperimenterMapPtr getPrimaryGroupExperimenterMap(const ::Ice::Context*);

    virtual ::omero::model::GroupExperimenterMapPtr setPrimaryGroupExperimenterMap(const ::omero::model::GroupExperimenterMapPtr&, const ::Ice::Context*);

    virtual ::omero::model::GroupExperimenterMapPtr linkExperimenterGroup(const ::omero::model::ExperimenterGroupPtr&, const ::Ice::Context*);

    virtual void addGroupExperimenterMapToBoth(const ::omero::model::GroupExperimenterMapPtr&, bool, const ::Ice::Context*);

    virtual ::omero::model::ExperimenterGroupExperimenterMapSeq findGroupExperimenterMap(const ::omero::model::ExperimenterGroupPtr&, const ::Ice::Context*);

    virtual void unlinkExperimenterGroup(const ::omero::model::ExperimenterGroupPtr&, const ::Ice::Context*);

    virtual void removeGroupExperimenterMapFromBoth(const ::omero::model::GroupExperimenterMapPtr&, bool, const ::Ice::Context*);

    virtual ::omero::model::ExperimenterLinkedExperimenterGroupSeq linkedExperimenterGroupList(const ::Ice::Context*);

    virtual ::omero::RStringPtr getOmeName(const ::Ice::Context*);

    virtual void setOmeName(const ::omero::RStringPtr&, const ::Ice::Context*);

    virtual ::omero::RStringPtr getFirstName(const ::Ice::Context*);

    virtual void setFirstName(const ::omero::RStringPtr&, const ::Ice::Context*);

    virtual ::omero::RStringPtr getMiddleName(const ::Ice::Context*);

    virtual void setMiddleName(const ::omero::RStringPtr&, const ::Ice::Context*);

    virtual ::omero::RStringPtr getLastName(const ::Ice::Context*);

    virtual void setLastName(const ::omero::RStringPtr&, const ::Ice::Context*);

    virtual ::omero::RStringPtr getInstitution(const ::Ice::Context*);

    virtual void setInstitution(const ::omero::RStringPtr&, const ::Ice::Context*);

    virtual ::omero::RStringPtr getEmail(const ::Ice::Context*);

    virtual void setEmail(const ::omero::RStringPtr&, const ::Ice::Context*);

    virtual void unloadAnnotationLinks(const ::Ice::Context*);

    virtual ::Ice::Int sizeOfAnnotationLinks(const ::Ice::Context*);

    virtual ::omero::model::ExperimenterAnnotationLinksSeq copyAnnotationLinks(const ::Ice::Context*);

    virtual void addExperimenterAnnotationLink(const ::omero::model::ExperimenterAnnotationLinkPtr&, const ::Ice::Context*);

    virtual void addAllExperimenterAnnotationLinkSet(const ::omero::model::ExperimenterAnnotationLinksSeq&, const ::Ice::Context*);

    virtual void removeExperimenterAnnotationLink(const ::omero::model::ExperimenterAnnotationLinkPtr&, const ::Ice::Context*);

    virtual void removeAllExperimenterAnnotationLinkSet(const ::omero::model::ExperimenterAnnotationLinksSeq&, const ::Ice::Context*);

    virtual void clearAnnotationLinks(const ::Ice::Context*);

    virtual void reloadAnnotationLinks(const ::omero::model::ExperimenterPtr&, const ::Ice::Context*);

    virtual ::omero::sys::CountMap getAnnotationLinksCountPerOwner(const ::Ice::Context*);

    virtual ::omero::model::ExperimenterAnnotationLinkPtr linkAnnotation(const ::omero::model::AnnotationPtr&, const ::Ice::Context*);

    virtual void addExperimenterAnnotationLinkToBoth(const ::omero::model::ExperimenterAnnotationLinkPtr&, bool, const ::Ice::Context*);

    virtual ::omero::model::ExperimenterAnnotationLinksSeq findExperimenterAnnotationLink(const ::omero::model::AnnotationPtr&, const ::Ice::Context*);

    virtual void unlinkAnnotation(const ::omero::model::AnnotationPtr&, const ::Ice::Context*);

    virtual void removeExperimenterAnnotationLinkFromBoth(const ::omero::model::ExperimenterAnnotationLinkPtr&, bool, const ::Ice::Context*);

    virtual ::omero::model::ExperimenterLinkedAnnotationSeq linkedAnnotationList(const ::Ice::Context*);
};

}

}

}

namespace omero
{

namespace model
{

class Experimenter : public ::omero::model::IObject
{
public:

    typedef ExperimenterPrx ProxyType;
    typedef ExperimenterPtr PointerType;
    
    Experimenter() {}
    Experimenter(const ::omero::RLongPtr&, const ::omero::model::DetailsPtr&, bool, const ::omero::RIntPtr&, const ::omero::model::ExperimenterGroupExperimenterMapSeq&, bool, const ::omero::RStringPtr&, const ::omero::RStringPtr&, const ::omero::RStringPtr&, const ::omero::RStringPtr&, const ::omero::RStringPtr&, const ::omero::RStringPtr&, const ::omero::model::ExperimenterAnnotationLinksSeq&, bool, const ::omero::sys::CountMap&);
    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void __gcReachable(::IceInternal::GCCountMap&) const;
    virtual void __gcClear();

    virtual ::omero::RIntPtr getVersion(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getVersion(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setVersion(const ::omero::RIntPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setVersion(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void unloadGroupExperimenterMap(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___unloadGroupExperimenterMap(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Int sizeOfGroupExperimenterMap(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___sizeOfGroupExperimenterMap(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::model::ExperimenterGroupExperimenterMapSeq copyGroupExperimenterMap(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___copyGroupExperimenterMap(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void addGroupExperimenterMap(const ::omero::model::GroupExperimenterMapPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___addGroupExperimenterMap(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void addAllGroupExperimenterMapSet(const ::omero::model::ExperimenterGroupExperimenterMapSeq&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___addAllGroupExperimenterMapSet(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void removeGroupExperimenterMap(const ::omero::model::GroupExperimenterMapPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___removeGroupExperimenterMap(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void removeAllGroupExperimenterMapSet(const ::omero::model::ExperimenterGroupExperimenterMapSeq&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___removeAllGroupExperimenterMapSet(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void clearGroupExperimenterMap(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___clearGroupExperimenterMap(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void reloadGroupExperimenterMap(const ::omero::model::ExperimenterPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___reloadGroupExperimenterMap(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::model::GroupExperimenterMapPtr getGroupExperimenterMap(::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getGroupExperimenterMap(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::model::GroupExperimenterMapPtr setGroupExperimenterMap(::Ice::Int, const ::omero::model::GroupExperimenterMapPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setGroupExperimenterMap(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::model::GroupExperimenterMapPtr getPrimaryGroupExperimenterMap(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getPrimaryGroupExperimenterMap(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::model::GroupExperimenterMapPtr setPrimaryGroupExperimenterMap(const ::omero::model::GroupExperimenterMapPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setPrimaryGroupExperimenterMap(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::model::GroupExperimenterMapPtr linkExperimenterGroup(const ::omero::model::ExperimenterGroupPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___linkExperimenterGroup(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void addGroupExperimenterMapToBoth(const ::omero::model::GroupExperimenterMapPtr&, bool, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___addGroupExperimenterMapToBoth(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::model::ExperimenterGroupExperimenterMapSeq findGroupExperimenterMap(const ::omero::model::ExperimenterGroupPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___findGroupExperimenterMap(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void unlinkExperimenterGroup(const ::omero::model::ExperimenterGroupPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___unlinkExperimenterGroup(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void removeGroupExperimenterMapFromBoth(const ::omero::model::GroupExperimenterMapPtr&, bool, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___removeGroupExperimenterMapFromBoth(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::model::ExperimenterLinkedExperimenterGroupSeq linkedExperimenterGroupList(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___linkedExperimenterGroupList(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::RStringPtr getOmeName(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getOmeName(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setOmeName(const ::omero::RStringPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setOmeName(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::RStringPtr getFirstName(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getFirstName(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setFirstName(const ::omero::RStringPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setFirstName(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::RStringPtr getMiddleName(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getMiddleName(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setMiddleName(const ::omero::RStringPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setMiddleName(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::RStringPtr getLastName(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getLastName(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setLastName(const ::omero::RStringPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setLastName(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::RStringPtr getInstitution(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getInstitution(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setInstitution(const ::omero::RStringPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setInstitution(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::RStringPtr getEmail(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getEmail(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setEmail(const ::omero::RStringPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setEmail(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void unloadAnnotationLinks(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___unloadAnnotationLinks(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Int sizeOfAnnotationLinks(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___sizeOfAnnotationLinks(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::model::ExperimenterAnnotationLinksSeq copyAnnotationLinks(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___copyAnnotationLinks(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void addExperimenterAnnotationLink(const ::omero::model::ExperimenterAnnotationLinkPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___addExperimenterAnnotationLink(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void addAllExperimenterAnnotationLinkSet(const ::omero::model::ExperimenterAnnotationLinksSeq&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___addAllExperimenterAnnotationLinkSet(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void removeExperimenterAnnotationLink(const ::omero::model::ExperimenterAnnotationLinkPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___removeExperimenterAnnotationLink(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void removeAllExperimenterAnnotationLinkSet(const ::omero::model::ExperimenterAnnotationLinksSeq&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___removeAllExperimenterAnnotationLinkSet(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void clearAnnotationLinks(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___clearAnnotationLinks(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void reloadAnnotationLinks(const ::omero::model::ExperimenterPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___reloadAnnotationLinks(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::sys::CountMap getAnnotationLinksCountPerOwner(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getAnnotationLinksCountPerOwner(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::model::ExperimenterAnnotationLinkPtr linkAnnotation(const ::omero::model::AnnotationPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___linkAnnotation(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void addExperimenterAnnotationLinkToBoth(const ::omero::model::ExperimenterAnnotationLinkPtr&, bool, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___addExperimenterAnnotationLinkToBoth(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::model::ExperimenterAnnotationLinksSeq findExperimenterAnnotationLink(const ::omero::model::AnnotationPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___findExperimenterAnnotationLink(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void unlinkAnnotation(const ::omero::model::AnnotationPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___unlinkAnnotation(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void removeExperimenterAnnotationLinkFromBoth(const ::omero::model::ExperimenterAnnotationLinkPtr&, bool, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___removeExperimenterAnnotationLinkFromBoth(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::model::ExperimenterLinkedAnnotationSeq linkedAnnotationList(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___linkedAnnotationList(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void __write(::IceInternal::BasicStream*) const;
    virtual void __read(::IceInternal::BasicStream*, bool);
// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
    virtual void __write(const ::Ice::OutputStreamPtr&) const;
    virtual void __read(const ::Ice::InputStreamPtr&, bool);
#endif

protected:

    ::omero::RIntPtr version;

    ::omero::model::ExperimenterGroupExperimenterMapSeq groupExperimenterMapSeq;

    bool groupExperimenterMapLoaded;

    ::omero::RStringPtr omeName;

    ::omero::RStringPtr firstName;

    ::omero::RStringPtr middleName;

    ::omero::RStringPtr lastName;

    ::omero::RStringPtr institution;

    ::omero::RStringPtr email;

    ::omero::model::ExperimenterAnnotationLinksSeq annotationLinksSeq;

    bool annotationLinksLoaded;

    ::omero::sys::CountMap annotationLinksCountPerOwner;
};

inline bool operator==(const Experimenter& l, const Experimenter& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const Experimenter& l, const Experimenter& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

}

}

namespace omero
{

namespace model
{

template<class T>
class CallbackNC_Experimenter_getVersion : public Callback_Experimenter_getVersion_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::RIntPtr&);

    CallbackNC_Experimenter_getVersion(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::ExperimenterPrx __proxy = ::omero::model::ExperimenterPrx::uncheckedCast(__result->getProxy());
        ::omero::RIntPtr __ret;
        try
        {
            __ret = __proxy->end_getVersion(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_Experimenter_getVersionPtr
newCallback_Experimenter_getVersion(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RIntPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_getVersion<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Experimenter_getVersionPtr
newCallback_Experimenter_getVersion(T* instance, void (T::*cb)(const ::omero::RIntPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_getVersion<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Experimenter_getVersion : public Callback_Experimenter_getVersion_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::RIntPtr&, const CT&);

    Callback_Experimenter_getVersion(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::ExperimenterPrx __proxy = ::omero::model::ExperimenterPrx::uncheckedCast(__result->getProxy());
        ::omero::RIntPtr __ret;
        try
        {
            __ret = __proxy->end_getVersion(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Experimenter_getVersionPtr
newCallback_Experimenter_getVersion(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RIntPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_getVersion<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Experimenter_getVersionPtr
newCallback_Experimenter_getVersion(T* instance, void (T::*cb)(const ::omero::RIntPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_getVersion<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Experimenter_setVersion : public Callback_Experimenter_setVersion_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Experimenter_setVersion(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_Experimenter_setVersionPtr
newCallback_Experimenter_setVersion(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_setVersion<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Experimenter_setVersionPtr
newCallback_Experimenter_setVersion(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_setVersion<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Experimenter_setVersionPtr
newCallback_Experimenter_setVersion(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_setVersion<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Experimenter_setVersionPtr
newCallback_Experimenter_setVersion(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_setVersion<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Experimenter_setVersion : public Callback_Experimenter_setVersion_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Experimenter_setVersion(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_Experimenter_setVersionPtr
newCallback_Experimenter_setVersion(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_setVersion<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Experimenter_setVersionPtr
newCallback_Experimenter_setVersion(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_setVersion<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Experimenter_setVersionPtr
newCallback_Experimenter_setVersion(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_setVersion<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Experimenter_setVersionPtr
newCallback_Experimenter_setVersion(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_setVersion<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Experimenter_unloadGroupExperimenterMap : public Callback_Experimenter_unloadGroupExperimenterMap_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Experimenter_unloadGroupExperimenterMap(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_Experimenter_unloadGroupExperimenterMapPtr
newCallback_Experimenter_unloadGroupExperimenterMap(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_unloadGroupExperimenterMap<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Experimenter_unloadGroupExperimenterMapPtr
newCallback_Experimenter_unloadGroupExperimenterMap(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_unloadGroupExperimenterMap<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Experimenter_unloadGroupExperimenterMapPtr
newCallback_Experimenter_unloadGroupExperimenterMap(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_unloadGroupExperimenterMap<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Experimenter_unloadGroupExperimenterMapPtr
newCallback_Experimenter_unloadGroupExperimenterMap(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_unloadGroupExperimenterMap<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Experimenter_unloadGroupExperimenterMap : public Callback_Experimenter_unloadGroupExperimenterMap_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Experimenter_unloadGroupExperimenterMap(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_Experimenter_unloadGroupExperimenterMapPtr
newCallback_Experimenter_unloadGroupExperimenterMap(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_unloadGroupExperimenterMap<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Experimenter_unloadGroupExperimenterMapPtr
newCallback_Experimenter_unloadGroupExperimenterMap(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_unloadGroupExperimenterMap<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Experimenter_unloadGroupExperimenterMapPtr
newCallback_Experimenter_unloadGroupExperimenterMap(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_unloadGroupExperimenterMap<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Experimenter_unloadGroupExperimenterMapPtr
newCallback_Experimenter_unloadGroupExperimenterMap(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_unloadGroupExperimenterMap<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Experimenter_sizeOfGroupExperimenterMap : public Callback_Experimenter_sizeOfGroupExperimenterMap_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int);

    CallbackNC_Experimenter_sizeOfGroupExperimenterMap(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::ExperimenterPrx __proxy = ::omero::model::ExperimenterPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_sizeOfGroupExperimenterMap(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_Experimenter_sizeOfGroupExperimenterMapPtr
newCallback_Experimenter_sizeOfGroupExperimenterMap(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_sizeOfGroupExperimenterMap<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Experimenter_sizeOfGroupExperimenterMapPtr
newCallback_Experimenter_sizeOfGroupExperimenterMap(T* instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_sizeOfGroupExperimenterMap<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Experimenter_sizeOfGroupExperimenterMap : public Callback_Experimenter_sizeOfGroupExperimenterMap_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const CT&);

    Callback_Experimenter_sizeOfGroupExperimenterMap(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::ExperimenterPrx __proxy = ::omero::model::ExperimenterPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_sizeOfGroupExperimenterMap(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Experimenter_sizeOfGroupExperimenterMapPtr
newCallback_Experimenter_sizeOfGroupExperimenterMap(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_sizeOfGroupExperimenterMap<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Experimenter_sizeOfGroupExperimenterMapPtr
newCallback_Experimenter_sizeOfGroupExperimenterMap(T* instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_sizeOfGroupExperimenterMap<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Experimenter_copyGroupExperimenterMap : public Callback_Experimenter_copyGroupExperimenterMap_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::model::ExperimenterGroupExperimenterMapSeq&);

    CallbackNC_Experimenter_copyGroupExperimenterMap(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::ExperimenterPrx __proxy = ::omero::model::ExperimenterPrx::uncheckedCast(__result->getProxy());
        ::omero::model::ExperimenterGroupExperimenterMapSeq __ret;
        try
        {
            __ret = __proxy->end_copyGroupExperimenterMap(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_Experimenter_copyGroupExperimenterMapPtr
newCallback_Experimenter_copyGroupExperimenterMap(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::ExperimenterGroupExperimenterMapSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_copyGroupExperimenterMap<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Experimenter_copyGroupExperimenterMapPtr
newCallback_Experimenter_copyGroupExperimenterMap(T* instance, void (T::*cb)(const ::omero::model::ExperimenterGroupExperimenterMapSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_copyGroupExperimenterMap<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Experimenter_copyGroupExperimenterMap : public Callback_Experimenter_copyGroupExperimenterMap_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::model::ExperimenterGroupExperimenterMapSeq&, const CT&);

    Callback_Experimenter_copyGroupExperimenterMap(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::ExperimenterPrx __proxy = ::omero::model::ExperimenterPrx::uncheckedCast(__result->getProxy());
        ::omero::model::ExperimenterGroupExperimenterMapSeq __ret;
        try
        {
            __ret = __proxy->end_copyGroupExperimenterMap(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Experimenter_copyGroupExperimenterMapPtr
newCallback_Experimenter_copyGroupExperimenterMap(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::ExperimenterGroupExperimenterMapSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_copyGroupExperimenterMap<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Experimenter_copyGroupExperimenterMapPtr
newCallback_Experimenter_copyGroupExperimenterMap(T* instance, void (T::*cb)(const ::omero::model::ExperimenterGroupExperimenterMapSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_copyGroupExperimenterMap<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Experimenter_addGroupExperimenterMap : public Callback_Experimenter_addGroupExperimenterMap_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Experimenter_addGroupExperimenterMap(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_Experimenter_addGroupExperimenterMapPtr
newCallback_Experimenter_addGroupExperimenterMap(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_addGroupExperimenterMap<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Experimenter_addGroupExperimenterMapPtr
newCallback_Experimenter_addGroupExperimenterMap(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_addGroupExperimenterMap<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Experimenter_addGroupExperimenterMapPtr
newCallback_Experimenter_addGroupExperimenterMap(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_addGroupExperimenterMap<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Experimenter_addGroupExperimenterMapPtr
newCallback_Experimenter_addGroupExperimenterMap(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_addGroupExperimenterMap<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Experimenter_addGroupExperimenterMap : public Callback_Experimenter_addGroupExperimenterMap_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Experimenter_addGroupExperimenterMap(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_Experimenter_addGroupExperimenterMapPtr
newCallback_Experimenter_addGroupExperimenterMap(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_addGroupExperimenterMap<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Experimenter_addGroupExperimenterMapPtr
newCallback_Experimenter_addGroupExperimenterMap(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_addGroupExperimenterMap<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Experimenter_addGroupExperimenterMapPtr
newCallback_Experimenter_addGroupExperimenterMap(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_addGroupExperimenterMap<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Experimenter_addGroupExperimenterMapPtr
newCallback_Experimenter_addGroupExperimenterMap(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_addGroupExperimenterMap<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Experimenter_addAllGroupExperimenterMapSet : public Callback_Experimenter_addAllGroupExperimenterMapSet_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Experimenter_addAllGroupExperimenterMapSet(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_Experimenter_addAllGroupExperimenterMapSetPtr
newCallback_Experimenter_addAllGroupExperimenterMapSet(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_addAllGroupExperimenterMapSet<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Experimenter_addAllGroupExperimenterMapSetPtr
newCallback_Experimenter_addAllGroupExperimenterMapSet(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_addAllGroupExperimenterMapSet<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Experimenter_addAllGroupExperimenterMapSetPtr
newCallback_Experimenter_addAllGroupExperimenterMapSet(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_addAllGroupExperimenterMapSet<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Experimenter_addAllGroupExperimenterMapSetPtr
newCallback_Experimenter_addAllGroupExperimenterMapSet(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_addAllGroupExperimenterMapSet<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Experimenter_addAllGroupExperimenterMapSet : public Callback_Experimenter_addAllGroupExperimenterMapSet_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Experimenter_addAllGroupExperimenterMapSet(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_Experimenter_addAllGroupExperimenterMapSetPtr
newCallback_Experimenter_addAllGroupExperimenterMapSet(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_addAllGroupExperimenterMapSet<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Experimenter_addAllGroupExperimenterMapSetPtr
newCallback_Experimenter_addAllGroupExperimenterMapSet(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_addAllGroupExperimenterMapSet<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Experimenter_addAllGroupExperimenterMapSetPtr
newCallback_Experimenter_addAllGroupExperimenterMapSet(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_addAllGroupExperimenterMapSet<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Experimenter_addAllGroupExperimenterMapSetPtr
newCallback_Experimenter_addAllGroupExperimenterMapSet(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_addAllGroupExperimenterMapSet<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Experimenter_removeGroupExperimenterMap : public Callback_Experimenter_removeGroupExperimenterMap_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Experimenter_removeGroupExperimenterMap(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_Experimenter_removeGroupExperimenterMapPtr
newCallback_Experimenter_removeGroupExperimenterMap(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_removeGroupExperimenterMap<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Experimenter_removeGroupExperimenterMapPtr
newCallback_Experimenter_removeGroupExperimenterMap(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_removeGroupExperimenterMap<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Experimenter_removeGroupExperimenterMapPtr
newCallback_Experimenter_removeGroupExperimenterMap(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_removeGroupExperimenterMap<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Experimenter_removeGroupExperimenterMapPtr
newCallback_Experimenter_removeGroupExperimenterMap(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_removeGroupExperimenterMap<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Experimenter_removeGroupExperimenterMap : public Callback_Experimenter_removeGroupExperimenterMap_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Experimenter_removeGroupExperimenterMap(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_Experimenter_removeGroupExperimenterMapPtr
newCallback_Experimenter_removeGroupExperimenterMap(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_removeGroupExperimenterMap<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Experimenter_removeGroupExperimenterMapPtr
newCallback_Experimenter_removeGroupExperimenterMap(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_removeGroupExperimenterMap<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Experimenter_removeGroupExperimenterMapPtr
newCallback_Experimenter_removeGroupExperimenterMap(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_removeGroupExperimenterMap<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Experimenter_removeGroupExperimenterMapPtr
newCallback_Experimenter_removeGroupExperimenterMap(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_removeGroupExperimenterMap<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Experimenter_removeAllGroupExperimenterMapSet : public Callback_Experimenter_removeAllGroupExperimenterMapSet_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Experimenter_removeAllGroupExperimenterMapSet(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_Experimenter_removeAllGroupExperimenterMapSetPtr
newCallback_Experimenter_removeAllGroupExperimenterMapSet(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_removeAllGroupExperimenterMapSet<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Experimenter_removeAllGroupExperimenterMapSetPtr
newCallback_Experimenter_removeAllGroupExperimenterMapSet(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_removeAllGroupExperimenterMapSet<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Experimenter_removeAllGroupExperimenterMapSetPtr
newCallback_Experimenter_removeAllGroupExperimenterMapSet(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_removeAllGroupExperimenterMapSet<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Experimenter_removeAllGroupExperimenterMapSetPtr
newCallback_Experimenter_removeAllGroupExperimenterMapSet(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_removeAllGroupExperimenterMapSet<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Experimenter_removeAllGroupExperimenterMapSet : public Callback_Experimenter_removeAllGroupExperimenterMapSet_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Experimenter_removeAllGroupExperimenterMapSet(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_Experimenter_removeAllGroupExperimenterMapSetPtr
newCallback_Experimenter_removeAllGroupExperimenterMapSet(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_removeAllGroupExperimenterMapSet<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Experimenter_removeAllGroupExperimenterMapSetPtr
newCallback_Experimenter_removeAllGroupExperimenterMapSet(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_removeAllGroupExperimenterMapSet<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Experimenter_removeAllGroupExperimenterMapSetPtr
newCallback_Experimenter_removeAllGroupExperimenterMapSet(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_removeAllGroupExperimenterMapSet<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Experimenter_removeAllGroupExperimenterMapSetPtr
newCallback_Experimenter_removeAllGroupExperimenterMapSet(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_removeAllGroupExperimenterMapSet<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Experimenter_clearGroupExperimenterMap : public Callback_Experimenter_clearGroupExperimenterMap_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Experimenter_clearGroupExperimenterMap(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_Experimenter_clearGroupExperimenterMapPtr
newCallback_Experimenter_clearGroupExperimenterMap(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_clearGroupExperimenterMap<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Experimenter_clearGroupExperimenterMapPtr
newCallback_Experimenter_clearGroupExperimenterMap(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_clearGroupExperimenterMap<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Experimenter_clearGroupExperimenterMapPtr
newCallback_Experimenter_clearGroupExperimenterMap(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_clearGroupExperimenterMap<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Experimenter_clearGroupExperimenterMapPtr
newCallback_Experimenter_clearGroupExperimenterMap(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_clearGroupExperimenterMap<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Experimenter_clearGroupExperimenterMap : public Callback_Experimenter_clearGroupExperimenterMap_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Experimenter_clearGroupExperimenterMap(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_Experimenter_clearGroupExperimenterMapPtr
newCallback_Experimenter_clearGroupExperimenterMap(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_clearGroupExperimenterMap<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Experimenter_clearGroupExperimenterMapPtr
newCallback_Experimenter_clearGroupExperimenterMap(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_clearGroupExperimenterMap<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Experimenter_clearGroupExperimenterMapPtr
newCallback_Experimenter_clearGroupExperimenterMap(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_clearGroupExperimenterMap<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Experimenter_clearGroupExperimenterMapPtr
newCallback_Experimenter_clearGroupExperimenterMap(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_clearGroupExperimenterMap<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Experimenter_reloadGroupExperimenterMap : public Callback_Experimenter_reloadGroupExperimenterMap_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Experimenter_reloadGroupExperimenterMap(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_Experimenter_reloadGroupExperimenterMapPtr
newCallback_Experimenter_reloadGroupExperimenterMap(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_reloadGroupExperimenterMap<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Experimenter_reloadGroupExperimenterMapPtr
newCallback_Experimenter_reloadGroupExperimenterMap(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_reloadGroupExperimenterMap<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Experimenter_reloadGroupExperimenterMapPtr
newCallback_Experimenter_reloadGroupExperimenterMap(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_reloadGroupExperimenterMap<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Experimenter_reloadGroupExperimenterMapPtr
newCallback_Experimenter_reloadGroupExperimenterMap(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_reloadGroupExperimenterMap<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Experimenter_reloadGroupExperimenterMap : public Callback_Experimenter_reloadGroupExperimenterMap_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Experimenter_reloadGroupExperimenterMap(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_Experimenter_reloadGroupExperimenterMapPtr
newCallback_Experimenter_reloadGroupExperimenterMap(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_reloadGroupExperimenterMap<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Experimenter_reloadGroupExperimenterMapPtr
newCallback_Experimenter_reloadGroupExperimenterMap(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_reloadGroupExperimenterMap<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Experimenter_reloadGroupExperimenterMapPtr
newCallback_Experimenter_reloadGroupExperimenterMap(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_reloadGroupExperimenterMap<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Experimenter_reloadGroupExperimenterMapPtr
newCallback_Experimenter_reloadGroupExperimenterMap(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_reloadGroupExperimenterMap<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Experimenter_getGroupExperimenterMap : public Callback_Experimenter_getGroupExperimenterMap_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::model::GroupExperimenterMapPtr&);

    CallbackNC_Experimenter_getGroupExperimenterMap(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::ExperimenterPrx __proxy = ::omero::model::ExperimenterPrx::uncheckedCast(__result->getProxy());
        ::omero::model::GroupExperimenterMapPtr __ret;
        try
        {
            __ret = __proxy->end_getGroupExperimenterMap(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_Experimenter_getGroupExperimenterMapPtr
newCallback_Experimenter_getGroupExperimenterMap(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::GroupExperimenterMapPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_getGroupExperimenterMap<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Experimenter_getGroupExperimenterMapPtr
newCallback_Experimenter_getGroupExperimenterMap(T* instance, void (T::*cb)(const ::omero::model::GroupExperimenterMapPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_getGroupExperimenterMap<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Experimenter_getGroupExperimenterMap : public Callback_Experimenter_getGroupExperimenterMap_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::model::GroupExperimenterMapPtr&, const CT&);

    Callback_Experimenter_getGroupExperimenterMap(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::ExperimenterPrx __proxy = ::omero::model::ExperimenterPrx::uncheckedCast(__result->getProxy());
        ::omero::model::GroupExperimenterMapPtr __ret;
        try
        {
            __ret = __proxy->end_getGroupExperimenterMap(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Experimenter_getGroupExperimenterMapPtr
newCallback_Experimenter_getGroupExperimenterMap(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::GroupExperimenterMapPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_getGroupExperimenterMap<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Experimenter_getGroupExperimenterMapPtr
newCallback_Experimenter_getGroupExperimenterMap(T* instance, void (T::*cb)(const ::omero::model::GroupExperimenterMapPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_getGroupExperimenterMap<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Experimenter_setGroupExperimenterMap : public Callback_Experimenter_setGroupExperimenterMap_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::model::GroupExperimenterMapPtr&);

    CallbackNC_Experimenter_setGroupExperimenterMap(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::ExperimenterPrx __proxy = ::omero::model::ExperimenterPrx::uncheckedCast(__result->getProxy());
        ::omero::model::GroupExperimenterMapPtr __ret;
        try
        {
            __ret = __proxy->end_setGroupExperimenterMap(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_Experimenter_setGroupExperimenterMapPtr
newCallback_Experimenter_setGroupExperimenterMap(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::GroupExperimenterMapPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_setGroupExperimenterMap<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Experimenter_setGroupExperimenterMapPtr
newCallback_Experimenter_setGroupExperimenterMap(T* instance, void (T::*cb)(const ::omero::model::GroupExperimenterMapPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_setGroupExperimenterMap<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Experimenter_setGroupExperimenterMap : public Callback_Experimenter_setGroupExperimenterMap_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::model::GroupExperimenterMapPtr&, const CT&);

    Callback_Experimenter_setGroupExperimenterMap(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::ExperimenterPrx __proxy = ::omero::model::ExperimenterPrx::uncheckedCast(__result->getProxy());
        ::omero::model::GroupExperimenterMapPtr __ret;
        try
        {
            __ret = __proxy->end_setGroupExperimenterMap(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Experimenter_setGroupExperimenterMapPtr
newCallback_Experimenter_setGroupExperimenterMap(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::GroupExperimenterMapPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_setGroupExperimenterMap<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Experimenter_setGroupExperimenterMapPtr
newCallback_Experimenter_setGroupExperimenterMap(T* instance, void (T::*cb)(const ::omero::model::GroupExperimenterMapPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_setGroupExperimenterMap<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Experimenter_getPrimaryGroupExperimenterMap : public Callback_Experimenter_getPrimaryGroupExperimenterMap_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::model::GroupExperimenterMapPtr&);

    CallbackNC_Experimenter_getPrimaryGroupExperimenterMap(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::ExperimenterPrx __proxy = ::omero::model::ExperimenterPrx::uncheckedCast(__result->getProxy());
        ::omero::model::GroupExperimenterMapPtr __ret;
        try
        {
            __ret = __proxy->end_getPrimaryGroupExperimenterMap(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_Experimenter_getPrimaryGroupExperimenterMapPtr
newCallback_Experimenter_getPrimaryGroupExperimenterMap(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::GroupExperimenterMapPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_getPrimaryGroupExperimenterMap<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Experimenter_getPrimaryGroupExperimenterMapPtr
newCallback_Experimenter_getPrimaryGroupExperimenterMap(T* instance, void (T::*cb)(const ::omero::model::GroupExperimenterMapPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_getPrimaryGroupExperimenterMap<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Experimenter_getPrimaryGroupExperimenterMap : public Callback_Experimenter_getPrimaryGroupExperimenterMap_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::model::GroupExperimenterMapPtr&, const CT&);

    Callback_Experimenter_getPrimaryGroupExperimenterMap(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::ExperimenterPrx __proxy = ::omero::model::ExperimenterPrx::uncheckedCast(__result->getProxy());
        ::omero::model::GroupExperimenterMapPtr __ret;
        try
        {
            __ret = __proxy->end_getPrimaryGroupExperimenterMap(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Experimenter_getPrimaryGroupExperimenterMapPtr
newCallback_Experimenter_getPrimaryGroupExperimenterMap(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::GroupExperimenterMapPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_getPrimaryGroupExperimenterMap<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Experimenter_getPrimaryGroupExperimenterMapPtr
newCallback_Experimenter_getPrimaryGroupExperimenterMap(T* instance, void (T::*cb)(const ::omero::model::GroupExperimenterMapPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_getPrimaryGroupExperimenterMap<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Experimenter_setPrimaryGroupExperimenterMap : public Callback_Experimenter_setPrimaryGroupExperimenterMap_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::model::GroupExperimenterMapPtr&);

    CallbackNC_Experimenter_setPrimaryGroupExperimenterMap(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::ExperimenterPrx __proxy = ::omero::model::ExperimenterPrx::uncheckedCast(__result->getProxy());
        ::omero::model::GroupExperimenterMapPtr __ret;
        try
        {
            __ret = __proxy->end_setPrimaryGroupExperimenterMap(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_Experimenter_setPrimaryGroupExperimenterMapPtr
newCallback_Experimenter_setPrimaryGroupExperimenterMap(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::GroupExperimenterMapPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_setPrimaryGroupExperimenterMap<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Experimenter_setPrimaryGroupExperimenterMapPtr
newCallback_Experimenter_setPrimaryGroupExperimenterMap(T* instance, void (T::*cb)(const ::omero::model::GroupExperimenterMapPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_setPrimaryGroupExperimenterMap<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Experimenter_setPrimaryGroupExperimenterMap : public Callback_Experimenter_setPrimaryGroupExperimenterMap_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::model::GroupExperimenterMapPtr&, const CT&);

    Callback_Experimenter_setPrimaryGroupExperimenterMap(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::ExperimenterPrx __proxy = ::omero::model::ExperimenterPrx::uncheckedCast(__result->getProxy());
        ::omero::model::GroupExperimenterMapPtr __ret;
        try
        {
            __ret = __proxy->end_setPrimaryGroupExperimenterMap(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Experimenter_setPrimaryGroupExperimenterMapPtr
newCallback_Experimenter_setPrimaryGroupExperimenterMap(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::GroupExperimenterMapPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_setPrimaryGroupExperimenterMap<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Experimenter_setPrimaryGroupExperimenterMapPtr
newCallback_Experimenter_setPrimaryGroupExperimenterMap(T* instance, void (T::*cb)(const ::omero::model::GroupExperimenterMapPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_setPrimaryGroupExperimenterMap<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Experimenter_linkExperimenterGroup : public Callback_Experimenter_linkExperimenterGroup_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::model::GroupExperimenterMapPtr&);

    CallbackNC_Experimenter_linkExperimenterGroup(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::ExperimenterPrx __proxy = ::omero::model::ExperimenterPrx::uncheckedCast(__result->getProxy());
        ::omero::model::GroupExperimenterMapPtr __ret;
        try
        {
            __ret = __proxy->end_linkExperimenterGroup(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_Experimenter_linkExperimenterGroupPtr
newCallback_Experimenter_linkExperimenterGroup(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::GroupExperimenterMapPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_linkExperimenterGroup<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Experimenter_linkExperimenterGroupPtr
newCallback_Experimenter_linkExperimenterGroup(T* instance, void (T::*cb)(const ::omero::model::GroupExperimenterMapPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_linkExperimenterGroup<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Experimenter_linkExperimenterGroup : public Callback_Experimenter_linkExperimenterGroup_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::model::GroupExperimenterMapPtr&, const CT&);

    Callback_Experimenter_linkExperimenterGroup(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::ExperimenterPrx __proxy = ::omero::model::ExperimenterPrx::uncheckedCast(__result->getProxy());
        ::omero::model::GroupExperimenterMapPtr __ret;
        try
        {
            __ret = __proxy->end_linkExperimenterGroup(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Experimenter_linkExperimenterGroupPtr
newCallback_Experimenter_linkExperimenterGroup(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::GroupExperimenterMapPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_linkExperimenterGroup<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Experimenter_linkExperimenterGroupPtr
newCallback_Experimenter_linkExperimenterGroup(T* instance, void (T::*cb)(const ::omero::model::GroupExperimenterMapPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_linkExperimenterGroup<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Experimenter_addGroupExperimenterMapToBoth : public Callback_Experimenter_addGroupExperimenterMapToBoth_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Experimenter_addGroupExperimenterMapToBoth(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_Experimenter_addGroupExperimenterMapToBothPtr
newCallback_Experimenter_addGroupExperimenterMapToBoth(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_addGroupExperimenterMapToBoth<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Experimenter_addGroupExperimenterMapToBothPtr
newCallback_Experimenter_addGroupExperimenterMapToBoth(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_addGroupExperimenterMapToBoth<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Experimenter_addGroupExperimenterMapToBothPtr
newCallback_Experimenter_addGroupExperimenterMapToBoth(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_addGroupExperimenterMapToBoth<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Experimenter_addGroupExperimenterMapToBothPtr
newCallback_Experimenter_addGroupExperimenterMapToBoth(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_addGroupExperimenterMapToBoth<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Experimenter_addGroupExperimenterMapToBoth : public Callback_Experimenter_addGroupExperimenterMapToBoth_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Experimenter_addGroupExperimenterMapToBoth(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_Experimenter_addGroupExperimenterMapToBothPtr
newCallback_Experimenter_addGroupExperimenterMapToBoth(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_addGroupExperimenterMapToBoth<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Experimenter_addGroupExperimenterMapToBothPtr
newCallback_Experimenter_addGroupExperimenterMapToBoth(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_addGroupExperimenterMapToBoth<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Experimenter_addGroupExperimenterMapToBothPtr
newCallback_Experimenter_addGroupExperimenterMapToBoth(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_addGroupExperimenterMapToBoth<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Experimenter_addGroupExperimenterMapToBothPtr
newCallback_Experimenter_addGroupExperimenterMapToBoth(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_addGroupExperimenterMapToBoth<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Experimenter_findGroupExperimenterMap : public Callback_Experimenter_findGroupExperimenterMap_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::model::ExperimenterGroupExperimenterMapSeq&);

    CallbackNC_Experimenter_findGroupExperimenterMap(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::ExperimenterPrx __proxy = ::omero::model::ExperimenterPrx::uncheckedCast(__result->getProxy());
        ::omero::model::ExperimenterGroupExperimenterMapSeq __ret;
        try
        {
            __ret = __proxy->end_findGroupExperimenterMap(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_Experimenter_findGroupExperimenterMapPtr
newCallback_Experimenter_findGroupExperimenterMap(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::ExperimenterGroupExperimenterMapSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_findGroupExperimenterMap<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Experimenter_findGroupExperimenterMapPtr
newCallback_Experimenter_findGroupExperimenterMap(T* instance, void (T::*cb)(const ::omero::model::ExperimenterGroupExperimenterMapSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_findGroupExperimenterMap<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Experimenter_findGroupExperimenterMap : public Callback_Experimenter_findGroupExperimenterMap_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::model::ExperimenterGroupExperimenterMapSeq&, const CT&);

    Callback_Experimenter_findGroupExperimenterMap(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::ExperimenterPrx __proxy = ::omero::model::ExperimenterPrx::uncheckedCast(__result->getProxy());
        ::omero::model::ExperimenterGroupExperimenterMapSeq __ret;
        try
        {
            __ret = __proxy->end_findGroupExperimenterMap(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Experimenter_findGroupExperimenterMapPtr
newCallback_Experimenter_findGroupExperimenterMap(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::ExperimenterGroupExperimenterMapSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_findGroupExperimenterMap<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Experimenter_findGroupExperimenterMapPtr
newCallback_Experimenter_findGroupExperimenterMap(T* instance, void (T::*cb)(const ::omero::model::ExperimenterGroupExperimenterMapSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_findGroupExperimenterMap<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Experimenter_unlinkExperimenterGroup : public Callback_Experimenter_unlinkExperimenterGroup_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Experimenter_unlinkExperimenterGroup(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_Experimenter_unlinkExperimenterGroupPtr
newCallback_Experimenter_unlinkExperimenterGroup(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_unlinkExperimenterGroup<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Experimenter_unlinkExperimenterGroupPtr
newCallback_Experimenter_unlinkExperimenterGroup(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_unlinkExperimenterGroup<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Experimenter_unlinkExperimenterGroupPtr
newCallback_Experimenter_unlinkExperimenterGroup(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_unlinkExperimenterGroup<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Experimenter_unlinkExperimenterGroupPtr
newCallback_Experimenter_unlinkExperimenterGroup(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_unlinkExperimenterGroup<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Experimenter_unlinkExperimenterGroup : public Callback_Experimenter_unlinkExperimenterGroup_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Experimenter_unlinkExperimenterGroup(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_Experimenter_unlinkExperimenterGroupPtr
newCallback_Experimenter_unlinkExperimenterGroup(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_unlinkExperimenterGroup<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Experimenter_unlinkExperimenterGroupPtr
newCallback_Experimenter_unlinkExperimenterGroup(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_unlinkExperimenterGroup<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Experimenter_unlinkExperimenterGroupPtr
newCallback_Experimenter_unlinkExperimenterGroup(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_unlinkExperimenterGroup<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Experimenter_unlinkExperimenterGroupPtr
newCallback_Experimenter_unlinkExperimenterGroup(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_unlinkExperimenterGroup<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Experimenter_removeGroupExperimenterMapFromBoth : public Callback_Experimenter_removeGroupExperimenterMapFromBoth_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Experimenter_removeGroupExperimenterMapFromBoth(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_Experimenter_removeGroupExperimenterMapFromBothPtr
newCallback_Experimenter_removeGroupExperimenterMapFromBoth(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_removeGroupExperimenterMapFromBoth<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Experimenter_removeGroupExperimenterMapFromBothPtr
newCallback_Experimenter_removeGroupExperimenterMapFromBoth(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_removeGroupExperimenterMapFromBoth<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Experimenter_removeGroupExperimenterMapFromBothPtr
newCallback_Experimenter_removeGroupExperimenterMapFromBoth(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_removeGroupExperimenterMapFromBoth<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Experimenter_removeGroupExperimenterMapFromBothPtr
newCallback_Experimenter_removeGroupExperimenterMapFromBoth(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_removeGroupExperimenterMapFromBoth<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Experimenter_removeGroupExperimenterMapFromBoth : public Callback_Experimenter_removeGroupExperimenterMapFromBoth_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Experimenter_removeGroupExperimenterMapFromBoth(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_Experimenter_removeGroupExperimenterMapFromBothPtr
newCallback_Experimenter_removeGroupExperimenterMapFromBoth(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_removeGroupExperimenterMapFromBoth<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Experimenter_removeGroupExperimenterMapFromBothPtr
newCallback_Experimenter_removeGroupExperimenterMapFromBoth(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_removeGroupExperimenterMapFromBoth<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Experimenter_removeGroupExperimenterMapFromBothPtr
newCallback_Experimenter_removeGroupExperimenterMapFromBoth(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_removeGroupExperimenterMapFromBoth<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Experimenter_removeGroupExperimenterMapFromBothPtr
newCallback_Experimenter_removeGroupExperimenterMapFromBoth(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_removeGroupExperimenterMapFromBoth<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Experimenter_linkedExperimenterGroupList : public Callback_Experimenter_linkedExperimenterGroupList_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::model::ExperimenterLinkedExperimenterGroupSeq&);

    CallbackNC_Experimenter_linkedExperimenterGroupList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::ExperimenterPrx __proxy = ::omero::model::ExperimenterPrx::uncheckedCast(__result->getProxy());
        ::omero::model::ExperimenterLinkedExperimenterGroupSeq __ret;
        try
        {
            __ret = __proxy->end_linkedExperimenterGroupList(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_Experimenter_linkedExperimenterGroupListPtr
newCallback_Experimenter_linkedExperimenterGroupList(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::ExperimenterLinkedExperimenterGroupSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_linkedExperimenterGroupList<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Experimenter_linkedExperimenterGroupListPtr
newCallback_Experimenter_linkedExperimenterGroupList(T* instance, void (T::*cb)(const ::omero::model::ExperimenterLinkedExperimenterGroupSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_linkedExperimenterGroupList<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Experimenter_linkedExperimenterGroupList : public Callback_Experimenter_linkedExperimenterGroupList_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::model::ExperimenterLinkedExperimenterGroupSeq&, const CT&);

    Callback_Experimenter_linkedExperimenterGroupList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::ExperimenterPrx __proxy = ::omero::model::ExperimenterPrx::uncheckedCast(__result->getProxy());
        ::omero::model::ExperimenterLinkedExperimenterGroupSeq __ret;
        try
        {
            __ret = __proxy->end_linkedExperimenterGroupList(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Experimenter_linkedExperimenterGroupListPtr
newCallback_Experimenter_linkedExperimenterGroupList(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::ExperimenterLinkedExperimenterGroupSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_linkedExperimenterGroupList<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Experimenter_linkedExperimenterGroupListPtr
newCallback_Experimenter_linkedExperimenterGroupList(T* instance, void (T::*cb)(const ::omero::model::ExperimenterLinkedExperimenterGroupSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_linkedExperimenterGroupList<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Experimenter_getOmeName : public Callback_Experimenter_getOmeName_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::RStringPtr&);

    CallbackNC_Experimenter_getOmeName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::ExperimenterPrx __proxy = ::omero::model::ExperimenterPrx::uncheckedCast(__result->getProxy());
        ::omero::RStringPtr __ret;
        try
        {
            __ret = __proxy->end_getOmeName(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_Experimenter_getOmeNamePtr
newCallback_Experimenter_getOmeName(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RStringPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_getOmeName<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Experimenter_getOmeNamePtr
newCallback_Experimenter_getOmeName(T* instance, void (T::*cb)(const ::omero::RStringPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_getOmeName<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Experimenter_getOmeName : public Callback_Experimenter_getOmeName_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::RStringPtr&, const CT&);

    Callback_Experimenter_getOmeName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::ExperimenterPrx __proxy = ::omero::model::ExperimenterPrx::uncheckedCast(__result->getProxy());
        ::omero::RStringPtr __ret;
        try
        {
            __ret = __proxy->end_getOmeName(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Experimenter_getOmeNamePtr
newCallback_Experimenter_getOmeName(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RStringPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_getOmeName<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Experimenter_getOmeNamePtr
newCallback_Experimenter_getOmeName(T* instance, void (T::*cb)(const ::omero::RStringPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_getOmeName<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Experimenter_setOmeName : public Callback_Experimenter_setOmeName_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Experimenter_setOmeName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_Experimenter_setOmeNamePtr
newCallback_Experimenter_setOmeName(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_setOmeName<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Experimenter_setOmeNamePtr
newCallback_Experimenter_setOmeName(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_setOmeName<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Experimenter_setOmeNamePtr
newCallback_Experimenter_setOmeName(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_setOmeName<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Experimenter_setOmeNamePtr
newCallback_Experimenter_setOmeName(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_setOmeName<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Experimenter_setOmeName : public Callback_Experimenter_setOmeName_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Experimenter_setOmeName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_Experimenter_setOmeNamePtr
newCallback_Experimenter_setOmeName(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_setOmeName<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Experimenter_setOmeNamePtr
newCallback_Experimenter_setOmeName(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_setOmeName<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Experimenter_setOmeNamePtr
newCallback_Experimenter_setOmeName(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_setOmeName<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Experimenter_setOmeNamePtr
newCallback_Experimenter_setOmeName(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_setOmeName<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Experimenter_getFirstName : public Callback_Experimenter_getFirstName_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::RStringPtr&);

    CallbackNC_Experimenter_getFirstName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::ExperimenterPrx __proxy = ::omero::model::ExperimenterPrx::uncheckedCast(__result->getProxy());
        ::omero::RStringPtr __ret;
        try
        {
            __ret = __proxy->end_getFirstName(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_Experimenter_getFirstNamePtr
newCallback_Experimenter_getFirstName(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RStringPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_getFirstName<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Experimenter_getFirstNamePtr
newCallback_Experimenter_getFirstName(T* instance, void (T::*cb)(const ::omero::RStringPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_getFirstName<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Experimenter_getFirstName : public Callback_Experimenter_getFirstName_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::RStringPtr&, const CT&);

    Callback_Experimenter_getFirstName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::ExperimenterPrx __proxy = ::omero::model::ExperimenterPrx::uncheckedCast(__result->getProxy());
        ::omero::RStringPtr __ret;
        try
        {
            __ret = __proxy->end_getFirstName(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Experimenter_getFirstNamePtr
newCallback_Experimenter_getFirstName(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RStringPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_getFirstName<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Experimenter_getFirstNamePtr
newCallback_Experimenter_getFirstName(T* instance, void (T::*cb)(const ::omero::RStringPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_getFirstName<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Experimenter_setFirstName : public Callback_Experimenter_setFirstName_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Experimenter_setFirstName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_Experimenter_setFirstNamePtr
newCallback_Experimenter_setFirstName(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_setFirstName<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Experimenter_setFirstNamePtr
newCallback_Experimenter_setFirstName(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_setFirstName<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Experimenter_setFirstNamePtr
newCallback_Experimenter_setFirstName(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_setFirstName<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Experimenter_setFirstNamePtr
newCallback_Experimenter_setFirstName(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_setFirstName<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Experimenter_setFirstName : public Callback_Experimenter_setFirstName_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Experimenter_setFirstName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_Experimenter_setFirstNamePtr
newCallback_Experimenter_setFirstName(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_setFirstName<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Experimenter_setFirstNamePtr
newCallback_Experimenter_setFirstName(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_setFirstName<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Experimenter_setFirstNamePtr
newCallback_Experimenter_setFirstName(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_setFirstName<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Experimenter_setFirstNamePtr
newCallback_Experimenter_setFirstName(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_setFirstName<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Experimenter_getMiddleName : public Callback_Experimenter_getMiddleName_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::RStringPtr&);

    CallbackNC_Experimenter_getMiddleName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::ExperimenterPrx __proxy = ::omero::model::ExperimenterPrx::uncheckedCast(__result->getProxy());
        ::omero::RStringPtr __ret;
        try
        {
            __ret = __proxy->end_getMiddleName(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_Experimenter_getMiddleNamePtr
newCallback_Experimenter_getMiddleName(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RStringPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_getMiddleName<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Experimenter_getMiddleNamePtr
newCallback_Experimenter_getMiddleName(T* instance, void (T::*cb)(const ::omero::RStringPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_getMiddleName<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Experimenter_getMiddleName : public Callback_Experimenter_getMiddleName_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::RStringPtr&, const CT&);

    Callback_Experimenter_getMiddleName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::ExperimenterPrx __proxy = ::omero::model::ExperimenterPrx::uncheckedCast(__result->getProxy());
        ::omero::RStringPtr __ret;
        try
        {
            __ret = __proxy->end_getMiddleName(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Experimenter_getMiddleNamePtr
newCallback_Experimenter_getMiddleName(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RStringPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_getMiddleName<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Experimenter_getMiddleNamePtr
newCallback_Experimenter_getMiddleName(T* instance, void (T::*cb)(const ::omero::RStringPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_getMiddleName<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Experimenter_setMiddleName : public Callback_Experimenter_setMiddleName_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Experimenter_setMiddleName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_Experimenter_setMiddleNamePtr
newCallback_Experimenter_setMiddleName(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_setMiddleName<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Experimenter_setMiddleNamePtr
newCallback_Experimenter_setMiddleName(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_setMiddleName<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Experimenter_setMiddleNamePtr
newCallback_Experimenter_setMiddleName(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_setMiddleName<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Experimenter_setMiddleNamePtr
newCallback_Experimenter_setMiddleName(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_setMiddleName<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Experimenter_setMiddleName : public Callback_Experimenter_setMiddleName_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Experimenter_setMiddleName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_Experimenter_setMiddleNamePtr
newCallback_Experimenter_setMiddleName(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_setMiddleName<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Experimenter_setMiddleNamePtr
newCallback_Experimenter_setMiddleName(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_setMiddleName<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Experimenter_setMiddleNamePtr
newCallback_Experimenter_setMiddleName(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_setMiddleName<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Experimenter_setMiddleNamePtr
newCallback_Experimenter_setMiddleName(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_setMiddleName<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Experimenter_getLastName : public Callback_Experimenter_getLastName_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::RStringPtr&);

    CallbackNC_Experimenter_getLastName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::ExperimenterPrx __proxy = ::omero::model::ExperimenterPrx::uncheckedCast(__result->getProxy());
        ::omero::RStringPtr __ret;
        try
        {
            __ret = __proxy->end_getLastName(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_Experimenter_getLastNamePtr
newCallback_Experimenter_getLastName(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RStringPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_getLastName<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Experimenter_getLastNamePtr
newCallback_Experimenter_getLastName(T* instance, void (T::*cb)(const ::omero::RStringPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_getLastName<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Experimenter_getLastName : public Callback_Experimenter_getLastName_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::RStringPtr&, const CT&);

    Callback_Experimenter_getLastName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::ExperimenterPrx __proxy = ::omero::model::ExperimenterPrx::uncheckedCast(__result->getProxy());
        ::omero::RStringPtr __ret;
        try
        {
            __ret = __proxy->end_getLastName(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Experimenter_getLastNamePtr
newCallback_Experimenter_getLastName(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RStringPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_getLastName<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Experimenter_getLastNamePtr
newCallback_Experimenter_getLastName(T* instance, void (T::*cb)(const ::omero::RStringPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_getLastName<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Experimenter_setLastName : public Callback_Experimenter_setLastName_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Experimenter_setLastName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_Experimenter_setLastNamePtr
newCallback_Experimenter_setLastName(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_setLastName<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Experimenter_setLastNamePtr
newCallback_Experimenter_setLastName(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_setLastName<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Experimenter_setLastNamePtr
newCallback_Experimenter_setLastName(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_setLastName<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Experimenter_setLastNamePtr
newCallback_Experimenter_setLastName(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_setLastName<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Experimenter_setLastName : public Callback_Experimenter_setLastName_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Experimenter_setLastName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_Experimenter_setLastNamePtr
newCallback_Experimenter_setLastName(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_setLastName<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Experimenter_setLastNamePtr
newCallback_Experimenter_setLastName(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_setLastName<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Experimenter_setLastNamePtr
newCallback_Experimenter_setLastName(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_setLastName<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Experimenter_setLastNamePtr
newCallback_Experimenter_setLastName(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_setLastName<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Experimenter_getInstitution : public Callback_Experimenter_getInstitution_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::RStringPtr&);

    CallbackNC_Experimenter_getInstitution(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::ExperimenterPrx __proxy = ::omero::model::ExperimenterPrx::uncheckedCast(__result->getProxy());
        ::omero::RStringPtr __ret;
        try
        {
            __ret = __proxy->end_getInstitution(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_Experimenter_getInstitutionPtr
newCallback_Experimenter_getInstitution(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RStringPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_getInstitution<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Experimenter_getInstitutionPtr
newCallback_Experimenter_getInstitution(T* instance, void (T::*cb)(const ::omero::RStringPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_getInstitution<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Experimenter_getInstitution : public Callback_Experimenter_getInstitution_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::RStringPtr&, const CT&);

    Callback_Experimenter_getInstitution(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::ExperimenterPrx __proxy = ::omero::model::ExperimenterPrx::uncheckedCast(__result->getProxy());
        ::omero::RStringPtr __ret;
        try
        {
            __ret = __proxy->end_getInstitution(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Experimenter_getInstitutionPtr
newCallback_Experimenter_getInstitution(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RStringPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_getInstitution<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Experimenter_getInstitutionPtr
newCallback_Experimenter_getInstitution(T* instance, void (T::*cb)(const ::omero::RStringPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_getInstitution<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Experimenter_setInstitution : public Callback_Experimenter_setInstitution_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Experimenter_setInstitution(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_Experimenter_setInstitutionPtr
newCallback_Experimenter_setInstitution(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_setInstitution<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Experimenter_setInstitutionPtr
newCallback_Experimenter_setInstitution(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_setInstitution<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Experimenter_setInstitutionPtr
newCallback_Experimenter_setInstitution(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_setInstitution<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Experimenter_setInstitutionPtr
newCallback_Experimenter_setInstitution(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_setInstitution<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Experimenter_setInstitution : public Callback_Experimenter_setInstitution_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Experimenter_setInstitution(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_Experimenter_setInstitutionPtr
newCallback_Experimenter_setInstitution(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_setInstitution<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Experimenter_setInstitutionPtr
newCallback_Experimenter_setInstitution(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_setInstitution<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Experimenter_setInstitutionPtr
newCallback_Experimenter_setInstitution(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_setInstitution<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Experimenter_setInstitutionPtr
newCallback_Experimenter_setInstitution(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_setInstitution<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Experimenter_getEmail : public Callback_Experimenter_getEmail_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::RStringPtr&);

    CallbackNC_Experimenter_getEmail(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::ExperimenterPrx __proxy = ::omero::model::ExperimenterPrx::uncheckedCast(__result->getProxy());
        ::omero::RStringPtr __ret;
        try
        {
            __ret = __proxy->end_getEmail(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_Experimenter_getEmailPtr
newCallback_Experimenter_getEmail(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RStringPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_getEmail<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Experimenter_getEmailPtr
newCallback_Experimenter_getEmail(T* instance, void (T::*cb)(const ::omero::RStringPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_getEmail<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Experimenter_getEmail : public Callback_Experimenter_getEmail_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::RStringPtr&, const CT&);

    Callback_Experimenter_getEmail(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::ExperimenterPrx __proxy = ::omero::model::ExperimenterPrx::uncheckedCast(__result->getProxy());
        ::omero::RStringPtr __ret;
        try
        {
            __ret = __proxy->end_getEmail(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Experimenter_getEmailPtr
newCallback_Experimenter_getEmail(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RStringPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_getEmail<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Experimenter_getEmailPtr
newCallback_Experimenter_getEmail(T* instance, void (T::*cb)(const ::omero::RStringPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_getEmail<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Experimenter_setEmail : public Callback_Experimenter_setEmail_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Experimenter_setEmail(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_Experimenter_setEmailPtr
newCallback_Experimenter_setEmail(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_setEmail<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Experimenter_setEmailPtr
newCallback_Experimenter_setEmail(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_setEmail<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Experimenter_setEmailPtr
newCallback_Experimenter_setEmail(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_setEmail<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Experimenter_setEmailPtr
newCallback_Experimenter_setEmail(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_setEmail<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Experimenter_setEmail : public Callback_Experimenter_setEmail_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Experimenter_setEmail(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_Experimenter_setEmailPtr
newCallback_Experimenter_setEmail(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_setEmail<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Experimenter_setEmailPtr
newCallback_Experimenter_setEmail(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_setEmail<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Experimenter_setEmailPtr
newCallback_Experimenter_setEmail(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_setEmail<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Experimenter_setEmailPtr
newCallback_Experimenter_setEmail(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_setEmail<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Experimenter_unloadAnnotationLinks : public Callback_Experimenter_unloadAnnotationLinks_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Experimenter_unloadAnnotationLinks(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_Experimenter_unloadAnnotationLinksPtr
newCallback_Experimenter_unloadAnnotationLinks(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_unloadAnnotationLinks<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Experimenter_unloadAnnotationLinksPtr
newCallback_Experimenter_unloadAnnotationLinks(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_unloadAnnotationLinks<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Experimenter_unloadAnnotationLinksPtr
newCallback_Experimenter_unloadAnnotationLinks(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_unloadAnnotationLinks<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Experimenter_unloadAnnotationLinksPtr
newCallback_Experimenter_unloadAnnotationLinks(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_unloadAnnotationLinks<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Experimenter_unloadAnnotationLinks : public Callback_Experimenter_unloadAnnotationLinks_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Experimenter_unloadAnnotationLinks(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_Experimenter_unloadAnnotationLinksPtr
newCallback_Experimenter_unloadAnnotationLinks(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_unloadAnnotationLinks<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Experimenter_unloadAnnotationLinksPtr
newCallback_Experimenter_unloadAnnotationLinks(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_unloadAnnotationLinks<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Experimenter_unloadAnnotationLinksPtr
newCallback_Experimenter_unloadAnnotationLinks(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_unloadAnnotationLinks<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Experimenter_unloadAnnotationLinksPtr
newCallback_Experimenter_unloadAnnotationLinks(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_unloadAnnotationLinks<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Experimenter_sizeOfAnnotationLinks : public Callback_Experimenter_sizeOfAnnotationLinks_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int);

    CallbackNC_Experimenter_sizeOfAnnotationLinks(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::ExperimenterPrx __proxy = ::omero::model::ExperimenterPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_sizeOfAnnotationLinks(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_Experimenter_sizeOfAnnotationLinksPtr
newCallback_Experimenter_sizeOfAnnotationLinks(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_sizeOfAnnotationLinks<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Experimenter_sizeOfAnnotationLinksPtr
newCallback_Experimenter_sizeOfAnnotationLinks(T* instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_sizeOfAnnotationLinks<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Experimenter_sizeOfAnnotationLinks : public Callback_Experimenter_sizeOfAnnotationLinks_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const CT&);

    Callback_Experimenter_sizeOfAnnotationLinks(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::ExperimenterPrx __proxy = ::omero::model::ExperimenterPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_sizeOfAnnotationLinks(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Experimenter_sizeOfAnnotationLinksPtr
newCallback_Experimenter_sizeOfAnnotationLinks(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_sizeOfAnnotationLinks<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Experimenter_sizeOfAnnotationLinksPtr
newCallback_Experimenter_sizeOfAnnotationLinks(T* instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_sizeOfAnnotationLinks<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Experimenter_copyAnnotationLinks : public Callback_Experimenter_copyAnnotationLinks_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::model::ExperimenterAnnotationLinksSeq&);

    CallbackNC_Experimenter_copyAnnotationLinks(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::ExperimenterPrx __proxy = ::omero::model::ExperimenterPrx::uncheckedCast(__result->getProxy());
        ::omero::model::ExperimenterAnnotationLinksSeq __ret;
        try
        {
            __ret = __proxy->end_copyAnnotationLinks(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_Experimenter_copyAnnotationLinksPtr
newCallback_Experimenter_copyAnnotationLinks(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::ExperimenterAnnotationLinksSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_copyAnnotationLinks<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Experimenter_copyAnnotationLinksPtr
newCallback_Experimenter_copyAnnotationLinks(T* instance, void (T::*cb)(const ::omero::model::ExperimenterAnnotationLinksSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_copyAnnotationLinks<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Experimenter_copyAnnotationLinks : public Callback_Experimenter_copyAnnotationLinks_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::model::ExperimenterAnnotationLinksSeq&, const CT&);

    Callback_Experimenter_copyAnnotationLinks(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::ExperimenterPrx __proxy = ::omero::model::ExperimenterPrx::uncheckedCast(__result->getProxy());
        ::omero::model::ExperimenterAnnotationLinksSeq __ret;
        try
        {
            __ret = __proxy->end_copyAnnotationLinks(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Experimenter_copyAnnotationLinksPtr
newCallback_Experimenter_copyAnnotationLinks(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::ExperimenterAnnotationLinksSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_copyAnnotationLinks<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Experimenter_copyAnnotationLinksPtr
newCallback_Experimenter_copyAnnotationLinks(T* instance, void (T::*cb)(const ::omero::model::ExperimenterAnnotationLinksSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_copyAnnotationLinks<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Experimenter_addExperimenterAnnotationLink : public Callback_Experimenter_addExperimenterAnnotationLink_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Experimenter_addExperimenterAnnotationLink(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_Experimenter_addExperimenterAnnotationLinkPtr
newCallback_Experimenter_addExperimenterAnnotationLink(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_addExperimenterAnnotationLink<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Experimenter_addExperimenterAnnotationLinkPtr
newCallback_Experimenter_addExperimenterAnnotationLink(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_addExperimenterAnnotationLink<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Experimenter_addExperimenterAnnotationLinkPtr
newCallback_Experimenter_addExperimenterAnnotationLink(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_addExperimenterAnnotationLink<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Experimenter_addExperimenterAnnotationLinkPtr
newCallback_Experimenter_addExperimenterAnnotationLink(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_addExperimenterAnnotationLink<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Experimenter_addExperimenterAnnotationLink : public Callback_Experimenter_addExperimenterAnnotationLink_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Experimenter_addExperimenterAnnotationLink(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_Experimenter_addExperimenterAnnotationLinkPtr
newCallback_Experimenter_addExperimenterAnnotationLink(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_addExperimenterAnnotationLink<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Experimenter_addExperimenterAnnotationLinkPtr
newCallback_Experimenter_addExperimenterAnnotationLink(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_addExperimenterAnnotationLink<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Experimenter_addExperimenterAnnotationLinkPtr
newCallback_Experimenter_addExperimenterAnnotationLink(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_addExperimenterAnnotationLink<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Experimenter_addExperimenterAnnotationLinkPtr
newCallback_Experimenter_addExperimenterAnnotationLink(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_addExperimenterAnnotationLink<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Experimenter_addAllExperimenterAnnotationLinkSet : public Callback_Experimenter_addAllExperimenterAnnotationLinkSet_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Experimenter_addAllExperimenterAnnotationLinkSet(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_Experimenter_addAllExperimenterAnnotationLinkSetPtr
newCallback_Experimenter_addAllExperimenterAnnotationLinkSet(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_addAllExperimenterAnnotationLinkSet<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Experimenter_addAllExperimenterAnnotationLinkSetPtr
newCallback_Experimenter_addAllExperimenterAnnotationLinkSet(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_addAllExperimenterAnnotationLinkSet<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Experimenter_addAllExperimenterAnnotationLinkSetPtr
newCallback_Experimenter_addAllExperimenterAnnotationLinkSet(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_addAllExperimenterAnnotationLinkSet<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Experimenter_addAllExperimenterAnnotationLinkSetPtr
newCallback_Experimenter_addAllExperimenterAnnotationLinkSet(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_addAllExperimenterAnnotationLinkSet<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Experimenter_addAllExperimenterAnnotationLinkSet : public Callback_Experimenter_addAllExperimenterAnnotationLinkSet_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Experimenter_addAllExperimenterAnnotationLinkSet(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_Experimenter_addAllExperimenterAnnotationLinkSetPtr
newCallback_Experimenter_addAllExperimenterAnnotationLinkSet(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_addAllExperimenterAnnotationLinkSet<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Experimenter_addAllExperimenterAnnotationLinkSetPtr
newCallback_Experimenter_addAllExperimenterAnnotationLinkSet(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_addAllExperimenterAnnotationLinkSet<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Experimenter_addAllExperimenterAnnotationLinkSetPtr
newCallback_Experimenter_addAllExperimenterAnnotationLinkSet(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_addAllExperimenterAnnotationLinkSet<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Experimenter_addAllExperimenterAnnotationLinkSetPtr
newCallback_Experimenter_addAllExperimenterAnnotationLinkSet(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_addAllExperimenterAnnotationLinkSet<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Experimenter_removeExperimenterAnnotationLink : public Callback_Experimenter_removeExperimenterAnnotationLink_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Experimenter_removeExperimenterAnnotationLink(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_Experimenter_removeExperimenterAnnotationLinkPtr
newCallback_Experimenter_removeExperimenterAnnotationLink(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_removeExperimenterAnnotationLink<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Experimenter_removeExperimenterAnnotationLinkPtr
newCallback_Experimenter_removeExperimenterAnnotationLink(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_removeExperimenterAnnotationLink<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Experimenter_removeExperimenterAnnotationLinkPtr
newCallback_Experimenter_removeExperimenterAnnotationLink(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_removeExperimenterAnnotationLink<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Experimenter_removeExperimenterAnnotationLinkPtr
newCallback_Experimenter_removeExperimenterAnnotationLink(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_removeExperimenterAnnotationLink<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Experimenter_removeExperimenterAnnotationLink : public Callback_Experimenter_removeExperimenterAnnotationLink_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Experimenter_removeExperimenterAnnotationLink(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_Experimenter_removeExperimenterAnnotationLinkPtr
newCallback_Experimenter_removeExperimenterAnnotationLink(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_removeExperimenterAnnotationLink<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Experimenter_removeExperimenterAnnotationLinkPtr
newCallback_Experimenter_removeExperimenterAnnotationLink(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_removeExperimenterAnnotationLink<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Experimenter_removeExperimenterAnnotationLinkPtr
newCallback_Experimenter_removeExperimenterAnnotationLink(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_removeExperimenterAnnotationLink<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Experimenter_removeExperimenterAnnotationLinkPtr
newCallback_Experimenter_removeExperimenterAnnotationLink(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_removeExperimenterAnnotationLink<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Experimenter_removeAllExperimenterAnnotationLinkSet : public Callback_Experimenter_removeAllExperimenterAnnotationLinkSet_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Experimenter_removeAllExperimenterAnnotationLinkSet(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_Experimenter_removeAllExperimenterAnnotationLinkSetPtr
newCallback_Experimenter_removeAllExperimenterAnnotationLinkSet(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_removeAllExperimenterAnnotationLinkSet<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Experimenter_removeAllExperimenterAnnotationLinkSetPtr
newCallback_Experimenter_removeAllExperimenterAnnotationLinkSet(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_removeAllExperimenterAnnotationLinkSet<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Experimenter_removeAllExperimenterAnnotationLinkSetPtr
newCallback_Experimenter_removeAllExperimenterAnnotationLinkSet(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_removeAllExperimenterAnnotationLinkSet<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Experimenter_removeAllExperimenterAnnotationLinkSetPtr
newCallback_Experimenter_removeAllExperimenterAnnotationLinkSet(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_removeAllExperimenterAnnotationLinkSet<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Experimenter_removeAllExperimenterAnnotationLinkSet : public Callback_Experimenter_removeAllExperimenterAnnotationLinkSet_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Experimenter_removeAllExperimenterAnnotationLinkSet(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_Experimenter_removeAllExperimenterAnnotationLinkSetPtr
newCallback_Experimenter_removeAllExperimenterAnnotationLinkSet(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_removeAllExperimenterAnnotationLinkSet<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Experimenter_removeAllExperimenterAnnotationLinkSetPtr
newCallback_Experimenter_removeAllExperimenterAnnotationLinkSet(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_removeAllExperimenterAnnotationLinkSet<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Experimenter_removeAllExperimenterAnnotationLinkSetPtr
newCallback_Experimenter_removeAllExperimenterAnnotationLinkSet(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_removeAllExperimenterAnnotationLinkSet<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Experimenter_removeAllExperimenterAnnotationLinkSetPtr
newCallback_Experimenter_removeAllExperimenterAnnotationLinkSet(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_removeAllExperimenterAnnotationLinkSet<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Experimenter_clearAnnotationLinks : public Callback_Experimenter_clearAnnotationLinks_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Experimenter_clearAnnotationLinks(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_Experimenter_clearAnnotationLinksPtr
newCallback_Experimenter_clearAnnotationLinks(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_clearAnnotationLinks<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Experimenter_clearAnnotationLinksPtr
newCallback_Experimenter_clearAnnotationLinks(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_clearAnnotationLinks<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Experimenter_clearAnnotationLinksPtr
newCallback_Experimenter_clearAnnotationLinks(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_clearAnnotationLinks<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Experimenter_clearAnnotationLinksPtr
newCallback_Experimenter_clearAnnotationLinks(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_clearAnnotationLinks<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Experimenter_clearAnnotationLinks : public Callback_Experimenter_clearAnnotationLinks_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Experimenter_clearAnnotationLinks(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_Experimenter_clearAnnotationLinksPtr
newCallback_Experimenter_clearAnnotationLinks(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_clearAnnotationLinks<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Experimenter_clearAnnotationLinksPtr
newCallback_Experimenter_clearAnnotationLinks(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_clearAnnotationLinks<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Experimenter_clearAnnotationLinksPtr
newCallback_Experimenter_clearAnnotationLinks(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_clearAnnotationLinks<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Experimenter_clearAnnotationLinksPtr
newCallback_Experimenter_clearAnnotationLinks(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_clearAnnotationLinks<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Experimenter_reloadAnnotationLinks : public Callback_Experimenter_reloadAnnotationLinks_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Experimenter_reloadAnnotationLinks(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_Experimenter_reloadAnnotationLinksPtr
newCallback_Experimenter_reloadAnnotationLinks(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_reloadAnnotationLinks<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Experimenter_reloadAnnotationLinksPtr
newCallback_Experimenter_reloadAnnotationLinks(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_reloadAnnotationLinks<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Experimenter_reloadAnnotationLinksPtr
newCallback_Experimenter_reloadAnnotationLinks(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_reloadAnnotationLinks<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Experimenter_reloadAnnotationLinksPtr
newCallback_Experimenter_reloadAnnotationLinks(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_reloadAnnotationLinks<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Experimenter_reloadAnnotationLinks : public Callback_Experimenter_reloadAnnotationLinks_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Experimenter_reloadAnnotationLinks(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_Experimenter_reloadAnnotationLinksPtr
newCallback_Experimenter_reloadAnnotationLinks(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_reloadAnnotationLinks<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Experimenter_reloadAnnotationLinksPtr
newCallback_Experimenter_reloadAnnotationLinks(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_reloadAnnotationLinks<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Experimenter_reloadAnnotationLinksPtr
newCallback_Experimenter_reloadAnnotationLinks(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_reloadAnnotationLinks<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Experimenter_reloadAnnotationLinksPtr
newCallback_Experimenter_reloadAnnotationLinks(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_reloadAnnotationLinks<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Experimenter_getAnnotationLinksCountPerOwner : public Callback_Experimenter_getAnnotationLinksCountPerOwner_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::sys::CountMap&);

    CallbackNC_Experimenter_getAnnotationLinksCountPerOwner(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::ExperimenterPrx __proxy = ::omero::model::ExperimenterPrx::uncheckedCast(__result->getProxy());
        ::omero::sys::CountMap __ret;
        try
        {
            __ret = __proxy->end_getAnnotationLinksCountPerOwner(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_Experimenter_getAnnotationLinksCountPerOwnerPtr
newCallback_Experimenter_getAnnotationLinksCountPerOwner(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::sys::CountMap&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_getAnnotationLinksCountPerOwner<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Experimenter_getAnnotationLinksCountPerOwnerPtr
newCallback_Experimenter_getAnnotationLinksCountPerOwner(T* instance, void (T::*cb)(const ::omero::sys::CountMap&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_getAnnotationLinksCountPerOwner<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Experimenter_getAnnotationLinksCountPerOwner : public Callback_Experimenter_getAnnotationLinksCountPerOwner_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::sys::CountMap&, const CT&);

    Callback_Experimenter_getAnnotationLinksCountPerOwner(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::ExperimenterPrx __proxy = ::omero::model::ExperimenterPrx::uncheckedCast(__result->getProxy());
        ::omero::sys::CountMap __ret;
        try
        {
            __ret = __proxy->end_getAnnotationLinksCountPerOwner(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Experimenter_getAnnotationLinksCountPerOwnerPtr
newCallback_Experimenter_getAnnotationLinksCountPerOwner(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::sys::CountMap&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_getAnnotationLinksCountPerOwner<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Experimenter_getAnnotationLinksCountPerOwnerPtr
newCallback_Experimenter_getAnnotationLinksCountPerOwner(T* instance, void (T::*cb)(const ::omero::sys::CountMap&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_getAnnotationLinksCountPerOwner<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Experimenter_linkAnnotation : public Callback_Experimenter_linkAnnotation_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::model::ExperimenterAnnotationLinkPtr&);

    CallbackNC_Experimenter_linkAnnotation(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::ExperimenterPrx __proxy = ::omero::model::ExperimenterPrx::uncheckedCast(__result->getProxy());
        ::omero::model::ExperimenterAnnotationLinkPtr __ret;
        try
        {
            __ret = __proxy->end_linkAnnotation(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_Experimenter_linkAnnotationPtr
newCallback_Experimenter_linkAnnotation(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::ExperimenterAnnotationLinkPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_linkAnnotation<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Experimenter_linkAnnotationPtr
newCallback_Experimenter_linkAnnotation(T* instance, void (T::*cb)(const ::omero::model::ExperimenterAnnotationLinkPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_linkAnnotation<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Experimenter_linkAnnotation : public Callback_Experimenter_linkAnnotation_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::model::ExperimenterAnnotationLinkPtr&, const CT&);

    Callback_Experimenter_linkAnnotation(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::ExperimenterPrx __proxy = ::omero::model::ExperimenterPrx::uncheckedCast(__result->getProxy());
        ::omero::model::ExperimenterAnnotationLinkPtr __ret;
        try
        {
            __ret = __proxy->end_linkAnnotation(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Experimenter_linkAnnotationPtr
newCallback_Experimenter_linkAnnotation(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::ExperimenterAnnotationLinkPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_linkAnnotation<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Experimenter_linkAnnotationPtr
newCallback_Experimenter_linkAnnotation(T* instance, void (T::*cb)(const ::omero::model::ExperimenterAnnotationLinkPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_linkAnnotation<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Experimenter_addExperimenterAnnotationLinkToBoth : public Callback_Experimenter_addExperimenterAnnotationLinkToBoth_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Experimenter_addExperimenterAnnotationLinkToBoth(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_Experimenter_addExperimenterAnnotationLinkToBothPtr
newCallback_Experimenter_addExperimenterAnnotationLinkToBoth(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_addExperimenterAnnotationLinkToBoth<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Experimenter_addExperimenterAnnotationLinkToBothPtr
newCallback_Experimenter_addExperimenterAnnotationLinkToBoth(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_addExperimenterAnnotationLinkToBoth<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Experimenter_addExperimenterAnnotationLinkToBothPtr
newCallback_Experimenter_addExperimenterAnnotationLinkToBoth(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_addExperimenterAnnotationLinkToBoth<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Experimenter_addExperimenterAnnotationLinkToBothPtr
newCallback_Experimenter_addExperimenterAnnotationLinkToBoth(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_addExperimenterAnnotationLinkToBoth<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Experimenter_addExperimenterAnnotationLinkToBoth : public Callback_Experimenter_addExperimenterAnnotationLinkToBoth_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Experimenter_addExperimenterAnnotationLinkToBoth(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_Experimenter_addExperimenterAnnotationLinkToBothPtr
newCallback_Experimenter_addExperimenterAnnotationLinkToBoth(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_addExperimenterAnnotationLinkToBoth<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Experimenter_addExperimenterAnnotationLinkToBothPtr
newCallback_Experimenter_addExperimenterAnnotationLinkToBoth(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_addExperimenterAnnotationLinkToBoth<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Experimenter_addExperimenterAnnotationLinkToBothPtr
newCallback_Experimenter_addExperimenterAnnotationLinkToBoth(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_addExperimenterAnnotationLinkToBoth<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Experimenter_addExperimenterAnnotationLinkToBothPtr
newCallback_Experimenter_addExperimenterAnnotationLinkToBoth(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_addExperimenterAnnotationLinkToBoth<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Experimenter_findExperimenterAnnotationLink : public Callback_Experimenter_findExperimenterAnnotationLink_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::model::ExperimenterAnnotationLinksSeq&);

    CallbackNC_Experimenter_findExperimenterAnnotationLink(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::ExperimenterPrx __proxy = ::omero::model::ExperimenterPrx::uncheckedCast(__result->getProxy());
        ::omero::model::ExperimenterAnnotationLinksSeq __ret;
        try
        {
            __ret = __proxy->end_findExperimenterAnnotationLink(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_Experimenter_findExperimenterAnnotationLinkPtr
newCallback_Experimenter_findExperimenterAnnotationLink(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::ExperimenterAnnotationLinksSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_findExperimenterAnnotationLink<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Experimenter_findExperimenterAnnotationLinkPtr
newCallback_Experimenter_findExperimenterAnnotationLink(T* instance, void (T::*cb)(const ::omero::model::ExperimenterAnnotationLinksSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_findExperimenterAnnotationLink<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Experimenter_findExperimenterAnnotationLink : public Callback_Experimenter_findExperimenterAnnotationLink_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::model::ExperimenterAnnotationLinksSeq&, const CT&);

    Callback_Experimenter_findExperimenterAnnotationLink(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::ExperimenterPrx __proxy = ::omero::model::ExperimenterPrx::uncheckedCast(__result->getProxy());
        ::omero::model::ExperimenterAnnotationLinksSeq __ret;
        try
        {
            __ret = __proxy->end_findExperimenterAnnotationLink(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Experimenter_findExperimenterAnnotationLinkPtr
newCallback_Experimenter_findExperimenterAnnotationLink(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::ExperimenterAnnotationLinksSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_findExperimenterAnnotationLink<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Experimenter_findExperimenterAnnotationLinkPtr
newCallback_Experimenter_findExperimenterAnnotationLink(T* instance, void (T::*cb)(const ::omero::model::ExperimenterAnnotationLinksSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_findExperimenterAnnotationLink<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Experimenter_unlinkAnnotation : public Callback_Experimenter_unlinkAnnotation_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Experimenter_unlinkAnnotation(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_Experimenter_unlinkAnnotationPtr
newCallback_Experimenter_unlinkAnnotation(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_unlinkAnnotation<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Experimenter_unlinkAnnotationPtr
newCallback_Experimenter_unlinkAnnotation(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_unlinkAnnotation<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Experimenter_unlinkAnnotationPtr
newCallback_Experimenter_unlinkAnnotation(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_unlinkAnnotation<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Experimenter_unlinkAnnotationPtr
newCallback_Experimenter_unlinkAnnotation(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_unlinkAnnotation<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Experimenter_unlinkAnnotation : public Callback_Experimenter_unlinkAnnotation_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Experimenter_unlinkAnnotation(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_Experimenter_unlinkAnnotationPtr
newCallback_Experimenter_unlinkAnnotation(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_unlinkAnnotation<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Experimenter_unlinkAnnotationPtr
newCallback_Experimenter_unlinkAnnotation(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_unlinkAnnotation<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Experimenter_unlinkAnnotationPtr
newCallback_Experimenter_unlinkAnnotation(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_unlinkAnnotation<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Experimenter_unlinkAnnotationPtr
newCallback_Experimenter_unlinkAnnotation(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_unlinkAnnotation<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Experimenter_removeExperimenterAnnotationLinkFromBoth : public Callback_Experimenter_removeExperimenterAnnotationLinkFromBoth_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Experimenter_removeExperimenterAnnotationLinkFromBoth(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_Experimenter_removeExperimenterAnnotationLinkFromBothPtr
newCallback_Experimenter_removeExperimenterAnnotationLinkFromBoth(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_removeExperimenterAnnotationLinkFromBoth<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Experimenter_removeExperimenterAnnotationLinkFromBothPtr
newCallback_Experimenter_removeExperimenterAnnotationLinkFromBoth(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_removeExperimenterAnnotationLinkFromBoth<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Experimenter_removeExperimenterAnnotationLinkFromBothPtr
newCallback_Experimenter_removeExperimenterAnnotationLinkFromBoth(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_removeExperimenterAnnotationLinkFromBoth<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Experimenter_removeExperimenterAnnotationLinkFromBothPtr
newCallback_Experimenter_removeExperimenterAnnotationLinkFromBoth(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_removeExperimenterAnnotationLinkFromBoth<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Experimenter_removeExperimenterAnnotationLinkFromBoth : public Callback_Experimenter_removeExperimenterAnnotationLinkFromBoth_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Experimenter_removeExperimenterAnnotationLinkFromBoth(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_Experimenter_removeExperimenterAnnotationLinkFromBothPtr
newCallback_Experimenter_removeExperimenterAnnotationLinkFromBoth(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_removeExperimenterAnnotationLinkFromBoth<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Experimenter_removeExperimenterAnnotationLinkFromBothPtr
newCallback_Experimenter_removeExperimenterAnnotationLinkFromBoth(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_removeExperimenterAnnotationLinkFromBoth<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Experimenter_removeExperimenterAnnotationLinkFromBothPtr
newCallback_Experimenter_removeExperimenterAnnotationLinkFromBoth(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_removeExperimenterAnnotationLinkFromBoth<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Experimenter_removeExperimenterAnnotationLinkFromBothPtr
newCallback_Experimenter_removeExperimenterAnnotationLinkFromBoth(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_removeExperimenterAnnotationLinkFromBoth<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Experimenter_linkedAnnotationList : public Callback_Experimenter_linkedAnnotationList_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::model::ExperimenterLinkedAnnotationSeq&);

    CallbackNC_Experimenter_linkedAnnotationList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::ExperimenterPrx __proxy = ::omero::model::ExperimenterPrx::uncheckedCast(__result->getProxy());
        ::omero::model::ExperimenterLinkedAnnotationSeq __ret;
        try
        {
            __ret = __proxy->end_linkedAnnotationList(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_Experimenter_linkedAnnotationListPtr
newCallback_Experimenter_linkedAnnotationList(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::ExperimenterLinkedAnnotationSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_linkedAnnotationList<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Experimenter_linkedAnnotationListPtr
newCallback_Experimenter_linkedAnnotationList(T* instance, void (T::*cb)(const ::omero::model::ExperimenterLinkedAnnotationSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Experimenter_linkedAnnotationList<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Experimenter_linkedAnnotationList : public Callback_Experimenter_linkedAnnotationList_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::model::ExperimenterLinkedAnnotationSeq&, const CT&);

    Callback_Experimenter_linkedAnnotationList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::ExperimenterPrx __proxy = ::omero::model::ExperimenterPrx::uncheckedCast(__result->getProxy());
        ::omero::model::ExperimenterLinkedAnnotationSeq __ret;
        try
        {
            __ret = __proxy->end_linkedAnnotationList(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Experimenter_linkedAnnotationListPtr
newCallback_Experimenter_linkedAnnotationList(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::ExperimenterLinkedAnnotationSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_linkedAnnotationList<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Experimenter_linkedAnnotationListPtr
newCallback_Experimenter_linkedAnnotationList(T* instance, void (T::*cb)(const ::omero::model::ExperimenterLinkedAnnotationSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Experimenter_linkedAnnotationList<T, CT>(instance, cb, excb, sentcb);
}

}

}

#endif
