// **********************************************************************
//
// Copyright (c) 2003-2011 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.4.2
//
// <auto-generated>
//
// Generated from file `RenderingDef.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __omero_model__opt_hudson_workspace_OMERO_5_0_release_src_components_blitz_generated_omero_model_RenderingDef_h__
#define __omero_model__opt_hudson_workspace_OMERO_5_0_release_src_components_blitz_generated_omero_model_RenderingDef_h__

#include <Ice/LocalObjectF.h>
#include <Ice/ProxyF.h>
#include <Ice/ObjectF.h>
#include <Ice/Exception.h>
#include <Ice/LocalObject.h>
#include <Ice/Proxy.h>
#include <Ice/Object.h>
#include <Ice/Outgoing.h>
#include <Ice/OutgoingAsync.h>
#include <Ice/Incoming.h>
#include <Ice/Direct.h>
#include <Ice/FactoryTableInit.h>
#include <IceUtil/ScopedArray.h>
#include <Ice/StreamF.h>
#include <omero/model/IObject.h>
#include <omero/RTypes.h>
#include <omero/System.h>
#include <omero/Collections.h>
#include <Ice/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 304
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 > 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 2
#       error Ice patch level mismatch!
#   endif
#endif

namespace IceProxy
{

namespace omero
{

namespace model
{

class Pixels;

class RenderingModel;

class ChannelBinding;

class QuantumDef;

class CodomainMapContext;

class Details;

class RenderingDef;

}

}

}

namespace omero
{

namespace model
{

class Pixels;
bool operator==(const Pixels&, const Pixels&);
bool operator<(const Pixels&, const Pixels&);

class RenderingModel;
bool operator==(const RenderingModel&, const RenderingModel&);
bool operator<(const RenderingModel&, const RenderingModel&);

class ChannelBinding;
bool operator==(const ChannelBinding&, const ChannelBinding&);
bool operator<(const ChannelBinding&, const ChannelBinding&);

class QuantumDef;
bool operator==(const QuantumDef&, const QuantumDef&);
bool operator<(const QuantumDef&, const QuantumDef&);

class CodomainMapContext;
bool operator==(const CodomainMapContext&, const CodomainMapContext&);
bool operator<(const CodomainMapContext&, const CodomainMapContext&);

class Details;
bool operator==(const Details&, const Details&);
bool operator<(const Details&, const Details&);

class RenderingDef;
bool operator==(const RenderingDef&, const RenderingDef&);
bool operator<(const RenderingDef&, const RenderingDef&);

}

}

namespace IceInternal
{

::Ice::Object* upCast(::omero::model::Pixels*);
::IceProxy::Ice::Object* upCast(::IceProxy::omero::model::Pixels*);

::Ice::Object* upCast(::omero::model::RenderingModel*);
::IceProxy::Ice::Object* upCast(::IceProxy::omero::model::RenderingModel*);

::Ice::Object* upCast(::omero::model::ChannelBinding*);
::IceProxy::Ice::Object* upCast(::IceProxy::omero::model::ChannelBinding*);

::Ice::Object* upCast(::omero::model::QuantumDef*);
::IceProxy::Ice::Object* upCast(::IceProxy::omero::model::QuantumDef*);

::Ice::Object* upCast(::omero::model::CodomainMapContext*);
::IceProxy::Ice::Object* upCast(::IceProxy::omero::model::CodomainMapContext*);

::Ice::Object* upCast(::omero::model::Details*);
::IceProxy::Ice::Object* upCast(::IceProxy::omero::model::Details*);

::Ice::Object* upCast(::omero::model::RenderingDef*);
::IceProxy::Ice::Object* upCast(::IceProxy::omero::model::RenderingDef*);

}

namespace omero
{

namespace model
{

typedef ::IceInternal::Handle< ::omero::model::Pixels> PixelsPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::omero::model::Pixels> PixelsPrx;

void __read(::IceInternal::BasicStream*, PixelsPrx&);
void __patch__PixelsPtr(void*, ::Ice::ObjectPtr&);

typedef ::IceInternal::Handle< ::omero::model::RenderingModel> RenderingModelPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::omero::model::RenderingModel> RenderingModelPrx;

void __read(::IceInternal::BasicStream*, RenderingModelPrx&);
void __patch__RenderingModelPtr(void*, ::Ice::ObjectPtr&);

typedef ::IceInternal::Handle< ::omero::model::ChannelBinding> ChannelBindingPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::omero::model::ChannelBinding> ChannelBindingPrx;

void __read(::IceInternal::BasicStream*, ChannelBindingPrx&);
void __patch__ChannelBindingPtr(void*, ::Ice::ObjectPtr&);

typedef ::IceInternal::Handle< ::omero::model::QuantumDef> QuantumDefPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::omero::model::QuantumDef> QuantumDefPrx;

void __read(::IceInternal::BasicStream*, QuantumDefPrx&);
void __patch__QuantumDefPtr(void*, ::Ice::ObjectPtr&);

typedef ::IceInternal::Handle< ::omero::model::CodomainMapContext> CodomainMapContextPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::omero::model::CodomainMapContext> CodomainMapContextPrx;

void __read(::IceInternal::BasicStream*, CodomainMapContextPrx&);
void __patch__CodomainMapContextPtr(void*, ::Ice::ObjectPtr&);

typedef ::IceInternal::Handle< ::omero::model::Details> DetailsPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::omero::model::Details> DetailsPrx;

void __read(::IceInternal::BasicStream*, DetailsPrx&);
void __patch__DetailsPtr(void*, ::Ice::ObjectPtr&);

typedef ::IceInternal::Handle< ::omero::model::RenderingDef> RenderingDefPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::omero::model::RenderingDef> RenderingDefPrx;

void __read(::IceInternal::BasicStream*, RenderingDefPrx&);
void __patch__RenderingDefPtr(void*, ::Ice::ObjectPtr&);

}

}

namespace omero
{

namespace model
{

typedef ::std::vector< ::omero::model::ChannelBindingPtr> RenderingDefWaveRenderingSeq;
void __writeRenderingDefWaveRenderingSeq(::IceInternal::BasicStream*, const ::omero::model::ChannelBindingPtr*, const ::omero::model::ChannelBindingPtr*);
void __readRenderingDefWaveRenderingSeq(::IceInternal::BasicStream*, RenderingDefWaveRenderingSeq&);

typedef ::std::vector< ::omero::model::CodomainMapContextPtr> RenderingDefSpatialDomainEnhancementSeq;
void __writeRenderingDefSpatialDomainEnhancementSeq(::IceInternal::BasicStream*, const ::omero::model::CodomainMapContextPtr*, const ::omero::model::CodomainMapContextPtr*);
void __readRenderingDefSpatialDomainEnhancementSeq(::IceInternal::BasicStream*, RenderingDefSpatialDomainEnhancementSeq&);

}

}

namespace omero
{

namespace model
{

class Callback_RenderingDef_getVersion_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RenderingDef_getVersion_Base> Callback_RenderingDef_getVersionPtr;

class Callback_RenderingDef_setVersion_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RenderingDef_setVersion_Base> Callback_RenderingDef_setVersionPtr;

class Callback_RenderingDef_getPixels_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RenderingDef_getPixels_Base> Callback_RenderingDef_getPixelsPtr;

class Callback_RenderingDef_setPixels_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RenderingDef_setPixels_Base> Callback_RenderingDef_setPixelsPtr;

class Callback_RenderingDef_getDefaultZ_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RenderingDef_getDefaultZ_Base> Callback_RenderingDef_getDefaultZPtr;

class Callback_RenderingDef_setDefaultZ_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RenderingDef_setDefaultZ_Base> Callback_RenderingDef_setDefaultZPtr;

class Callback_RenderingDef_getDefaultT_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RenderingDef_getDefaultT_Base> Callback_RenderingDef_getDefaultTPtr;

class Callback_RenderingDef_setDefaultT_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RenderingDef_setDefaultT_Base> Callback_RenderingDef_setDefaultTPtr;

class Callback_RenderingDef_getModel_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RenderingDef_getModel_Base> Callback_RenderingDef_getModelPtr;

class Callback_RenderingDef_setModel_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RenderingDef_setModel_Base> Callback_RenderingDef_setModelPtr;

class Callback_RenderingDef_unloadWaveRendering_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RenderingDef_unloadWaveRendering_Base> Callback_RenderingDef_unloadWaveRenderingPtr;

class Callback_RenderingDef_sizeOfWaveRendering_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RenderingDef_sizeOfWaveRendering_Base> Callback_RenderingDef_sizeOfWaveRenderingPtr;

class Callback_RenderingDef_copyWaveRendering_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RenderingDef_copyWaveRendering_Base> Callback_RenderingDef_copyWaveRenderingPtr;

class Callback_RenderingDef_addChannelBinding_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RenderingDef_addChannelBinding_Base> Callback_RenderingDef_addChannelBindingPtr;

class Callback_RenderingDef_addAllChannelBindingSet_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RenderingDef_addAllChannelBindingSet_Base> Callback_RenderingDef_addAllChannelBindingSetPtr;

class Callback_RenderingDef_removeChannelBinding_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RenderingDef_removeChannelBinding_Base> Callback_RenderingDef_removeChannelBindingPtr;

class Callback_RenderingDef_removeAllChannelBindingSet_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RenderingDef_removeAllChannelBindingSet_Base> Callback_RenderingDef_removeAllChannelBindingSetPtr;

class Callback_RenderingDef_clearWaveRendering_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RenderingDef_clearWaveRendering_Base> Callback_RenderingDef_clearWaveRenderingPtr;

class Callback_RenderingDef_reloadWaveRendering_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RenderingDef_reloadWaveRendering_Base> Callback_RenderingDef_reloadWaveRenderingPtr;

class Callback_RenderingDef_getChannelBinding_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RenderingDef_getChannelBinding_Base> Callback_RenderingDef_getChannelBindingPtr;

class Callback_RenderingDef_setChannelBinding_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RenderingDef_setChannelBinding_Base> Callback_RenderingDef_setChannelBindingPtr;

class Callback_RenderingDef_getPrimaryChannelBinding_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RenderingDef_getPrimaryChannelBinding_Base> Callback_RenderingDef_getPrimaryChannelBindingPtr;

class Callback_RenderingDef_setPrimaryChannelBinding_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RenderingDef_setPrimaryChannelBinding_Base> Callback_RenderingDef_setPrimaryChannelBindingPtr;

class Callback_RenderingDef_getName_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RenderingDef_getName_Base> Callback_RenderingDef_getNamePtr;

class Callback_RenderingDef_setName_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RenderingDef_setName_Base> Callback_RenderingDef_setNamePtr;

class Callback_RenderingDef_getCompression_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RenderingDef_getCompression_Base> Callback_RenderingDef_getCompressionPtr;

class Callback_RenderingDef_setCompression_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RenderingDef_setCompression_Base> Callback_RenderingDef_setCompressionPtr;

class Callback_RenderingDef_getQuantization_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RenderingDef_getQuantization_Base> Callback_RenderingDef_getQuantizationPtr;

class Callback_RenderingDef_setQuantization_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RenderingDef_setQuantization_Base> Callback_RenderingDef_setQuantizationPtr;

class Callback_RenderingDef_unloadSpatialDomainEnhancement_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RenderingDef_unloadSpatialDomainEnhancement_Base> Callback_RenderingDef_unloadSpatialDomainEnhancementPtr;

class Callback_RenderingDef_sizeOfSpatialDomainEnhancement_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RenderingDef_sizeOfSpatialDomainEnhancement_Base> Callback_RenderingDef_sizeOfSpatialDomainEnhancementPtr;

class Callback_RenderingDef_copySpatialDomainEnhancement_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RenderingDef_copySpatialDomainEnhancement_Base> Callback_RenderingDef_copySpatialDomainEnhancementPtr;

class Callback_RenderingDef_addCodomainMapContext_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RenderingDef_addCodomainMapContext_Base> Callback_RenderingDef_addCodomainMapContextPtr;

class Callback_RenderingDef_addAllCodomainMapContextSet_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RenderingDef_addAllCodomainMapContextSet_Base> Callback_RenderingDef_addAllCodomainMapContextSetPtr;

class Callback_RenderingDef_removeCodomainMapContext_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RenderingDef_removeCodomainMapContext_Base> Callback_RenderingDef_removeCodomainMapContextPtr;

class Callback_RenderingDef_removeAllCodomainMapContextSet_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RenderingDef_removeAllCodomainMapContextSet_Base> Callback_RenderingDef_removeAllCodomainMapContextSetPtr;

class Callback_RenderingDef_clearSpatialDomainEnhancement_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RenderingDef_clearSpatialDomainEnhancement_Base> Callback_RenderingDef_clearSpatialDomainEnhancementPtr;

class Callback_RenderingDef_reloadSpatialDomainEnhancement_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RenderingDef_reloadSpatialDomainEnhancement_Base> Callback_RenderingDef_reloadSpatialDomainEnhancementPtr;

class Callback_RenderingDef_getCodomainMapContext_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RenderingDef_getCodomainMapContext_Base> Callback_RenderingDef_getCodomainMapContextPtr;

class Callback_RenderingDef_setCodomainMapContext_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RenderingDef_setCodomainMapContext_Base> Callback_RenderingDef_setCodomainMapContextPtr;

class Callback_RenderingDef_getPrimaryCodomainMapContext_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RenderingDef_getPrimaryCodomainMapContext_Base> Callback_RenderingDef_getPrimaryCodomainMapContextPtr;

class Callback_RenderingDef_setPrimaryCodomainMapContext_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RenderingDef_setPrimaryCodomainMapContext_Base> Callback_RenderingDef_setPrimaryCodomainMapContextPtr;

}

}

namespace IceProxy
{

namespace omero
{

namespace model
{

class RenderingDef : virtual public ::IceProxy::omero::model::IObject
{
public:

    ::omero::RIntPtr getVersion()
    {
        return getVersion(0);
    }
    ::omero::RIntPtr getVersion(const ::Ice::Context& __ctx)
    {
        return getVersion(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getVersion()
    {
        return begin_getVersion(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getVersion(const ::Ice::Context& __ctx)
    {
        return begin_getVersion(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getVersion(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getVersion(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getVersion(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getVersion(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getVersion(const ::omero::model::Callback_RenderingDef_getVersionPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getVersion(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getVersion(const ::Ice::Context& __ctx, const ::omero::model::Callback_RenderingDef_getVersionPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getVersion(&__ctx, __del, __cookie);
    }

    ::omero::RIntPtr end_getVersion(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::RIntPtr getVersion(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getVersion(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setVersion(const ::omero::RIntPtr& theVersion)
    {
        setVersion(theVersion, 0);
    }
    void setVersion(const ::omero::RIntPtr& theVersion, const ::Ice::Context& __ctx)
    {
        setVersion(theVersion, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setVersion(const ::omero::RIntPtr& theVersion)
    {
        return begin_setVersion(theVersion, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setVersion(const ::omero::RIntPtr& theVersion, const ::Ice::Context& __ctx)
    {
        return begin_setVersion(theVersion, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setVersion(const ::omero::RIntPtr& theVersion, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setVersion(theVersion, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setVersion(const ::omero::RIntPtr& theVersion, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setVersion(theVersion, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setVersion(const ::omero::RIntPtr& theVersion, const ::omero::model::Callback_RenderingDef_setVersionPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setVersion(theVersion, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setVersion(const ::omero::RIntPtr& theVersion, const ::Ice::Context& __ctx, const ::omero::model::Callback_RenderingDef_setVersionPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setVersion(theVersion, &__ctx, __del, __cookie);
    }

    void end_setVersion(const ::Ice::AsyncResultPtr&);
    
private:

    void setVersion(const ::omero::RIntPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setVersion(const ::omero::RIntPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::model::PixelsPtr getPixels()
    {
        return getPixels(0);
    }
    ::omero::model::PixelsPtr getPixels(const ::Ice::Context& __ctx)
    {
        return getPixels(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getPixels()
    {
        return begin_getPixels(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getPixels(const ::Ice::Context& __ctx)
    {
        return begin_getPixels(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getPixels(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getPixels(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getPixels(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getPixels(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getPixels(const ::omero::model::Callback_RenderingDef_getPixelsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getPixels(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getPixels(const ::Ice::Context& __ctx, const ::omero::model::Callback_RenderingDef_getPixelsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getPixels(&__ctx, __del, __cookie);
    }

    ::omero::model::PixelsPtr end_getPixels(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::model::PixelsPtr getPixels(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getPixels(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setPixels(const ::omero::model::PixelsPtr& thePixels)
    {
        setPixels(thePixels, 0);
    }
    void setPixels(const ::omero::model::PixelsPtr& thePixels, const ::Ice::Context& __ctx)
    {
        setPixels(thePixels, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setPixels(const ::omero::model::PixelsPtr& thePixels)
    {
        return begin_setPixels(thePixels, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setPixels(const ::omero::model::PixelsPtr& thePixels, const ::Ice::Context& __ctx)
    {
        return begin_setPixels(thePixels, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setPixels(const ::omero::model::PixelsPtr& thePixels, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setPixels(thePixels, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setPixels(const ::omero::model::PixelsPtr& thePixels, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setPixels(thePixels, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setPixels(const ::omero::model::PixelsPtr& thePixels, const ::omero::model::Callback_RenderingDef_setPixelsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setPixels(thePixels, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setPixels(const ::omero::model::PixelsPtr& thePixels, const ::Ice::Context& __ctx, const ::omero::model::Callback_RenderingDef_setPixelsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setPixels(thePixels, &__ctx, __del, __cookie);
    }

    void end_setPixels(const ::Ice::AsyncResultPtr&);
    
private:

    void setPixels(const ::omero::model::PixelsPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setPixels(const ::omero::model::PixelsPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::RIntPtr getDefaultZ()
    {
        return getDefaultZ(0);
    }
    ::omero::RIntPtr getDefaultZ(const ::Ice::Context& __ctx)
    {
        return getDefaultZ(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getDefaultZ()
    {
        return begin_getDefaultZ(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getDefaultZ(const ::Ice::Context& __ctx)
    {
        return begin_getDefaultZ(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getDefaultZ(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getDefaultZ(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getDefaultZ(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getDefaultZ(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getDefaultZ(const ::omero::model::Callback_RenderingDef_getDefaultZPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getDefaultZ(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getDefaultZ(const ::Ice::Context& __ctx, const ::omero::model::Callback_RenderingDef_getDefaultZPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getDefaultZ(&__ctx, __del, __cookie);
    }

    ::omero::RIntPtr end_getDefaultZ(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::RIntPtr getDefaultZ(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getDefaultZ(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setDefaultZ(const ::omero::RIntPtr& theDefaultZ)
    {
        setDefaultZ(theDefaultZ, 0);
    }
    void setDefaultZ(const ::omero::RIntPtr& theDefaultZ, const ::Ice::Context& __ctx)
    {
        setDefaultZ(theDefaultZ, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setDefaultZ(const ::omero::RIntPtr& theDefaultZ)
    {
        return begin_setDefaultZ(theDefaultZ, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setDefaultZ(const ::omero::RIntPtr& theDefaultZ, const ::Ice::Context& __ctx)
    {
        return begin_setDefaultZ(theDefaultZ, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setDefaultZ(const ::omero::RIntPtr& theDefaultZ, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setDefaultZ(theDefaultZ, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setDefaultZ(const ::omero::RIntPtr& theDefaultZ, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setDefaultZ(theDefaultZ, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setDefaultZ(const ::omero::RIntPtr& theDefaultZ, const ::omero::model::Callback_RenderingDef_setDefaultZPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setDefaultZ(theDefaultZ, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setDefaultZ(const ::omero::RIntPtr& theDefaultZ, const ::Ice::Context& __ctx, const ::omero::model::Callback_RenderingDef_setDefaultZPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setDefaultZ(theDefaultZ, &__ctx, __del, __cookie);
    }

    void end_setDefaultZ(const ::Ice::AsyncResultPtr&);
    
private:

    void setDefaultZ(const ::omero::RIntPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setDefaultZ(const ::omero::RIntPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::RIntPtr getDefaultT()
    {
        return getDefaultT(0);
    }
    ::omero::RIntPtr getDefaultT(const ::Ice::Context& __ctx)
    {
        return getDefaultT(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getDefaultT()
    {
        return begin_getDefaultT(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getDefaultT(const ::Ice::Context& __ctx)
    {
        return begin_getDefaultT(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getDefaultT(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getDefaultT(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getDefaultT(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getDefaultT(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getDefaultT(const ::omero::model::Callback_RenderingDef_getDefaultTPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getDefaultT(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getDefaultT(const ::Ice::Context& __ctx, const ::omero::model::Callback_RenderingDef_getDefaultTPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getDefaultT(&__ctx, __del, __cookie);
    }

    ::omero::RIntPtr end_getDefaultT(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::RIntPtr getDefaultT(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getDefaultT(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setDefaultT(const ::omero::RIntPtr& theDefaultT)
    {
        setDefaultT(theDefaultT, 0);
    }
    void setDefaultT(const ::omero::RIntPtr& theDefaultT, const ::Ice::Context& __ctx)
    {
        setDefaultT(theDefaultT, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setDefaultT(const ::omero::RIntPtr& theDefaultT)
    {
        return begin_setDefaultT(theDefaultT, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setDefaultT(const ::omero::RIntPtr& theDefaultT, const ::Ice::Context& __ctx)
    {
        return begin_setDefaultT(theDefaultT, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setDefaultT(const ::omero::RIntPtr& theDefaultT, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setDefaultT(theDefaultT, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setDefaultT(const ::omero::RIntPtr& theDefaultT, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setDefaultT(theDefaultT, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setDefaultT(const ::omero::RIntPtr& theDefaultT, const ::omero::model::Callback_RenderingDef_setDefaultTPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setDefaultT(theDefaultT, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setDefaultT(const ::omero::RIntPtr& theDefaultT, const ::Ice::Context& __ctx, const ::omero::model::Callback_RenderingDef_setDefaultTPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setDefaultT(theDefaultT, &__ctx, __del, __cookie);
    }

    void end_setDefaultT(const ::Ice::AsyncResultPtr&);
    
private:

    void setDefaultT(const ::omero::RIntPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setDefaultT(const ::omero::RIntPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::model::RenderingModelPtr getModel()
    {
        return getModel(0);
    }
    ::omero::model::RenderingModelPtr getModel(const ::Ice::Context& __ctx)
    {
        return getModel(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getModel()
    {
        return begin_getModel(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getModel(const ::Ice::Context& __ctx)
    {
        return begin_getModel(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getModel(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getModel(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getModel(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getModel(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getModel(const ::omero::model::Callback_RenderingDef_getModelPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getModel(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getModel(const ::Ice::Context& __ctx, const ::omero::model::Callback_RenderingDef_getModelPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getModel(&__ctx, __del, __cookie);
    }

    ::omero::model::RenderingModelPtr end_getModel(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::model::RenderingModelPtr getModel(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getModel(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setModel(const ::omero::model::RenderingModelPtr& theModel)
    {
        setModel(theModel, 0);
    }
    void setModel(const ::omero::model::RenderingModelPtr& theModel, const ::Ice::Context& __ctx)
    {
        setModel(theModel, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setModel(const ::omero::model::RenderingModelPtr& theModel)
    {
        return begin_setModel(theModel, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setModel(const ::omero::model::RenderingModelPtr& theModel, const ::Ice::Context& __ctx)
    {
        return begin_setModel(theModel, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setModel(const ::omero::model::RenderingModelPtr& theModel, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setModel(theModel, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setModel(const ::omero::model::RenderingModelPtr& theModel, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setModel(theModel, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setModel(const ::omero::model::RenderingModelPtr& theModel, const ::omero::model::Callback_RenderingDef_setModelPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setModel(theModel, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setModel(const ::omero::model::RenderingModelPtr& theModel, const ::Ice::Context& __ctx, const ::omero::model::Callback_RenderingDef_setModelPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setModel(theModel, &__ctx, __del, __cookie);
    }

    void end_setModel(const ::Ice::AsyncResultPtr&);
    
private:

    void setModel(const ::omero::model::RenderingModelPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setModel(const ::omero::model::RenderingModelPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void unloadWaveRendering()
    {
        unloadWaveRendering(0);
    }
    void unloadWaveRendering(const ::Ice::Context& __ctx)
    {
        unloadWaveRendering(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_unloadWaveRendering()
    {
        return begin_unloadWaveRendering(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_unloadWaveRendering(const ::Ice::Context& __ctx)
    {
        return begin_unloadWaveRendering(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_unloadWaveRendering(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_unloadWaveRendering(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_unloadWaveRendering(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_unloadWaveRendering(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_unloadWaveRendering(const ::omero::model::Callback_RenderingDef_unloadWaveRenderingPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_unloadWaveRendering(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_unloadWaveRendering(const ::Ice::Context& __ctx, const ::omero::model::Callback_RenderingDef_unloadWaveRenderingPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_unloadWaveRendering(&__ctx, __del, __cookie);
    }

    void end_unloadWaveRendering(const ::Ice::AsyncResultPtr&);
    
private:

    void unloadWaveRendering(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_unloadWaveRendering(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Int sizeOfWaveRendering()
    {
        return sizeOfWaveRendering(0);
    }
    ::Ice::Int sizeOfWaveRendering(const ::Ice::Context& __ctx)
    {
        return sizeOfWaveRendering(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_sizeOfWaveRendering()
    {
        return begin_sizeOfWaveRendering(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_sizeOfWaveRendering(const ::Ice::Context& __ctx)
    {
        return begin_sizeOfWaveRendering(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_sizeOfWaveRendering(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_sizeOfWaveRendering(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_sizeOfWaveRendering(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_sizeOfWaveRendering(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_sizeOfWaveRendering(const ::omero::model::Callback_RenderingDef_sizeOfWaveRenderingPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_sizeOfWaveRendering(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_sizeOfWaveRendering(const ::Ice::Context& __ctx, const ::omero::model::Callback_RenderingDef_sizeOfWaveRenderingPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_sizeOfWaveRendering(&__ctx, __del, __cookie);
    }

    ::Ice::Int end_sizeOfWaveRendering(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int sizeOfWaveRendering(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_sizeOfWaveRendering(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::model::RenderingDefWaveRenderingSeq copyWaveRendering()
    {
        return copyWaveRendering(0);
    }
    ::omero::model::RenderingDefWaveRenderingSeq copyWaveRendering(const ::Ice::Context& __ctx)
    {
        return copyWaveRendering(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_copyWaveRendering()
    {
        return begin_copyWaveRendering(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_copyWaveRendering(const ::Ice::Context& __ctx)
    {
        return begin_copyWaveRendering(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_copyWaveRendering(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_copyWaveRendering(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_copyWaveRendering(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_copyWaveRendering(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_copyWaveRendering(const ::omero::model::Callback_RenderingDef_copyWaveRenderingPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_copyWaveRendering(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_copyWaveRendering(const ::Ice::Context& __ctx, const ::omero::model::Callback_RenderingDef_copyWaveRenderingPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_copyWaveRendering(&__ctx, __del, __cookie);
    }

    ::omero::model::RenderingDefWaveRenderingSeq end_copyWaveRendering(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::model::RenderingDefWaveRenderingSeq copyWaveRendering(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_copyWaveRendering(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void addChannelBinding(const ::omero::model::ChannelBindingPtr& target)
    {
        addChannelBinding(target, 0);
    }
    void addChannelBinding(const ::omero::model::ChannelBindingPtr& target, const ::Ice::Context& __ctx)
    {
        addChannelBinding(target, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_addChannelBinding(const ::omero::model::ChannelBindingPtr& target)
    {
        return begin_addChannelBinding(target, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_addChannelBinding(const ::omero::model::ChannelBindingPtr& target, const ::Ice::Context& __ctx)
    {
        return begin_addChannelBinding(target, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_addChannelBinding(const ::omero::model::ChannelBindingPtr& target, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_addChannelBinding(target, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_addChannelBinding(const ::omero::model::ChannelBindingPtr& target, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_addChannelBinding(target, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_addChannelBinding(const ::omero::model::ChannelBindingPtr& target, const ::omero::model::Callback_RenderingDef_addChannelBindingPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_addChannelBinding(target, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_addChannelBinding(const ::omero::model::ChannelBindingPtr& target, const ::Ice::Context& __ctx, const ::omero::model::Callback_RenderingDef_addChannelBindingPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_addChannelBinding(target, &__ctx, __del, __cookie);
    }

    void end_addChannelBinding(const ::Ice::AsyncResultPtr&);
    
private:

    void addChannelBinding(const ::omero::model::ChannelBindingPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_addChannelBinding(const ::omero::model::ChannelBindingPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void addAllChannelBindingSet(const ::omero::model::RenderingDefWaveRenderingSeq& targets)
    {
        addAllChannelBindingSet(targets, 0);
    }
    void addAllChannelBindingSet(const ::omero::model::RenderingDefWaveRenderingSeq& targets, const ::Ice::Context& __ctx)
    {
        addAllChannelBindingSet(targets, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_addAllChannelBindingSet(const ::omero::model::RenderingDefWaveRenderingSeq& targets)
    {
        return begin_addAllChannelBindingSet(targets, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_addAllChannelBindingSet(const ::omero::model::RenderingDefWaveRenderingSeq& targets, const ::Ice::Context& __ctx)
    {
        return begin_addAllChannelBindingSet(targets, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_addAllChannelBindingSet(const ::omero::model::RenderingDefWaveRenderingSeq& targets, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_addAllChannelBindingSet(targets, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_addAllChannelBindingSet(const ::omero::model::RenderingDefWaveRenderingSeq& targets, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_addAllChannelBindingSet(targets, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_addAllChannelBindingSet(const ::omero::model::RenderingDefWaveRenderingSeq& targets, const ::omero::model::Callback_RenderingDef_addAllChannelBindingSetPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_addAllChannelBindingSet(targets, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_addAllChannelBindingSet(const ::omero::model::RenderingDefWaveRenderingSeq& targets, const ::Ice::Context& __ctx, const ::omero::model::Callback_RenderingDef_addAllChannelBindingSetPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_addAllChannelBindingSet(targets, &__ctx, __del, __cookie);
    }

    void end_addAllChannelBindingSet(const ::Ice::AsyncResultPtr&);
    
private:

    void addAllChannelBindingSet(const ::omero::model::RenderingDefWaveRenderingSeq&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_addAllChannelBindingSet(const ::omero::model::RenderingDefWaveRenderingSeq&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void removeChannelBinding(const ::omero::model::ChannelBindingPtr& theTarget)
    {
        removeChannelBinding(theTarget, 0);
    }
    void removeChannelBinding(const ::omero::model::ChannelBindingPtr& theTarget, const ::Ice::Context& __ctx)
    {
        removeChannelBinding(theTarget, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_removeChannelBinding(const ::omero::model::ChannelBindingPtr& theTarget)
    {
        return begin_removeChannelBinding(theTarget, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_removeChannelBinding(const ::omero::model::ChannelBindingPtr& theTarget, const ::Ice::Context& __ctx)
    {
        return begin_removeChannelBinding(theTarget, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_removeChannelBinding(const ::omero::model::ChannelBindingPtr& theTarget, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_removeChannelBinding(theTarget, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_removeChannelBinding(const ::omero::model::ChannelBindingPtr& theTarget, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_removeChannelBinding(theTarget, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_removeChannelBinding(const ::omero::model::ChannelBindingPtr& theTarget, const ::omero::model::Callback_RenderingDef_removeChannelBindingPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_removeChannelBinding(theTarget, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_removeChannelBinding(const ::omero::model::ChannelBindingPtr& theTarget, const ::Ice::Context& __ctx, const ::omero::model::Callback_RenderingDef_removeChannelBindingPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_removeChannelBinding(theTarget, &__ctx, __del, __cookie);
    }

    void end_removeChannelBinding(const ::Ice::AsyncResultPtr&);
    
private:

    void removeChannelBinding(const ::omero::model::ChannelBindingPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_removeChannelBinding(const ::omero::model::ChannelBindingPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void removeAllChannelBindingSet(const ::omero::model::RenderingDefWaveRenderingSeq& targets)
    {
        removeAllChannelBindingSet(targets, 0);
    }
    void removeAllChannelBindingSet(const ::omero::model::RenderingDefWaveRenderingSeq& targets, const ::Ice::Context& __ctx)
    {
        removeAllChannelBindingSet(targets, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_removeAllChannelBindingSet(const ::omero::model::RenderingDefWaveRenderingSeq& targets)
    {
        return begin_removeAllChannelBindingSet(targets, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_removeAllChannelBindingSet(const ::omero::model::RenderingDefWaveRenderingSeq& targets, const ::Ice::Context& __ctx)
    {
        return begin_removeAllChannelBindingSet(targets, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_removeAllChannelBindingSet(const ::omero::model::RenderingDefWaveRenderingSeq& targets, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_removeAllChannelBindingSet(targets, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_removeAllChannelBindingSet(const ::omero::model::RenderingDefWaveRenderingSeq& targets, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_removeAllChannelBindingSet(targets, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_removeAllChannelBindingSet(const ::omero::model::RenderingDefWaveRenderingSeq& targets, const ::omero::model::Callback_RenderingDef_removeAllChannelBindingSetPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_removeAllChannelBindingSet(targets, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_removeAllChannelBindingSet(const ::omero::model::RenderingDefWaveRenderingSeq& targets, const ::Ice::Context& __ctx, const ::omero::model::Callback_RenderingDef_removeAllChannelBindingSetPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_removeAllChannelBindingSet(targets, &__ctx, __del, __cookie);
    }

    void end_removeAllChannelBindingSet(const ::Ice::AsyncResultPtr&);
    
private:

    void removeAllChannelBindingSet(const ::omero::model::RenderingDefWaveRenderingSeq&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_removeAllChannelBindingSet(const ::omero::model::RenderingDefWaveRenderingSeq&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void clearWaveRendering()
    {
        clearWaveRendering(0);
    }
    void clearWaveRendering(const ::Ice::Context& __ctx)
    {
        clearWaveRendering(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_clearWaveRendering()
    {
        return begin_clearWaveRendering(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_clearWaveRendering(const ::Ice::Context& __ctx)
    {
        return begin_clearWaveRendering(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_clearWaveRendering(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_clearWaveRendering(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_clearWaveRendering(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_clearWaveRendering(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_clearWaveRendering(const ::omero::model::Callback_RenderingDef_clearWaveRenderingPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_clearWaveRendering(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_clearWaveRendering(const ::Ice::Context& __ctx, const ::omero::model::Callback_RenderingDef_clearWaveRenderingPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_clearWaveRendering(&__ctx, __del, __cookie);
    }

    void end_clearWaveRendering(const ::Ice::AsyncResultPtr&);
    
private:

    void clearWaveRendering(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_clearWaveRendering(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void reloadWaveRendering(const ::omero::model::RenderingDefPtr& toCopy)
    {
        reloadWaveRendering(toCopy, 0);
    }
    void reloadWaveRendering(const ::omero::model::RenderingDefPtr& toCopy, const ::Ice::Context& __ctx)
    {
        reloadWaveRendering(toCopy, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_reloadWaveRendering(const ::omero::model::RenderingDefPtr& toCopy)
    {
        return begin_reloadWaveRendering(toCopy, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_reloadWaveRendering(const ::omero::model::RenderingDefPtr& toCopy, const ::Ice::Context& __ctx)
    {
        return begin_reloadWaveRendering(toCopy, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_reloadWaveRendering(const ::omero::model::RenderingDefPtr& toCopy, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_reloadWaveRendering(toCopy, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_reloadWaveRendering(const ::omero::model::RenderingDefPtr& toCopy, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_reloadWaveRendering(toCopy, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_reloadWaveRendering(const ::omero::model::RenderingDefPtr& toCopy, const ::omero::model::Callback_RenderingDef_reloadWaveRenderingPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_reloadWaveRendering(toCopy, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_reloadWaveRendering(const ::omero::model::RenderingDefPtr& toCopy, const ::Ice::Context& __ctx, const ::omero::model::Callback_RenderingDef_reloadWaveRenderingPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_reloadWaveRendering(toCopy, &__ctx, __del, __cookie);
    }

    void end_reloadWaveRendering(const ::Ice::AsyncResultPtr&);
    
private:

    void reloadWaveRendering(const ::omero::model::RenderingDefPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_reloadWaveRendering(const ::omero::model::RenderingDefPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::model::ChannelBindingPtr getChannelBinding(::Ice::Int index)
    {
        return getChannelBinding(index, 0);
    }
    ::omero::model::ChannelBindingPtr getChannelBinding(::Ice::Int index, const ::Ice::Context& __ctx)
    {
        return getChannelBinding(index, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_getChannelBinding(::Ice::Int index)
    {
        return begin_getChannelBinding(index, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getChannelBinding(::Ice::Int index, const ::Ice::Context& __ctx)
    {
        return begin_getChannelBinding(index, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getChannelBinding(::Ice::Int index, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getChannelBinding(index, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getChannelBinding(::Ice::Int index, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getChannelBinding(index, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getChannelBinding(::Ice::Int index, const ::omero::model::Callback_RenderingDef_getChannelBindingPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getChannelBinding(index, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getChannelBinding(::Ice::Int index, const ::Ice::Context& __ctx, const ::omero::model::Callback_RenderingDef_getChannelBindingPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getChannelBinding(index, &__ctx, __del, __cookie);
    }

    ::omero::model::ChannelBindingPtr end_getChannelBinding(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::model::ChannelBindingPtr getChannelBinding(::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getChannelBinding(::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::model::ChannelBindingPtr setChannelBinding(::Ice::Int index, const ::omero::model::ChannelBindingPtr& theElement)
    {
        return setChannelBinding(index, theElement, 0);
    }
    ::omero::model::ChannelBindingPtr setChannelBinding(::Ice::Int index, const ::omero::model::ChannelBindingPtr& theElement, const ::Ice::Context& __ctx)
    {
        return setChannelBinding(index, theElement, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setChannelBinding(::Ice::Int index, const ::omero::model::ChannelBindingPtr& theElement)
    {
        return begin_setChannelBinding(index, theElement, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setChannelBinding(::Ice::Int index, const ::omero::model::ChannelBindingPtr& theElement, const ::Ice::Context& __ctx)
    {
        return begin_setChannelBinding(index, theElement, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setChannelBinding(::Ice::Int index, const ::omero::model::ChannelBindingPtr& theElement, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setChannelBinding(index, theElement, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setChannelBinding(::Ice::Int index, const ::omero::model::ChannelBindingPtr& theElement, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setChannelBinding(index, theElement, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setChannelBinding(::Ice::Int index, const ::omero::model::ChannelBindingPtr& theElement, const ::omero::model::Callback_RenderingDef_setChannelBindingPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setChannelBinding(index, theElement, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setChannelBinding(::Ice::Int index, const ::omero::model::ChannelBindingPtr& theElement, const ::Ice::Context& __ctx, const ::omero::model::Callback_RenderingDef_setChannelBindingPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setChannelBinding(index, theElement, &__ctx, __del, __cookie);
    }

    ::omero::model::ChannelBindingPtr end_setChannelBinding(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::model::ChannelBindingPtr setChannelBinding(::Ice::Int, const ::omero::model::ChannelBindingPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setChannelBinding(::Ice::Int, const ::omero::model::ChannelBindingPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::model::ChannelBindingPtr getPrimaryChannelBinding()
    {
        return getPrimaryChannelBinding(0);
    }
    ::omero::model::ChannelBindingPtr getPrimaryChannelBinding(const ::Ice::Context& __ctx)
    {
        return getPrimaryChannelBinding(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getPrimaryChannelBinding()
    {
        return begin_getPrimaryChannelBinding(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getPrimaryChannelBinding(const ::Ice::Context& __ctx)
    {
        return begin_getPrimaryChannelBinding(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getPrimaryChannelBinding(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getPrimaryChannelBinding(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getPrimaryChannelBinding(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getPrimaryChannelBinding(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getPrimaryChannelBinding(const ::omero::model::Callback_RenderingDef_getPrimaryChannelBindingPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getPrimaryChannelBinding(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getPrimaryChannelBinding(const ::Ice::Context& __ctx, const ::omero::model::Callback_RenderingDef_getPrimaryChannelBindingPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getPrimaryChannelBinding(&__ctx, __del, __cookie);
    }

    ::omero::model::ChannelBindingPtr end_getPrimaryChannelBinding(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::model::ChannelBindingPtr getPrimaryChannelBinding(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getPrimaryChannelBinding(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::model::ChannelBindingPtr setPrimaryChannelBinding(const ::omero::model::ChannelBindingPtr& theElement)
    {
        return setPrimaryChannelBinding(theElement, 0);
    }
    ::omero::model::ChannelBindingPtr setPrimaryChannelBinding(const ::omero::model::ChannelBindingPtr& theElement, const ::Ice::Context& __ctx)
    {
        return setPrimaryChannelBinding(theElement, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setPrimaryChannelBinding(const ::omero::model::ChannelBindingPtr& theElement)
    {
        return begin_setPrimaryChannelBinding(theElement, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setPrimaryChannelBinding(const ::omero::model::ChannelBindingPtr& theElement, const ::Ice::Context& __ctx)
    {
        return begin_setPrimaryChannelBinding(theElement, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setPrimaryChannelBinding(const ::omero::model::ChannelBindingPtr& theElement, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setPrimaryChannelBinding(theElement, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setPrimaryChannelBinding(const ::omero::model::ChannelBindingPtr& theElement, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setPrimaryChannelBinding(theElement, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setPrimaryChannelBinding(const ::omero::model::ChannelBindingPtr& theElement, const ::omero::model::Callback_RenderingDef_setPrimaryChannelBindingPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setPrimaryChannelBinding(theElement, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setPrimaryChannelBinding(const ::omero::model::ChannelBindingPtr& theElement, const ::Ice::Context& __ctx, const ::omero::model::Callback_RenderingDef_setPrimaryChannelBindingPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setPrimaryChannelBinding(theElement, &__ctx, __del, __cookie);
    }

    ::omero::model::ChannelBindingPtr end_setPrimaryChannelBinding(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::model::ChannelBindingPtr setPrimaryChannelBinding(const ::omero::model::ChannelBindingPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setPrimaryChannelBinding(const ::omero::model::ChannelBindingPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::RStringPtr getName()
    {
        return getName(0);
    }
    ::omero::RStringPtr getName(const ::Ice::Context& __ctx)
    {
        return getName(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getName()
    {
        return begin_getName(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getName(const ::Ice::Context& __ctx)
    {
        return begin_getName(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getName(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getName(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getName(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getName(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getName(const ::omero::model::Callback_RenderingDef_getNamePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getName(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getName(const ::Ice::Context& __ctx, const ::omero::model::Callback_RenderingDef_getNamePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getName(&__ctx, __del, __cookie);
    }

    ::omero::RStringPtr end_getName(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::RStringPtr getName(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getName(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setName(const ::omero::RStringPtr& theName)
    {
        setName(theName, 0);
    }
    void setName(const ::omero::RStringPtr& theName, const ::Ice::Context& __ctx)
    {
        setName(theName, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setName(const ::omero::RStringPtr& theName)
    {
        return begin_setName(theName, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setName(const ::omero::RStringPtr& theName, const ::Ice::Context& __ctx)
    {
        return begin_setName(theName, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setName(const ::omero::RStringPtr& theName, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setName(theName, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setName(const ::omero::RStringPtr& theName, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setName(theName, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setName(const ::omero::RStringPtr& theName, const ::omero::model::Callback_RenderingDef_setNamePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setName(theName, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setName(const ::omero::RStringPtr& theName, const ::Ice::Context& __ctx, const ::omero::model::Callback_RenderingDef_setNamePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setName(theName, &__ctx, __del, __cookie);
    }

    void end_setName(const ::Ice::AsyncResultPtr&);
    
private:

    void setName(const ::omero::RStringPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setName(const ::omero::RStringPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::RDoublePtr getCompression()
    {
        return getCompression(0);
    }
    ::omero::RDoublePtr getCompression(const ::Ice::Context& __ctx)
    {
        return getCompression(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getCompression()
    {
        return begin_getCompression(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getCompression(const ::Ice::Context& __ctx)
    {
        return begin_getCompression(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getCompression(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getCompression(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getCompression(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getCompression(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getCompression(const ::omero::model::Callback_RenderingDef_getCompressionPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getCompression(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getCompression(const ::Ice::Context& __ctx, const ::omero::model::Callback_RenderingDef_getCompressionPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getCompression(&__ctx, __del, __cookie);
    }

    ::omero::RDoublePtr end_getCompression(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::RDoublePtr getCompression(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getCompression(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setCompression(const ::omero::RDoublePtr& theCompression)
    {
        setCompression(theCompression, 0);
    }
    void setCompression(const ::omero::RDoublePtr& theCompression, const ::Ice::Context& __ctx)
    {
        setCompression(theCompression, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setCompression(const ::omero::RDoublePtr& theCompression)
    {
        return begin_setCompression(theCompression, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setCompression(const ::omero::RDoublePtr& theCompression, const ::Ice::Context& __ctx)
    {
        return begin_setCompression(theCompression, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setCompression(const ::omero::RDoublePtr& theCompression, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setCompression(theCompression, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setCompression(const ::omero::RDoublePtr& theCompression, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setCompression(theCompression, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setCompression(const ::omero::RDoublePtr& theCompression, const ::omero::model::Callback_RenderingDef_setCompressionPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setCompression(theCompression, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setCompression(const ::omero::RDoublePtr& theCompression, const ::Ice::Context& __ctx, const ::omero::model::Callback_RenderingDef_setCompressionPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setCompression(theCompression, &__ctx, __del, __cookie);
    }

    void end_setCompression(const ::Ice::AsyncResultPtr&);
    
private:

    void setCompression(const ::omero::RDoublePtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setCompression(const ::omero::RDoublePtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::model::QuantumDefPtr getQuantization()
    {
        return getQuantization(0);
    }
    ::omero::model::QuantumDefPtr getQuantization(const ::Ice::Context& __ctx)
    {
        return getQuantization(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getQuantization()
    {
        return begin_getQuantization(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getQuantization(const ::Ice::Context& __ctx)
    {
        return begin_getQuantization(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getQuantization(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getQuantization(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getQuantization(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getQuantization(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getQuantization(const ::omero::model::Callback_RenderingDef_getQuantizationPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getQuantization(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getQuantization(const ::Ice::Context& __ctx, const ::omero::model::Callback_RenderingDef_getQuantizationPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getQuantization(&__ctx, __del, __cookie);
    }

    ::omero::model::QuantumDefPtr end_getQuantization(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::model::QuantumDefPtr getQuantization(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getQuantization(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setQuantization(const ::omero::model::QuantumDefPtr& theQuantization)
    {
        setQuantization(theQuantization, 0);
    }
    void setQuantization(const ::omero::model::QuantumDefPtr& theQuantization, const ::Ice::Context& __ctx)
    {
        setQuantization(theQuantization, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setQuantization(const ::omero::model::QuantumDefPtr& theQuantization)
    {
        return begin_setQuantization(theQuantization, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setQuantization(const ::omero::model::QuantumDefPtr& theQuantization, const ::Ice::Context& __ctx)
    {
        return begin_setQuantization(theQuantization, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setQuantization(const ::omero::model::QuantumDefPtr& theQuantization, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setQuantization(theQuantization, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setQuantization(const ::omero::model::QuantumDefPtr& theQuantization, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setQuantization(theQuantization, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setQuantization(const ::omero::model::QuantumDefPtr& theQuantization, const ::omero::model::Callback_RenderingDef_setQuantizationPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setQuantization(theQuantization, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setQuantization(const ::omero::model::QuantumDefPtr& theQuantization, const ::Ice::Context& __ctx, const ::omero::model::Callback_RenderingDef_setQuantizationPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setQuantization(theQuantization, &__ctx, __del, __cookie);
    }

    void end_setQuantization(const ::Ice::AsyncResultPtr&);
    
private:

    void setQuantization(const ::omero::model::QuantumDefPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setQuantization(const ::omero::model::QuantumDefPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void unloadSpatialDomainEnhancement()
    {
        unloadSpatialDomainEnhancement(0);
    }
    void unloadSpatialDomainEnhancement(const ::Ice::Context& __ctx)
    {
        unloadSpatialDomainEnhancement(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_unloadSpatialDomainEnhancement()
    {
        return begin_unloadSpatialDomainEnhancement(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_unloadSpatialDomainEnhancement(const ::Ice::Context& __ctx)
    {
        return begin_unloadSpatialDomainEnhancement(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_unloadSpatialDomainEnhancement(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_unloadSpatialDomainEnhancement(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_unloadSpatialDomainEnhancement(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_unloadSpatialDomainEnhancement(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_unloadSpatialDomainEnhancement(const ::omero::model::Callback_RenderingDef_unloadSpatialDomainEnhancementPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_unloadSpatialDomainEnhancement(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_unloadSpatialDomainEnhancement(const ::Ice::Context& __ctx, const ::omero::model::Callback_RenderingDef_unloadSpatialDomainEnhancementPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_unloadSpatialDomainEnhancement(&__ctx, __del, __cookie);
    }

    void end_unloadSpatialDomainEnhancement(const ::Ice::AsyncResultPtr&);
    
private:

    void unloadSpatialDomainEnhancement(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_unloadSpatialDomainEnhancement(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Int sizeOfSpatialDomainEnhancement()
    {
        return sizeOfSpatialDomainEnhancement(0);
    }
    ::Ice::Int sizeOfSpatialDomainEnhancement(const ::Ice::Context& __ctx)
    {
        return sizeOfSpatialDomainEnhancement(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_sizeOfSpatialDomainEnhancement()
    {
        return begin_sizeOfSpatialDomainEnhancement(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_sizeOfSpatialDomainEnhancement(const ::Ice::Context& __ctx)
    {
        return begin_sizeOfSpatialDomainEnhancement(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_sizeOfSpatialDomainEnhancement(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_sizeOfSpatialDomainEnhancement(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_sizeOfSpatialDomainEnhancement(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_sizeOfSpatialDomainEnhancement(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_sizeOfSpatialDomainEnhancement(const ::omero::model::Callback_RenderingDef_sizeOfSpatialDomainEnhancementPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_sizeOfSpatialDomainEnhancement(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_sizeOfSpatialDomainEnhancement(const ::Ice::Context& __ctx, const ::omero::model::Callback_RenderingDef_sizeOfSpatialDomainEnhancementPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_sizeOfSpatialDomainEnhancement(&__ctx, __del, __cookie);
    }

    ::Ice::Int end_sizeOfSpatialDomainEnhancement(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int sizeOfSpatialDomainEnhancement(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_sizeOfSpatialDomainEnhancement(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::model::RenderingDefSpatialDomainEnhancementSeq copySpatialDomainEnhancement()
    {
        return copySpatialDomainEnhancement(0);
    }
    ::omero::model::RenderingDefSpatialDomainEnhancementSeq copySpatialDomainEnhancement(const ::Ice::Context& __ctx)
    {
        return copySpatialDomainEnhancement(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_copySpatialDomainEnhancement()
    {
        return begin_copySpatialDomainEnhancement(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_copySpatialDomainEnhancement(const ::Ice::Context& __ctx)
    {
        return begin_copySpatialDomainEnhancement(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_copySpatialDomainEnhancement(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_copySpatialDomainEnhancement(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_copySpatialDomainEnhancement(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_copySpatialDomainEnhancement(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_copySpatialDomainEnhancement(const ::omero::model::Callback_RenderingDef_copySpatialDomainEnhancementPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_copySpatialDomainEnhancement(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_copySpatialDomainEnhancement(const ::Ice::Context& __ctx, const ::omero::model::Callback_RenderingDef_copySpatialDomainEnhancementPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_copySpatialDomainEnhancement(&__ctx, __del, __cookie);
    }

    ::omero::model::RenderingDefSpatialDomainEnhancementSeq end_copySpatialDomainEnhancement(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::model::RenderingDefSpatialDomainEnhancementSeq copySpatialDomainEnhancement(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_copySpatialDomainEnhancement(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void addCodomainMapContext(const ::omero::model::CodomainMapContextPtr& target)
    {
        addCodomainMapContext(target, 0);
    }
    void addCodomainMapContext(const ::omero::model::CodomainMapContextPtr& target, const ::Ice::Context& __ctx)
    {
        addCodomainMapContext(target, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_addCodomainMapContext(const ::omero::model::CodomainMapContextPtr& target)
    {
        return begin_addCodomainMapContext(target, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_addCodomainMapContext(const ::omero::model::CodomainMapContextPtr& target, const ::Ice::Context& __ctx)
    {
        return begin_addCodomainMapContext(target, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_addCodomainMapContext(const ::omero::model::CodomainMapContextPtr& target, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_addCodomainMapContext(target, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_addCodomainMapContext(const ::omero::model::CodomainMapContextPtr& target, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_addCodomainMapContext(target, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_addCodomainMapContext(const ::omero::model::CodomainMapContextPtr& target, const ::omero::model::Callback_RenderingDef_addCodomainMapContextPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_addCodomainMapContext(target, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_addCodomainMapContext(const ::omero::model::CodomainMapContextPtr& target, const ::Ice::Context& __ctx, const ::omero::model::Callback_RenderingDef_addCodomainMapContextPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_addCodomainMapContext(target, &__ctx, __del, __cookie);
    }

    void end_addCodomainMapContext(const ::Ice::AsyncResultPtr&);
    
private:

    void addCodomainMapContext(const ::omero::model::CodomainMapContextPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_addCodomainMapContext(const ::omero::model::CodomainMapContextPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void addAllCodomainMapContextSet(const ::omero::model::RenderingDefSpatialDomainEnhancementSeq& targets)
    {
        addAllCodomainMapContextSet(targets, 0);
    }
    void addAllCodomainMapContextSet(const ::omero::model::RenderingDefSpatialDomainEnhancementSeq& targets, const ::Ice::Context& __ctx)
    {
        addAllCodomainMapContextSet(targets, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_addAllCodomainMapContextSet(const ::omero::model::RenderingDefSpatialDomainEnhancementSeq& targets)
    {
        return begin_addAllCodomainMapContextSet(targets, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_addAllCodomainMapContextSet(const ::omero::model::RenderingDefSpatialDomainEnhancementSeq& targets, const ::Ice::Context& __ctx)
    {
        return begin_addAllCodomainMapContextSet(targets, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_addAllCodomainMapContextSet(const ::omero::model::RenderingDefSpatialDomainEnhancementSeq& targets, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_addAllCodomainMapContextSet(targets, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_addAllCodomainMapContextSet(const ::omero::model::RenderingDefSpatialDomainEnhancementSeq& targets, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_addAllCodomainMapContextSet(targets, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_addAllCodomainMapContextSet(const ::omero::model::RenderingDefSpatialDomainEnhancementSeq& targets, const ::omero::model::Callback_RenderingDef_addAllCodomainMapContextSetPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_addAllCodomainMapContextSet(targets, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_addAllCodomainMapContextSet(const ::omero::model::RenderingDefSpatialDomainEnhancementSeq& targets, const ::Ice::Context& __ctx, const ::omero::model::Callback_RenderingDef_addAllCodomainMapContextSetPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_addAllCodomainMapContextSet(targets, &__ctx, __del, __cookie);
    }

    void end_addAllCodomainMapContextSet(const ::Ice::AsyncResultPtr&);
    
private:

    void addAllCodomainMapContextSet(const ::omero::model::RenderingDefSpatialDomainEnhancementSeq&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_addAllCodomainMapContextSet(const ::omero::model::RenderingDefSpatialDomainEnhancementSeq&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void removeCodomainMapContext(const ::omero::model::CodomainMapContextPtr& theTarget)
    {
        removeCodomainMapContext(theTarget, 0);
    }
    void removeCodomainMapContext(const ::omero::model::CodomainMapContextPtr& theTarget, const ::Ice::Context& __ctx)
    {
        removeCodomainMapContext(theTarget, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_removeCodomainMapContext(const ::omero::model::CodomainMapContextPtr& theTarget)
    {
        return begin_removeCodomainMapContext(theTarget, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_removeCodomainMapContext(const ::omero::model::CodomainMapContextPtr& theTarget, const ::Ice::Context& __ctx)
    {
        return begin_removeCodomainMapContext(theTarget, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_removeCodomainMapContext(const ::omero::model::CodomainMapContextPtr& theTarget, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_removeCodomainMapContext(theTarget, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_removeCodomainMapContext(const ::omero::model::CodomainMapContextPtr& theTarget, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_removeCodomainMapContext(theTarget, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_removeCodomainMapContext(const ::omero::model::CodomainMapContextPtr& theTarget, const ::omero::model::Callback_RenderingDef_removeCodomainMapContextPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_removeCodomainMapContext(theTarget, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_removeCodomainMapContext(const ::omero::model::CodomainMapContextPtr& theTarget, const ::Ice::Context& __ctx, const ::omero::model::Callback_RenderingDef_removeCodomainMapContextPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_removeCodomainMapContext(theTarget, &__ctx, __del, __cookie);
    }

    void end_removeCodomainMapContext(const ::Ice::AsyncResultPtr&);
    
private:

    void removeCodomainMapContext(const ::omero::model::CodomainMapContextPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_removeCodomainMapContext(const ::omero::model::CodomainMapContextPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void removeAllCodomainMapContextSet(const ::omero::model::RenderingDefSpatialDomainEnhancementSeq& targets)
    {
        removeAllCodomainMapContextSet(targets, 0);
    }
    void removeAllCodomainMapContextSet(const ::omero::model::RenderingDefSpatialDomainEnhancementSeq& targets, const ::Ice::Context& __ctx)
    {
        removeAllCodomainMapContextSet(targets, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_removeAllCodomainMapContextSet(const ::omero::model::RenderingDefSpatialDomainEnhancementSeq& targets)
    {
        return begin_removeAllCodomainMapContextSet(targets, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_removeAllCodomainMapContextSet(const ::omero::model::RenderingDefSpatialDomainEnhancementSeq& targets, const ::Ice::Context& __ctx)
    {
        return begin_removeAllCodomainMapContextSet(targets, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_removeAllCodomainMapContextSet(const ::omero::model::RenderingDefSpatialDomainEnhancementSeq& targets, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_removeAllCodomainMapContextSet(targets, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_removeAllCodomainMapContextSet(const ::omero::model::RenderingDefSpatialDomainEnhancementSeq& targets, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_removeAllCodomainMapContextSet(targets, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_removeAllCodomainMapContextSet(const ::omero::model::RenderingDefSpatialDomainEnhancementSeq& targets, const ::omero::model::Callback_RenderingDef_removeAllCodomainMapContextSetPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_removeAllCodomainMapContextSet(targets, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_removeAllCodomainMapContextSet(const ::omero::model::RenderingDefSpatialDomainEnhancementSeq& targets, const ::Ice::Context& __ctx, const ::omero::model::Callback_RenderingDef_removeAllCodomainMapContextSetPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_removeAllCodomainMapContextSet(targets, &__ctx, __del, __cookie);
    }

    void end_removeAllCodomainMapContextSet(const ::Ice::AsyncResultPtr&);
    
private:

    void removeAllCodomainMapContextSet(const ::omero::model::RenderingDefSpatialDomainEnhancementSeq&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_removeAllCodomainMapContextSet(const ::omero::model::RenderingDefSpatialDomainEnhancementSeq&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void clearSpatialDomainEnhancement()
    {
        clearSpatialDomainEnhancement(0);
    }
    void clearSpatialDomainEnhancement(const ::Ice::Context& __ctx)
    {
        clearSpatialDomainEnhancement(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_clearSpatialDomainEnhancement()
    {
        return begin_clearSpatialDomainEnhancement(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_clearSpatialDomainEnhancement(const ::Ice::Context& __ctx)
    {
        return begin_clearSpatialDomainEnhancement(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_clearSpatialDomainEnhancement(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_clearSpatialDomainEnhancement(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_clearSpatialDomainEnhancement(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_clearSpatialDomainEnhancement(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_clearSpatialDomainEnhancement(const ::omero::model::Callback_RenderingDef_clearSpatialDomainEnhancementPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_clearSpatialDomainEnhancement(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_clearSpatialDomainEnhancement(const ::Ice::Context& __ctx, const ::omero::model::Callback_RenderingDef_clearSpatialDomainEnhancementPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_clearSpatialDomainEnhancement(&__ctx, __del, __cookie);
    }

    void end_clearSpatialDomainEnhancement(const ::Ice::AsyncResultPtr&);
    
private:

    void clearSpatialDomainEnhancement(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_clearSpatialDomainEnhancement(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void reloadSpatialDomainEnhancement(const ::omero::model::RenderingDefPtr& toCopy)
    {
        reloadSpatialDomainEnhancement(toCopy, 0);
    }
    void reloadSpatialDomainEnhancement(const ::omero::model::RenderingDefPtr& toCopy, const ::Ice::Context& __ctx)
    {
        reloadSpatialDomainEnhancement(toCopy, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_reloadSpatialDomainEnhancement(const ::omero::model::RenderingDefPtr& toCopy)
    {
        return begin_reloadSpatialDomainEnhancement(toCopy, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_reloadSpatialDomainEnhancement(const ::omero::model::RenderingDefPtr& toCopy, const ::Ice::Context& __ctx)
    {
        return begin_reloadSpatialDomainEnhancement(toCopy, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_reloadSpatialDomainEnhancement(const ::omero::model::RenderingDefPtr& toCopy, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_reloadSpatialDomainEnhancement(toCopy, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_reloadSpatialDomainEnhancement(const ::omero::model::RenderingDefPtr& toCopy, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_reloadSpatialDomainEnhancement(toCopy, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_reloadSpatialDomainEnhancement(const ::omero::model::RenderingDefPtr& toCopy, const ::omero::model::Callback_RenderingDef_reloadSpatialDomainEnhancementPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_reloadSpatialDomainEnhancement(toCopy, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_reloadSpatialDomainEnhancement(const ::omero::model::RenderingDefPtr& toCopy, const ::Ice::Context& __ctx, const ::omero::model::Callback_RenderingDef_reloadSpatialDomainEnhancementPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_reloadSpatialDomainEnhancement(toCopy, &__ctx, __del, __cookie);
    }

    void end_reloadSpatialDomainEnhancement(const ::Ice::AsyncResultPtr&);
    
private:

    void reloadSpatialDomainEnhancement(const ::omero::model::RenderingDefPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_reloadSpatialDomainEnhancement(const ::omero::model::RenderingDefPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::model::CodomainMapContextPtr getCodomainMapContext(::Ice::Int index)
    {
        return getCodomainMapContext(index, 0);
    }
    ::omero::model::CodomainMapContextPtr getCodomainMapContext(::Ice::Int index, const ::Ice::Context& __ctx)
    {
        return getCodomainMapContext(index, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_getCodomainMapContext(::Ice::Int index)
    {
        return begin_getCodomainMapContext(index, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getCodomainMapContext(::Ice::Int index, const ::Ice::Context& __ctx)
    {
        return begin_getCodomainMapContext(index, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getCodomainMapContext(::Ice::Int index, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getCodomainMapContext(index, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getCodomainMapContext(::Ice::Int index, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getCodomainMapContext(index, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getCodomainMapContext(::Ice::Int index, const ::omero::model::Callback_RenderingDef_getCodomainMapContextPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getCodomainMapContext(index, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getCodomainMapContext(::Ice::Int index, const ::Ice::Context& __ctx, const ::omero::model::Callback_RenderingDef_getCodomainMapContextPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getCodomainMapContext(index, &__ctx, __del, __cookie);
    }

    ::omero::model::CodomainMapContextPtr end_getCodomainMapContext(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::model::CodomainMapContextPtr getCodomainMapContext(::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getCodomainMapContext(::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::model::CodomainMapContextPtr setCodomainMapContext(::Ice::Int index, const ::omero::model::CodomainMapContextPtr& theElement)
    {
        return setCodomainMapContext(index, theElement, 0);
    }
    ::omero::model::CodomainMapContextPtr setCodomainMapContext(::Ice::Int index, const ::omero::model::CodomainMapContextPtr& theElement, const ::Ice::Context& __ctx)
    {
        return setCodomainMapContext(index, theElement, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setCodomainMapContext(::Ice::Int index, const ::omero::model::CodomainMapContextPtr& theElement)
    {
        return begin_setCodomainMapContext(index, theElement, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setCodomainMapContext(::Ice::Int index, const ::omero::model::CodomainMapContextPtr& theElement, const ::Ice::Context& __ctx)
    {
        return begin_setCodomainMapContext(index, theElement, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setCodomainMapContext(::Ice::Int index, const ::omero::model::CodomainMapContextPtr& theElement, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setCodomainMapContext(index, theElement, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setCodomainMapContext(::Ice::Int index, const ::omero::model::CodomainMapContextPtr& theElement, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setCodomainMapContext(index, theElement, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setCodomainMapContext(::Ice::Int index, const ::omero::model::CodomainMapContextPtr& theElement, const ::omero::model::Callback_RenderingDef_setCodomainMapContextPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setCodomainMapContext(index, theElement, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setCodomainMapContext(::Ice::Int index, const ::omero::model::CodomainMapContextPtr& theElement, const ::Ice::Context& __ctx, const ::omero::model::Callback_RenderingDef_setCodomainMapContextPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setCodomainMapContext(index, theElement, &__ctx, __del, __cookie);
    }

    ::omero::model::CodomainMapContextPtr end_setCodomainMapContext(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::model::CodomainMapContextPtr setCodomainMapContext(::Ice::Int, const ::omero::model::CodomainMapContextPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setCodomainMapContext(::Ice::Int, const ::omero::model::CodomainMapContextPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::model::CodomainMapContextPtr getPrimaryCodomainMapContext()
    {
        return getPrimaryCodomainMapContext(0);
    }
    ::omero::model::CodomainMapContextPtr getPrimaryCodomainMapContext(const ::Ice::Context& __ctx)
    {
        return getPrimaryCodomainMapContext(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getPrimaryCodomainMapContext()
    {
        return begin_getPrimaryCodomainMapContext(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getPrimaryCodomainMapContext(const ::Ice::Context& __ctx)
    {
        return begin_getPrimaryCodomainMapContext(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getPrimaryCodomainMapContext(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getPrimaryCodomainMapContext(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getPrimaryCodomainMapContext(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getPrimaryCodomainMapContext(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getPrimaryCodomainMapContext(const ::omero::model::Callback_RenderingDef_getPrimaryCodomainMapContextPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getPrimaryCodomainMapContext(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getPrimaryCodomainMapContext(const ::Ice::Context& __ctx, const ::omero::model::Callback_RenderingDef_getPrimaryCodomainMapContextPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getPrimaryCodomainMapContext(&__ctx, __del, __cookie);
    }

    ::omero::model::CodomainMapContextPtr end_getPrimaryCodomainMapContext(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::model::CodomainMapContextPtr getPrimaryCodomainMapContext(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getPrimaryCodomainMapContext(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::model::CodomainMapContextPtr setPrimaryCodomainMapContext(const ::omero::model::CodomainMapContextPtr& theElement)
    {
        return setPrimaryCodomainMapContext(theElement, 0);
    }
    ::omero::model::CodomainMapContextPtr setPrimaryCodomainMapContext(const ::omero::model::CodomainMapContextPtr& theElement, const ::Ice::Context& __ctx)
    {
        return setPrimaryCodomainMapContext(theElement, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setPrimaryCodomainMapContext(const ::omero::model::CodomainMapContextPtr& theElement)
    {
        return begin_setPrimaryCodomainMapContext(theElement, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setPrimaryCodomainMapContext(const ::omero::model::CodomainMapContextPtr& theElement, const ::Ice::Context& __ctx)
    {
        return begin_setPrimaryCodomainMapContext(theElement, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setPrimaryCodomainMapContext(const ::omero::model::CodomainMapContextPtr& theElement, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setPrimaryCodomainMapContext(theElement, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setPrimaryCodomainMapContext(const ::omero::model::CodomainMapContextPtr& theElement, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setPrimaryCodomainMapContext(theElement, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setPrimaryCodomainMapContext(const ::omero::model::CodomainMapContextPtr& theElement, const ::omero::model::Callback_RenderingDef_setPrimaryCodomainMapContextPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setPrimaryCodomainMapContext(theElement, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setPrimaryCodomainMapContext(const ::omero::model::CodomainMapContextPtr& theElement, const ::Ice::Context& __ctx, const ::omero::model::Callback_RenderingDef_setPrimaryCodomainMapContextPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setPrimaryCodomainMapContext(theElement, &__ctx, __del, __cookie);
    }

    ::omero::model::CodomainMapContextPtr end_setPrimaryCodomainMapContext(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::model::CodomainMapContextPtr setPrimaryCodomainMapContext(const ::omero::model::CodomainMapContextPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setPrimaryCodomainMapContext(const ::omero::model::CodomainMapContextPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    
    ::IceInternal::ProxyHandle<RenderingDef> ice_context(const ::Ice::Context& __context) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<RenderingDef*>(_Base::ice_context(__context).get());
    #else
        return dynamic_cast<RenderingDef*>(::IceProxy::Ice::Object::ice_context(__context).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<RenderingDef> ice_adapterId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<RenderingDef*>(_Base::ice_adapterId(__id).get());
    #else
        return dynamic_cast<RenderingDef*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<RenderingDef> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<RenderingDef*>(_Base::ice_endpoints(__endpoints).get());
    #else
        return dynamic_cast<RenderingDef*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<RenderingDef> ice_locatorCacheTimeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<RenderingDef*>(_Base::ice_locatorCacheTimeout(__timeout).get());
    #else
        return dynamic_cast<RenderingDef*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<RenderingDef> ice_connectionCached(bool __cached) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<RenderingDef*>(_Base::ice_connectionCached(__cached).get());
    #else
        return dynamic_cast<RenderingDef*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<RenderingDef> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<RenderingDef*>(_Base::ice_endpointSelection(__est).get());
    #else
        return dynamic_cast<RenderingDef*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<RenderingDef> ice_secure(bool __secure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<RenderingDef*>(_Base::ice_secure(__secure).get());
    #else
        return dynamic_cast<RenderingDef*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<RenderingDef> ice_preferSecure(bool __preferSecure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<RenderingDef*>(_Base::ice_preferSecure(__preferSecure).get());
    #else
        return dynamic_cast<RenderingDef*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<RenderingDef> ice_router(const ::Ice::RouterPrx& __router) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<RenderingDef*>(_Base::ice_router(__router).get());
    #else
        return dynamic_cast<RenderingDef*>(::IceProxy::Ice::Object::ice_router(__router).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<RenderingDef> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<RenderingDef*>(_Base::ice_locator(__locator).get());
    #else
        return dynamic_cast<RenderingDef*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<RenderingDef> ice_collocationOptimized(bool __co) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<RenderingDef*>(_Base::ice_collocationOptimized(__co).get());
    #else
        return dynamic_cast<RenderingDef*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<RenderingDef> ice_twoway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<RenderingDef*>(_Base::ice_twoway().get());
    #else
        return dynamic_cast<RenderingDef*>(::IceProxy::Ice::Object::ice_twoway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<RenderingDef> ice_oneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<RenderingDef*>(_Base::ice_oneway().get());
    #else
        return dynamic_cast<RenderingDef*>(::IceProxy::Ice::Object::ice_oneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<RenderingDef> ice_batchOneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<RenderingDef*>(_Base::ice_batchOneway().get());
    #else
        return dynamic_cast<RenderingDef*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<RenderingDef> ice_datagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<RenderingDef*>(_Base::ice_datagram().get());
    #else
        return dynamic_cast<RenderingDef*>(::IceProxy::Ice::Object::ice_datagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<RenderingDef> ice_batchDatagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<RenderingDef*>(_Base::ice_batchDatagram().get());
    #else
        return dynamic_cast<RenderingDef*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<RenderingDef> ice_compress(bool __compress) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<RenderingDef*>(_Base::ice_compress(__compress).get());
    #else
        return dynamic_cast<RenderingDef*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<RenderingDef> ice_timeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<RenderingDef*>(_Base::ice_timeout(__timeout).get());
    #else
        return dynamic_cast<RenderingDef*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<RenderingDef> ice_connectionId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<RenderingDef*>(_Base::ice_connectionId(__id).get());
    #else
        return dynamic_cast<RenderingDef*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    #endif
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

}

}

}

namespace IceDelegate
{

namespace omero
{

namespace model
{

class RenderingDef : virtual public ::IceDelegate::omero::model::IObject
{
public:

    virtual ::omero::RIntPtr getVersion(const ::Ice::Context*) = 0;

    virtual void setVersion(const ::omero::RIntPtr&, const ::Ice::Context*) = 0;

    virtual ::omero::model::PixelsPtr getPixels(const ::Ice::Context*) = 0;

    virtual void setPixels(const ::omero::model::PixelsPtr&, const ::Ice::Context*) = 0;

    virtual ::omero::RIntPtr getDefaultZ(const ::Ice::Context*) = 0;

    virtual void setDefaultZ(const ::omero::RIntPtr&, const ::Ice::Context*) = 0;

    virtual ::omero::RIntPtr getDefaultT(const ::Ice::Context*) = 0;

    virtual void setDefaultT(const ::omero::RIntPtr&, const ::Ice::Context*) = 0;

    virtual ::omero::model::RenderingModelPtr getModel(const ::Ice::Context*) = 0;

    virtual void setModel(const ::omero::model::RenderingModelPtr&, const ::Ice::Context*) = 0;

    virtual void unloadWaveRendering(const ::Ice::Context*) = 0;

    virtual ::Ice::Int sizeOfWaveRendering(const ::Ice::Context*) = 0;

    virtual ::omero::model::RenderingDefWaveRenderingSeq copyWaveRendering(const ::Ice::Context*) = 0;

    virtual void addChannelBinding(const ::omero::model::ChannelBindingPtr&, const ::Ice::Context*) = 0;

    virtual void addAllChannelBindingSet(const ::omero::model::RenderingDefWaveRenderingSeq&, const ::Ice::Context*) = 0;

    virtual void removeChannelBinding(const ::omero::model::ChannelBindingPtr&, const ::Ice::Context*) = 0;

    virtual void removeAllChannelBindingSet(const ::omero::model::RenderingDefWaveRenderingSeq&, const ::Ice::Context*) = 0;

    virtual void clearWaveRendering(const ::Ice::Context*) = 0;

    virtual void reloadWaveRendering(const ::omero::model::RenderingDefPtr&, const ::Ice::Context*) = 0;

    virtual ::omero::model::ChannelBindingPtr getChannelBinding(::Ice::Int, const ::Ice::Context*) = 0;

    virtual ::omero::model::ChannelBindingPtr setChannelBinding(::Ice::Int, const ::omero::model::ChannelBindingPtr&, const ::Ice::Context*) = 0;

    virtual ::omero::model::ChannelBindingPtr getPrimaryChannelBinding(const ::Ice::Context*) = 0;

    virtual ::omero::model::ChannelBindingPtr setPrimaryChannelBinding(const ::omero::model::ChannelBindingPtr&, const ::Ice::Context*) = 0;

    virtual ::omero::RStringPtr getName(const ::Ice::Context*) = 0;

    virtual void setName(const ::omero::RStringPtr&, const ::Ice::Context*) = 0;

    virtual ::omero::RDoublePtr getCompression(const ::Ice::Context*) = 0;

    virtual void setCompression(const ::omero::RDoublePtr&, const ::Ice::Context*) = 0;

    virtual ::omero::model::QuantumDefPtr getQuantization(const ::Ice::Context*) = 0;

    virtual void setQuantization(const ::omero::model::QuantumDefPtr&, const ::Ice::Context*) = 0;

    virtual void unloadSpatialDomainEnhancement(const ::Ice::Context*) = 0;

    virtual ::Ice::Int sizeOfSpatialDomainEnhancement(const ::Ice::Context*) = 0;

    virtual ::omero::model::RenderingDefSpatialDomainEnhancementSeq copySpatialDomainEnhancement(const ::Ice::Context*) = 0;

    virtual void addCodomainMapContext(const ::omero::model::CodomainMapContextPtr&, const ::Ice::Context*) = 0;

    virtual void addAllCodomainMapContextSet(const ::omero::model::RenderingDefSpatialDomainEnhancementSeq&, const ::Ice::Context*) = 0;

    virtual void removeCodomainMapContext(const ::omero::model::CodomainMapContextPtr&, const ::Ice::Context*) = 0;

    virtual void removeAllCodomainMapContextSet(const ::omero::model::RenderingDefSpatialDomainEnhancementSeq&, const ::Ice::Context*) = 0;

    virtual void clearSpatialDomainEnhancement(const ::Ice::Context*) = 0;

    virtual void reloadSpatialDomainEnhancement(const ::omero::model::RenderingDefPtr&, const ::Ice::Context*) = 0;

    virtual ::omero::model::CodomainMapContextPtr getCodomainMapContext(::Ice::Int, const ::Ice::Context*) = 0;

    virtual ::omero::model::CodomainMapContextPtr setCodomainMapContext(::Ice::Int, const ::omero::model::CodomainMapContextPtr&, const ::Ice::Context*) = 0;

    virtual ::omero::model::CodomainMapContextPtr getPrimaryCodomainMapContext(const ::Ice::Context*) = 0;

    virtual ::omero::model::CodomainMapContextPtr setPrimaryCodomainMapContext(const ::omero::model::CodomainMapContextPtr&, const ::Ice::Context*) = 0;
};

}

}

}

namespace IceDelegateM
{

namespace omero
{

namespace model
{

class RenderingDef : virtual public ::IceDelegate::omero::model::RenderingDef,
                     virtual public ::IceDelegateM::omero::model::IObject
{
public:

    virtual ::omero::RIntPtr getVersion(const ::Ice::Context*);

    virtual void setVersion(const ::omero::RIntPtr&, const ::Ice::Context*);

    virtual ::omero::model::PixelsPtr getPixels(const ::Ice::Context*);

    virtual void setPixels(const ::omero::model::PixelsPtr&, const ::Ice::Context*);

    virtual ::omero::RIntPtr getDefaultZ(const ::Ice::Context*);

    virtual void setDefaultZ(const ::omero::RIntPtr&, const ::Ice::Context*);

    virtual ::omero::RIntPtr getDefaultT(const ::Ice::Context*);

    virtual void setDefaultT(const ::omero::RIntPtr&, const ::Ice::Context*);

    virtual ::omero::model::RenderingModelPtr getModel(const ::Ice::Context*);

    virtual void setModel(const ::omero::model::RenderingModelPtr&, const ::Ice::Context*);

    virtual void unloadWaveRendering(const ::Ice::Context*);

    virtual ::Ice::Int sizeOfWaveRendering(const ::Ice::Context*);

    virtual ::omero::model::RenderingDefWaveRenderingSeq copyWaveRendering(const ::Ice::Context*);

    virtual void addChannelBinding(const ::omero::model::ChannelBindingPtr&, const ::Ice::Context*);

    virtual void addAllChannelBindingSet(const ::omero::model::RenderingDefWaveRenderingSeq&, const ::Ice::Context*);

    virtual void removeChannelBinding(const ::omero::model::ChannelBindingPtr&, const ::Ice::Context*);

    virtual void removeAllChannelBindingSet(const ::omero::model::RenderingDefWaveRenderingSeq&, const ::Ice::Context*);

    virtual void clearWaveRendering(const ::Ice::Context*);

    virtual void reloadWaveRendering(const ::omero::model::RenderingDefPtr&, const ::Ice::Context*);

    virtual ::omero::model::ChannelBindingPtr getChannelBinding(::Ice::Int, const ::Ice::Context*);

    virtual ::omero::model::ChannelBindingPtr setChannelBinding(::Ice::Int, const ::omero::model::ChannelBindingPtr&, const ::Ice::Context*);

    virtual ::omero::model::ChannelBindingPtr getPrimaryChannelBinding(const ::Ice::Context*);

    virtual ::omero::model::ChannelBindingPtr setPrimaryChannelBinding(const ::omero::model::ChannelBindingPtr&, const ::Ice::Context*);

    virtual ::omero::RStringPtr getName(const ::Ice::Context*);

    virtual void setName(const ::omero::RStringPtr&, const ::Ice::Context*);

    virtual ::omero::RDoublePtr getCompression(const ::Ice::Context*);

    virtual void setCompression(const ::omero::RDoublePtr&, const ::Ice::Context*);

    virtual ::omero::model::QuantumDefPtr getQuantization(const ::Ice::Context*);

    virtual void setQuantization(const ::omero::model::QuantumDefPtr&, const ::Ice::Context*);

    virtual void unloadSpatialDomainEnhancement(const ::Ice::Context*);

    virtual ::Ice::Int sizeOfSpatialDomainEnhancement(const ::Ice::Context*);

    virtual ::omero::model::RenderingDefSpatialDomainEnhancementSeq copySpatialDomainEnhancement(const ::Ice::Context*);

    virtual void addCodomainMapContext(const ::omero::model::CodomainMapContextPtr&, const ::Ice::Context*);

    virtual void addAllCodomainMapContextSet(const ::omero::model::RenderingDefSpatialDomainEnhancementSeq&, const ::Ice::Context*);

    virtual void removeCodomainMapContext(const ::omero::model::CodomainMapContextPtr&, const ::Ice::Context*);

    virtual void removeAllCodomainMapContextSet(const ::omero::model::RenderingDefSpatialDomainEnhancementSeq&, const ::Ice::Context*);

    virtual void clearSpatialDomainEnhancement(const ::Ice::Context*);

    virtual void reloadSpatialDomainEnhancement(const ::omero::model::RenderingDefPtr&, const ::Ice::Context*);

    virtual ::omero::model::CodomainMapContextPtr getCodomainMapContext(::Ice::Int, const ::Ice::Context*);

    virtual ::omero::model::CodomainMapContextPtr setCodomainMapContext(::Ice::Int, const ::omero::model::CodomainMapContextPtr&, const ::Ice::Context*);

    virtual ::omero::model::CodomainMapContextPtr getPrimaryCodomainMapContext(const ::Ice::Context*);

    virtual ::omero::model::CodomainMapContextPtr setPrimaryCodomainMapContext(const ::omero::model::CodomainMapContextPtr&, const ::Ice::Context*);
};

}

}

}

namespace IceDelegateD
{

namespace omero
{

namespace model
{

class RenderingDef : virtual public ::IceDelegate::omero::model::RenderingDef,
                     virtual public ::IceDelegateD::omero::model::IObject
{
public:

    virtual ::omero::RIntPtr getVersion(const ::Ice::Context*);

    virtual void setVersion(const ::omero::RIntPtr&, const ::Ice::Context*);

    virtual ::omero::model::PixelsPtr getPixels(const ::Ice::Context*);

    virtual void setPixels(const ::omero::model::PixelsPtr&, const ::Ice::Context*);

    virtual ::omero::RIntPtr getDefaultZ(const ::Ice::Context*);

    virtual void setDefaultZ(const ::omero::RIntPtr&, const ::Ice::Context*);

    virtual ::omero::RIntPtr getDefaultT(const ::Ice::Context*);

    virtual void setDefaultT(const ::omero::RIntPtr&, const ::Ice::Context*);

    virtual ::omero::model::RenderingModelPtr getModel(const ::Ice::Context*);

    virtual void setModel(const ::omero::model::RenderingModelPtr&, const ::Ice::Context*);

    virtual void unloadWaveRendering(const ::Ice::Context*);

    virtual ::Ice::Int sizeOfWaveRendering(const ::Ice::Context*);

    virtual ::omero::model::RenderingDefWaveRenderingSeq copyWaveRendering(const ::Ice::Context*);

    virtual void addChannelBinding(const ::omero::model::ChannelBindingPtr&, const ::Ice::Context*);

    virtual void addAllChannelBindingSet(const ::omero::model::RenderingDefWaveRenderingSeq&, const ::Ice::Context*);

    virtual void removeChannelBinding(const ::omero::model::ChannelBindingPtr&, const ::Ice::Context*);

    virtual void removeAllChannelBindingSet(const ::omero::model::RenderingDefWaveRenderingSeq&, const ::Ice::Context*);

    virtual void clearWaveRendering(const ::Ice::Context*);

    virtual void reloadWaveRendering(const ::omero::model::RenderingDefPtr&, const ::Ice::Context*);

    virtual ::omero::model::ChannelBindingPtr getChannelBinding(::Ice::Int, const ::Ice::Context*);

    virtual ::omero::model::ChannelBindingPtr setChannelBinding(::Ice::Int, const ::omero::model::ChannelBindingPtr&, const ::Ice::Context*);

    virtual ::omero::model::ChannelBindingPtr getPrimaryChannelBinding(const ::Ice::Context*);

    virtual ::omero::model::ChannelBindingPtr setPrimaryChannelBinding(const ::omero::model::ChannelBindingPtr&, const ::Ice::Context*);

    virtual ::omero::RStringPtr getName(const ::Ice::Context*);

    virtual void setName(const ::omero::RStringPtr&, const ::Ice::Context*);

    virtual ::omero::RDoublePtr getCompression(const ::Ice::Context*);

    virtual void setCompression(const ::omero::RDoublePtr&, const ::Ice::Context*);

    virtual ::omero::model::QuantumDefPtr getQuantization(const ::Ice::Context*);

    virtual void setQuantization(const ::omero::model::QuantumDefPtr&, const ::Ice::Context*);

    virtual void unloadSpatialDomainEnhancement(const ::Ice::Context*);

    virtual ::Ice::Int sizeOfSpatialDomainEnhancement(const ::Ice::Context*);

    virtual ::omero::model::RenderingDefSpatialDomainEnhancementSeq copySpatialDomainEnhancement(const ::Ice::Context*);

    virtual void addCodomainMapContext(const ::omero::model::CodomainMapContextPtr&, const ::Ice::Context*);

    virtual void addAllCodomainMapContextSet(const ::omero::model::RenderingDefSpatialDomainEnhancementSeq&, const ::Ice::Context*);

    virtual void removeCodomainMapContext(const ::omero::model::CodomainMapContextPtr&, const ::Ice::Context*);

    virtual void removeAllCodomainMapContextSet(const ::omero::model::RenderingDefSpatialDomainEnhancementSeq&, const ::Ice::Context*);

    virtual void clearSpatialDomainEnhancement(const ::Ice::Context*);

    virtual void reloadSpatialDomainEnhancement(const ::omero::model::RenderingDefPtr&, const ::Ice::Context*);

    virtual ::omero::model::CodomainMapContextPtr getCodomainMapContext(::Ice::Int, const ::Ice::Context*);

    virtual ::omero::model::CodomainMapContextPtr setCodomainMapContext(::Ice::Int, const ::omero::model::CodomainMapContextPtr&, const ::Ice::Context*);

    virtual ::omero::model::CodomainMapContextPtr getPrimaryCodomainMapContext(const ::Ice::Context*);

    virtual ::omero::model::CodomainMapContextPtr setPrimaryCodomainMapContext(const ::omero::model::CodomainMapContextPtr&, const ::Ice::Context*);
};

}

}

}

namespace omero
{

namespace model
{

class RenderingDef : public ::omero::model::IObject
{
public:

    typedef RenderingDefPrx ProxyType;
    typedef RenderingDefPtr PointerType;
    
    RenderingDef() {}
    RenderingDef(const ::omero::RLongPtr&, const ::omero::model::DetailsPtr&, bool, const ::omero::RIntPtr&, const ::omero::model::PixelsPtr&, const ::omero::RIntPtr&, const ::omero::RIntPtr&, const ::omero::model::RenderingModelPtr&, const ::omero::model::RenderingDefWaveRenderingSeq&, bool, const ::omero::RStringPtr&, const ::omero::RDoublePtr&, const ::omero::model::QuantumDefPtr&, const ::omero::model::RenderingDefSpatialDomainEnhancementSeq&, bool);
    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void __gcReachable(::IceInternal::GCCountMap&) const;
    virtual void __gcClear();

    virtual ::omero::RIntPtr getVersion(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getVersion(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setVersion(const ::omero::RIntPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setVersion(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::model::PixelsPtr getPixels(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getPixels(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setPixels(const ::omero::model::PixelsPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setPixels(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::RIntPtr getDefaultZ(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getDefaultZ(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setDefaultZ(const ::omero::RIntPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setDefaultZ(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::RIntPtr getDefaultT(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getDefaultT(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setDefaultT(const ::omero::RIntPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setDefaultT(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::model::RenderingModelPtr getModel(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getModel(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setModel(const ::omero::model::RenderingModelPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setModel(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void unloadWaveRendering(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___unloadWaveRendering(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Int sizeOfWaveRendering(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___sizeOfWaveRendering(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::model::RenderingDefWaveRenderingSeq copyWaveRendering(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___copyWaveRendering(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void addChannelBinding(const ::omero::model::ChannelBindingPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___addChannelBinding(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void addAllChannelBindingSet(const ::omero::model::RenderingDefWaveRenderingSeq&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___addAllChannelBindingSet(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void removeChannelBinding(const ::omero::model::ChannelBindingPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___removeChannelBinding(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void removeAllChannelBindingSet(const ::omero::model::RenderingDefWaveRenderingSeq&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___removeAllChannelBindingSet(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void clearWaveRendering(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___clearWaveRendering(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void reloadWaveRendering(const ::omero::model::RenderingDefPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___reloadWaveRendering(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::model::ChannelBindingPtr getChannelBinding(::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getChannelBinding(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::model::ChannelBindingPtr setChannelBinding(::Ice::Int, const ::omero::model::ChannelBindingPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setChannelBinding(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::model::ChannelBindingPtr getPrimaryChannelBinding(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getPrimaryChannelBinding(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::model::ChannelBindingPtr setPrimaryChannelBinding(const ::omero::model::ChannelBindingPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setPrimaryChannelBinding(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::RStringPtr getName(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getName(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setName(const ::omero::RStringPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setName(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::RDoublePtr getCompression(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getCompression(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setCompression(const ::omero::RDoublePtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setCompression(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::model::QuantumDefPtr getQuantization(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getQuantization(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setQuantization(const ::omero::model::QuantumDefPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setQuantization(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void unloadSpatialDomainEnhancement(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___unloadSpatialDomainEnhancement(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Int sizeOfSpatialDomainEnhancement(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___sizeOfSpatialDomainEnhancement(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::model::RenderingDefSpatialDomainEnhancementSeq copySpatialDomainEnhancement(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___copySpatialDomainEnhancement(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void addCodomainMapContext(const ::omero::model::CodomainMapContextPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___addCodomainMapContext(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void addAllCodomainMapContextSet(const ::omero::model::RenderingDefSpatialDomainEnhancementSeq&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___addAllCodomainMapContextSet(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void removeCodomainMapContext(const ::omero::model::CodomainMapContextPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___removeCodomainMapContext(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void removeAllCodomainMapContextSet(const ::omero::model::RenderingDefSpatialDomainEnhancementSeq&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___removeAllCodomainMapContextSet(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void clearSpatialDomainEnhancement(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___clearSpatialDomainEnhancement(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void reloadSpatialDomainEnhancement(const ::omero::model::RenderingDefPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___reloadSpatialDomainEnhancement(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::model::CodomainMapContextPtr getCodomainMapContext(::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getCodomainMapContext(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::model::CodomainMapContextPtr setCodomainMapContext(::Ice::Int, const ::omero::model::CodomainMapContextPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setCodomainMapContext(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::model::CodomainMapContextPtr getPrimaryCodomainMapContext(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getPrimaryCodomainMapContext(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::model::CodomainMapContextPtr setPrimaryCodomainMapContext(const ::omero::model::CodomainMapContextPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setPrimaryCodomainMapContext(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void __write(::IceInternal::BasicStream*) const;
    virtual void __read(::IceInternal::BasicStream*, bool);
// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
    virtual void __write(const ::Ice::OutputStreamPtr&) const;
    virtual void __read(const ::Ice::InputStreamPtr&, bool);
#endif

protected:

    ::omero::RIntPtr version;

    ::omero::model::PixelsPtr pixels;

    ::omero::RIntPtr defaultZ;

    ::omero::RIntPtr defaultT;

    ::omero::model::RenderingModelPtr model;

    ::omero::model::RenderingDefWaveRenderingSeq waveRenderingSeq;

    bool waveRenderingLoaded;

    ::omero::RStringPtr name;

    ::omero::RDoublePtr compression;

    ::omero::model::QuantumDefPtr quantization;

    ::omero::model::RenderingDefSpatialDomainEnhancementSeq spatialDomainEnhancementSeq;

    bool spatialDomainEnhancementLoaded;
};

inline bool operator==(const RenderingDef& l, const RenderingDef& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const RenderingDef& l, const RenderingDef& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

}

}

namespace omero
{

namespace model
{

template<class T>
class CallbackNC_RenderingDef_getVersion : public Callback_RenderingDef_getVersion_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::RIntPtr&);

    CallbackNC_RenderingDef_getVersion(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::RenderingDefPrx __proxy = ::omero::model::RenderingDefPrx::uncheckedCast(__result->getProxy());
        ::omero::RIntPtr __ret;
        try
        {
            __ret = __proxy->end_getVersion(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_RenderingDef_getVersionPtr
newCallback_RenderingDef_getVersion(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RIntPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_getVersion<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RenderingDef_getVersionPtr
newCallback_RenderingDef_getVersion(T* instance, void (T::*cb)(const ::omero::RIntPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_getVersion<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RenderingDef_getVersion : public Callback_RenderingDef_getVersion_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::RIntPtr&, const CT&);

    Callback_RenderingDef_getVersion(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::RenderingDefPrx __proxy = ::omero::model::RenderingDefPrx::uncheckedCast(__result->getProxy());
        ::omero::RIntPtr __ret;
        try
        {
            __ret = __proxy->end_getVersion(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RenderingDef_getVersionPtr
newCallback_RenderingDef_getVersion(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RIntPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_getVersion<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RenderingDef_getVersionPtr
newCallback_RenderingDef_getVersion(T* instance, void (T::*cb)(const ::omero::RIntPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_getVersion<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_RenderingDef_setVersion : public Callback_RenderingDef_setVersion_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_RenderingDef_setVersion(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_RenderingDef_setVersionPtr
newCallback_RenderingDef_setVersion(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_setVersion<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RenderingDef_setVersionPtr
newCallback_RenderingDef_setVersion(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_setVersion<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_RenderingDef_setVersionPtr
newCallback_RenderingDef_setVersion(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_setVersion<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RenderingDef_setVersionPtr
newCallback_RenderingDef_setVersion(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_setVersion<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_RenderingDef_setVersion : public Callback_RenderingDef_setVersion_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_RenderingDef_setVersion(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_RenderingDef_setVersionPtr
newCallback_RenderingDef_setVersion(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_setVersion<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RenderingDef_setVersionPtr
newCallback_RenderingDef_setVersion(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_setVersion<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_RenderingDef_setVersionPtr
newCallback_RenderingDef_setVersion(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_setVersion<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RenderingDef_setVersionPtr
newCallback_RenderingDef_setVersion(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_setVersion<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_RenderingDef_getPixels : public Callback_RenderingDef_getPixels_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::model::PixelsPtr&);

    CallbackNC_RenderingDef_getPixels(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::RenderingDefPrx __proxy = ::omero::model::RenderingDefPrx::uncheckedCast(__result->getProxy());
        ::omero::model::PixelsPtr __ret;
        try
        {
            __ret = __proxy->end_getPixels(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_RenderingDef_getPixelsPtr
newCallback_RenderingDef_getPixels(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::PixelsPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_getPixels<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RenderingDef_getPixelsPtr
newCallback_RenderingDef_getPixels(T* instance, void (T::*cb)(const ::omero::model::PixelsPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_getPixels<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RenderingDef_getPixels : public Callback_RenderingDef_getPixels_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::model::PixelsPtr&, const CT&);

    Callback_RenderingDef_getPixels(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::RenderingDefPrx __proxy = ::omero::model::RenderingDefPrx::uncheckedCast(__result->getProxy());
        ::omero::model::PixelsPtr __ret;
        try
        {
            __ret = __proxy->end_getPixels(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RenderingDef_getPixelsPtr
newCallback_RenderingDef_getPixels(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::PixelsPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_getPixels<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RenderingDef_getPixelsPtr
newCallback_RenderingDef_getPixels(T* instance, void (T::*cb)(const ::omero::model::PixelsPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_getPixels<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_RenderingDef_setPixels : public Callback_RenderingDef_setPixels_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_RenderingDef_setPixels(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_RenderingDef_setPixelsPtr
newCallback_RenderingDef_setPixels(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_setPixels<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RenderingDef_setPixelsPtr
newCallback_RenderingDef_setPixels(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_setPixels<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_RenderingDef_setPixelsPtr
newCallback_RenderingDef_setPixels(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_setPixels<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RenderingDef_setPixelsPtr
newCallback_RenderingDef_setPixels(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_setPixels<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_RenderingDef_setPixels : public Callback_RenderingDef_setPixels_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_RenderingDef_setPixels(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_RenderingDef_setPixelsPtr
newCallback_RenderingDef_setPixels(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_setPixels<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RenderingDef_setPixelsPtr
newCallback_RenderingDef_setPixels(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_setPixels<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_RenderingDef_setPixelsPtr
newCallback_RenderingDef_setPixels(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_setPixels<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RenderingDef_setPixelsPtr
newCallback_RenderingDef_setPixels(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_setPixels<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_RenderingDef_getDefaultZ : public Callback_RenderingDef_getDefaultZ_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::RIntPtr&);

    CallbackNC_RenderingDef_getDefaultZ(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::RenderingDefPrx __proxy = ::omero::model::RenderingDefPrx::uncheckedCast(__result->getProxy());
        ::omero::RIntPtr __ret;
        try
        {
            __ret = __proxy->end_getDefaultZ(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_RenderingDef_getDefaultZPtr
newCallback_RenderingDef_getDefaultZ(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RIntPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_getDefaultZ<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RenderingDef_getDefaultZPtr
newCallback_RenderingDef_getDefaultZ(T* instance, void (T::*cb)(const ::omero::RIntPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_getDefaultZ<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RenderingDef_getDefaultZ : public Callback_RenderingDef_getDefaultZ_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::RIntPtr&, const CT&);

    Callback_RenderingDef_getDefaultZ(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::RenderingDefPrx __proxy = ::omero::model::RenderingDefPrx::uncheckedCast(__result->getProxy());
        ::omero::RIntPtr __ret;
        try
        {
            __ret = __proxy->end_getDefaultZ(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RenderingDef_getDefaultZPtr
newCallback_RenderingDef_getDefaultZ(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RIntPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_getDefaultZ<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RenderingDef_getDefaultZPtr
newCallback_RenderingDef_getDefaultZ(T* instance, void (T::*cb)(const ::omero::RIntPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_getDefaultZ<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_RenderingDef_setDefaultZ : public Callback_RenderingDef_setDefaultZ_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_RenderingDef_setDefaultZ(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_RenderingDef_setDefaultZPtr
newCallback_RenderingDef_setDefaultZ(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_setDefaultZ<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RenderingDef_setDefaultZPtr
newCallback_RenderingDef_setDefaultZ(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_setDefaultZ<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_RenderingDef_setDefaultZPtr
newCallback_RenderingDef_setDefaultZ(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_setDefaultZ<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RenderingDef_setDefaultZPtr
newCallback_RenderingDef_setDefaultZ(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_setDefaultZ<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_RenderingDef_setDefaultZ : public Callback_RenderingDef_setDefaultZ_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_RenderingDef_setDefaultZ(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_RenderingDef_setDefaultZPtr
newCallback_RenderingDef_setDefaultZ(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_setDefaultZ<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RenderingDef_setDefaultZPtr
newCallback_RenderingDef_setDefaultZ(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_setDefaultZ<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_RenderingDef_setDefaultZPtr
newCallback_RenderingDef_setDefaultZ(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_setDefaultZ<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RenderingDef_setDefaultZPtr
newCallback_RenderingDef_setDefaultZ(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_setDefaultZ<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_RenderingDef_getDefaultT : public Callback_RenderingDef_getDefaultT_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::RIntPtr&);

    CallbackNC_RenderingDef_getDefaultT(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::RenderingDefPrx __proxy = ::omero::model::RenderingDefPrx::uncheckedCast(__result->getProxy());
        ::omero::RIntPtr __ret;
        try
        {
            __ret = __proxy->end_getDefaultT(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_RenderingDef_getDefaultTPtr
newCallback_RenderingDef_getDefaultT(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RIntPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_getDefaultT<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RenderingDef_getDefaultTPtr
newCallback_RenderingDef_getDefaultT(T* instance, void (T::*cb)(const ::omero::RIntPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_getDefaultT<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RenderingDef_getDefaultT : public Callback_RenderingDef_getDefaultT_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::RIntPtr&, const CT&);

    Callback_RenderingDef_getDefaultT(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::RenderingDefPrx __proxy = ::omero::model::RenderingDefPrx::uncheckedCast(__result->getProxy());
        ::omero::RIntPtr __ret;
        try
        {
            __ret = __proxy->end_getDefaultT(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RenderingDef_getDefaultTPtr
newCallback_RenderingDef_getDefaultT(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RIntPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_getDefaultT<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RenderingDef_getDefaultTPtr
newCallback_RenderingDef_getDefaultT(T* instance, void (T::*cb)(const ::omero::RIntPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_getDefaultT<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_RenderingDef_setDefaultT : public Callback_RenderingDef_setDefaultT_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_RenderingDef_setDefaultT(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_RenderingDef_setDefaultTPtr
newCallback_RenderingDef_setDefaultT(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_setDefaultT<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RenderingDef_setDefaultTPtr
newCallback_RenderingDef_setDefaultT(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_setDefaultT<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_RenderingDef_setDefaultTPtr
newCallback_RenderingDef_setDefaultT(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_setDefaultT<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RenderingDef_setDefaultTPtr
newCallback_RenderingDef_setDefaultT(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_setDefaultT<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_RenderingDef_setDefaultT : public Callback_RenderingDef_setDefaultT_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_RenderingDef_setDefaultT(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_RenderingDef_setDefaultTPtr
newCallback_RenderingDef_setDefaultT(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_setDefaultT<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RenderingDef_setDefaultTPtr
newCallback_RenderingDef_setDefaultT(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_setDefaultT<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_RenderingDef_setDefaultTPtr
newCallback_RenderingDef_setDefaultT(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_setDefaultT<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RenderingDef_setDefaultTPtr
newCallback_RenderingDef_setDefaultT(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_setDefaultT<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_RenderingDef_getModel : public Callback_RenderingDef_getModel_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::model::RenderingModelPtr&);

    CallbackNC_RenderingDef_getModel(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::RenderingDefPrx __proxy = ::omero::model::RenderingDefPrx::uncheckedCast(__result->getProxy());
        ::omero::model::RenderingModelPtr __ret;
        try
        {
            __ret = __proxy->end_getModel(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_RenderingDef_getModelPtr
newCallback_RenderingDef_getModel(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::RenderingModelPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_getModel<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RenderingDef_getModelPtr
newCallback_RenderingDef_getModel(T* instance, void (T::*cb)(const ::omero::model::RenderingModelPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_getModel<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RenderingDef_getModel : public Callback_RenderingDef_getModel_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::model::RenderingModelPtr&, const CT&);

    Callback_RenderingDef_getModel(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::RenderingDefPrx __proxy = ::omero::model::RenderingDefPrx::uncheckedCast(__result->getProxy());
        ::omero::model::RenderingModelPtr __ret;
        try
        {
            __ret = __proxy->end_getModel(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RenderingDef_getModelPtr
newCallback_RenderingDef_getModel(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::RenderingModelPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_getModel<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RenderingDef_getModelPtr
newCallback_RenderingDef_getModel(T* instance, void (T::*cb)(const ::omero::model::RenderingModelPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_getModel<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_RenderingDef_setModel : public Callback_RenderingDef_setModel_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_RenderingDef_setModel(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_RenderingDef_setModelPtr
newCallback_RenderingDef_setModel(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_setModel<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RenderingDef_setModelPtr
newCallback_RenderingDef_setModel(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_setModel<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_RenderingDef_setModelPtr
newCallback_RenderingDef_setModel(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_setModel<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RenderingDef_setModelPtr
newCallback_RenderingDef_setModel(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_setModel<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_RenderingDef_setModel : public Callback_RenderingDef_setModel_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_RenderingDef_setModel(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_RenderingDef_setModelPtr
newCallback_RenderingDef_setModel(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_setModel<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RenderingDef_setModelPtr
newCallback_RenderingDef_setModel(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_setModel<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_RenderingDef_setModelPtr
newCallback_RenderingDef_setModel(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_setModel<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RenderingDef_setModelPtr
newCallback_RenderingDef_setModel(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_setModel<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_RenderingDef_unloadWaveRendering : public Callback_RenderingDef_unloadWaveRendering_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_RenderingDef_unloadWaveRendering(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_RenderingDef_unloadWaveRenderingPtr
newCallback_RenderingDef_unloadWaveRendering(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_unloadWaveRendering<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RenderingDef_unloadWaveRenderingPtr
newCallback_RenderingDef_unloadWaveRendering(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_unloadWaveRendering<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_RenderingDef_unloadWaveRenderingPtr
newCallback_RenderingDef_unloadWaveRendering(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_unloadWaveRendering<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RenderingDef_unloadWaveRenderingPtr
newCallback_RenderingDef_unloadWaveRendering(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_unloadWaveRendering<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_RenderingDef_unloadWaveRendering : public Callback_RenderingDef_unloadWaveRendering_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_RenderingDef_unloadWaveRendering(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_RenderingDef_unloadWaveRenderingPtr
newCallback_RenderingDef_unloadWaveRendering(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_unloadWaveRendering<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RenderingDef_unloadWaveRenderingPtr
newCallback_RenderingDef_unloadWaveRendering(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_unloadWaveRendering<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_RenderingDef_unloadWaveRenderingPtr
newCallback_RenderingDef_unloadWaveRendering(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_unloadWaveRendering<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RenderingDef_unloadWaveRenderingPtr
newCallback_RenderingDef_unloadWaveRendering(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_unloadWaveRendering<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_RenderingDef_sizeOfWaveRendering : public Callback_RenderingDef_sizeOfWaveRendering_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int);

    CallbackNC_RenderingDef_sizeOfWaveRendering(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::RenderingDefPrx __proxy = ::omero::model::RenderingDefPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_sizeOfWaveRendering(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_RenderingDef_sizeOfWaveRenderingPtr
newCallback_RenderingDef_sizeOfWaveRendering(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_sizeOfWaveRendering<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RenderingDef_sizeOfWaveRenderingPtr
newCallback_RenderingDef_sizeOfWaveRendering(T* instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_sizeOfWaveRendering<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RenderingDef_sizeOfWaveRendering : public Callback_RenderingDef_sizeOfWaveRendering_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const CT&);

    Callback_RenderingDef_sizeOfWaveRendering(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::RenderingDefPrx __proxy = ::omero::model::RenderingDefPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_sizeOfWaveRendering(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RenderingDef_sizeOfWaveRenderingPtr
newCallback_RenderingDef_sizeOfWaveRendering(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_sizeOfWaveRendering<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RenderingDef_sizeOfWaveRenderingPtr
newCallback_RenderingDef_sizeOfWaveRendering(T* instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_sizeOfWaveRendering<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_RenderingDef_copyWaveRendering : public Callback_RenderingDef_copyWaveRendering_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::model::RenderingDefWaveRenderingSeq&);

    CallbackNC_RenderingDef_copyWaveRendering(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::RenderingDefPrx __proxy = ::omero::model::RenderingDefPrx::uncheckedCast(__result->getProxy());
        ::omero::model::RenderingDefWaveRenderingSeq __ret;
        try
        {
            __ret = __proxy->end_copyWaveRendering(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_RenderingDef_copyWaveRenderingPtr
newCallback_RenderingDef_copyWaveRendering(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::RenderingDefWaveRenderingSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_copyWaveRendering<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RenderingDef_copyWaveRenderingPtr
newCallback_RenderingDef_copyWaveRendering(T* instance, void (T::*cb)(const ::omero::model::RenderingDefWaveRenderingSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_copyWaveRendering<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RenderingDef_copyWaveRendering : public Callback_RenderingDef_copyWaveRendering_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::model::RenderingDefWaveRenderingSeq&, const CT&);

    Callback_RenderingDef_copyWaveRendering(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::RenderingDefPrx __proxy = ::omero::model::RenderingDefPrx::uncheckedCast(__result->getProxy());
        ::omero::model::RenderingDefWaveRenderingSeq __ret;
        try
        {
            __ret = __proxy->end_copyWaveRendering(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RenderingDef_copyWaveRenderingPtr
newCallback_RenderingDef_copyWaveRendering(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::RenderingDefWaveRenderingSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_copyWaveRendering<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RenderingDef_copyWaveRenderingPtr
newCallback_RenderingDef_copyWaveRendering(T* instance, void (T::*cb)(const ::omero::model::RenderingDefWaveRenderingSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_copyWaveRendering<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_RenderingDef_addChannelBinding : public Callback_RenderingDef_addChannelBinding_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_RenderingDef_addChannelBinding(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_RenderingDef_addChannelBindingPtr
newCallback_RenderingDef_addChannelBinding(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_addChannelBinding<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RenderingDef_addChannelBindingPtr
newCallback_RenderingDef_addChannelBinding(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_addChannelBinding<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_RenderingDef_addChannelBindingPtr
newCallback_RenderingDef_addChannelBinding(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_addChannelBinding<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RenderingDef_addChannelBindingPtr
newCallback_RenderingDef_addChannelBinding(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_addChannelBinding<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_RenderingDef_addChannelBinding : public Callback_RenderingDef_addChannelBinding_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_RenderingDef_addChannelBinding(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_RenderingDef_addChannelBindingPtr
newCallback_RenderingDef_addChannelBinding(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_addChannelBinding<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RenderingDef_addChannelBindingPtr
newCallback_RenderingDef_addChannelBinding(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_addChannelBinding<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_RenderingDef_addChannelBindingPtr
newCallback_RenderingDef_addChannelBinding(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_addChannelBinding<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RenderingDef_addChannelBindingPtr
newCallback_RenderingDef_addChannelBinding(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_addChannelBinding<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_RenderingDef_addAllChannelBindingSet : public Callback_RenderingDef_addAllChannelBindingSet_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_RenderingDef_addAllChannelBindingSet(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_RenderingDef_addAllChannelBindingSetPtr
newCallback_RenderingDef_addAllChannelBindingSet(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_addAllChannelBindingSet<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RenderingDef_addAllChannelBindingSetPtr
newCallback_RenderingDef_addAllChannelBindingSet(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_addAllChannelBindingSet<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_RenderingDef_addAllChannelBindingSetPtr
newCallback_RenderingDef_addAllChannelBindingSet(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_addAllChannelBindingSet<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RenderingDef_addAllChannelBindingSetPtr
newCallback_RenderingDef_addAllChannelBindingSet(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_addAllChannelBindingSet<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_RenderingDef_addAllChannelBindingSet : public Callback_RenderingDef_addAllChannelBindingSet_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_RenderingDef_addAllChannelBindingSet(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_RenderingDef_addAllChannelBindingSetPtr
newCallback_RenderingDef_addAllChannelBindingSet(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_addAllChannelBindingSet<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RenderingDef_addAllChannelBindingSetPtr
newCallback_RenderingDef_addAllChannelBindingSet(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_addAllChannelBindingSet<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_RenderingDef_addAllChannelBindingSetPtr
newCallback_RenderingDef_addAllChannelBindingSet(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_addAllChannelBindingSet<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RenderingDef_addAllChannelBindingSetPtr
newCallback_RenderingDef_addAllChannelBindingSet(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_addAllChannelBindingSet<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_RenderingDef_removeChannelBinding : public Callback_RenderingDef_removeChannelBinding_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_RenderingDef_removeChannelBinding(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_RenderingDef_removeChannelBindingPtr
newCallback_RenderingDef_removeChannelBinding(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_removeChannelBinding<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RenderingDef_removeChannelBindingPtr
newCallback_RenderingDef_removeChannelBinding(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_removeChannelBinding<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_RenderingDef_removeChannelBindingPtr
newCallback_RenderingDef_removeChannelBinding(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_removeChannelBinding<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RenderingDef_removeChannelBindingPtr
newCallback_RenderingDef_removeChannelBinding(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_removeChannelBinding<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_RenderingDef_removeChannelBinding : public Callback_RenderingDef_removeChannelBinding_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_RenderingDef_removeChannelBinding(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_RenderingDef_removeChannelBindingPtr
newCallback_RenderingDef_removeChannelBinding(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_removeChannelBinding<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RenderingDef_removeChannelBindingPtr
newCallback_RenderingDef_removeChannelBinding(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_removeChannelBinding<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_RenderingDef_removeChannelBindingPtr
newCallback_RenderingDef_removeChannelBinding(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_removeChannelBinding<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RenderingDef_removeChannelBindingPtr
newCallback_RenderingDef_removeChannelBinding(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_removeChannelBinding<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_RenderingDef_removeAllChannelBindingSet : public Callback_RenderingDef_removeAllChannelBindingSet_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_RenderingDef_removeAllChannelBindingSet(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_RenderingDef_removeAllChannelBindingSetPtr
newCallback_RenderingDef_removeAllChannelBindingSet(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_removeAllChannelBindingSet<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RenderingDef_removeAllChannelBindingSetPtr
newCallback_RenderingDef_removeAllChannelBindingSet(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_removeAllChannelBindingSet<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_RenderingDef_removeAllChannelBindingSetPtr
newCallback_RenderingDef_removeAllChannelBindingSet(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_removeAllChannelBindingSet<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RenderingDef_removeAllChannelBindingSetPtr
newCallback_RenderingDef_removeAllChannelBindingSet(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_removeAllChannelBindingSet<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_RenderingDef_removeAllChannelBindingSet : public Callback_RenderingDef_removeAllChannelBindingSet_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_RenderingDef_removeAllChannelBindingSet(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_RenderingDef_removeAllChannelBindingSetPtr
newCallback_RenderingDef_removeAllChannelBindingSet(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_removeAllChannelBindingSet<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RenderingDef_removeAllChannelBindingSetPtr
newCallback_RenderingDef_removeAllChannelBindingSet(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_removeAllChannelBindingSet<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_RenderingDef_removeAllChannelBindingSetPtr
newCallback_RenderingDef_removeAllChannelBindingSet(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_removeAllChannelBindingSet<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RenderingDef_removeAllChannelBindingSetPtr
newCallback_RenderingDef_removeAllChannelBindingSet(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_removeAllChannelBindingSet<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_RenderingDef_clearWaveRendering : public Callback_RenderingDef_clearWaveRendering_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_RenderingDef_clearWaveRendering(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_RenderingDef_clearWaveRenderingPtr
newCallback_RenderingDef_clearWaveRendering(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_clearWaveRendering<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RenderingDef_clearWaveRenderingPtr
newCallback_RenderingDef_clearWaveRendering(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_clearWaveRendering<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_RenderingDef_clearWaveRenderingPtr
newCallback_RenderingDef_clearWaveRendering(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_clearWaveRendering<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RenderingDef_clearWaveRenderingPtr
newCallback_RenderingDef_clearWaveRendering(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_clearWaveRendering<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_RenderingDef_clearWaveRendering : public Callback_RenderingDef_clearWaveRendering_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_RenderingDef_clearWaveRendering(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_RenderingDef_clearWaveRenderingPtr
newCallback_RenderingDef_clearWaveRendering(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_clearWaveRendering<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RenderingDef_clearWaveRenderingPtr
newCallback_RenderingDef_clearWaveRendering(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_clearWaveRendering<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_RenderingDef_clearWaveRenderingPtr
newCallback_RenderingDef_clearWaveRendering(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_clearWaveRendering<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RenderingDef_clearWaveRenderingPtr
newCallback_RenderingDef_clearWaveRendering(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_clearWaveRendering<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_RenderingDef_reloadWaveRendering : public Callback_RenderingDef_reloadWaveRendering_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_RenderingDef_reloadWaveRendering(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_RenderingDef_reloadWaveRenderingPtr
newCallback_RenderingDef_reloadWaveRendering(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_reloadWaveRendering<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RenderingDef_reloadWaveRenderingPtr
newCallback_RenderingDef_reloadWaveRendering(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_reloadWaveRendering<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_RenderingDef_reloadWaveRenderingPtr
newCallback_RenderingDef_reloadWaveRendering(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_reloadWaveRendering<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RenderingDef_reloadWaveRenderingPtr
newCallback_RenderingDef_reloadWaveRendering(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_reloadWaveRendering<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_RenderingDef_reloadWaveRendering : public Callback_RenderingDef_reloadWaveRendering_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_RenderingDef_reloadWaveRendering(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_RenderingDef_reloadWaveRenderingPtr
newCallback_RenderingDef_reloadWaveRendering(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_reloadWaveRendering<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RenderingDef_reloadWaveRenderingPtr
newCallback_RenderingDef_reloadWaveRendering(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_reloadWaveRendering<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_RenderingDef_reloadWaveRenderingPtr
newCallback_RenderingDef_reloadWaveRendering(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_reloadWaveRendering<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RenderingDef_reloadWaveRenderingPtr
newCallback_RenderingDef_reloadWaveRendering(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_reloadWaveRendering<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_RenderingDef_getChannelBinding : public Callback_RenderingDef_getChannelBinding_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::model::ChannelBindingPtr&);

    CallbackNC_RenderingDef_getChannelBinding(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::RenderingDefPrx __proxy = ::omero::model::RenderingDefPrx::uncheckedCast(__result->getProxy());
        ::omero::model::ChannelBindingPtr __ret;
        try
        {
            __ret = __proxy->end_getChannelBinding(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_RenderingDef_getChannelBindingPtr
newCallback_RenderingDef_getChannelBinding(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::ChannelBindingPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_getChannelBinding<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RenderingDef_getChannelBindingPtr
newCallback_RenderingDef_getChannelBinding(T* instance, void (T::*cb)(const ::omero::model::ChannelBindingPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_getChannelBinding<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RenderingDef_getChannelBinding : public Callback_RenderingDef_getChannelBinding_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::model::ChannelBindingPtr&, const CT&);

    Callback_RenderingDef_getChannelBinding(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::RenderingDefPrx __proxy = ::omero::model::RenderingDefPrx::uncheckedCast(__result->getProxy());
        ::omero::model::ChannelBindingPtr __ret;
        try
        {
            __ret = __proxy->end_getChannelBinding(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RenderingDef_getChannelBindingPtr
newCallback_RenderingDef_getChannelBinding(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::ChannelBindingPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_getChannelBinding<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RenderingDef_getChannelBindingPtr
newCallback_RenderingDef_getChannelBinding(T* instance, void (T::*cb)(const ::omero::model::ChannelBindingPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_getChannelBinding<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_RenderingDef_setChannelBinding : public Callback_RenderingDef_setChannelBinding_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::model::ChannelBindingPtr&);

    CallbackNC_RenderingDef_setChannelBinding(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::RenderingDefPrx __proxy = ::omero::model::RenderingDefPrx::uncheckedCast(__result->getProxy());
        ::omero::model::ChannelBindingPtr __ret;
        try
        {
            __ret = __proxy->end_setChannelBinding(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_RenderingDef_setChannelBindingPtr
newCallback_RenderingDef_setChannelBinding(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::ChannelBindingPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_setChannelBinding<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RenderingDef_setChannelBindingPtr
newCallback_RenderingDef_setChannelBinding(T* instance, void (T::*cb)(const ::omero::model::ChannelBindingPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_setChannelBinding<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RenderingDef_setChannelBinding : public Callback_RenderingDef_setChannelBinding_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::model::ChannelBindingPtr&, const CT&);

    Callback_RenderingDef_setChannelBinding(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::RenderingDefPrx __proxy = ::omero::model::RenderingDefPrx::uncheckedCast(__result->getProxy());
        ::omero::model::ChannelBindingPtr __ret;
        try
        {
            __ret = __proxy->end_setChannelBinding(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RenderingDef_setChannelBindingPtr
newCallback_RenderingDef_setChannelBinding(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::ChannelBindingPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_setChannelBinding<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RenderingDef_setChannelBindingPtr
newCallback_RenderingDef_setChannelBinding(T* instance, void (T::*cb)(const ::omero::model::ChannelBindingPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_setChannelBinding<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_RenderingDef_getPrimaryChannelBinding : public Callback_RenderingDef_getPrimaryChannelBinding_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::model::ChannelBindingPtr&);

    CallbackNC_RenderingDef_getPrimaryChannelBinding(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::RenderingDefPrx __proxy = ::omero::model::RenderingDefPrx::uncheckedCast(__result->getProxy());
        ::omero::model::ChannelBindingPtr __ret;
        try
        {
            __ret = __proxy->end_getPrimaryChannelBinding(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_RenderingDef_getPrimaryChannelBindingPtr
newCallback_RenderingDef_getPrimaryChannelBinding(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::ChannelBindingPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_getPrimaryChannelBinding<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RenderingDef_getPrimaryChannelBindingPtr
newCallback_RenderingDef_getPrimaryChannelBinding(T* instance, void (T::*cb)(const ::omero::model::ChannelBindingPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_getPrimaryChannelBinding<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RenderingDef_getPrimaryChannelBinding : public Callback_RenderingDef_getPrimaryChannelBinding_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::model::ChannelBindingPtr&, const CT&);

    Callback_RenderingDef_getPrimaryChannelBinding(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::RenderingDefPrx __proxy = ::omero::model::RenderingDefPrx::uncheckedCast(__result->getProxy());
        ::omero::model::ChannelBindingPtr __ret;
        try
        {
            __ret = __proxy->end_getPrimaryChannelBinding(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RenderingDef_getPrimaryChannelBindingPtr
newCallback_RenderingDef_getPrimaryChannelBinding(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::ChannelBindingPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_getPrimaryChannelBinding<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RenderingDef_getPrimaryChannelBindingPtr
newCallback_RenderingDef_getPrimaryChannelBinding(T* instance, void (T::*cb)(const ::omero::model::ChannelBindingPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_getPrimaryChannelBinding<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_RenderingDef_setPrimaryChannelBinding : public Callback_RenderingDef_setPrimaryChannelBinding_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::model::ChannelBindingPtr&);

    CallbackNC_RenderingDef_setPrimaryChannelBinding(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::RenderingDefPrx __proxy = ::omero::model::RenderingDefPrx::uncheckedCast(__result->getProxy());
        ::omero::model::ChannelBindingPtr __ret;
        try
        {
            __ret = __proxy->end_setPrimaryChannelBinding(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_RenderingDef_setPrimaryChannelBindingPtr
newCallback_RenderingDef_setPrimaryChannelBinding(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::ChannelBindingPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_setPrimaryChannelBinding<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RenderingDef_setPrimaryChannelBindingPtr
newCallback_RenderingDef_setPrimaryChannelBinding(T* instance, void (T::*cb)(const ::omero::model::ChannelBindingPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_setPrimaryChannelBinding<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RenderingDef_setPrimaryChannelBinding : public Callback_RenderingDef_setPrimaryChannelBinding_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::model::ChannelBindingPtr&, const CT&);

    Callback_RenderingDef_setPrimaryChannelBinding(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::RenderingDefPrx __proxy = ::omero::model::RenderingDefPrx::uncheckedCast(__result->getProxy());
        ::omero::model::ChannelBindingPtr __ret;
        try
        {
            __ret = __proxy->end_setPrimaryChannelBinding(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RenderingDef_setPrimaryChannelBindingPtr
newCallback_RenderingDef_setPrimaryChannelBinding(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::ChannelBindingPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_setPrimaryChannelBinding<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RenderingDef_setPrimaryChannelBindingPtr
newCallback_RenderingDef_setPrimaryChannelBinding(T* instance, void (T::*cb)(const ::omero::model::ChannelBindingPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_setPrimaryChannelBinding<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_RenderingDef_getName : public Callback_RenderingDef_getName_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::RStringPtr&);

    CallbackNC_RenderingDef_getName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::RenderingDefPrx __proxy = ::omero::model::RenderingDefPrx::uncheckedCast(__result->getProxy());
        ::omero::RStringPtr __ret;
        try
        {
            __ret = __proxy->end_getName(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_RenderingDef_getNamePtr
newCallback_RenderingDef_getName(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RStringPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_getName<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RenderingDef_getNamePtr
newCallback_RenderingDef_getName(T* instance, void (T::*cb)(const ::omero::RStringPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_getName<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RenderingDef_getName : public Callback_RenderingDef_getName_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::RStringPtr&, const CT&);

    Callback_RenderingDef_getName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::RenderingDefPrx __proxy = ::omero::model::RenderingDefPrx::uncheckedCast(__result->getProxy());
        ::omero::RStringPtr __ret;
        try
        {
            __ret = __proxy->end_getName(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RenderingDef_getNamePtr
newCallback_RenderingDef_getName(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RStringPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_getName<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RenderingDef_getNamePtr
newCallback_RenderingDef_getName(T* instance, void (T::*cb)(const ::omero::RStringPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_getName<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_RenderingDef_setName : public Callback_RenderingDef_setName_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_RenderingDef_setName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_RenderingDef_setNamePtr
newCallback_RenderingDef_setName(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_setName<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RenderingDef_setNamePtr
newCallback_RenderingDef_setName(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_setName<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_RenderingDef_setNamePtr
newCallback_RenderingDef_setName(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_setName<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RenderingDef_setNamePtr
newCallback_RenderingDef_setName(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_setName<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_RenderingDef_setName : public Callback_RenderingDef_setName_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_RenderingDef_setName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_RenderingDef_setNamePtr
newCallback_RenderingDef_setName(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_setName<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RenderingDef_setNamePtr
newCallback_RenderingDef_setName(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_setName<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_RenderingDef_setNamePtr
newCallback_RenderingDef_setName(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_setName<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RenderingDef_setNamePtr
newCallback_RenderingDef_setName(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_setName<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_RenderingDef_getCompression : public Callback_RenderingDef_getCompression_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::RDoublePtr&);

    CallbackNC_RenderingDef_getCompression(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::RenderingDefPrx __proxy = ::omero::model::RenderingDefPrx::uncheckedCast(__result->getProxy());
        ::omero::RDoublePtr __ret;
        try
        {
            __ret = __proxy->end_getCompression(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_RenderingDef_getCompressionPtr
newCallback_RenderingDef_getCompression(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RDoublePtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_getCompression<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RenderingDef_getCompressionPtr
newCallback_RenderingDef_getCompression(T* instance, void (T::*cb)(const ::omero::RDoublePtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_getCompression<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RenderingDef_getCompression : public Callback_RenderingDef_getCompression_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::RDoublePtr&, const CT&);

    Callback_RenderingDef_getCompression(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::RenderingDefPrx __proxy = ::omero::model::RenderingDefPrx::uncheckedCast(__result->getProxy());
        ::omero::RDoublePtr __ret;
        try
        {
            __ret = __proxy->end_getCompression(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RenderingDef_getCompressionPtr
newCallback_RenderingDef_getCompression(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RDoublePtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_getCompression<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RenderingDef_getCompressionPtr
newCallback_RenderingDef_getCompression(T* instance, void (T::*cb)(const ::omero::RDoublePtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_getCompression<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_RenderingDef_setCompression : public Callback_RenderingDef_setCompression_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_RenderingDef_setCompression(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_RenderingDef_setCompressionPtr
newCallback_RenderingDef_setCompression(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_setCompression<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RenderingDef_setCompressionPtr
newCallback_RenderingDef_setCompression(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_setCompression<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_RenderingDef_setCompressionPtr
newCallback_RenderingDef_setCompression(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_setCompression<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RenderingDef_setCompressionPtr
newCallback_RenderingDef_setCompression(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_setCompression<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_RenderingDef_setCompression : public Callback_RenderingDef_setCompression_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_RenderingDef_setCompression(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_RenderingDef_setCompressionPtr
newCallback_RenderingDef_setCompression(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_setCompression<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RenderingDef_setCompressionPtr
newCallback_RenderingDef_setCompression(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_setCompression<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_RenderingDef_setCompressionPtr
newCallback_RenderingDef_setCompression(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_setCompression<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RenderingDef_setCompressionPtr
newCallback_RenderingDef_setCompression(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_setCompression<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_RenderingDef_getQuantization : public Callback_RenderingDef_getQuantization_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::model::QuantumDefPtr&);

    CallbackNC_RenderingDef_getQuantization(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::RenderingDefPrx __proxy = ::omero::model::RenderingDefPrx::uncheckedCast(__result->getProxy());
        ::omero::model::QuantumDefPtr __ret;
        try
        {
            __ret = __proxy->end_getQuantization(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_RenderingDef_getQuantizationPtr
newCallback_RenderingDef_getQuantization(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::QuantumDefPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_getQuantization<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RenderingDef_getQuantizationPtr
newCallback_RenderingDef_getQuantization(T* instance, void (T::*cb)(const ::omero::model::QuantumDefPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_getQuantization<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RenderingDef_getQuantization : public Callback_RenderingDef_getQuantization_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::model::QuantumDefPtr&, const CT&);

    Callback_RenderingDef_getQuantization(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::RenderingDefPrx __proxy = ::omero::model::RenderingDefPrx::uncheckedCast(__result->getProxy());
        ::omero::model::QuantumDefPtr __ret;
        try
        {
            __ret = __proxy->end_getQuantization(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RenderingDef_getQuantizationPtr
newCallback_RenderingDef_getQuantization(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::QuantumDefPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_getQuantization<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RenderingDef_getQuantizationPtr
newCallback_RenderingDef_getQuantization(T* instance, void (T::*cb)(const ::omero::model::QuantumDefPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_getQuantization<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_RenderingDef_setQuantization : public Callback_RenderingDef_setQuantization_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_RenderingDef_setQuantization(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_RenderingDef_setQuantizationPtr
newCallback_RenderingDef_setQuantization(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_setQuantization<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RenderingDef_setQuantizationPtr
newCallback_RenderingDef_setQuantization(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_setQuantization<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_RenderingDef_setQuantizationPtr
newCallback_RenderingDef_setQuantization(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_setQuantization<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RenderingDef_setQuantizationPtr
newCallback_RenderingDef_setQuantization(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_setQuantization<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_RenderingDef_setQuantization : public Callback_RenderingDef_setQuantization_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_RenderingDef_setQuantization(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_RenderingDef_setQuantizationPtr
newCallback_RenderingDef_setQuantization(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_setQuantization<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RenderingDef_setQuantizationPtr
newCallback_RenderingDef_setQuantization(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_setQuantization<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_RenderingDef_setQuantizationPtr
newCallback_RenderingDef_setQuantization(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_setQuantization<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RenderingDef_setQuantizationPtr
newCallback_RenderingDef_setQuantization(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_setQuantization<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_RenderingDef_unloadSpatialDomainEnhancement : public Callback_RenderingDef_unloadSpatialDomainEnhancement_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_RenderingDef_unloadSpatialDomainEnhancement(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_RenderingDef_unloadSpatialDomainEnhancementPtr
newCallback_RenderingDef_unloadSpatialDomainEnhancement(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_unloadSpatialDomainEnhancement<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RenderingDef_unloadSpatialDomainEnhancementPtr
newCallback_RenderingDef_unloadSpatialDomainEnhancement(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_unloadSpatialDomainEnhancement<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_RenderingDef_unloadSpatialDomainEnhancementPtr
newCallback_RenderingDef_unloadSpatialDomainEnhancement(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_unloadSpatialDomainEnhancement<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RenderingDef_unloadSpatialDomainEnhancementPtr
newCallback_RenderingDef_unloadSpatialDomainEnhancement(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_unloadSpatialDomainEnhancement<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_RenderingDef_unloadSpatialDomainEnhancement : public Callback_RenderingDef_unloadSpatialDomainEnhancement_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_RenderingDef_unloadSpatialDomainEnhancement(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_RenderingDef_unloadSpatialDomainEnhancementPtr
newCallback_RenderingDef_unloadSpatialDomainEnhancement(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_unloadSpatialDomainEnhancement<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RenderingDef_unloadSpatialDomainEnhancementPtr
newCallback_RenderingDef_unloadSpatialDomainEnhancement(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_unloadSpatialDomainEnhancement<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_RenderingDef_unloadSpatialDomainEnhancementPtr
newCallback_RenderingDef_unloadSpatialDomainEnhancement(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_unloadSpatialDomainEnhancement<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RenderingDef_unloadSpatialDomainEnhancementPtr
newCallback_RenderingDef_unloadSpatialDomainEnhancement(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_unloadSpatialDomainEnhancement<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_RenderingDef_sizeOfSpatialDomainEnhancement : public Callback_RenderingDef_sizeOfSpatialDomainEnhancement_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int);

    CallbackNC_RenderingDef_sizeOfSpatialDomainEnhancement(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::RenderingDefPrx __proxy = ::omero::model::RenderingDefPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_sizeOfSpatialDomainEnhancement(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_RenderingDef_sizeOfSpatialDomainEnhancementPtr
newCallback_RenderingDef_sizeOfSpatialDomainEnhancement(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_sizeOfSpatialDomainEnhancement<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RenderingDef_sizeOfSpatialDomainEnhancementPtr
newCallback_RenderingDef_sizeOfSpatialDomainEnhancement(T* instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_sizeOfSpatialDomainEnhancement<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RenderingDef_sizeOfSpatialDomainEnhancement : public Callback_RenderingDef_sizeOfSpatialDomainEnhancement_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const CT&);

    Callback_RenderingDef_sizeOfSpatialDomainEnhancement(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::RenderingDefPrx __proxy = ::omero::model::RenderingDefPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_sizeOfSpatialDomainEnhancement(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RenderingDef_sizeOfSpatialDomainEnhancementPtr
newCallback_RenderingDef_sizeOfSpatialDomainEnhancement(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_sizeOfSpatialDomainEnhancement<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RenderingDef_sizeOfSpatialDomainEnhancementPtr
newCallback_RenderingDef_sizeOfSpatialDomainEnhancement(T* instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_sizeOfSpatialDomainEnhancement<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_RenderingDef_copySpatialDomainEnhancement : public Callback_RenderingDef_copySpatialDomainEnhancement_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::model::RenderingDefSpatialDomainEnhancementSeq&);

    CallbackNC_RenderingDef_copySpatialDomainEnhancement(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::RenderingDefPrx __proxy = ::omero::model::RenderingDefPrx::uncheckedCast(__result->getProxy());
        ::omero::model::RenderingDefSpatialDomainEnhancementSeq __ret;
        try
        {
            __ret = __proxy->end_copySpatialDomainEnhancement(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_RenderingDef_copySpatialDomainEnhancementPtr
newCallback_RenderingDef_copySpatialDomainEnhancement(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::RenderingDefSpatialDomainEnhancementSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_copySpatialDomainEnhancement<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RenderingDef_copySpatialDomainEnhancementPtr
newCallback_RenderingDef_copySpatialDomainEnhancement(T* instance, void (T::*cb)(const ::omero::model::RenderingDefSpatialDomainEnhancementSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_copySpatialDomainEnhancement<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RenderingDef_copySpatialDomainEnhancement : public Callback_RenderingDef_copySpatialDomainEnhancement_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::model::RenderingDefSpatialDomainEnhancementSeq&, const CT&);

    Callback_RenderingDef_copySpatialDomainEnhancement(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::RenderingDefPrx __proxy = ::omero::model::RenderingDefPrx::uncheckedCast(__result->getProxy());
        ::omero::model::RenderingDefSpatialDomainEnhancementSeq __ret;
        try
        {
            __ret = __proxy->end_copySpatialDomainEnhancement(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RenderingDef_copySpatialDomainEnhancementPtr
newCallback_RenderingDef_copySpatialDomainEnhancement(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::RenderingDefSpatialDomainEnhancementSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_copySpatialDomainEnhancement<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RenderingDef_copySpatialDomainEnhancementPtr
newCallback_RenderingDef_copySpatialDomainEnhancement(T* instance, void (T::*cb)(const ::omero::model::RenderingDefSpatialDomainEnhancementSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_copySpatialDomainEnhancement<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_RenderingDef_addCodomainMapContext : public Callback_RenderingDef_addCodomainMapContext_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_RenderingDef_addCodomainMapContext(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_RenderingDef_addCodomainMapContextPtr
newCallback_RenderingDef_addCodomainMapContext(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_addCodomainMapContext<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RenderingDef_addCodomainMapContextPtr
newCallback_RenderingDef_addCodomainMapContext(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_addCodomainMapContext<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_RenderingDef_addCodomainMapContextPtr
newCallback_RenderingDef_addCodomainMapContext(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_addCodomainMapContext<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RenderingDef_addCodomainMapContextPtr
newCallback_RenderingDef_addCodomainMapContext(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_addCodomainMapContext<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_RenderingDef_addCodomainMapContext : public Callback_RenderingDef_addCodomainMapContext_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_RenderingDef_addCodomainMapContext(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_RenderingDef_addCodomainMapContextPtr
newCallback_RenderingDef_addCodomainMapContext(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_addCodomainMapContext<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RenderingDef_addCodomainMapContextPtr
newCallback_RenderingDef_addCodomainMapContext(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_addCodomainMapContext<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_RenderingDef_addCodomainMapContextPtr
newCallback_RenderingDef_addCodomainMapContext(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_addCodomainMapContext<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RenderingDef_addCodomainMapContextPtr
newCallback_RenderingDef_addCodomainMapContext(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_addCodomainMapContext<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_RenderingDef_addAllCodomainMapContextSet : public Callback_RenderingDef_addAllCodomainMapContextSet_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_RenderingDef_addAllCodomainMapContextSet(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_RenderingDef_addAllCodomainMapContextSetPtr
newCallback_RenderingDef_addAllCodomainMapContextSet(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_addAllCodomainMapContextSet<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RenderingDef_addAllCodomainMapContextSetPtr
newCallback_RenderingDef_addAllCodomainMapContextSet(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_addAllCodomainMapContextSet<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_RenderingDef_addAllCodomainMapContextSetPtr
newCallback_RenderingDef_addAllCodomainMapContextSet(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_addAllCodomainMapContextSet<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RenderingDef_addAllCodomainMapContextSetPtr
newCallback_RenderingDef_addAllCodomainMapContextSet(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_addAllCodomainMapContextSet<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_RenderingDef_addAllCodomainMapContextSet : public Callback_RenderingDef_addAllCodomainMapContextSet_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_RenderingDef_addAllCodomainMapContextSet(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_RenderingDef_addAllCodomainMapContextSetPtr
newCallback_RenderingDef_addAllCodomainMapContextSet(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_addAllCodomainMapContextSet<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RenderingDef_addAllCodomainMapContextSetPtr
newCallback_RenderingDef_addAllCodomainMapContextSet(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_addAllCodomainMapContextSet<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_RenderingDef_addAllCodomainMapContextSetPtr
newCallback_RenderingDef_addAllCodomainMapContextSet(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_addAllCodomainMapContextSet<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RenderingDef_addAllCodomainMapContextSetPtr
newCallback_RenderingDef_addAllCodomainMapContextSet(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_addAllCodomainMapContextSet<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_RenderingDef_removeCodomainMapContext : public Callback_RenderingDef_removeCodomainMapContext_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_RenderingDef_removeCodomainMapContext(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_RenderingDef_removeCodomainMapContextPtr
newCallback_RenderingDef_removeCodomainMapContext(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_removeCodomainMapContext<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RenderingDef_removeCodomainMapContextPtr
newCallback_RenderingDef_removeCodomainMapContext(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_removeCodomainMapContext<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_RenderingDef_removeCodomainMapContextPtr
newCallback_RenderingDef_removeCodomainMapContext(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_removeCodomainMapContext<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RenderingDef_removeCodomainMapContextPtr
newCallback_RenderingDef_removeCodomainMapContext(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_removeCodomainMapContext<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_RenderingDef_removeCodomainMapContext : public Callback_RenderingDef_removeCodomainMapContext_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_RenderingDef_removeCodomainMapContext(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_RenderingDef_removeCodomainMapContextPtr
newCallback_RenderingDef_removeCodomainMapContext(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_removeCodomainMapContext<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RenderingDef_removeCodomainMapContextPtr
newCallback_RenderingDef_removeCodomainMapContext(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_removeCodomainMapContext<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_RenderingDef_removeCodomainMapContextPtr
newCallback_RenderingDef_removeCodomainMapContext(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_removeCodomainMapContext<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RenderingDef_removeCodomainMapContextPtr
newCallback_RenderingDef_removeCodomainMapContext(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_removeCodomainMapContext<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_RenderingDef_removeAllCodomainMapContextSet : public Callback_RenderingDef_removeAllCodomainMapContextSet_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_RenderingDef_removeAllCodomainMapContextSet(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_RenderingDef_removeAllCodomainMapContextSetPtr
newCallback_RenderingDef_removeAllCodomainMapContextSet(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_removeAllCodomainMapContextSet<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RenderingDef_removeAllCodomainMapContextSetPtr
newCallback_RenderingDef_removeAllCodomainMapContextSet(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_removeAllCodomainMapContextSet<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_RenderingDef_removeAllCodomainMapContextSetPtr
newCallback_RenderingDef_removeAllCodomainMapContextSet(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_removeAllCodomainMapContextSet<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RenderingDef_removeAllCodomainMapContextSetPtr
newCallback_RenderingDef_removeAllCodomainMapContextSet(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_removeAllCodomainMapContextSet<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_RenderingDef_removeAllCodomainMapContextSet : public Callback_RenderingDef_removeAllCodomainMapContextSet_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_RenderingDef_removeAllCodomainMapContextSet(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_RenderingDef_removeAllCodomainMapContextSetPtr
newCallback_RenderingDef_removeAllCodomainMapContextSet(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_removeAllCodomainMapContextSet<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RenderingDef_removeAllCodomainMapContextSetPtr
newCallback_RenderingDef_removeAllCodomainMapContextSet(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_removeAllCodomainMapContextSet<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_RenderingDef_removeAllCodomainMapContextSetPtr
newCallback_RenderingDef_removeAllCodomainMapContextSet(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_removeAllCodomainMapContextSet<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RenderingDef_removeAllCodomainMapContextSetPtr
newCallback_RenderingDef_removeAllCodomainMapContextSet(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_removeAllCodomainMapContextSet<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_RenderingDef_clearSpatialDomainEnhancement : public Callback_RenderingDef_clearSpatialDomainEnhancement_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_RenderingDef_clearSpatialDomainEnhancement(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_RenderingDef_clearSpatialDomainEnhancementPtr
newCallback_RenderingDef_clearSpatialDomainEnhancement(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_clearSpatialDomainEnhancement<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RenderingDef_clearSpatialDomainEnhancementPtr
newCallback_RenderingDef_clearSpatialDomainEnhancement(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_clearSpatialDomainEnhancement<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_RenderingDef_clearSpatialDomainEnhancementPtr
newCallback_RenderingDef_clearSpatialDomainEnhancement(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_clearSpatialDomainEnhancement<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RenderingDef_clearSpatialDomainEnhancementPtr
newCallback_RenderingDef_clearSpatialDomainEnhancement(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_clearSpatialDomainEnhancement<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_RenderingDef_clearSpatialDomainEnhancement : public Callback_RenderingDef_clearSpatialDomainEnhancement_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_RenderingDef_clearSpatialDomainEnhancement(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_RenderingDef_clearSpatialDomainEnhancementPtr
newCallback_RenderingDef_clearSpatialDomainEnhancement(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_clearSpatialDomainEnhancement<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RenderingDef_clearSpatialDomainEnhancementPtr
newCallback_RenderingDef_clearSpatialDomainEnhancement(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_clearSpatialDomainEnhancement<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_RenderingDef_clearSpatialDomainEnhancementPtr
newCallback_RenderingDef_clearSpatialDomainEnhancement(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_clearSpatialDomainEnhancement<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RenderingDef_clearSpatialDomainEnhancementPtr
newCallback_RenderingDef_clearSpatialDomainEnhancement(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_clearSpatialDomainEnhancement<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_RenderingDef_reloadSpatialDomainEnhancement : public Callback_RenderingDef_reloadSpatialDomainEnhancement_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_RenderingDef_reloadSpatialDomainEnhancement(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_RenderingDef_reloadSpatialDomainEnhancementPtr
newCallback_RenderingDef_reloadSpatialDomainEnhancement(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_reloadSpatialDomainEnhancement<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RenderingDef_reloadSpatialDomainEnhancementPtr
newCallback_RenderingDef_reloadSpatialDomainEnhancement(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_reloadSpatialDomainEnhancement<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_RenderingDef_reloadSpatialDomainEnhancementPtr
newCallback_RenderingDef_reloadSpatialDomainEnhancement(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_reloadSpatialDomainEnhancement<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RenderingDef_reloadSpatialDomainEnhancementPtr
newCallback_RenderingDef_reloadSpatialDomainEnhancement(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_reloadSpatialDomainEnhancement<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_RenderingDef_reloadSpatialDomainEnhancement : public Callback_RenderingDef_reloadSpatialDomainEnhancement_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_RenderingDef_reloadSpatialDomainEnhancement(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_RenderingDef_reloadSpatialDomainEnhancementPtr
newCallback_RenderingDef_reloadSpatialDomainEnhancement(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_reloadSpatialDomainEnhancement<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RenderingDef_reloadSpatialDomainEnhancementPtr
newCallback_RenderingDef_reloadSpatialDomainEnhancement(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_reloadSpatialDomainEnhancement<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_RenderingDef_reloadSpatialDomainEnhancementPtr
newCallback_RenderingDef_reloadSpatialDomainEnhancement(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_reloadSpatialDomainEnhancement<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RenderingDef_reloadSpatialDomainEnhancementPtr
newCallback_RenderingDef_reloadSpatialDomainEnhancement(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_reloadSpatialDomainEnhancement<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_RenderingDef_getCodomainMapContext : public Callback_RenderingDef_getCodomainMapContext_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::model::CodomainMapContextPtr&);

    CallbackNC_RenderingDef_getCodomainMapContext(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::RenderingDefPrx __proxy = ::omero::model::RenderingDefPrx::uncheckedCast(__result->getProxy());
        ::omero::model::CodomainMapContextPtr __ret;
        try
        {
            __ret = __proxy->end_getCodomainMapContext(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_RenderingDef_getCodomainMapContextPtr
newCallback_RenderingDef_getCodomainMapContext(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::CodomainMapContextPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_getCodomainMapContext<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RenderingDef_getCodomainMapContextPtr
newCallback_RenderingDef_getCodomainMapContext(T* instance, void (T::*cb)(const ::omero::model::CodomainMapContextPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_getCodomainMapContext<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RenderingDef_getCodomainMapContext : public Callback_RenderingDef_getCodomainMapContext_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::model::CodomainMapContextPtr&, const CT&);

    Callback_RenderingDef_getCodomainMapContext(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::RenderingDefPrx __proxy = ::omero::model::RenderingDefPrx::uncheckedCast(__result->getProxy());
        ::omero::model::CodomainMapContextPtr __ret;
        try
        {
            __ret = __proxy->end_getCodomainMapContext(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RenderingDef_getCodomainMapContextPtr
newCallback_RenderingDef_getCodomainMapContext(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::CodomainMapContextPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_getCodomainMapContext<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RenderingDef_getCodomainMapContextPtr
newCallback_RenderingDef_getCodomainMapContext(T* instance, void (T::*cb)(const ::omero::model::CodomainMapContextPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_getCodomainMapContext<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_RenderingDef_setCodomainMapContext : public Callback_RenderingDef_setCodomainMapContext_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::model::CodomainMapContextPtr&);

    CallbackNC_RenderingDef_setCodomainMapContext(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::RenderingDefPrx __proxy = ::omero::model::RenderingDefPrx::uncheckedCast(__result->getProxy());
        ::omero::model::CodomainMapContextPtr __ret;
        try
        {
            __ret = __proxy->end_setCodomainMapContext(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_RenderingDef_setCodomainMapContextPtr
newCallback_RenderingDef_setCodomainMapContext(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::CodomainMapContextPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_setCodomainMapContext<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RenderingDef_setCodomainMapContextPtr
newCallback_RenderingDef_setCodomainMapContext(T* instance, void (T::*cb)(const ::omero::model::CodomainMapContextPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_setCodomainMapContext<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RenderingDef_setCodomainMapContext : public Callback_RenderingDef_setCodomainMapContext_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::model::CodomainMapContextPtr&, const CT&);

    Callback_RenderingDef_setCodomainMapContext(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::RenderingDefPrx __proxy = ::omero::model::RenderingDefPrx::uncheckedCast(__result->getProxy());
        ::omero::model::CodomainMapContextPtr __ret;
        try
        {
            __ret = __proxy->end_setCodomainMapContext(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RenderingDef_setCodomainMapContextPtr
newCallback_RenderingDef_setCodomainMapContext(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::CodomainMapContextPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_setCodomainMapContext<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RenderingDef_setCodomainMapContextPtr
newCallback_RenderingDef_setCodomainMapContext(T* instance, void (T::*cb)(const ::omero::model::CodomainMapContextPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_setCodomainMapContext<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_RenderingDef_getPrimaryCodomainMapContext : public Callback_RenderingDef_getPrimaryCodomainMapContext_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::model::CodomainMapContextPtr&);

    CallbackNC_RenderingDef_getPrimaryCodomainMapContext(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::RenderingDefPrx __proxy = ::omero::model::RenderingDefPrx::uncheckedCast(__result->getProxy());
        ::omero::model::CodomainMapContextPtr __ret;
        try
        {
            __ret = __proxy->end_getPrimaryCodomainMapContext(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_RenderingDef_getPrimaryCodomainMapContextPtr
newCallback_RenderingDef_getPrimaryCodomainMapContext(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::CodomainMapContextPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_getPrimaryCodomainMapContext<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RenderingDef_getPrimaryCodomainMapContextPtr
newCallback_RenderingDef_getPrimaryCodomainMapContext(T* instance, void (T::*cb)(const ::omero::model::CodomainMapContextPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_getPrimaryCodomainMapContext<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RenderingDef_getPrimaryCodomainMapContext : public Callback_RenderingDef_getPrimaryCodomainMapContext_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::model::CodomainMapContextPtr&, const CT&);

    Callback_RenderingDef_getPrimaryCodomainMapContext(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::RenderingDefPrx __proxy = ::omero::model::RenderingDefPrx::uncheckedCast(__result->getProxy());
        ::omero::model::CodomainMapContextPtr __ret;
        try
        {
            __ret = __proxy->end_getPrimaryCodomainMapContext(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RenderingDef_getPrimaryCodomainMapContextPtr
newCallback_RenderingDef_getPrimaryCodomainMapContext(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::CodomainMapContextPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_getPrimaryCodomainMapContext<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RenderingDef_getPrimaryCodomainMapContextPtr
newCallback_RenderingDef_getPrimaryCodomainMapContext(T* instance, void (T::*cb)(const ::omero::model::CodomainMapContextPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_getPrimaryCodomainMapContext<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_RenderingDef_setPrimaryCodomainMapContext : public Callback_RenderingDef_setPrimaryCodomainMapContext_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::model::CodomainMapContextPtr&);

    CallbackNC_RenderingDef_setPrimaryCodomainMapContext(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::RenderingDefPrx __proxy = ::omero::model::RenderingDefPrx::uncheckedCast(__result->getProxy());
        ::omero::model::CodomainMapContextPtr __ret;
        try
        {
            __ret = __proxy->end_setPrimaryCodomainMapContext(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_RenderingDef_setPrimaryCodomainMapContextPtr
newCallback_RenderingDef_setPrimaryCodomainMapContext(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::CodomainMapContextPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_setPrimaryCodomainMapContext<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RenderingDef_setPrimaryCodomainMapContextPtr
newCallback_RenderingDef_setPrimaryCodomainMapContext(T* instance, void (T::*cb)(const ::omero::model::CodomainMapContextPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RenderingDef_setPrimaryCodomainMapContext<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RenderingDef_setPrimaryCodomainMapContext : public Callback_RenderingDef_setPrimaryCodomainMapContext_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::model::CodomainMapContextPtr&, const CT&);

    Callback_RenderingDef_setPrimaryCodomainMapContext(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::RenderingDefPrx __proxy = ::omero::model::RenderingDefPrx::uncheckedCast(__result->getProxy());
        ::omero::model::CodomainMapContextPtr __ret;
        try
        {
            __ret = __proxy->end_setPrimaryCodomainMapContext(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RenderingDef_setPrimaryCodomainMapContextPtr
newCallback_RenderingDef_setPrimaryCodomainMapContext(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::CodomainMapContextPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_setPrimaryCodomainMapContext<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RenderingDef_setPrimaryCodomainMapContextPtr
newCallback_RenderingDef_setPrimaryCodomainMapContext(T* instance, void (T::*cb)(const ::omero::model::CodomainMapContextPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RenderingDef_setPrimaryCodomainMapContext<T, CT>(instance, cb, excb, sentcb);
}

}

}

#endif
