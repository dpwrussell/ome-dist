// **********************************************************************
//
// Copyright (c) 2003-2011 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.4.2
//
// <auto-generated>
//
// Generated from file `LogicalChannel.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __omero_model__opt_hudson_workspace_OMERO_5_0_release_src_components_blitz_generated_omero_model_LogicalChannel_h__
#define __omero_model__opt_hudson_workspace_OMERO_5_0_release_src_components_blitz_generated_omero_model_LogicalChannel_h__

#include <Ice/LocalObjectF.h>
#include <Ice/ProxyF.h>
#include <Ice/ObjectF.h>
#include <Ice/Exception.h>
#include <Ice/LocalObject.h>
#include <Ice/Proxy.h>
#include <Ice/Object.h>
#include <Ice/Outgoing.h>
#include <Ice/OutgoingAsync.h>
#include <Ice/Incoming.h>
#include <Ice/Direct.h>
#include <Ice/FactoryTableInit.h>
#include <IceUtil/ScopedArray.h>
#include <Ice/StreamF.h>
#include <omero/model/IObject.h>
#include <omero/RTypes.h>
#include <omero/System.h>
#include <omero/Collections.h>
#include <Ice/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 304
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 > 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 2
#       error Ice patch level mismatch!
#   endif
#endif

namespace IceProxy
{

namespace omero
{

namespace model
{

class Illumination;

class ContrastMethod;

class OTF;

class DetectorSettings;

class LightSettings;

class FilterSet;

class PhotometricInterpretation;

class AcquisitionMode;

class Channel;

class LightPath;

class Details;

class LogicalChannel;

}

}

}

namespace omero
{

namespace model
{

class Illumination;
bool operator==(const Illumination&, const Illumination&);
bool operator<(const Illumination&, const Illumination&);

class ContrastMethod;
bool operator==(const ContrastMethod&, const ContrastMethod&);
bool operator<(const ContrastMethod&, const ContrastMethod&);

class OTF;
bool operator==(const OTF&, const OTF&);
bool operator<(const OTF&, const OTF&);

class DetectorSettings;
bool operator==(const DetectorSettings&, const DetectorSettings&);
bool operator<(const DetectorSettings&, const DetectorSettings&);

class LightSettings;
bool operator==(const LightSettings&, const LightSettings&);
bool operator<(const LightSettings&, const LightSettings&);

class FilterSet;
bool operator==(const FilterSet&, const FilterSet&);
bool operator<(const FilterSet&, const FilterSet&);

class PhotometricInterpretation;
bool operator==(const PhotometricInterpretation&, const PhotometricInterpretation&);
bool operator<(const PhotometricInterpretation&, const PhotometricInterpretation&);

class AcquisitionMode;
bool operator==(const AcquisitionMode&, const AcquisitionMode&);
bool operator<(const AcquisitionMode&, const AcquisitionMode&);

class Channel;
bool operator==(const Channel&, const Channel&);
bool operator<(const Channel&, const Channel&);

class LightPath;
bool operator==(const LightPath&, const LightPath&);
bool operator<(const LightPath&, const LightPath&);

class Details;
bool operator==(const Details&, const Details&);
bool operator<(const Details&, const Details&);

class LogicalChannel;
bool operator==(const LogicalChannel&, const LogicalChannel&);
bool operator<(const LogicalChannel&, const LogicalChannel&);

}

}

namespace IceInternal
{

::Ice::Object* upCast(::omero::model::Illumination*);
::IceProxy::Ice::Object* upCast(::IceProxy::omero::model::Illumination*);

::Ice::Object* upCast(::omero::model::ContrastMethod*);
::IceProxy::Ice::Object* upCast(::IceProxy::omero::model::ContrastMethod*);

::Ice::Object* upCast(::omero::model::OTF*);
::IceProxy::Ice::Object* upCast(::IceProxy::omero::model::OTF*);

::Ice::Object* upCast(::omero::model::DetectorSettings*);
::IceProxy::Ice::Object* upCast(::IceProxy::omero::model::DetectorSettings*);

::Ice::Object* upCast(::omero::model::LightSettings*);
::IceProxy::Ice::Object* upCast(::IceProxy::omero::model::LightSettings*);

::Ice::Object* upCast(::omero::model::FilterSet*);
::IceProxy::Ice::Object* upCast(::IceProxy::omero::model::FilterSet*);

::Ice::Object* upCast(::omero::model::PhotometricInterpretation*);
::IceProxy::Ice::Object* upCast(::IceProxy::omero::model::PhotometricInterpretation*);

::Ice::Object* upCast(::omero::model::AcquisitionMode*);
::IceProxy::Ice::Object* upCast(::IceProxy::omero::model::AcquisitionMode*);

::Ice::Object* upCast(::omero::model::Channel*);
::IceProxy::Ice::Object* upCast(::IceProxy::omero::model::Channel*);

::Ice::Object* upCast(::omero::model::LightPath*);
::IceProxy::Ice::Object* upCast(::IceProxy::omero::model::LightPath*);

::Ice::Object* upCast(::omero::model::Details*);
::IceProxy::Ice::Object* upCast(::IceProxy::omero::model::Details*);

::Ice::Object* upCast(::omero::model::LogicalChannel*);
::IceProxy::Ice::Object* upCast(::IceProxy::omero::model::LogicalChannel*);

}

namespace omero
{

namespace model
{

typedef ::IceInternal::Handle< ::omero::model::Illumination> IlluminationPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::omero::model::Illumination> IlluminationPrx;

void __read(::IceInternal::BasicStream*, IlluminationPrx&);
void __patch__IlluminationPtr(void*, ::Ice::ObjectPtr&);

typedef ::IceInternal::Handle< ::omero::model::ContrastMethod> ContrastMethodPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::omero::model::ContrastMethod> ContrastMethodPrx;

void __read(::IceInternal::BasicStream*, ContrastMethodPrx&);
void __patch__ContrastMethodPtr(void*, ::Ice::ObjectPtr&);

typedef ::IceInternal::Handle< ::omero::model::OTF> OTFPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::omero::model::OTF> OTFPrx;

void __read(::IceInternal::BasicStream*, OTFPrx&);
void __patch__OTFPtr(void*, ::Ice::ObjectPtr&);

typedef ::IceInternal::Handle< ::omero::model::DetectorSettings> DetectorSettingsPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::omero::model::DetectorSettings> DetectorSettingsPrx;

void __read(::IceInternal::BasicStream*, DetectorSettingsPrx&);
void __patch__DetectorSettingsPtr(void*, ::Ice::ObjectPtr&);

typedef ::IceInternal::Handle< ::omero::model::LightSettings> LightSettingsPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::omero::model::LightSettings> LightSettingsPrx;

void __read(::IceInternal::BasicStream*, LightSettingsPrx&);
void __patch__LightSettingsPtr(void*, ::Ice::ObjectPtr&);

typedef ::IceInternal::Handle< ::omero::model::FilterSet> FilterSetPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::omero::model::FilterSet> FilterSetPrx;

void __read(::IceInternal::BasicStream*, FilterSetPrx&);
void __patch__FilterSetPtr(void*, ::Ice::ObjectPtr&);

typedef ::IceInternal::Handle< ::omero::model::PhotometricInterpretation> PhotometricInterpretationPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::omero::model::PhotometricInterpretation> PhotometricInterpretationPrx;

void __read(::IceInternal::BasicStream*, PhotometricInterpretationPrx&);
void __patch__PhotometricInterpretationPtr(void*, ::Ice::ObjectPtr&);

typedef ::IceInternal::Handle< ::omero::model::AcquisitionMode> AcquisitionModePtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::omero::model::AcquisitionMode> AcquisitionModePrx;

void __read(::IceInternal::BasicStream*, AcquisitionModePrx&);
void __patch__AcquisitionModePtr(void*, ::Ice::ObjectPtr&);

typedef ::IceInternal::Handle< ::omero::model::Channel> ChannelPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::omero::model::Channel> ChannelPrx;

void __read(::IceInternal::BasicStream*, ChannelPrx&);
void __patch__ChannelPtr(void*, ::Ice::ObjectPtr&);

typedef ::IceInternal::Handle< ::omero::model::LightPath> LightPathPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::omero::model::LightPath> LightPathPrx;

void __read(::IceInternal::BasicStream*, LightPathPrx&);
void __patch__LightPathPtr(void*, ::Ice::ObjectPtr&);

typedef ::IceInternal::Handle< ::omero::model::Details> DetailsPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::omero::model::Details> DetailsPrx;

void __read(::IceInternal::BasicStream*, DetailsPrx&);
void __patch__DetailsPtr(void*, ::Ice::ObjectPtr&);

typedef ::IceInternal::Handle< ::omero::model::LogicalChannel> LogicalChannelPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::omero::model::LogicalChannel> LogicalChannelPrx;

void __read(::IceInternal::BasicStream*, LogicalChannelPrx&);
void __patch__LogicalChannelPtr(void*, ::Ice::ObjectPtr&);

}

}

namespace omero
{

namespace model
{

typedef ::std::vector< ::omero::model::ChannelPtr> LogicalChannelChannelsSeq;
void __writeLogicalChannelChannelsSeq(::IceInternal::BasicStream*, const ::omero::model::ChannelPtr*, const ::omero::model::ChannelPtr*);
void __readLogicalChannelChannelsSeq(::IceInternal::BasicStream*, LogicalChannelChannelsSeq&);

}

}

namespace omero
{

namespace model
{

class Callback_LogicalChannel_getVersion_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicalChannel_getVersion_Base> Callback_LogicalChannel_getVersionPtr;

class Callback_LogicalChannel_setVersion_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicalChannel_setVersion_Base> Callback_LogicalChannel_setVersionPtr;

class Callback_LogicalChannel_getName_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicalChannel_getName_Base> Callback_LogicalChannel_getNamePtr;

class Callback_LogicalChannel_setName_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicalChannel_setName_Base> Callback_LogicalChannel_setNamePtr;

class Callback_LogicalChannel_getPinHoleSize_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicalChannel_getPinHoleSize_Base> Callback_LogicalChannel_getPinHoleSizePtr;

class Callback_LogicalChannel_setPinHoleSize_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicalChannel_setPinHoleSize_Base> Callback_LogicalChannel_setPinHoleSizePtr;

class Callback_LogicalChannel_getIllumination_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicalChannel_getIllumination_Base> Callback_LogicalChannel_getIlluminationPtr;

class Callback_LogicalChannel_setIllumination_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicalChannel_setIllumination_Base> Callback_LogicalChannel_setIlluminationPtr;

class Callback_LogicalChannel_getContrastMethod_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicalChannel_getContrastMethod_Base> Callback_LogicalChannel_getContrastMethodPtr;

class Callback_LogicalChannel_setContrastMethod_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicalChannel_setContrastMethod_Base> Callback_LogicalChannel_setContrastMethodPtr;

class Callback_LogicalChannel_getExcitationWave_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicalChannel_getExcitationWave_Base> Callback_LogicalChannel_getExcitationWavePtr;

class Callback_LogicalChannel_setExcitationWave_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicalChannel_setExcitationWave_Base> Callback_LogicalChannel_setExcitationWavePtr;

class Callback_LogicalChannel_getEmissionWave_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicalChannel_getEmissionWave_Base> Callback_LogicalChannel_getEmissionWavePtr;

class Callback_LogicalChannel_setEmissionWave_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicalChannel_setEmissionWave_Base> Callback_LogicalChannel_setEmissionWavePtr;

class Callback_LogicalChannel_getFluor_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicalChannel_getFluor_Base> Callback_LogicalChannel_getFluorPtr;

class Callback_LogicalChannel_setFluor_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicalChannel_setFluor_Base> Callback_LogicalChannel_setFluorPtr;

class Callback_LogicalChannel_getNdFilter_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicalChannel_getNdFilter_Base> Callback_LogicalChannel_getNdFilterPtr;

class Callback_LogicalChannel_setNdFilter_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicalChannel_setNdFilter_Base> Callback_LogicalChannel_setNdFilterPtr;

class Callback_LogicalChannel_getOtf_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicalChannel_getOtf_Base> Callback_LogicalChannel_getOtfPtr;

class Callback_LogicalChannel_setOtf_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicalChannel_setOtf_Base> Callback_LogicalChannel_setOtfPtr;

class Callback_LogicalChannel_getDetectorSettings_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicalChannel_getDetectorSettings_Base> Callback_LogicalChannel_getDetectorSettingsPtr;

class Callback_LogicalChannel_setDetectorSettings_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicalChannel_setDetectorSettings_Base> Callback_LogicalChannel_setDetectorSettingsPtr;

class Callback_LogicalChannel_getLightSourceSettings_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicalChannel_getLightSourceSettings_Base> Callback_LogicalChannel_getLightSourceSettingsPtr;

class Callback_LogicalChannel_setLightSourceSettings_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicalChannel_setLightSourceSettings_Base> Callback_LogicalChannel_setLightSourceSettingsPtr;

class Callback_LogicalChannel_getFilterSet_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicalChannel_getFilterSet_Base> Callback_LogicalChannel_getFilterSetPtr;

class Callback_LogicalChannel_setFilterSet_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicalChannel_setFilterSet_Base> Callback_LogicalChannel_setFilterSetPtr;

class Callback_LogicalChannel_getSamplesPerPixel_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicalChannel_getSamplesPerPixel_Base> Callback_LogicalChannel_getSamplesPerPixelPtr;

class Callback_LogicalChannel_setSamplesPerPixel_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicalChannel_setSamplesPerPixel_Base> Callback_LogicalChannel_setSamplesPerPixelPtr;

class Callback_LogicalChannel_getPhotometricInterpretation_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicalChannel_getPhotometricInterpretation_Base> Callback_LogicalChannel_getPhotometricInterpretationPtr;

class Callback_LogicalChannel_setPhotometricInterpretation_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicalChannel_setPhotometricInterpretation_Base> Callback_LogicalChannel_setPhotometricInterpretationPtr;

class Callback_LogicalChannel_getMode_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicalChannel_getMode_Base> Callback_LogicalChannel_getModePtr;

class Callback_LogicalChannel_setMode_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicalChannel_setMode_Base> Callback_LogicalChannel_setModePtr;

class Callback_LogicalChannel_getPockelCellSetting_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicalChannel_getPockelCellSetting_Base> Callback_LogicalChannel_getPockelCellSettingPtr;

class Callback_LogicalChannel_setPockelCellSetting_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicalChannel_setPockelCellSetting_Base> Callback_LogicalChannel_setPockelCellSettingPtr;

class Callback_LogicalChannel_unloadChannels_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicalChannel_unloadChannels_Base> Callback_LogicalChannel_unloadChannelsPtr;

class Callback_LogicalChannel_sizeOfChannels_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicalChannel_sizeOfChannels_Base> Callback_LogicalChannel_sizeOfChannelsPtr;

class Callback_LogicalChannel_copyChannels_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicalChannel_copyChannels_Base> Callback_LogicalChannel_copyChannelsPtr;

class Callback_LogicalChannel_addChannel_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicalChannel_addChannel_Base> Callback_LogicalChannel_addChannelPtr;

class Callback_LogicalChannel_addAllChannelSet_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicalChannel_addAllChannelSet_Base> Callback_LogicalChannel_addAllChannelSetPtr;

class Callback_LogicalChannel_removeChannel_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicalChannel_removeChannel_Base> Callback_LogicalChannel_removeChannelPtr;

class Callback_LogicalChannel_removeAllChannelSet_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicalChannel_removeAllChannelSet_Base> Callback_LogicalChannel_removeAllChannelSetPtr;

class Callback_LogicalChannel_clearChannels_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicalChannel_clearChannels_Base> Callback_LogicalChannel_clearChannelsPtr;

class Callback_LogicalChannel_reloadChannels_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicalChannel_reloadChannels_Base> Callback_LogicalChannel_reloadChannelsPtr;

class Callback_LogicalChannel_getLightPath_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicalChannel_getLightPath_Base> Callback_LogicalChannel_getLightPathPtr;

class Callback_LogicalChannel_setLightPath_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicalChannel_setLightPath_Base> Callback_LogicalChannel_setLightPathPtr;

}

}

namespace IceProxy
{

namespace omero
{

namespace model
{

class LogicalChannel : virtual public ::IceProxy::omero::model::IObject
{
public:

    ::omero::RIntPtr getVersion()
    {
        return getVersion(0);
    }
    ::omero::RIntPtr getVersion(const ::Ice::Context& __ctx)
    {
        return getVersion(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getVersion()
    {
        return begin_getVersion(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getVersion(const ::Ice::Context& __ctx)
    {
        return begin_getVersion(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getVersion(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getVersion(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getVersion(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getVersion(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getVersion(const ::omero::model::Callback_LogicalChannel_getVersionPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getVersion(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getVersion(const ::Ice::Context& __ctx, const ::omero::model::Callback_LogicalChannel_getVersionPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getVersion(&__ctx, __del, __cookie);
    }

    ::omero::RIntPtr end_getVersion(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::RIntPtr getVersion(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getVersion(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setVersion(const ::omero::RIntPtr& theVersion)
    {
        setVersion(theVersion, 0);
    }
    void setVersion(const ::omero::RIntPtr& theVersion, const ::Ice::Context& __ctx)
    {
        setVersion(theVersion, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setVersion(const ::omero::RIntPtr& theVersion)
    {
        return begin_setVersion(theVersion, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setVersion(const ::omero::RIntPtr& theVersion, const ::Ice::Context& __ctx)
    {
        return begin_setVersion(theVersion, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setVersion(const ::omero::RIntPtr& theVersion, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setVersion(theVersion, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setVersion(const ::omero::RIntPtr& theVersion, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setVersion(theVersion, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setVersion(const ::omero::RIntPtr& theVersion, const ::omero::model::Callback_LogicalChannel_setVersionPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setVersion(theVersion, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setVersion(const ::omero::RIntPtr& theVersion, const ::Ice::Context& __ctx, const ::omero::model::Callback_LogicalChannel_setVersionPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setVersion(theVersion, &__ctx, __del, __cookie);
    }

    void end_setVersion(const ::Ice::AsyncResultPtr&);
    
private:

    void setVersion(const ::omero::RIntPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setVersion(const ::omero::RIntPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::RStringPtr getName()
    {
        return getName(0);
    }
    ::omero::RStringPtr getName(const ::Ice::Context& __ctx)
    {
        return getName(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getName()
    {
        return begin_getName(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getName(const ::Ice::Context& __ctx)
    {
        return begin_getName(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getName(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getName(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getName(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getName(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getName(const ::omero::model::Callback_LogicalChannel_getNamePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getName(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getName(const ::Ice::Context& __ctx, const ::omero::model::Callback_LogicalChannel_getNamePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getName(&__ctx, __del, __cookie);
    }

    ::omero::RStringPtr end_getName(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::RStringPtr getName(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getName(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setName(const ::omero::RStringPtr& theName)
    {
        setName(theName, 0);
    }
    void setName(const ::omero::RStringPtr& theName, const ::Ice::Context& __ctx)
    {
        setName(theName, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setName(const ::omero::RStringPtr& theName)
    {
        return begin_setName(theName, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setName(const ::omero::RStringPtr& theName, const ::Ice::Context& __ctx)
    {
        return begin_setName(theName, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setName(const ::omero::RStringPtr& theName, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setName(theName, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setName(const ::omero::RStringPtr& theName, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setName(theName, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setName(const ::omero::RStringPtr& theName, const ::omero::model::Callback_LogicalChannel_setNamePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setName(theName, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setName(const ::omero::RStringPtr& theName, const ::Ice::Context& __ctx, const ::omero::model::Callback_LogicalChannel_setNamePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setName(theName, &__ctx, __del, __cookie);
    }

    void end_setName(const ::Ice::AsyncResultPtr&);
    
private:

    void setName(const ::omero::RStringPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setName(const ::omero::RStringPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::RDoublePtr getPinHoleSize()
    {
        return getPinHoleSize(0);
    }
    ::omero::RDoublePtr getPinHoleSize(const ::Ice::Context& __ctx)
    {
        return getPinHoleSize(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getPinHoleSize()
    {
        return begin_getPinHoleSize(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getPinHoleSize(const ::Ice::Context& __ctx)
    {
        return begin_getPinHoleSize(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getPinHoleSize(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getPinHoleSize(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getPinHoleSize(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getPinHoleSize(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getPinHoleSize(const ::omero::model::Callback_LogicalChannel_getPinHoleSizePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getPinHoleSize(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getPinHoleSize(const ::Ice::Context& __ctx, const ::omero::model::Callback_LogicalChannel_getPinHoleSizePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getPinHoleSize(&__ctx, __del, __cookie);
    }

    ::omero::RDoublePtr end_getPinHoleSize(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::RDoublePtr getPinHoleSize(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getPinHoleSize(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setPinHoleSize(const ::omero::RDoublePtr& thePinHoleSize)
    {
        setPinHoleSize(thePinHoleSize, 0);
    }
    void setPinHoleSize(const ::omero::RDoublePtr& thePinHoleSize, const ::Ice::Context& __ctx)
    {
        setPinHoleSize(thePinHoleSize, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setPinHoleSize(const ::omero::RDoublePtr& thePinHoleSize)
    {
        return begin_setPinHoleSize(thePinHoleSize, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setPinHoleSize(const ::omero::RDoublePtr& thePinHoleSize, const ::Ice::Context& __ctx)
    {
        return begin_setPinHoleSize(thePinHoleSize, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setPinHoleSize(const ::omero::RDoublePtr& thePinHoleSize, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setPinHoleSize(thePinHoleSize, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setPinHoleSize(const ::omero::RDoublePtr& thePinHoleSize, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setPinHoleSize(thePinHoleSize, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setPinHoleSize(const ::omero::RDoublePtr& thePinHoleSize, const ::omero::model::Callback_LogicalChannel_setPinHoleSizePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setPinHoleSize(thePinHoleSize, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setPinHoleSize(const ::omero::RDoublePtr& thePinHoleSize, const ::Ice::Context& __ctx, const ::omero::model::Callback_LogicalChannel_setPinHoleSizePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setPinHoleSize(thePinHoleSize, &__ctx, __del, __cookie);
    }

    void end_setPinHoleSize(const ::Ice::AsyncResultPtr&);
    
private:

    void setPinHoleSize(const ::omero::RDoublePtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setPinHoleSize(const ::omero::RDoublePtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::model::IlluminationPtr getIllumination()
    {
        return getIllumination(0);
    }
    ::omero::model::IlluminationPtr getIllumination(const ::Ice::Context& __ctx)
    {
        return getIllumination(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getIllumination()
    {
        return begin_getIllumination(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getIllumination(const ::Ice::Context& __ctx)
    {
        return begin_getIllumination(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getIllumination(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getIllumination(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getIllumination(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getIllumination(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getIllumination(const ::omero::model::Callback_LogicalChannel_getIlluminationPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getIllumination(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getIllumination(const ::Ice::Context& __ctx, const ::omero::model::Callback_LogicalChannel_getIlluminationPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getIllumination(&__ctx, __del, __cookie);
    }

    ::omero::model::IlluminationPtr end_getIllumination(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::model::IlluminationPtr getIllumination(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getIllumination(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setIllumination(const ::omero::model::IlluminationPtr& theIllumination)
    {
        setIllumination(theIllumination, 0);
    }
    void setIllumination(const ::omero::model::IlluminationPtr& theIllumination, const ::Ice::Context& __ctx)
    {
        setIllumination(theIllumination, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setIllumination(const ::omero::model::IlluminationPtr& theIllumination)
    {
        return begin_setIllumination(theIllumination, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setIllumination(const ::omero::model::IlluminationPtr& theIllumination, const ::Ice::Context& __ctx)
    {
        return begin_setIllumination(theIllumination, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setIllumination(const ::omero::model::IlluminationPtr& theIllumination, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setIllumination(theIllumination, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setIllumination(const ::omero::model::IlluminationPtr& theIllumination, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setIllumination(theIllumination, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setIllumination(const ::omero::model::IlluminationPtr& theIllumination, const ::omero::model::Callback_LogicalChannel_setIlluminationPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setIllumination(theIllumination, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setIllumination(const ::omero::model::IlluminationPtr& theIllumination, const ::Ice::Context& __ctx, const ::omero::model::Callback_LogicalChannel_setIlluminationPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setIllumination(theIllumination, &__ctx, __del, __cookie);
    }

    void end_setIllumination(const ::Ice::AsyncResultPtr&);
    
private:

    void setIllumination(const ::omero::model::IlluminationPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setIllumination(const ::omero::model::IlluminationPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::model::ContrastMethodPtr getContrastMethod()
    {
        return getContrastMethod(0);
    }
    ::omero::model::ContrastMethodPtr getContrastMethod(const ::Ice::Context& __ctx)
    {
        return getContrastMethod(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getContrastMethod()
    {
        return begin_getContrastMethod(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getContrastMethod(const ::Ice::Context& __ctx)
    {
        return begin_getContrastMethod(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getContrastMethod(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getContrastMethod(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getContrastMethod(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getContrastMethod(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getContrastMethod(const ::omero::model::Callback_LogicalChannel_getContrastMethodPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getContrastMethod(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getContrastMethod(const ::Ice::Context& __ctx, const ::omero::model::Callback_LogicalChannel_getContrastMethodPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getContrastMethod(&__ctx, __del, __cookie);
    }

    ::omero::model::ContrastMethodPtr end_getContrastMethod(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::model::ContrastMethodPtr getContrastMethod(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getContrastMethod(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setContrastMethod(const ::omero::model::ContrastMethodPtr& theContrastMethod)
    {
        setContrastMethod(theContrastMethod, 0);
    }
    void setContrastMethod(const ::omero::model::ContrastMethodPtr& theContrastMethod, const ::Ice::Context& __ctx)
    {
        setContrastMethod(theContrastMethod, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setContrastMethod(const ::omero::model::ContrastMethodPtr& theContrastMethod)
    {
        return begin_setContrastMethod(theContrastMethod, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setContrastMethod(const ::omero::model::ContrastMethodPtr& theContrastMethod, const ::Ice::Context& __ctx)
    {
        return begin_setContrastMethod(theContrastMethod, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setContrastMethod(const ::omero::model::ContrastMethodPtr& theContrastMethod, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setContrastMethod(theContrastMethod, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setContrastMethod(const ::omero::model::ContrastMethodPtr& theContrastMethod, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setContrastMethod(theContrastMethod, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setContrastMethod(const ::omero::model::ContrastMethodPtr& theContrastMethod, const ::omero::model::Callback_LogicalChannel_setContrastMethodPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setContrastMethod(theContrastMethod, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setContrastMethod(const ::omero::model::ContrastMethodPtr& theContrastMethod, const ::Ice::Context& __ctx, const ::omero::model::Callback_LogicalChannel_setContrastMethodPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setContrastMethod(theContrastMethod, &__ctx, __del, __cookie);
    }

    void end_setContrastMethod(const ::Ice::AsyncResultPtr&);
    
private:

    void setContrastMethod(const ::omero::model::ContrastMethodPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setContrastMethod(const ::omero::model::ContrastMethodPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::RIntPtr getExcitationWave()
    {
        return getExcitationWave(0);
    }
    ::omero::RIntPtr getExcitationWave(const ::Ice::Context& __ctx)
    {
        return getExcitationWave(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getExcitationWave()
    {
        return begin_getExcitationWave(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getExcitationWave(const ::Ice::Context& __ctx)
    {
        return begin_getExcitationWave(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getExcitationWave(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getExcitationWave(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getExcitationWave(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getExcitationWave(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getExcitationWave(const ::omero::model::Callback_LogicalChannel_getExcitationWavePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getExcitationWave(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getExcitationWave(const ::Ice::Context& __ctx, const ::omero::model::Callback_LogicalChannel_getExcitationWavePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getExcitationWave(&__ctx, __del, __cookie);
    }

    ::omero::RIntPtr end_getExcitationWave(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::RIntPtr getExcitationWave(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getExcitationWave(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setExcitationWave(const ::omero::RIntPtr& theExcitationWave)
    {
        setExcitationWave(theExcitationWave, 0);
    }
    void setExcitationWave(const ::omero::RIntPtr& theExcitationWave, const ::Ice::Context& __ctx)
    {
        setExcitationWave(theExcitationWave, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setExcitationWave(const ::omero::RIntPtr& theExcitationWave)
    {
        return begin_setExcitationWave(theExcitationWave, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setExcitationWave(const ::omero::RIntPtr& theExcitationWave, const ::Ice::Context& __ctx)
    {
        return begin_setExcitationWave(theExcitationWave, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setExcitationWave(const ::omero::RIntPtr& theExcitationWave, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setExcitationWave(theExcitationWave, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setExcitationWave(const ::omero::RIntPtr& theExcitationWave, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setExcitationWave(theExcitationWave, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setExcitationWave(const ::omero::RIntPtr& theExcitationWave, const ::omero::model::Callback_LogicalChannel_setExcitationWavePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setExcitationWave(theExcitationWave, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setExcitationWave(const ::omero::RIntPtr& theExcitationWave, const ::Ice::Context& __ctx, const ::omero::model::Callback_LogicalChannel_setExcitationWavePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setExcitationWave(theExcitationWave, &__ctx, __del, __cookie);
    }

    void end_setExcitationWave(const ::Ice::AsyncResultPtr&);
    
private:

    void setExcitationWave(const ::omero::RIntPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setExcitationWave(const ::omero::RIntPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::RIntPtr getEmissionWave()
    {
        return getEmissionWave(0);
    }
    ::omero::RIntPtr getEmissionWave(const ::Ice::Context& __ctx)
    {
        return getEmissionWave(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getEmissionWave()
    {
        return begin_getEmissionWave(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getEmissionWave(const ::Ice::Context& __ctx)
    {
        return begin_getEmissionWave(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getEmissionWave(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getEmissionWave(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getEmissionWave(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getEmissionWave(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getEmissionWave(const ::omero::model::Callback_LogicalChannel_getEmissionWavePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getEmissionWave(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getEmissionWave(const ::Ice::Context& __ctx, const ::omero::model::Callback_LogicalChannel_getEmissionWavePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getEmissionWave(&__ctx, __del, __cookie);
    }

    ::omero::RIntPtr end_getEmissionWave(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::RIntPtr getEmissionWave(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getEmissionWave(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setEmissionWave(const ::omero::RIntPtr& theEmissionWave)
    {
        setEmissionWave(theEmissionWave, 0);
    }
    void setEmissionWave(const ::omero::RIntPtr& theEmissionWave, const ::Ice::Context& __ctx)
    {
        setEmissionWave(theEmissionWave, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setEmissionWave(const ::omero::RIntPtr& theEmissionWave)
    {
        return begin_setEmissionWave(theEmissionWave, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setEmissionWave(const ::omero::RIntPtr& theEmissionWave, const ::Ice::Context& __ctx)
    {
        return begin_setEmissionWave(theEmissionWave, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setEmissionWave(const ::omero::RIntPtr& theEmissionWave, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setEmissionWave(theEmissionWave, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setEmissionWave(const ::omero::RIntPtr& theEmissionWave, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setEmissionWave(theEmissionWave, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setEmissionWave(const ::omero::RIntPtr& theEmissionWave, const ::omero::model::Callback_LogicalChannel_setEmissionWavePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setEmissionWave(theEmissionWave, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setEmissionWave(const ::omero::RIntPtr& theEmissionWave, const ::Ice::Context& __ctx, const ::omero::model::Callback_LogicalChannel_setEmissionWavePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setEmissionWave(theEmissionWave, &__ctx, __del, __cookie);
    }

    void end_setEmissionWave(const ::Ice::AsyncResultPtr&);
    
private:

    void setEmissionWave(const ::omero::RIntPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setEmissionWave(const ::omero::RIntPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::RStringPtr getFluor()
    {
        return getFluor(0);
    }
    ::omero::RStringPtr getFluor(const ::Ice::Context& __ctx)
    {
        return getFluor(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getFluor()
    {
        return begin_getFluor(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getFluor(const ::Ice::Context& __ctx)
    {
        return begin_getFluor(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getFluor(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getFluor(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getFluor(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getFluor(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getFluor(const ::omero::model::Callback_LogicalChannel_getFluorPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getFluor(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getFluor(const ::Ice::Context& __ctx, const ::omero::model::Callback_LogicalChannel_getFluorPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getFluor(&__ctx, __del, __cookie);
    }

    ::omero::RStringPtr end_getFluor(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::RStringPtr getFluor(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getFluor(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setFluor(const ::omero::RStringPtr& theFluor)
    {
        setFluor(theFluor, 0);
    }
    void setFluor(const ::omero::RStringPtr& theFluor, const ::Ice::Context& __ctx)
    {
        setFluor(theFluor, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setFluor(const ::omero::RStringPtr& theFluor)
    {
        return begin_setFluor(theFluor, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setFluor(const ::omero::RStringPtr& theFluor, const ::Ice::Context& __ctx)
    {
        return begin_setFluor(theFluor, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setFluor(const ::omero::RStringPtr& theFluor, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setFluor(theFluor, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setFluor(const ::omero::RStringPtr& theFluor, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setFluor(theFluor, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setFluor(const ::omero::RStringPtr& theFluor, const ::omero::model::Callback_LogicalChannel_setFluorPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setFluor(theFluor, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setFluor(const ::omero::RStringPtr& theFluor, const ::Ice::Context& __ctx, const ::omero::model::Callback_LogicalChannel_setFluorPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setFluor(theFluor, &__ctx, __del, __cookie);
    }

    void end_setFluor(const ::Ice::AsyncResultPtr&);
    
private:

    void setFluor(const ::omero::RStringPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setFluor(const ::omero::RStringPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::RDoublePtr getNdFilter()
    {
        return getNdFilter(0);
    }
    ::omero::RDoublePtr getNdFilter(const ::Ice::Context& __ctx)
    {
        return getNdFilter(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getNdFilter()
    {
        return begin_getNdFilter(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getNdFilter(const ::Ice::Context& __ctx)
    {
        return begin_getNdFilter(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getNdFilter(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getNdFilter(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getNdFilter(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getNdFilter(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getNdFilter(const ::omero::model::Callback_LogicalChannel_getNdFilterPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getNdFilter(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getNdFilter(const ::Ice::Context& __ctx, const ::omero::model::Callback_LogicalChannel_getNdFilterPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getNdFilter(&__ctx, __del, __cookie);
    }

    ::omero::RDoublePtr end_getNdFilter(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::RDoublePtr getNdFilter(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getNdFilter(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setNdFilter(const ::omero::RDoublePtr& theNdFilter)
    {
        setNdFilter(theNdFilter, 0);
    }
    void setNdFilter(const ::omero::RDoublePtr& theNdFilter, const ::Ice::Context& __ctx)
    {
        setNdFilter(theNdFilter, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setNdFilter(const ::omero::RDoublePtr& theNdFilter)
    {
        return begin_setNdFilter(theNdFilter, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setNdFilter(const ::omero::RDoublePtr& theNdFilter, const ::Ice::Context& __ctx)
    {
        return begin_setNdFilter(theNdFilter, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setNdFilter(const ::omero::RDoublePtr& theNdFilter, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setNdFilter(theNdFilter, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setNdFilter(const ::omero::RDoublePtr& theNdFilter, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setNdFilter(theNdFilter, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setNdFilter(const ::omero::RDoublePtr& theNdFilter, const ::omero::model::Callback_LogicalChannel_setNdFilterPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setNdFilter(theNdFilter, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setNdFilter(const ::omero::RDoublePtr& theNdFilter, const ::Ice::Context& __ctx, const ::omero::model::Callback_LogicalChannel_setNdFilterPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setNdFilter(theNdFilter, &__ctx, __del, __cookie);
    }

    void end_setNdFilter(const ::Ice::AsyncResultPtr&);
    
private:

    void setNdFilter(const ::omero::RDoublePtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setNdFilter(const ::omero::RDoublePtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::model::OTFPtr getOtf()
    {
        return getOtf(0);
    }
    ::omero::model::OTFPtr getOtf(const ::Ice::Context& __ctx)
    {
        return getOtf(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getOtf()
    {
        return begin_getOtf(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getOtf(const ::Ice::Context& __ctx)
    {
        return begin_getOtf(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getOtf(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getOtf(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getOtf(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getOtf(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getOtf(const ::omero::model::Callback_LogicalChannel_getOtfPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getOtf(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getOtf(const ::Ice::Context& __ctx, const ::omero::model::Callback_LogicalChannel_getOtfPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getOtf(&__ctx, __del, __cookie);
    }

    ::omero::model::OTFPtr end_getOtf(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::model::OTFPtr getOtf(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getOtf(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setOtf(const ::omero::model::OTFPtr& theOtf)
    {
        setOtf(theOtf, 0);
    }
    void setOtf(const ::omero::model::OTFPtr& theOtf, const ::Ice::Context& __ctx)
    {
        setOtf(theOtf, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setOtf(const ::omero::model::OTFPtr& theOtf)
    {
        return begin_setOtf(theOtf, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setOtf(const ::omero::model::OTFPtr& theOtf, const ::Ice::Context& __ctx)
    {
        return begin_setOtf(theOtf, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setOtf(const ::omero::model::OTFPtr& theOtf, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setOtf(theOtf, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setOtf(const ::omero::model::OTFPtr& theOtf, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setOtf(theOtf, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setOtf(const ::omero::model::OTFPtr& theOtf, const ::omero::model::Callback_LogicalChannel_setOtfPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setOtf(theOtf, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setOtf(const ::omero::model::OTFPtr& theOtf, const ::Ice::Context& __ctx, const ::omero::model::Callback_LogicalChannel_setOtfPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setOtf(theOtf, &__ctx, __del, __cookie);
    }

    void end_setOtf(const ::Ice::AsyncResultPtr&);
    
private:

    void setOtf(const ::omero::model::OTFPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setOtf(const ::omero::model::OTFPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::model::DetectorSettingsPtr getDetectorSettings()
    {
        return getDetectorSettings(0);
    }
    ::omero::model::DetectorSettingsPtr getDetectorSettings(const ::Ice::Context& __ctx)
    {
        return getDetectorSettings(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getDetectorSettings()
    {
        return begin_getDetectorSettings(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getDetectorSettings(const ::Ice::Context& __ctx)
    {
        return begin_getDetectorSettings(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getDetectorSettings(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getDetectorSettings(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getDetectorSettings(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getDetectorSettings(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getDetectorSettings(const ::omero::model::Callback_LogicalChannel_getDetectorSettingsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getDetectorSettings(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getDetectorSettings(const ::Ice::Context& __ctx, const ::omero::model::Callback_LogicalChannel_getDetectorSettingsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getDetectorSettings(&__ctx, __del, __cookie);
    }

    ::omero::model::DetectorSettingsPtr end_getDetectorSettings(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::model::DetectorSettingsPtr getDetectorSettings(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getDetectorSettings(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setDetectorSettings(const ::omero::model::DetectorSettingsPtr& theDetectorSettings)
    {
        setDetectorSettings(theDetectorSettings, 0);
    }
    void setDetectorSettings(const ::omero::model::DetectorSettingsPtr& theDetectorSettings, const ::Ice::Context& __ctx)
    {
        setDetectorSettings(theDetectorSettings, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setDetectorSettings(const ::omero::model::DetectorSettingsPtr& theDetectorSettings)
    {
        return begin_setDetectorSettings(theDetectorSettings, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setDetectorSettings(const ::omero::model::DetectorSettingsPtr& theDetectorSettings, const ::Ice::Context& __ctx)
    {
        return begin_setDetectorSettings(theDetectorSettings, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setDetectorSettings(const ::omero::model::DetectorSettingsPtr& theDetectorSettings, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setDetectorSettings(theDetectorSettings, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setDetectorSettings(const ::omero::model::DetectorSettingsPtr& theDetectorSettings, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setDetectorSettings(theDetectorSettings, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setDetectorSettings(const ::omero::model::DetectorSettingsPtr& theDetectorSettings, const ::omero::model::Callback_LogicalChannel_setDetectorSettingsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setDetectorSettings(theDetectorSettings, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setDetectorSettings(const ::omero::model::DetectorSettingsPtr& theDetectorSettings, const ::Ice::Context& __ctx, const ::omero::model::Callback_LogicalChannel_setDetectorSettingsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setDetectorSettings(theDetectorSettings, &__ctx, __del, __cookie);
    }

    void end_setDetectorSettings(const ::Ice::AsyncResultPtr&);
    
private:

    void setDetectorSettings(const ::omero::model::DetectorSettingsPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setDetectorSettings(const ::omero::model::DetectorSettingsPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::model::LightSettingsPtr getLightSourceSettings()
    {
        return getLightSourceSettings(0);
    }
    ::omero::model::LightSettingsPtr getLightSourceSettings(const ::Ice::Context& __ctx)
    {
        return getLightSourceSettings(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getLightSourceSettings()
    {
        return begin_getLightSourceSettings(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getLightSourceSettings(const ::Ice::Context& __ctx)
    {
        return begin_getLightSourceSettings(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getLightSourceSettings(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getLightSourceSettings(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getLightSourceSettings(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getLightSourceSettings(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getLightSourceSettings(const ::omero::model::Callback_LogicalChannel_getLightSourceSettingsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getLightSourceSettings(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getLightSourceSettings(const ::Ice::Context& __ctx, const ::omero::model::Callback_LogicalChannel_getLightSourceSettingsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getLightSourceSettings(&__ctx, __del, __cookie);
    }

    ::omero::model::LightSettingsPtr end_getLightSourceSettings(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::model::LightSettingsPtr getLightSourceSettings(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getLightSourceSettings(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setLightSourceSettings(const ::omero::model::LightSettingsPtr& theLightSourceSettings)
    {
        setLightSourceSettings(theLightSourceSettings, 0);
    }
    void setLightSourceSettings(const ::omero::model::LightSettingsPtr& theLightSourceSettings, const ::Ice::Context& __ctx)
    {
        setLightSourceSettings(theLightSourceSettings, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setLightSourceSettings(const ::omero::model::LightSettingsPtr& theLightSourceSettings)
    {
        return begin_setLightSourceSettings(theLightSourceSettings, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setLightSourceSettings(const ::omero::model::LightSettingsPtr& theLightSourceSettings, const ::Ice::Context& __ctx)
    {
        return begin_setLightSourceSettings(theLightSourceSettings, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setLightSourceSettings(const ::omero::model::LightSettingsPtr& theLightSourceSettings, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setLightSourceSettings(theLightSourceSettings, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setLightSourceSettings(const ::omero::model::LightSettingsPtr& theLightSourceSettings, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setLightSourceSettings(theLightSourceSettings, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setLightSourceSettings(const ::omero::model::LightSettingsPtr& theLightSourceSettings, const ::omero::model::Callback_LogicalChannel_setLightSourceSettingsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setLightSourceSettings(theLightSourceSettings, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setLightSourceSettings(const ::omero::model::LightSettingsPtr& theLightSourceSettings, const ::Ice::Context& __ctx, const ::omero::model::Callback_LogicalChannel_setLightSourceSettingsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setLightSourceSettings(theLightSourceSettings, &__ctx, __del, __cookie);
    }

    void end_setLightSourceSettings(const ::Ice::AsyncResultPtr&);
    
private:

    void setLightSourceSettings(const ::omero::model::LightSettingsPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setLightSourceSettings(const ::omero::model::LightSettingsPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::model::FilterSetPtr getFilterSet()
    {
        return getFilterSet(0);
    }
    ::omero::model::FilterSetPtr getFilterSet(const ::Ice::Context& __ctx)
    {
        return getFilterSet(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getFilterSet()
    {
        return begin_getFilterSet(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getFilterSet(const ::Ice::Context& __ctx)
    {
        return begin_getFilterSet(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getFilterSet(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getFilterSet(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getFilterSet(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getFilterSet(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getFilterSet(const ::omero::model::Callback_LogicalChannel_getFilterSetPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getFilterSet(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getFilterSet(const ::Ice::Context& __ctx, const ::omero::model::Callback_LogicalChannel_getFilterSetPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getFilterSet(&__ctx, __del, __cookie);
    }

    ::omero::model::FilterSetPtr end_getFilterSet(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::model::FilterSetPtr getFilterSet(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getFilterSet(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setFilterSet(const ::omero::model::FilterSetPtr& theFilterSet)
    {
        setFilterSet(theFilterSet, 0);
    }
    void setFilterSet(const ::omero::model::FilterSetPtr& theFilterSet, const ::Ice::Context& __ctx)
    {
        setFilterSet(theFilterSet, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setFilterSet(const ::omero::model::FilterSetPtr& theFilterSet)
    {
        return begin_setFilterSet(theFilterSet, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setFilterSet(const ::omero::model::FilterSetPtr& theFilterSet, const ::Ice::Context& __ctx)
    {
        return begin_setFilterSet(theFilterSet, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setFilterSet(const ::omero::model::FilterSetPtr& theFilterSet, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setFilterSet(theFilterSet, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setFilterSet(const ::omero::model::FilterSetPtr& theFilterSet, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setFilterSet(theFilterSet, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setFilterSet(const ::omero::model::FilterSetPtr& theFilterSet, const ::omero::model::Callback_LogicalChannel_setFilterSetPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setFilterSet(theFilterSet, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setFilterSet(const ::omero::model::FilterSetPtr& theFilterSet, const ::Ice::Context& __ctx, const ::omero::model::Callback_LogicalChannel_setFilterSetPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setFilterSet(theFilterSet, &__ctx, __del, __cookie);
    }

    void end_setFilterSet(const ::Ice::AsyncResultPtr&);
    
private:

    void setFilterSet(const ::omero::model::FilterSetPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setFilterSet(const ::omero::model::FilterSetPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::RIntPtr getSamplesPerPixel()
    {
        return getSamplesPerPixel(0);
    }
    ::omero::RIntPtr getSamplesPerPixel(const ::Ice::Context& __ctx)
    {
        return getSamplesPerPixel(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getSamplesPerPixel()
    {
        return begin_getSamplesPerPixel(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getSamplesPerPixel(const ::Ice::Context& __ctx)
    {
        return begin_getSamplesPerPixel(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getSamplesPerPixel(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getSamplesPerPixel(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getSamplesPerPixel(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getSamplesPerPixel(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getSamplesPerPixel(const ::omero::model::Callback_LogicalChannel_getSamplesPerPixelPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getSamplesPerPixel(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getSamplesPerPixel(const ::Ice::Context& __ctx, const ::omero::model::Callback_LogicalChannel_getSamplesPerPixelPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getSamplesPerPixel(&__ctx, __del, __cookie);
    }

    ::omero::RIntPtr end_getSamplesPerPixel(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::RIntPtr getSamplesPerPixel(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getSamplesPerPixel(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setSamplesPerPixel(const ::omero::RIntPtr& theSamplesPerPixel)
    {
        setSamplesPerPixel(theSamplesPerPixel, 0);
    }
    void setSamplesPerPixel(const ::omero::RIntPtr& theSamplesPerPixel, const ::Ice::Context& __ctx)
    {
        setSamplesPerPixel(theSamplesPerPixel, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setSamplesPerPixel(const ::omero::RIntPtr& theSamplesPerPixel)
    {
        return begin_setSamplesPerPixel(theSamplesPerPixel, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setSamplesPerPixel(const ::omero::RIntPtr& theSamplesPerPixel, const ::Ice::Context& __ctx)
    {
        return begin_setSamplesPerPixel(theSamplesPerPixel, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setSamplesPerPixel(const ::omero::RIntPtr& theSamplesPerPixel, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setSamplesPerPixel(theSamplesPerPixel, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setSamplesPerPixel(const ::omero::RIntPtr& theSamplesPerPixel, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setSamplesPerPixel(theSamplesPerPixel, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setSamplesPerPixel(const ::omero::RIntPtr& theSamplesPerPixel, const ::omero::model::Callback_LogicalChannel_setSamplesPerPixelPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setSamplesPerPixel(theSamplesPerPixel, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setSamplesPerPixel(const ::omero::RIntPtr& theSamplesPerPixel, const ::Ice::Context& __ctx, const ::omero::model::Callback_LogicalChannel_setSamplesPerPixelPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setSamplesPerPixel(theSamplesPerPixel, &__ctx, __del, __cookie);
    }

    void end_setSamplesPerPixel(const ::Ice::AsyncResultPtr&);
    
private:

    void setSamplesPerPixel(const ::omero::RIntPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setSamplesPerPixel(const ::omero::RIntPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::model::PhotometricInterpretationPtr getPhotometricInterpretation()
    {
        return getPhotometricInterpretation(0);
    }
    ::omero::model::PhotometricInterpretationPtr getPhotometricInterpretation(const ::Ice::Context& __ctx)
    {
        return getPhotometricInterpretation(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getPhotometricInterpretation()
    {
        return begin_getPhotometricInterpretation(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getPhotometricInterpretation(const ::Ice::Context& __ctx)
    {
        return begin_getPhotometricInterpretation(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getPhotometricInterpretation(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getPhotometricInterpretation(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getPhotometricInterpretation(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getPhotometricInterpretation(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getPhotometricInterpretation(const ::omero::model::Callback_LogicalChannel_getPhotometricInterpretationPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getPhotometricInterpretation(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getPhotometricInterpretation(const ::Ice::Context& __ctx, const ::omero::model::Callback_LogicalChannel_getPhotometricInterpretationPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getPhotometricInterpretation(&__ctx, __del, __cookie);
    }

    ::omero::model::PhotometricInterpretationPtr end_getPhotometricInterpretation(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::model::PhotometricInterpretationPtr getPhotometricInterpretation(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getPhotometricInterpretation(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setPhotometricInterpretation(const ::omero::model::PhotometricInterpretationPtr& thePhotometricInterpretation)
    {
        setPhotometricInterpretation(thePhotometricInterpretation, 0);
    }
    void setPhotometricInterpretation(const ::omero::model::PhotometricInterpretationPtr& thePhotometricInterpretation, const ::Ice::Context& __ctx)
    {
        setPhotometricInterpretation(thePhotometricInterpretation, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setPhotometricInterpretation(const ::omero::model::PhotometricInterpretationPtr& thePhotometricInterpretation)
    {
        return begin_setPhotometricInterpretation(thePhotometricInterpretation, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setPhotometricInterpretation(const ::omero::model::PhotometricInterpretationPtr& thePhotometricInterpretation, const ::Ice::Context& __ctx)
    {
        return begin_setPhotometricInterpretation(thePhotometricInterpretation, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setPhotometricInterpretation(const ::omero::model::PhotometricInterpretationPtr& thePhotometricInterpretation, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setPhotometricInterpretation(thePhotometricInterpretation, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setPhotometricInterpretation(const ::omero::model::PhotometricInterpretationPtr& thePhotometricInterpretation, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setPhotometricInterpretation(thePhotometricInterpretation, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setPhotometricInterpretation(const ::omero::model::PhotometricInterpretationPtr& thePhotometricInterpretation, const ::omero::model::Callback_LogicalChannel_setPhotometricInterpretationPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setPhotometricInterpretation(thePhotometricInterpretation, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setPhotometricInterpretation(const ::omero::model::PhotometricInterpretationPtr& thePhotometricInterpretation, const ::Ice::Context& __ctx, const ::omero::model::Callback_LogicalChannel_setPhotometricInterpretationPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setPhotometricInterpretation(thePhotometricInterpretation, &__ctx, __del, __cookie);
    }

    void end_setPhotometricInterpretation(const ::Ice::AsyncResultPtr&);
    
private:

    void setPhotometricInterpretation(const ::omero::model::PhotometricInterpretationPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setPhotometricInterpretation(const ::omero::model::PhotometricInterpretationPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::model::AcquisitionModePtr getMode()
    {
        return getMode(0);
    }
    ::omero::model::AcquisitionModePtr getMode(const ::Ice::Context& __ctx)
    {
        return getMode(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getMode()
    {
        return begin_getMode(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getMode(const ::Ice::Context& __ctx)
    {
        return begin_getMode(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getMode(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getMode(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getMode(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getMode(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getMode(const ::omero::model::Callback_LogicalChannel_getModePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getMode(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getMode(const ::Ice::Context& __ctx, const ::omero::model::Callback_LogicalChannel_getModePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getMode(&__ctx, __del, __cookie);
    }

    ::omero::model::AcquisitionModePtr end_getMode(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::model::AcquisitionModePtr getMode(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getMode(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setMode(const ::omero::model::AcquisitionModePtr& theMode)
    {
        setMode(theMode, 0);
    }
    void setMode(const ::omero::model::AcquisitionModePtr& theMode, const ::Ice::Context& __ctx)
    {
        setMode(theMode, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setMode(const ::omero::model::AcquisitionModePtr& theMode)
    {
        return begin_setMode(theMode, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setMode(const ::omero::model::AcquisitionModePtr& theMode, const ::Ice::Context& __ctx)
    {
        return begin_setMode(theMode, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setMode(const ::omero::model::AcquisitionModePtr& theMode, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setMode(theMode, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setMode(const ::omero::model::AcquisitionModePtr& theMode, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setMode(theMode, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setMode(const ::omero::model::AcquisitionModePtr& theMode, const ::omero::model::Callback_LogicalChannel_setModePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setMode(theMode, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setMode(const ::omero::model::AcquisitionModePtr& theMode, const ::Ice::Context& __ctx, const ::omero::model::Callback_LogicalChannel_setModePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setMode(theMode, &__ctx, __del, __cookie);
    }

    void end_setMode(const ::Ice::AsyncResultPtr&);
    
private:

    void setMode(const ::omero::model::AcquisitionModePtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setMode(const ::omero::model::AcquisitionModePtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::RIntPtr getPockelCellSetting()
    {
        return getPockelCellSetting(0);
    }
    ::omero::RIntPtr getPockelCellSetting(const ::Ice::Context& __ctx)
    {
        return getPockelCellSetting(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getPockelCellSetting()
    {
        return begin_getPockelCellSetting(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getPockelCellSetting(const ::Ice::Context& __ctx)
    {
        return begin_getPockelCellSetting(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getPockelCellSetting(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getPockelCellSetting(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getPockelCellSetting(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getPockelCellSetting(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getPockelCellSetting(const ::omero::model::Callback_LogicalChannel_getPockelCellSettingPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getPockelCellSetting(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getPockelCellSetting(const ::Ice::Context& __ctx, const ::omero::model::Callback_LogicalChannel_getPockelCellSettingPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getPockelCellSetting(&__ctx, __del, __cookie);
    }

    ::omero::RIntPtr end_getPockelCellSetting(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::RIntPtr getPockelCellSetting(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getPockelCellSetting(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setPockelCellSetting(const ::omero::RIntPtr& thePockelCellSetting)
    {
        setPockelCellSetting(thePockelCellSetting, 0);
    }
    void setPockelCellSetting(const ::omero::RIntPtr& thePockelCellSetting, const ::Ice::Context& __ctx)
    {
        setPockelCellSetting(thePockelCellSetting, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setPockelCellSetting(const ::omero::RIntPtr& thePockelCellSetting)
    {
        return begin_setPockelCellSetting(thePockelCellSetting, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setPockelCellSetting(const ::omero::RIntPtr& thePockelCellSetting, const ::Ice::Context& __ctx)
    {
        return begin_setPockelCellSetting(thePockelCellSetting, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setPockelCellSetting(const ::omero::RIntPtr& thePockelCellSetting, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setPockelCellSetting(thePockelCellSetting, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setPockelCellSetting(const ::omero::RIntPtr& thePockelCellSetting, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setPockelCellSetting(thePockelCellSetting, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setPockelCellSetting(const ::omero::RIntPtr& thePockelCellSetting, const ::omero::model::Callback_LogicalChannel_setPockelCellSettingPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setPockelCellSetting(thePockelCellSetting, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setPockelCellSetting(const ::omero::RIntPtr& thePockelCellSetting, const ::Ice::Context& __ctx, const ::omero::model::Callback_LogicalChannel_setPockelCellSettingPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setPockelCellSetting(thePockelCellSetting, &__ctx, __del, __cookie);
    }

    void end_setPockelCellSetting(const ::Ice::AsyncResultPtr&);
    
private:

    void setPockelCellSetting(const ::omero::RIntPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setPockelCellSetting(const ::omero::RIntPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void unloadChannels()
    {
        unloadChannels(0);
    }
    void unloadChannels(const ::Ice::Context& __ctx)
    {
        unloadChannels(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_unloadChannels()
    {
        return begin_unloadChannels(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_unloadChannels(const ::Ice::Context& __ctx)
    {
        return begin_unloadChannels(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_unloadChannels(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_unloadChannels(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_unloadChannels(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_unloadChannels(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_unloadChannels(const ::omero::model::Callback_LogicalChannel_unloadChannelsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_unloadChannels(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_unloadChannels(const ::Ice::Context& __ctx, const ::omero::model::Callback_LogicalChannel_unloadChannelsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_unloadChannels(&__ctx, __del, __cookie);
    }

    void end_unloadChannels(const ::Ice::AsyncResultPtr&);
    
private:

    void unloadChannels(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_unloadChannels(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Int sizeOfChannels()
    {
        return sizeOfChannels(0);
    }
    ::Ice::Int sizeOfChannels(const ::Ice::Context& __ctx)
    {
        return sizeOfChannels(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_sizeOfChannels()
    {
        return begin_sizeOfChannels(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_sizeOfChannels(const ::Ice::Context& __ctx)
    {
        return begin_sizeOfChannels(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_sizeOfChannels(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_sizeOfChannels(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_sizeOfChannels(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_sizeOfChannels(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_sizeOfChannels(const ::omero::model::Callback_LogicalChannel_sizeOfChannelsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_sizeOfChannels(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_sizeOfChannels(const ::Ice::Context& __ctx, const ::omero::model::Callback_LogicalChannel_sizeOfChannelsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_sizeOfChannels(&__ctx, __del, __cookie);
    }

    ::Ice::Int end_sizeOfChannels(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int sizeOfChannels(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_sizeOfChannels(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::model::LogicalChannelChannelsSeq copyChannels()
    {
        return copyChannels(0);
    }
    ::omero::model::LogicalChannelChannelsSeq copyChannels(const ::Ice::Context& __ctx)
    {
        return copyChannels(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_copyChannels()
    {
        return begin_copyChannels(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_copyChannels(const ::Ice::Context& __ctx)
    {
        return begin_copyChannels(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_copyChannels(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_copyChannels(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_copyChannels(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_copyChannels(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_copyChannels(const ::omero::model::Callback_LogicalChannel_copyChannelsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_copyChannels(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_copyChannels(const ::Ice::Context& __ctx, const ::omero::model::Callback_LogicalChannel_copyChannelsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_copyChannels(&__ctx, __del, __cookie);
    }

    ::omero::model::LogicalChannelChannelsSeq end_copyChannels(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::model::LogicalChannelChannelsSeq copyChannels(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_copyChannels(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void addChannel(const ::omero::model::ChannelPtr& target)
    {
        addChannel(target, 0);
    }
    void addChannel(const ::omero::model::ChannelPtr& target, const ::Ice::Context& __ctx)
    {
        addChannel(target, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_addChannel(const ::omero::model::ChannelPtr& target)
    {
        return begin_addChannel(target, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_addChannel(const ::omero::model::ChannelPtr& target, const ::Ice::Context& __ctx)
    {
        return begin_addChannel(target, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_addChannel(const ::omero::model::ChannelPtr& target, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_addChannel(target, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_addChannel(const ::omero::model::ChannelPtr& target, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_addChannel(target, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_addChannel(const ::omero::model::ChannelPtr& target, const ::omero::model::Callback_LogicalChannel_addChannelPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_addChannel(target, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_addChannel(const ::omero::model::ChannelPtr& target, const ::Ice::Context& __ctx, const ::omero::model::Callback_LogicalChannel_addChannelPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_addChannel(target, &__ctx, __del, __cookie);
    }

    void end_addChannel(const ::Ice::AsyncResultPtr&);
    
private:

    void addChannel(const ::omero::model::ChannelPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_addChannel(const ::omero::model::ChannelPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void addAllChannelSet(const ::omero::model::LogicalChannelChannelsSeq& targets)
    {
        addAllChannelSet(targets, 0);
    }
    void addAllChannelSet(const ::omero::model::LogicalChannelChannelsSeq& targets, const ::Ice::Context& __ctx)
    {
        addAllChannelSet(targets, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_addAllChannelSet(const ::omero::model::LogicalChannelChannelsSeq& targets)
    {
        return begin_addAllChannelSet(targets, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_addAllChannelSet(const ::omero::model::LogicalChannelChannelsSeq& targets, const ::Ice::Context& __ctx)
    {
        return begin_addAllChannelSet(targets, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_addAllChannelSet(const ::omero::model::LogicalChannelChannelsSeq& targets, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_addAllChannelSet(targets, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_addAllChannelSet(const ::omero::model::LogicalChannelChannelsSeq& targets, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_addAllChannelSet(targets, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_addAllChannelSet(const ::omero::model::LogicalChannelChannelsSeq& targets, const ::omero::model::Callback_LogicalChannel_addAllChannelSetPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_addAllChannelSet(targets, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_addAllChannelSet(const ::omero::model::LogicalChannelChannelsSeq& targets, const ::Ice::Context& __ctx, const ::omero::model::Callback_LogicalChannel_addAllChannelSetPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_addAllChannelSet(targets, &__ctx, __del, __cookie);
    }

    void end_addAllChannelSet(const ::Ice::AsyncResultPtr&);
    
private:

    void addAllChannelSet(const ::omero::model::LogicalChannelChannelsSeq&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_addAllChannelSet(const ::omero::model::LogicalChannelChannelsSeq&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void removeChannel(const ::omero::model::ChannelPtr& theTarget)
    {
        removeChannel(theTarget, 0);
    }
    void removeChannel(const ::omero::model::ChannelPtr& theTarget, const ::Ice::Context& __ctx)
    {
        removeChannel(theTarget, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_removeChannel(const ::omero::model::ChannelPtr& theTarget)
    {
        return begin_removeChannel(theTarget, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_removeChannel(const ::omero::model::ChannelPtr& theTarget, const ::Ice::Context& __ctx)
    {
        return begin_removeChannel(theTarget, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_removeChannel(const ::omero::model::ChannelPtr& theTarget, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_removeChannel(theTarget, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_removeChannel(const ::omero::model::ChannelPtr& theTarget, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_removeChannel(theTarget, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_removeChannel(const ::omero::model::ChannelPtr& theTarget, const ::omero::model::Callback_LogicalChannel_removeChannelPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_removeChannel(theTarget, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_removeChannel(const ::omero::model::ChannelPtr& theTarget, const ::Ice::Context& __ctx, const ::omero::model::Callback_LogicalChannel_removeChannelPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_removeChannel(theTarget, &__ctx, __del, __cookie);
    }

    void end_removeChannel(const ::Ice::AsyncResultPtr&);
    
private:

    void removeChannel(const ::omero::model::ChannelPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_removeChannel(const ::omero::model::ChannelPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void removeAllChannelSet(const ::omero::model::LogicalChannelChannelsSeq& targets)
    {
        removeAllChannelSet(targets, 0);
    }
    void removeAllChannelSet(const ::omero::model::LogicalChannelChannelsSeq& targets, const ::Ice::Context& __ctx)
    {
        removeAllChannelSet(targets, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_removeAllChannelSet(const ::omero::model::LogicalChannelChannelsSeq& targets)
    {
        return begin_removeAllChannelSet(targets, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_removeAllChannelSet(const ::omero::model::LogicalChannelChannelsSeq& targets, const ::Ice::Context& __ctx)
    {
        return begin_removeAllChannelSet(targets, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_removeAllChannelSet(const ::omero::model::LogicalChannelChannelsSeq& targets, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_removeAllChannelSet(targets, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_removeAllChannelSet(const ::omero::model::LogicalChannelChannelsSeq& targets, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_removeAllChannelSet(targets, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_removeAllChannelSet(const ::omero::model::LogicalChannelChannelsSeq& targets, const ::omero::model::Callback_LogicalChannel_removeAllChannelSetPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_removeAllChannelSet(targets, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_removeAllChannelSet(const ::omero::model::LogicalChannelChannelsSeq& targets, const ::Ice::Context& __ctx, const ::omero::model::Callback_LogicalChannel_removeAllChannelSetPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_removeAllChannelSet(targets, &__ctx, __del, __cookie);
    }

    void end_removeAllChannelSet(const ::Ice::AsyncResultPtr&);
    
private:

    void removeAllChannelSet(const ::omero::model::LogicalChannelChannelsSeq&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_removeAllChannelSet(const ::omero::model::LogicalChannelChannelsSeq&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void clearChannels()
    {
        clearChannels(0);
    }
    void clearChannels(const ::Ice::Context& __ctx)
    {
        clearChannels(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_clearChannels()
    {
        return begin_clearChannels(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_clearChannels(const ::Ice::Context& __ctx)
    {
        return begin_clearChannels(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_clearChannels(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_clearChannels(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_clearChannels(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_clearChannels(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_clearChannels(const ::omero::model::Callback_LogicalChannel_clearChannelsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_clearChannels(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_clearChannels(const ::Ice::Context& __ctx, const ::omero::model::Callback_LogicalChannel_clearChannelsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_clearChannels(&__ctx, __del, __cookie);
    }

    void end_clearChannels(const ::Ice::AsyncResultPtr&);
    
private:

    void clearChannels(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_clearChannels(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void reloadChannels(const ::omero::model::LogicalChannelPtr& toCopy)
    {
        reloadChannels(toCopy, 0);
    }
    void reloadChannels(const ::omero::model::LogicalChannelPtr& toCopy, const ::Ice::Context& __ctx)
    {
        reloadChannels(toCopy, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_reloadChannels(const ::omero::model::LogicalChannelPtr& toCopy)
    {
        return begin_reloadChannels(toCopy, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_reloadChannels(const ::omero::model::LogicalChannelPtr& toCopy, const ::Ice::Context& __ctx)
    {
        return begin_reloadChannels(toCopy, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_reloadChannels(const ::omero::model::LogicalChannelPtr& toCopy, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_reloadChannels(toCopy, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_reloadChannels(const ::omero::model::LogicalChannelPtr& toCopy, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_reloadChannels(toCopy, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_reloadChannels(const ::omero::model::LogicalChannelPtr& toCopy, const ::omero::model::Callback_LogicalChannel_reloadChannelsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_reloadChannels(toCopy, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_reloadChannels(const ::omero::model::LogicalChannelPtr& toCopy, const ::Ice::Context& __ctx, const ::omero::model::Callback_LogicalChannel_reloadChannelsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_reloadChannels(toCopy, &__ctx, __del, __cookie);
    }

    void end_reloadChannels(const ::Ice::AsyncResultPtr&);
    
private:

    void reloadChannels(const ::omero::model::LogicalChannelPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_reloadChannels(const ::omero::model::LogicalChannelPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::omero::model::LightPathPtr getLightPath()
    {
        return getLightPath(0);
    }
    ::omero::model::LightPathPtr getLightPath(const ::Ice::Context& __ctx)
    {
        return getLightPath(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getLightPath()
    {
        return begin_getLightPath(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getLightPath(const ::Ice::Context& __ctx)
    {
        return begin_getLightPath(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getLightPath(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getLightPath(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getLightPath(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getLightPath(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getLightPath(const ::omero::model::Callback_LogicalChannel_getLightPathPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getLightPath(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getLightPath(const ::Ice::Context& __ctx, const ::omero::model::Callback_LogicalChannel_getLightPathPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getLightPath(&__ctx, __del, __cookie);
    }

    ::omero::model::LightPathPtr end_getLightPath(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::model::LightPathPtr getLightPath(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getLightPath(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setLightPath(const ::omero::model::LightPathPtr& theLightPath)
    {
        setLightPath(theLightPath, 0);
    }
    void setLightPath(const ::omero::model::LightPathPtr& theLightPath, const ::Ice::Context& __ctx)
    {
        setLightPath(theLightPath, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setLightPath(const ::omero::model::LightPathPtr& theLightPath)
    {
        return begin_setLightPath(theLightPath, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setLightPath(const ::omero::model::LightPathPtr& theLightPath, const ::Ice::Context& __ctx)
    {
        return begin_setLightPath(theLightPath, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setLightPath(const ::omero::model::LightPathPtr& theLightPath, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setLightPath(theLightPath, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setLightPath(const ::omero::model::LightPathPtr& theLightPath, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setLightPath(theLightPath, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setLightPath(const ::omero::model::LightPathPtr& theLightPath, const ::omero::model::Callback_LogicalChannel_setLightPathPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setLightPath(theLightPath, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setLightPath(const ::omero::model::LightPathPtr& theLightPath, const ::Ice::Context& __ctx, const ::omero::model::Callback_LogicalChannel_setLightPathPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setLightPath(theLightPath, &__ctx, __del, __cookie);
    }

    void end_setLightPath(const ::Ice::AsyncResultPtr&);
    
private:

    void setLightPath(const ::omero::model::LightPathPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setLightPath(const ::omero::model::LightPathPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    
    ::IceInternal::ProxyHandle<LogicalChannel> ice_context(const ::Ice::Context& __context) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LogicalChannel*>(_Base::ice_context(__context).get());
    #else
        return dynamic_cast<LogicalChannel*>(::IceProxy::Ice::Object::ice_context(__context).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LogicalChannel> ice_adapterId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LogicalChannel*>(_Base::ice_adapterId(__id).get());
    #else
        return dynamic_cast<LogicalChannel*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LogicalChannel> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LogicalChannel*>(_Base::ice_endpoints(__endpoints).get());
    #else
        return dynamic_cast<LogicalChannel*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LogicalChannel> ice_locatorCacheTimeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LogicalChannel*>(_Base::ice_locatorCacheTimeout(__timeout).get());
    #else
        return dynamic_cast<LogicalChannel*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LogicalChannel> ice_connectionCached(bool __cached) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LogicalChannel*>(_Base::ice_connectionCached(__cached).get());
    #else
        return dynamic_cast<LogicalChannel*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LogicalChannel> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LogicalChannel*>(_Base::ice_endpointSelection(__est).get());
    #else
        return dynamic_cast<LogicalChannel*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LogicalChannel> ice_secure(bool __secure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LogicalChannel*>(_Base::ice_secure(__secure).get());
    #else
        return dynamic_cast<LogicalChannel*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LogicalChannel> ice_preferSecure(bool __preferSecure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LogicalChannel*>(_Base::ice_preferSecure(__preferSecure).get());
    #else
        return dynamic_cast<LogicalChannel*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LogicalChannel> ice_router(const ::Ice::RouterPrx& __router) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LogicalChannel*>(_Base::ice_router(__router).get());
    #else
        return dynamic_cast<LogicalChannel*>(::IceProxy::Ice::Object::ice_router(__router).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LogicalChannel> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LogicalChannel*>(_Base::ice_locator(__locator).get());
    #else
        return dynamic_cast<LogicalChannel*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LogicalChannel> ice_collocationOptimized(bool __co) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LogicalChannel*>(_Base::ice_collocationOptimized(__co).get());
    #else
        return dynamic_cast<LogicalChannel*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LogicalChannel> ice_twoway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LogicalChannel*>(_Base::ice_twoway().get());
    #else
        return dynamic_cast<LogicalChannel*>(::IceProxy::Ice::Object::ice_twoway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LogicalChannel> ice_oneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LogicalChannel*>(_Base::ice_oneway().get());
    #else
        return dynamic_cast<LogicalChannel*>(::IceProxy::Ice::Object::ice_oneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LogicalChannel> ice_batchOneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LogicalChannel*>(_Base::ice_batchOneway().get());
    #else
        return dynamic_cast<LogicalChannel*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LogicalChannel> ice_datagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LogicalChannel*>(_Base::ice_datagram().get());
    #else
        return dynamic_cast<LogicalChannel*>(::IceProxy::Ice::Object::ice_datagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LogicalChannel> ice_batchDatagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LogicalChannel*>(_Base::ice_batchDatagram().get());
    #else
        return dynamic_cast<LogicalChannel*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LogicalChannel> ice_compress(bool __compress) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LogicalChannel*>(_Base::ice_compress(__compress).get());
    #else
        return dynamic_cast<LogicalChannel*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LogicalChannel> ice_timeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LogicalChannel*>(_Base::ice_timeout(__timeout).get());
    #else
        return dynamic_cast<LogicalChannel*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LogicalChannel> ice_connectionId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LogicalChannel*>(_Base::ice_connectionId(__id).get());
    #else
        return dynamic_cast<LogicalChannel*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    #endif
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

}

}

}

namespace IceDelegate
{

namespace omero
{

namespace model
{

class LogicalChannel : virtual public ::IceDelegate::omero::model::IObject
{
public:

    virtual ::omero::RIntPtr getVersion(const ::Ice::Context*) = 0;

    virtual void setVersion(const ::omero::RIntPtr&, const ::Ice::Context*) = 0;

    virtual ::omero::RStringPtr getName(const ::Ice::Context*) = 0;

    virtual void setName(const ::omero::RStringPtr&, const ::Ice::Context*) = 0;

    virtual ::omero::RDoublePtr getPinHoleSize(const ::Ice::Context*) = 0;

    virtual void setPinHoleSize(const ::omero::RDoublePtr&, const ::Ice::Context*) = 0;

    virtual ::omero::model::IlluminationPtr getIllumination(const ::Ice::Context*) = 0;

    virtual void setIllumination(const ::omero::model::IlluminationPtr&, const ::Ice::Context*) = 0;

    virtual ::omero::model::ContrastMethodPtr getContrastMethod(const ::Ice::Context*) = 0;

    virtual void setContrastMethod(const ::omero::model::ContrastMethodPtr&, const ::Ice::Context*) = 0;

    virtual ::omero::RIntPtr getExcitationWave(const ::Ice::Context*) = 0;

    virtual void setExcitationWave(const ::omero::RIntPtr&, const ::Ice::Context*) = 0;

    virtual ::omero::RIntPtr getEmissionWave(const ::Ice::Context*) = 0;

    virtual void setEmissionWave(const ::omero::RIntPtr&, const ::Ice::Context*) = 0;

    virtual ::omero::RStringPtr getFluor(const ::Ice::Context*) = 0;

    virtual void setFluor(const ::omero::RStringPtr&, const ::Ice::Context*) = 0;

    virtual ::omero::RDoublePtr getNdFilter(const ::Ice::Context*) = 0;

    virtual void setNdFilter(const ::omero::RDoublePtr&, const ::Ice::Context*) = 0;

    virtual ::omero::model::OTFPtr getOtf(const ::Ice::Context*) = 0;

    virtual void setOtf(const ::omero::model::OTFPtr&, const ::Ice::Context*) = 0;

    virtual ::omero::model::DetectorSettingsPtr getDetectorSettings(const ::Ice::Context*) = 0;

    virtual void setDetectorSettings(const ::omero::model::DetectorSettingsPtr&, const ::Ice::Context*) = 0;

    virtual ::omero::model::LightSettingsPtr getLightSourceSettings(const ::Ice::Context*) = 0;

    virtual void setLightSourceSettings(const ::omero::model::LightSettingsPtr&, const ::Ice::Context*) = 0;

    virtual ::omero::model::FilterSetPtr getFilterSet(const ::Ice::Context*) = 0;

    virtual void setFilterSet(const ::omero::model::FilterSetPtr&, const ::Ice::Context*) = 0;

    virtual ::omero::RIntPtr getSamplesPerPixel(const ::Ice::Context*) = 0;

    virtual void setSamplesPerPixel(const ::omero::RIntPtr&, const ::Ice::Context*) = 0;

    virtual ::omero::model::PhotometricInterpretationPtr getPhotometricInterpretation(const ::Ice::Context*) = 0;

    virtual void setPhotometricInterpretation(const ::omero::model::PhotometricInterpretationPtr&, const ::Ice::Context*) = 0;

    virtual ::omero::model::AcquisitionModePtr getMode(const ::Ice::Context*) = 0;

    virtual void setMode(const ::omero::model::AcquisitionModePtr&, const ::Ice::Context*) = 0;

    virtual ::omero::RIntPtr getPockelCellSetting(const ::Ice::Context*) = 0;

    virtual void setPockelCellSetting(const ::omero::RIntPtr&, const ::Ice::Context*) = 0;

    virtual void unloadChannels(const ::Ice::Context*) = 0;

    virtual ::Ice::Int sizeOfChannels(const ::Ice::Context*) = 0;

    virtual ::omero::model::LogicalChannelChannelsSeq copyChannels(const ::Ice::Context*) = 0;

    virtual void addChannel(const ::omero::model::ChannelPtr&, const ::Ice::Context*) = 0;

    virtual void addAllChannelSet(const ::omero::model::LogicalChannelChannelsSeq&, const ::Ice::Context*) = 0;

    virtual void removeChannel(const ::omero::model::ChannelPtr&, const ::Ice::Context*) = 0;

    virtual void removeAllChannelSet(const ::omero::model::LogicalChannelChannelsSeq&, const ::Ice::Context*) = 0;

    virtual void clearChannels(const ::Ice::Context*) = 0;

    virtual void reloadChannels(const ::omero::model::LogicalChannelPtr&, const ::Ice::Context*) = 0;

    virtual ::omero::model::LightPathPtr getLightPath(const ::Ice::Context*) = 0;

    virtual void setLightPath(const ::omero::model::LightPathPtr&, const ::Ice::Context*) = 0;
};

}

}

}

namespace IceDelegateM
{

namespace omero
{

namespace model
{

class LogicalChannel : virtual public ::IceDelegate::omero::model::LogicalChannel,
                       virtual public ::IceDelegateM::omero::model::IObject
{
public:

    virtual ::omero::RIntPtr getVersion(const ::Ice::Context*);

    virtual void setVersion(const ::omero::RIntPtr&, const ::Ice::Context*);

    virtual ::omero::RStringPtr getName(const ::Ice::Context*);

    virtual void setName(const ::omero::RStringPtr&, const ::Ice::Context*);

    virtual ::omero::RDoublePtr getPinHoleSize(const ::Ice::Context*);

    virtual void setPinHoleSize(const ::omero::RDoublePtr&, const ::Ice::Context*);

    virtual ::omero::model::IlluminationPtr getIllumination(const ::Ice::Context*);

    virtual void setIllumination(const ::omero::model::IlluminationPtr&, const ::Ice::Context*);

    virtual ::omero::model::ContrastMethodPtr getContrastMethod(const ::Ice::Context*);

    virtual void setContrastMethod(const ::omero::model::ContrastMethodPtr&, const ::Ice::Context*);

    virtual ::omero::RIntPtr getExcitationWave(const ::Ice::Context*);

    virtual void setExcitationWave(const ::omero::RIntPtr&, const ::Ice::Context*);

    virtual ::omero::RIntPtr getEmissionWave(const ::Ice::Context*);

    virtual void setEmissionWave(const ::omero::RIntPtr&, const ::Ice::Context*);

    virtual ::omero::RStringPtr getFluor(const ::Ice::Context*);

    virtual void setFluor(const ::omero::RStringPtr&, const ::Ice::Context*);

    virtual ::omero::RDoublePtr getNdFilter(const ::Ice::Context*);

    virtual void setNdFilter(const ::omero::RDoublePtr&, const ::Ice::Context*);

    virtual ::omero::model::OTFPtr getOtf(const ::Ice::Context*);

    virtual void setOtf(const ::omero::model::OTFPtr&, const ::Ice::Context*);

    virtual ::omero::model::DetectorSettingsPtr getDetectorSettings(const ::Ice::Context*);

    virtual void setDetectorSettings(const ::omero::model::DetectorSettingsPtr&, const ::Ice::Context*);

    virtual ::omero::model::LightSettingsPtr getLightSourceSettings(const ::Ice::Context*);

    virtual void setLightSourceSettings(const ::omero::model::LightSettingsPtr&, const ::Ice::Context*);

    virtual ::omero::model::FilterSetPtr getFilterSet(const ::Ice::Context*);

    virtual void setFilterSet(const ::omero::model::FilterSetPtr&, const ::Ice::Context*);

    virtual ::omero::RIntPtr getSamplesPerPixel(const ::Ice::Context*);

    virtual void setSamplesPerPixel(const ::omero::RIntPtr&, const ::Ice::Context*);

    virtual ::omero::model::PhotometricInterpretationPtr getPhotometricInterpretation(const ::Ice::Context*);

    virtual void setPhotometricInterpretation(const ::omero::model::PhotometricInterpretationPtr&, const ::Ice::Context*);

    virtual ::omero::model::AcquisitionModePtr getMode(const ::Ice::Context*);

    virtual void setMode(const ::omero::model::AcquisitionModePtr&, const ::Ice::Context*);

    virtual ::omero::RIntPtr getPockelCellSetting(const ::Ice::Context*);

    virtual void setPockelCellSetting(const ::omero::RIntPtr&, const ::Ice::Context*);

    virtual void unloadChannels(const ::Ice::Context*);

    virtual ::Ice::Int sizeOfChannels(const ::Ice::Context*);

    virtual ::omero::model::LogicalChannelChannelsSeq copyChannels(const ::Ice::Context*);

    virtual void addChannel(const ::omero::model::ChannelPtr&, const ::Ice::Context*);

    virtual void addAllChannelSet(const ::omero::model::LogicalChannelChannelsSeq&, const ::Ice::Context*);

    virtual void removeChannel(const ::omero::model::ChannelPtr&, const ::Ice::Context*);

    virtual void removeAllChannelSet(const ::omero::model::LogicalChannelChannelsSeq&, const ::Ice::Context*);

    virtual void clearChannels(const ::Ice::Context*);

    virtual void reloadChannels(const ::omero::model::LogicalChannelPtr&, const ::Ice::Context*);

    virtual ::omero::model::LightPathPtr getLightPath(const ::Ice::Context*);

    virtual void setLightPath(const ::omero::model::LightPathPtr&, const ::Ice::Context*);
};

}

}

}

namespace IceDelegateD
{

namespace omero
{

namespace model
{

class LogicalChannel : virtual public ::IceDelegate::omero::model::LogicalChannel,
                       virtual public ::IceDelegateD::omero::model::IObject
{
public:

    virtual ::omero::RIntPtr getVersion(const ::Ice::Context*);

    virtual void setVersion(const ::omero::RIntPtr&, const ::Ice::Context*);

    virtual ::omero::RStringPtr getName(const ::Ice::Context*);

    virtual void setName(const ::omero::RStringPtr&, const ::Ice::Context*);

    virtual ::omero::RDoublePtr getPinHoleSize(const ::Ice::Context*);

    virtual void setPinHoleSize(const ::omero::RDoublePtr&, const ::Ice::Context*);

    virtual ::omero::model::IlluminationPtr getIllumination(const ::Ice::Context*);

    virtual void setIllumination(const ::omero::model::IlluminationPtr&, const ::Ice::Context*);

    virtual ::omero::model::ContrastMethodPtr getContrastMethod(const ::Ice::Context*);

    virtual void setContrastMethod(const ::omero::model::ContrastMethodPtr&, const ::Ice::Context*);

    virtual ::omero::RIntPtr getExcitationWave(const ::Ice::Context*);

    virtual void setExcitationWave(const ::omero::RIntPtr&, const ::Ice::Context*);

    virtual ::omero::RIntPtr getEmissionWave(const ::Ice::Context*);

    virtual void setEmissionWave(const ::omero::RIntPtr&, const ::Ice::Context*);

    virtual ::omero::RStringPtr getFluor(const ::Ice::Context*);

    virtual void setFluor(const ::omero::RStringPtr&, const ::Ice::Context*);

    virtual ::omero::RDoublePtr getNdFilter(const ::Ice::Context*);

    virtual void setNdFilter(const ::omero::RDoublePtr&, const ::Ice::Context*);

    virtual ::omero::model::OTFPtr getOtf(const ::Ice::Context*);

    virtual void setOtf(const ::omero::model::OTFPtr&, const ::Ice::Context*);

    virtual ::omero::model::DetectorSettingsPtr getDetectorSettings(const ::Ice::Context*);

    virtual void setDetectorSettings(const ::omero::model::DetectorSettingsPtr&, const ::Ice::Context*);

    virtual ::omero::model::LightSettingsPtr getLightSourceSettings(const ::Ice::Context*);

    virtual void setLightSourceSettings(const ::omero::model::LightSettingsPtr&, const ::Ice::Context*);

    virtual ::omero::model::FilterSetPtr getFilterSet(const ::Ice::Context*);

    virtual void setFilterSet(const ::omero::model::FilterSetPtr&, const ::Ice::Context*);

    virtual ::omero::RIntPtr getSamplesPerPixel(const ::Ice::Context*);

    virtual void setSamplesPerPixel(const ::omero::RIntPtr&, const ::Ice::Context*);

    virtual ::omero::model::PhotometricInterpretationPtr getPhotometricInterpretation(const ::Ice::Context*);

    virtual void setPhotometricInterpretation(const ::omero::model::PhotometricInterpretationPtr&, const ::Ice::Context*);

    virtual ::omero::model::AcquisitionModePtr getMode(const ::Ice::Context*);

    virtual void setMode(const ::omero::model::AcquisitionModePtr&, const ::Ice::Context*);

    virtual ::omero::RIntPtr getPockelCellSetting(const ::Ice::Context*);

    virtual void setPockelCellSetting(const ::omero::RIntPtr&, const ::Ice::Context*);

    virtual void unloadChannels(const ::Ice::Context*);

    virtual ::Ice::Int sizeOfChannels(const ::Ice::Context*);

    virtual ::omero::model::LogicalChannelChannelsSeq copyChannels(const ::Ice::Context*);

    virtual void addChannel(const ::omero::model::ChannelPtr&, const ::Ice::Context*);

    virtual void addAllChannelSet(const ::omero::model::LogicalChannelChannelsSeq&, const ::Ice::Context*);

    virtual void removeChannel(const ::omero::model::ChannelPtr&, const ::Ice::Context*);

    virtual void removeAllChannelSet(const ::omero::model::LogicalChannelChannelsSeq&, const ::Ice::Context*);

    virtual void clearChannels(const ::Ice::Context*);

    virtual void reloadChannels(const ::omero::model::LogicalChannelPtr&, const ::Ice::Context*);

    virtual ::omero::model::LightPathPtr getLightPath(const ::Ice::Context*);

    virtual void setLightPath(const ::omero::model::LightPathPtr&, const ::Ice::Context*);
};

}

}

}

namespace omero
{

namespace model
{

class LogicalChannel : public ::omero::model::IObject
{
public:

    typedef LogicalChannelPrx ProxyType;
    typedef LogicalChannelPtr PointerType;
    
    LogicalChannel() {}
    LogicalChannel(const ::omero::RLongPtr&, const ::omero::model::DetailsPtr&, bool, const ::omero::RIntPtr&, const ::omero::RStringPtr&, const ::omero::RDoublePtr&, const ::omero::model::IlluminationPtr&, const ::omero::model::ContrastMethodPtr&, const ::omero::RIntPtr&, const ::omero::RIntPtr&, const ::omero::RStringPtr&, const ::omero::RDoublePtr&, const ::omero::model::OTFPtr&, const ::omero::model::DetectorSettingsPtr&, const ::omero::model::LightSettingsPtr&, const ::omero::model::FilterSetPtr&, const ::omero::RIntPtr&, const ::omero::model::PhotometricInterpretationPtr&, const ::omero::model::AcquisitionModePtr&, const ::omero::RIntPtr&, const ::omero::model::LogicalChannelChannelsSeq&, bool, const ::omero::model::LightPathPtr&);
    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void __gcReachable(::IceInternal::GCCountMap&) const;
    virtual void __gcClear();

    virtual ::omero::RIntPtr getVersion(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getVersion(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setVersion(const ::omero::RIntPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setVersion(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::RStringPtr getName(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getName(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setName(const ::omero::RStringPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setName(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::RDoublePtr getPinHoleSize(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getPinHoleSize(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setPinHoleSize(const ::omero::RDoublePtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setPinHoleSize(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::model::IlluminationPtr getIllumination(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getIllumination(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setIllumination(const ::omero::model::IlluminationPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setIllumination(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::model::ContrastMethodPtr getContrastMethod(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getContrastMethod(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setContrastMethod(const ::omero::model::ContrastMethodPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setContrastMethod(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::RIntPtr getExcitationWave(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getExcitationWave(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setExcitationWave(const ::omero::RIntPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setExcitationWave(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::RIntPtr getEmissionWave(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getEmissionWave(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setEmissionWave(const ::omero::RIntPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setEmissionWave(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::RStringPtr getFluor(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getFluor(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setFluor(const ::omero::RStringPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setFluor(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::RDoublePtr getNdFilter(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getNdFilter(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setNdFilter(const ::omero::RDoublePtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setNdFilter(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::model::OTFPtr getOtf(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getOtf(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setOtf(const ::omero::model::OTFPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setOtf(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::model::DetectorSettingsPtr getDetectorSettings(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getDetectorSettings(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setDetectorSettings(const ::omero::model::DetectorSettingsPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setDetectorSettings(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::model::LightSettingsPtr getLightSourceSettings(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getLightSourceSettings(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setLightSourceSettings(const ::omero::model::LightSettingsPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setLightSourceSettings(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::model::FilterSetPtr getFilterSet(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getFilterSet(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setFilterSet(const ::omero::model::FilterSetPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setFilterSet(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::RIntPtr getSamplesPerPixel(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getSamplesPerPixel(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setSamplesPerPixel(const ::omero::RIntPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setSamplesPerPixel(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::model::PhotometricInterpretationPtr getPhotometricInterpretation(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getPhotometricInterpretation(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setPhotometricInterpretation(const ::omero::model::PhotometricInterpretationPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setPhotometricInterpretation(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::model::AcquisitionModePtr getMode(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getMode(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setMode(const ::omero::model::AcquisitionModePtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setMode(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::RIntPtr getPockelCellSetting(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getPockelCellSetting(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setPockelCellSetting(const ::omero::RIntPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setPockelCellSetting(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void unloadChannels(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___unloadChannels(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Int sizeOfChannels(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___sizeOfChannels(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::model::LogicalChannelChannelsSeq copyChannels(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___copyChannels(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void addChannel(const ::omero::model::ChannelPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___addChannel(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void addAllChannelSet(const ::omero::model::LogicalChannelChannelsSeq&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___addAllChannelSet(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void removeChannel(const ::omero::model::ChannelPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___removeChannel(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void removeAllChannelSet(const ::omero::model::LogicalChannelChannelsSeq&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___removeAllChannelSet(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void clearChannels(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___clearChannels(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void reloadChannels(const ::omero::model::LogicalChannelPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___reloadChannels(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::omero::model::LightPathPtr getLightPath(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getLightPath(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setLightPath(const ::omero::model::LightPathPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setLightPath(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void __write(::IceInternal::BasicStream*) const;
    virtual void __read(::IceInternal::BasicStream*, bool);
// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
    virtual void __write(const ::Ice::OutputStreamPtr&) const;
    virtual void __read(const ::Ice::InputStreamPtr&, bool);
#endif

protected:

    ::omero::RIntPtr version;

    ::omero::RStringPtr name;

    ::omero::RDoublePtr pinHoleSize;

    ::omero::model::IlluminationPtr illumination;

    ::omero::model::ContrastMethodPtr contrastMethod;

    ::omero::RIntPtr excitationWave;

    ::omero::RIntPtr emissionWave;

    ::omero::RStringPtr fluor;

    ::omero::RDoublePtr ndFilter;

    ::omero::model::OTFPtr otf;

    ::omero::model::DetectorSettingsPtr detectorSettings;

    ::omero::model::LightSettingsPtr lightSourceSettings;

    ::omero::model::FilterSetPtr filterSet;

    ::omero::RIntPtr samplesPerPixel;

    ::omero::model::PhotometricInterpretationPtr photometricInterpretation;

    ::omero::model::AcquisitionModePtr mode;

    ::omero::RIntPtr pockelCellSetting;

    ::omero::model::LogicalChannelChannelsSeq channelsSeq;

    bool channelsLoaded;

    ::omero::model::LightPathPtr lightPath;
};

inline bool operator==(const LogicalChannel& l, const LogicalChannel& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const LogicalChannel& l, const LogicalChannel& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

}

}

namespace omero
{

namespace model
{

template<class T>
class CallbackNC_LogicalChannel_getVersion : public Callback_LogicalChannel_getVersion_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::RIntPtr&);

    CallbackNC_LogicalChannel_getVersion(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::LogicalChannelPrx __proxy = ::omero::model::LogicalChannelPrx::uncheckedCast(__result->getProxy());
        ::omero::RIntPtr __ret;
        try
        {
            __ret = __proxy->end_getVersion(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_LogicalChannel_getVersionPtr
newCallback_LogicalChannel_getVersion(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RIntPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_getVersion<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicalChannel_getVersionPtr
newCallback_LogicalChannel_getVersion(T* instance, void (T::*cb)(const ::omero::RIntPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_getVersion<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicalChannel_getVersion : public Callback_LogicalChannel_getVersion_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::RIntPtr&, const CT&);

    Callback_LogicalChannel_getVersion(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::LogicalChannelPrx __proxy = ::omero::model::LogicalChannelPrx::uncheckedCast(__result->getProxy());
        ::omero::RIntPtr __ret;
        try
        {
            __ret = __proxy->end_getVersion(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_LogicalChannel_getVersionPtr
newCallback_LogicalChannel_getVersion(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RIntPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_getVersion<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicalChannel_getVersionPtr
newCallback_LogicalChannel_getVersion(T* instance, void (T::*cb)(const ::omero::RIntPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_getVersion<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_LogicalChannel_setVersion : public Callback_LogicalChannel_setVersion_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_LogicalChannel_setVersion(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_LogicalChannel_setVersionPtr
newCallback_LogicalChannel_setVersion(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_setVersion<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicalChannel_setVersionPtr
newCallback_LogicalChannel_setVersion(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_setVersion<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_LogicalChannel_setVersionPtr
newCallback_LogicalChannel_setVersion(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_setVersion<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicalChannel_setVersionPtr
newCallback_LogicalChannel_setVersion(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_setVersion<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicalChannel_setVersion : public Callback_LogicalChannel_setVersion_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_LogicalChannel_setVersion(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_LogicalChannel_setVersionPtr
newCallback_LogicalChannel_setVersion(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_setVersion<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicalChannel_setVersionPtr
newCallback_LogicalChannel_setVersion(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_setVersion<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_LogicalChannel_setVersionPtr
newCallback_LogicalChannel_setVersion(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_setVersion<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicalChannel_setVersionPtr
newCallback_LogicalChannel_setVersion(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_setVersion<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_LogicalChannel_getName : public Callback_LogicalChannel_getName_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::RStringPtr&);

    CallbackNC_LogicalChannel_getName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::LogicalChannelPrx __proxy = ::omero::model::LogicalChannelPrx::uncheckedCast(__result->getProxy());
        ::omero::RStringPtr __ret;
        try
        {
            __ret = __proxy->end_getName(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_LogicalChannel_getNamePtr
newCallback_LogicalChannel_getName(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RStringPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_getName<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicalChannel_getNamePtr
newCallback_LogicalChannel_getName(T* instance, void (T::*cb)(const ::omero::RStringPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_getName<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicalChannel_getName : public Callback_LogicalChannel_getName_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::RStringPtr&, const CT&);

    Callback_LogicalChannel_getName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::LogicalChannelPrx __proxy = ::omero::model::LogicalChannelPrx::uncheckedCast(__result->getProxy());
        ::omero::RStringPtr __ret;
        try
        {
            __ret = __proxy->end_getName(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_LogicalChannel_getNamePtr
newCallback_LogicalChannel_getName(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RStringPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_getName<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicalChannel_getNamePtr
newCallback_LogicalChannel_getName(T* instance, void (T::*cb)(const ::omero::RStringPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_getName<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_LogicalChannel_setName : public Callback_LogicalChannel_setName_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_LogicalChannel_setName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_LogicalChannel_setNamePtr
newCallback_LogicalChannel_setName(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_setName<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicalChannel_setNamePtr
newCallback_LogicalChannel_setName(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_setName<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_LogicalChannel_setNamePtr
newCallback_LogicalChannel_setName(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_setName<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicalChannel_setNamePtr
newCallback_LogicalChannel_setName(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_setName<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicalChannel_setName : public Callback_LogicalChannel_setName_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_LogicalChannel_setName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_LogicalChannel_setNamePtr
newCallback_LogicalChannel_setName(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_setName<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicalChannel_setNamePtr
newCallback_LogicalChannel_setName(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_setName<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_LogicalChannel_setNamePtr
newCallback_LogicalChannel_setName(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_setName<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicalChannel_setNamePtr
newCallback_LogicalChannel_setName(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_setName<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_LogicalChannel_getPinHoleSize : public Callback_LogicalChannel_getPinHoleSize_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::RDoublePtr&);

    CallbackNC_LogicalChannel_getPinHoleSize(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::LogicalChannelPrx __proxy = ::omero::model::LogicalChannelPrx::uncheckedCast(__result->getProxy());
        ::omero::RDoublePtr __ret;
        try
        {
            __ret = __proxy->end_getPinHoleSize(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_LogicalChannel_getPinHoleSizePtr
newCallback_LogicalChannel_getPinHoleSize(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RDoublePtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_getPinHoleSize<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicalChannel_getPinHoleSizePtr
newCallback_LogicalChannel_getPinHoleSize(T* instance, void (T::*cb)(const ::omero::RDoublePtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_getPinHoleSize<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicalChannel_getPinHoleSize : public Callback_LogicalChannel_getPinHoleSize_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::RDoublePtr&, const CT&);

    Callback_LogicalChannel_getPinHoleSize(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::LogicalChannelPrx __proxy = ::omero::model::LogicalChannelPrx::uncheckedCast(__result->getProxy());
        ::omero::RDoublePtr __ret;
        try
        {
            __ret = __proxy->end_getPinHoleSize(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_LogicalChannel_getPinHoleSizePtr
newCallback_LogicalChannel_getPinHoleSize(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RDoublePtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_getPinHoleSize<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicalChannel_getPinHoleSizePtr
newCallback_LogicalChannel_getPinHoleSize(T* instance, void (T::*cb)(const ::omero::RDoublePtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_getPinHoleSize<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_LogicalChannel_setPinHoleSize : public Callback_LogicalChannel_setPinHoleSize_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_LogicalChannel_setPinHoleSize(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_LogicalChannel_setPinHoleSizePtr
newCallback_LogicalChannel_setPinHoleSize(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_setPinHoleSize<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicalChannel_setPinHoleSizePtr
newCallback_LogicalChannel_setPinHoleSize(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_setPinHoleSize<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_LogicalChannel_setPinHoleSizePtr
newCallback_LogicalChannel_setPinHoleSize(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_setPinHoleSize<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicalChannel_setPinHoleSizePtr
newCallback_LogicalChannel_setPinHoleSize(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_setPinHoleSize<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicalChannel_setPinHoleSize : public Callback_LogicalChannel_setPinHoleSize_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_LogicalChannel_setPinHoleSize(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_LogicalChannel_setPinHoleSizePtr
newCallback_LogicalChannel_setPinHoleSize(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_setPinHoleSize<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicalChannel_setPinHoleSizePtr
newCallback_LogicalChannel_setPinHoleSize(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_setPinHoleSize<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_LogicalChannel_setPinHoleSizePtr
newCallback_LogicalChannel_setPinHoleSize(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_setPinHoleSize<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicalChannel_setPinHoleSizePtr
newCallback_LogicalChannel_setPinHoleSize(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_setPinHoleSize<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_LogicalChannel_getIllumination : public Callback_LogicalChannel_getIllumination_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::model::IlluminationPtr&);

    CallbackNC_LogicalChannel_getIllumination(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::LogicalChannelPrx __proxy = ::omero::model::LogicalChannelPrx::uncheckedCast(__result->getProxy());
        ::omero::model::IlluminationPtr __ret;
        try
        {
            __ret = __proxy->end_getIllumination(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_LogicalChannel_getIlluminationPtr
newCallback_LogicalChannel_getIllumination(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::IlluminationPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_getIllumination<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicalChannel_getIlluminationPtr
newCallback_LogicalChannel_getIllumination(T* instance, void (T::*cb)(const ::omero::model::IlluminationPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_getIllumination<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicalChannel_getIllumination : public Callback_LogicalChannel_getIllumination_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::model::IlluminationPtr&, const CT&);

    Callback_LogicalChannel_getIllumination(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::LogicalChannelPrx __proxy = ::omero::model::LogicalChannelPrx::uncheckedCast(__result->getProxy());
        ::omero::model::IlluminationPtr __ret;
        try
        {
            __ret = __proxy->end_getIllumination(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_LogicalChannel_getIlluminationPtr
newCallback_LogicalChannel_getIllumination(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::IlluminationPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_getIllumination<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicalChannel_getIlluminationPtr
newCallback_LogicalChannel_getIllumination(T* instance, void (T::*cb)(const ::omero::model::IlluminationPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_getIllumination<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_LogicalChannel_setIllumination : public Callback_LogicalChannel_setIllumination_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_LogicalChannel_setIllumination(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_LogicalChannel_setIlluminationPtr
newCallback_LogicalChannel_setIllumination(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_setIllumination<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicalChannel_setIlluminationPtr
newCallback_LogicalChannel_setIllumination(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_setIllumination<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_LogicalChannel_setIlluminationPtr
newCallback_LogicalChannel_setIllumination(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_setIllumination<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicalChannel_setIlluminationPtr
newCallback_LogicalChannel_setIllumination(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_setIllumination<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicalChannel_setIllumination : public Callback_LogicalChannel_setIllumination_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_LogicalChannel_setIllumination(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_LogicalChannel_setIlluminationPtr
newCallback_LogicalChannel_setIllumination(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_setIllumination<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicalChannel_setIlluminationPtr
newCallback_LogicalChannel_setIllumination(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_setIllumination<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_LogicalChannel_setIlluminationPtr
newCallback_LogicalChannel_setIllumination(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_setIllumination<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicalChannel_setIlluminationPtr
newCallback_LogicalChannel_setIllumination(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_setIllumination<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_LogicalChannel_getContrastMethod : public Callback_LogicalChannel_getContrastMethod_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::model::ContrastMethodPtr&);

    CallbackNC_LogicalChannel_getContrastMethod(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::LogicalChannelPrx __proxy = ::omero::model::LogicalChannelPrx::uncheckedCast(__result->getProxy());
        ::omero::model::ContrastMethodPtr __ret;
        try
        {
            __ret = __proxy->end_getContrastMethod(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_LogicalChannel_getContrastMethodPtr
newCallback_LogicalChannel_getContrastMethod(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::ContrastMethodPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_getContrastMethod<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicalChannel_getContrastMethodPtr
newCallback_LogicalChannel_getContrastMethod(T* instance, void (T::*cb)(const ::omero::model::ContrastMethodPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_getContrastMethod<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicalChannel_getContrastMethod : public Callback_LogicalChannel_getContrastMethod_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::model::ContrastMethodPtr&, const CT&);

    Callback_LogicalChannel_getContrastMethod(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::LogicalChannelPrx __proxy = ::omero::model::LogicalChannelPrx::uncheckedCast(__result->getProxy());
        ::omero::model::ContrastMethodPtr __ret;
        try
        {
            __ret = __proxy->end_getContrastMethod(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_LogicalChannel_getContrastMethodPtr
newCallback_LogicalChannel_getContrastMethod(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::ContrastMethodPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_getContrastMethod<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicalChannel_getContrastMethodPtr
newCallback_LogicalChannel_getContrastMethod(T* instance, void (T::*cb)(const ::omero::model::ContrastMethodPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_getContrastMethod<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_LogicalChannel_setContrastMethod : public Callback_LogicalChannel_setContrastMethod_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_LogicalChannel_setContrastMethod(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_LogicalChannel_setContrastMethodPtr
newCallback_LogicalChannel_setContrastMethod(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_setContrastMethod<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicalChannel_setContrastMethodPtr
newCallback_LogicalChannel_setContrastMethod(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_setContrastMethod<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_LogicalChannel_setContrastMethodPtr
newCallback_LogicalChannel_setContrastMethod(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_setContrastMethod<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicalChannel_setContrastMethodPtr
newCallback_LogicalChannel_setContrastMethod(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_setContrastMethod<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicalChannel_setContrastMethod : public Callback_LogicalChannel_setContrastMethod_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_LogicalChannel_setContrastMethod(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_LogicalChannel_setContrastMethodPtr
newCallback_LogicalChannel_setContrastMethod(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_setContrastMethod<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicalChannel_setContrastMethodPtr
newCallback_LogicalChannel_setContrastMethod(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_setContrastMethod<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_LogicalChannel_setContrastMethodPtr
newCallback_LogicalChannel_setContrastMethod(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_setContrastMethod<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicalChannel_setContrastMethodPtr
newCallback_LogicalChannel_setContrastMethod(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_setContrastMethod<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_LogicalChannel_getExcitationWave : public Callback_LogicalChannel_getExcitationWave_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::RIntPtr&);

    CallbackNC_LogicalChannel_getExcitationWave(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::LogicalChannelPrx __proxy = ::omero::model::LogicalChannelPrx::uncheckedCast(__result->getProxy());
        ::omero::RIntPtr __ret;
        try
        {
            __ret = __proxy->end_getExcitationWave(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_LogicalChannel_getExcitationWavePtr
newCallback_LogicalChannel_getExcitationWave(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RIntPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_getExcitationWave<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicalChannel_getExcitationWavePtr
newCallback_LogicalChannel_getExcitationWave(T* instance, void (T::*cb)(const ::omero::RIntPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_getExcitationWave<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicalChannel_getExcitationWave : public Callback_LogicalChannel_getExcitationWave_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::RIntPtr&, const CT&);

    Callback_LogicalChannel_getExcitationWave(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::LogicalChannelPrx __proxy = ::omero::model::LogicalChannelPrx::uncheckedCast(__result->getProxy());
        ::omero::RIntPtr __ret;
        try
        {
            __ret = __proxy->end_getExcitationWave(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_LogicalChannel_getExcitationWavePtr
newCallback_LogicalChannel_getExcitationWave(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RIntPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_getExcitationWave<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicalChannel_getExcitationWavePtr
newCallback_LogicalChannel_getExcitationWave(T* instance, void (T::*cb)(const ::omero::RIntPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_getExcitationWave<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_LogicalChannel_setExcitationWave : public Callback_LogicalChannel_setExcitationWave_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_LogicalChannel_setExcitationWave(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_LogicalChannel_setExcitationWavePtr
newCallback_LogicalChannel_setExcitationWave(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_setExcitationWave<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicalChannel_setExcitationWavePtr
newCallback_LogicalChannel_setExcitationWave(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_setExcitationWave<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_LogicalChannel_setExcitationWavePtr
newCallback_LogicalChannel_setExcitationWave(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_setExcitationWave<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicalChannel_setExcitationWavePtr
newCallback_LogicalChannel_setExcitationWave(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_setExcitationWave<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicalChannel_setExcitationWave : public Callback_LogicalChannel_setExcitationWave_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_LogicalChannel_setExcitationWave(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_LogicalChannel_setExcitationWavePtr
newCallback_LogicalChannel_setExcitationWave(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_setExcitationWave<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicalChannel_setExcitationWavePtr
newCallback_LogicalChannel_setExcitationWave(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_setExcitationWave<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_LogicalChannel_setExcitationWavePtr
newCallback_LogicalChannel_setExcitationWave(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_setExcitationWave<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicalChannel_setExcitationWavePtr
newCallback_LogicalChannel_setExcitationWave(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_setExcitationWave<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_LogicalChannel_getEmissionWave : public Callback_LogicalChannel_getEmissionWave_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::RIntPtr&);

    CallbackNC_LogicalChannel_getEmissionWave(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::LogicalChannelPrx __proxy = ::omero::model::LogicalChannelPrx::uncheckedCast(__result->getProxy());
        ::omero::RIntPtr __ret;
        try
        {
            __ret = __proxy->end_getEmissionWave(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_LogicalChannel_getEmissionWavePtr
newCallback_LogicalChannel_getEmissionWave(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RIntPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_getEmissionWave<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicalChannel_getEmissionWavePtr
newCallback_LogicalChannel_getEmissionWave(T* instance, void (T::*cb)(const ::omero::RIntPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_getEmissionWave<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicalChannel_getEmissionWave : public Callback_LogicalChannel_getEmissionWave_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::RIntPtr&, const CT&);

    Callback_LogicalChannel_getEmissionWave(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::LogicalChannelPrx __proxy = ::omero::model::LogicalChannelPrx::uncheckedCast(__result->getProxy());
        ::omero::RIntPtr __ret;
        try
        {
            __ret = __proxy->end_getEmissionWave(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_LogicalChannel_getEmissionWavePtr
newCallback_LogicalChannel_getEmissionWave(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RIntPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_getEmissionWave<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicalChannel_getEmissionWavePtr
newCallback_LogicalChannel_getEmissionWave(T* instance, void (T::*cb)(const ::omero::RIntPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_getEmissionWave<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_LogicalChannel_setEmissionWave : public Callback_LogicalChannel_setEmissionWave_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_LogicalChannel_setEmissionWave(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_LogicalChannel_setEmissionWavePtr
newCallback_LogicalChannel_setEmissionWave(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_setEmissionWave<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicalChannel_setEmissionWavePtr
newCallback_LogicalChannel_setEmissionWave(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_setEmissionWave<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_LogicalChannel_setEmissionWavePtr
newCallback_LogicalChannel_setEmissionWave(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_setEmissionWave<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicalChannel_setEmissionWavePtr
newCallback_LogicalChannel_setEmissionWave(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_setEmissionWave<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicalChannel_setEmissionWave : public Callback_LogicalChannel_setEmissionWave_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_LogicalChannel_setEmissionWave(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_LogicalChannel_setEmissionWavePtr
newCallback_LogicalChannel_setEmissionWave(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_setEmissionWave<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicalChannel_setEmissionWavePtr
newCallback_LogicalChannel_setEmissionWave(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_setEmissionWave<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_LogicalChannel_setEmissionWavePtr
newCallback_LogicalChannel_setEmissionWave(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_setEmissionWave<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicalChannel_setEmissionWavePtr
newCallback_LogicalChannel_setEmissionWave(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_setEmissionWave<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_LogicalChannel_getFluor : public Callback_LogicalChannel_getFluor_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::RStringPtr&);

    CallbackNC_LogicalChannel_getFluor(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::LogicalChannelPrx __proxy = ::omero::model::LogicalChannelPrx::uncheckedCast(__result->getProxy());
        ::omero::RStringPtr __ret;
        try
        {
            __ret = __proxy->end_getFluor(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_LogicalChannel_getFluorPtr
newCallback_LogicalChannel_getFluor(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RStringPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_getFluor<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicalChannel_getFluorPtr
newCallback_LogicalChannel_getFluor(T* instance, void (T::*cb)(const ::omero::RStringPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_getFluor<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicalChannel_getFluor : public Callback_LogicalChannel_getFluor_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::RStringPtr&, const CT&);

    Callback_LogicalChannel_getFluor(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::LogicalChannelPrx __proxy = ::omero::model::LogicalChannelPrx::uncheckedCast(__result->getProxy());
        ::omero::RStringPtr __ret;
        try
        {
            __ret = __proxy->end_getFluor(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_LogicalChannel_getFluorPtr
newCallback_LogicalChannel_getFluor(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RStringPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_getFluor<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicalChannel_getFluorPtr
newCallback_LogicalChannel_getFluor(T* instance, void (T::*cb)(const ::omero::RStringPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_getFluor<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_LogicalChannel_setFluor : public Callback_LogicalChannel_setFluor_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_LogicalChannel_setFluor(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_LogicalChannel_setFluorPtr
newCallback_LogicalChannel_setFluor(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_setFluor<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicalChannel_setFluorPtr
newCallback_LogicalChannel_setFluor(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_setFluor<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_LogicalChannel_setFluorPtr
newCallback_LogicalChannel_setFluor(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_setFluor<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicalChannel_setFluorPtr
newCallback_LogicalChannel_setFluor(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_setFluor<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicalChannel_setFluor : public Callback_LogicalChannel_setFluor_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_LogicalChannel_setFluor(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_LogicalChannel_setFluorPtr
newCallback_LogicalChannel_setFluor(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_setFluor<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicalChannel_setFluorPtr
newCallback_LogicalChannel_setFluor(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_setFluor<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_LogicalChannel_setFluorPtr
newCallback_LogicalChannel_setFluor(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_setFluor<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicalChannel_setFluorPtr
newCallback_LogicalChannel_setFluor(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_setFluor<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_LogicalChannel_getNdFilter : public Callback_LogicalChannel_getNdFilter_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::RDoublePtr&);

    CallbackNC_LogicalChannel_getNdFilter(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::LogicalChannelPrx __proxy = ::omero::model::LogicalChannelPrx::uncheckedCast(__result->getProxy());
        ::omero::RDoublePtr __ret;
        try
        {
            __ret = __proxy->end_getNdFilter(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_LogicalChannel_getNdFilterPtr
newCallback_LogicalChannel_getNdFilter(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RDoublePtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_getNdFilter<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicalChannel_getNdFilterPtr
newCallback_LogicalChannel_getNdFilter(T* instance, void (T::*cb)(const ::omero::RDoublePtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_getNdFilter<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicalChannel_getNdFilter : public Callback_LogicalChannel_getNdFilter_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::RDoublePtr&, const CT&);

    Callback_LogicalChannel_getNdFilter(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::LogicalChannelPrx __proxy = ::omero::model::LogicalChannelPrx::uncheckedCast(__result->getProxy());
        ::omero::RDoublePtr __ret;
        try
        {
            __ret = __proxy->end_getNdFilter(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_LogicalChannel_getNdFilterPtr
newCallback_LogicalChannel_getNdFilter(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RDoublePtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_getNdFilter<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicalChannel_getNdFilterPtr
newCallback_LogicalChannel_getNdFilter(T* instance, void (T::*cb)(const ::omero::RDoublePtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_getNdFilter<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_LogicalChannel_setNdFilter : public Callback_LogicalChannel_setNdFilter_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_LogicalChannel_setNdFilter(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_LogicalChannel_setNdFilterPtr
newCallback_LogicalChannel_setNdFilter(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_setNdFilter<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicalChannel_setNdFilterPtr
newCallback_LogicalChannel_setNdFilter(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_setNdFilter<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_LogicalChannel_setNdFilterPtr
newCallback_LogicalChannel_setNdFilter(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_setNdFilter<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicalChannel_setNdFilterPtr
newCallback_LogicalChannel_setNdFilter(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_setNdFilter<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicalChannel_setNdFilter : public Callback_LogicalChannel_setNdFilter_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_LogicalChannel_setNdFilter(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_LogicalChannel_setNdFilterPtr
newCallback_LogicalChannel_setNdFilter(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_setNdFilter<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicalChannel_setNdFilterPtr
newCallback_LogicalChannel_setNdFilter(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_setNdFilter<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_LogicalChannel_setNdFilterPtr
newCallback_LogicalChannel_setNdFilter(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_setNdFilter<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicalChannel_setNdFilterPtr
newCallback_LogicalChannel_setNdFilter(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_setNdFilter<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_LogicalChannel_getOtf : public Callback_LogicalChannel_getOtf_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::model::OTFPtr&);

    CallbackNC_LogicalChannel_getOtf(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::LogicalChannelPrx __proxy = ::omero::model::LogicalChannelPrx::uncheckedCast(__result->getProxy());
        ::omero::model::OTFPtr __ret;
        try
        {
            __ret = __proxy->end_getOtf(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_LogicalChannel_getOtfPtr
newCallback_LogicalChannel_getOtf(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::OTFPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_getOtf<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicalChannel_getOtfPtr
newCallback_LogicalChannel_getOtf(T* instance, void (T::*cb)(const ::omero::model::OTFPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_getOtf<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicalChannel_getOtf : public Callback_LogicalChannel_getOtf_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::model::OTFPtr&, const CT&);

    Callback_LogicalChannel_getOtf(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::LogicalChannelPrx __proxy = ::omero::model::LogicalChannelPrx::uncheckedCast(__result->getProxy());
        ::omero::model::OTFPtr __ret;
        try
        {
            __ret = __proxy->end_getOtf(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_LogicalChannel_getOtfPtr
newCallback_LogicalChannel_getOtf(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::OTFPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_getOtf<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicalChannel_getOtfPtr
newCallback_LogicalChannel_getOtf(T* instance, void (T::*cb)(const ::omero::model::OTFPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_getOtf<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_LogicalChannel_setOtf : public Callback_LogicalChannel_setOtf_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_LogicalChannel_setOtf(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_LogicalChannel_setOtfPtr
newCallback_LogicalChannel_setOtf(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_setOtf<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicalChannel_setOtfPtr
newCallback_LogicalChannel_setOtf(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_setOtf<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_LogicalChannel_setOtfPtr
newCallback_LogicalChannel_setOtf(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_setOtf<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicalChannel_setOtfPtr
newCallback_LogicalChannel_setOtf(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_setOtf<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicalChannel_setOtf : public Callback_LogicalChannel_setOtf_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_LogicalChannel_setOtf(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_LogicalChannel_setOtfPtr
newCallback_LogicalChannel_setOtf(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_setOtf<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicalChannel_setOtfPtr
newCallback_LogicalChannel_setOtf(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_setOtf<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_LogicalChannel_setOtfPtr
newCallback_LogicalChannel_setOtf(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_setOtf<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicalChannel_setOtfPtr
newCallback_LogicalChannel_setOtf(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_setOtf<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_LogicalChannel_getDetectorSettings : public Callback_LogicalChannel_getDetectorSettings_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::model::DetectorSettingsPtr&);

    CallbackNC_LogicalChannel_getDetectorSettings(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::LogicalChannelPrx __proxy = ::omero::model::LogicalChannelPrx::uncheckedCast(__result->getProxy());
        ::omero::model::DetectorSettingsPtr __ret;
        try
        {
            __ret = __proxy->end_getDetectorSettings(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_LogicalChannel_getDetectorSettingsPtr
newCallback_LogicalChannel_getDetectorSettings(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::DetectorSettingsPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_getDetectorSettings<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicalChannel_getDetectorSettingsPtr
newCallback_LogicalChannel_getDetectorSettings(T* instance, void (T::*cb)(const ::omero::model::DetectorSettingsPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_getDetectorSettings<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicalChannel_getDetectorSettings : public Callback_LogicalChannel_getDetectorSettings_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::model::DetectorSettingsPtr&, const CT&);

    Callback_LogicalChannel_getDetectorSettings(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::LogicalChannelPrx __proxy = ::omero::model::LogicalChannelPrx::uncheckedCast(__result->getProxy());
        ::omero::model::DetectorSettingsPtr __ret;
        try
        {
            __ret = __proxy->end_getDetectorSettings(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_LogicalChannel_getDetectorSettingsPtr
newCallback_LogicalChannel_getDetectorSettings(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::DetectorSettingsPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_getDetectorSettings<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicalChannel_getDetectorSettingsPtr
newCallback_LogicalChannel_getDetectorSettings(T* instance, void (T::*cb)(const ::omero::model::DetectorSettingsPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_getDetectorSettings<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_LogicalChannel_setDetectorSettings : public Callback_LogicalChannel_setDetectorSettings_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_LogicalChannel_setDetectorSettings(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_LogicalChannel_setDetectorSettingsPtr
newCallback_LogicalChannel_setDetectorSettings(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_setDetectorSettings<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicalChannel_setDetectorSettingsPtr
newCallback_LogicalChannel_setDetectorSettings(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_setDetectorSettings<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_LogicalChannel_setDetectorSettingsPtr
newCallback_LogicalChannel_setDetectorSettings(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_setDetectorSettings<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicalChannel_setDetectorSettingsPtr
newCallback_LogicalChannel_setDetectorSettings(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_setDetectorSettings<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicalChannel_setDetectorSettings : public Callback_LogicalChannel_setDetectorSettings_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_LogicalChannel_setDetectorSettings(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_LogicalChannel_setDetectorSettingsPtr
newCallback_LogicalChannel_setDetectorSettings(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_setDetectorSettings<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicalChannel_setDetectorSettingsPtr
newCallback_LogicalChannel_setDetectorSettings(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_setDetectorSettings<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_LogicalChannel_setDetectorSettingsPtr
newCallback_LogicalChannel_setDetectorSettings(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_setDetectorSettings<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicalChannel_setDetectorSettingsPtr
newCallback_LogicalChannel_setDetectorSettings(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_setDetectorSettings<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_LogicalChannel_getLightSourceSettings : public Callback_LogicalChannel_getLightSourceSettings_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::model::LightSettingsPtr&);

    CallbackNC_LogicalChannel_getLightSourceSettings(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::LogicalChannelPrx __proxy = ::omero::model::LogicalChannelPrx::uncheckedCast(__result->getProxy());
        ::omero::model::LightSettingsPtr __ret;
        try
        {
            __ret = __proxy->end_getLightSourceSettings(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_LogicalChannel_getLightSourceSettingsPtr
newCallback_LogicalChannel_getLightSourceSettings(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::LightSettingsPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_getLightSourceSettings<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicalChannel_getLightSourceSettingsPtr
newCallback_LogicalChannel_getLightSourceSettings(T* instance, void (T::*cb)(const ::omero::model::LightSettingsPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_getLightSourceSettings<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicalChannel_getLightSourceSettings : public Callback_LogicalChannel_getLightSourceSettings_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::model::LightSettingsPtr&, const CT&);

    Callback_LogicalChannel_getLightSourceSettings(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::LogicalChannelPrx __proxy = ::omero::model::LogicalChannelPrx::uncheckedCast(__result->getProxy());
        ::omero::model::LightSettingsPtr __ret;
        try
        {
            __ret = __proxy->end_getLightSourceSettings(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_LogicalChannel_getLightSourceSettingsPtr
newCallback_LogicalChannel_getLightSourceSettings(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::LightSettingsPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_getLightSourceSettings<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicalChannel_getLightSourceSettingsPtr
newCallback_LogicalChannel_getLightSourceSettings(T* instance, void (T::*cb)(const ::omero::model::LightSettingsPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_getLightSourceSettings<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_LogicalChannel_setLightSourceSettings : public Callback_LogicalChannel_setLightSourceSettings_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_LogicalChannel_setLightSourceSettings(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_LogicalChannel_setLightSourceSettingsPtr
newCallback_LogicalChannel_setLightSourceSettings(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_setLightSourceSettings<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicalChannel_setLightSourceSettingsPtr
newCallback_LogicalChannel_setLightSourceSettings(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_setLightSourceSettings<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_LogicalChannel_setLightSourceSettingsPtr
newCallback_LogicalChannel_setLightSourceSettings(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_setLightSourceSettings<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicalChannel_setLightSourceSettingsPtr
newCallback_LogicalChannel_setLightSourceSettings(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_setLightSourceSettings<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicalChannel_setLightSourceSettings : public Callback_LogicalChannel_setLightSourceSettings_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_LogicalChannel_setLightSourceSettings(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_LogicalChannel_setLightSourceSettingsPtr
newCallback_LogicalChannel_setLightSourceSettings(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_setLightSourceSettings<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicalChannel_setLightSourceSettingsPtr
newCallback_LogicalChannel_setLightSourceSettings(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_setLightSourceSettings<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_LogicalChannel_setLightSourceSettingsPtr
newCallback_LogicalChannel_setLightSourceSettings(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_setLightSourceSettings<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicalChannel_setLightSourceSettingsPtr
newCallback_LogicalChannel_setLightSourceSettings(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_setLightSourceSettings<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_LogicalChannel_getFilterSet : public Callback_LogicalChannel_getFilterSet_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::model::FilterSetPtr&);

    CallbackNC_LogicalChannel_getFilterSet(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::LogicalChannelPrx __proxy = ::omero::model::LogicalChannelPrx::uncheckedCast(__result->getProxy());
        ::omero::model::FilterSetPtr __ret;
        try
        {
            __ret = __proxy->end_getFilterSet(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_LogicalChannel_getFilterSetPtr
newCallback_LogicalChannel_getFilterSet(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::FilterSetPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_getFilterSet<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicalChannel_getFilterSetPtr
newCallback_LogicalChannel_getFilterSet(T* instance, void (T::*cb)(const ::omero::model::FilterSetPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_getFilterSet<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicalChannel_getFilterSet : public Callback_LogicalChannel_getFilterSet_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::model::FilterSetPtr&, const CT&);

    Callback_LogicalChannel_getFilterSet(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::LogicalChannelPrx __proxy = ::omero::model::LogicalChannelPrx::uncheckedCast(__result->getProxy());
        ::omero::model::FilterSetPtr __ret;
        try
        {
            __ret = __proxy->end_getFilterSet(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_LogicalChannel_getFilterSetPtr
newCallback_LogicalChannel_getFilterSet(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::FilterSetPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_getFilterSet<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicalChannel_getFilterSetPtr
newCallback_LogicalChannel_getFilterSet(T* instance, void (T::*cb)(const ::omero::model::FilterSetPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_getFilterSet<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_LogicalChannel_setFilterSet : public Callback_LogicalChannel_setFilterSet_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_LogicalChannel_setFilterSet(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_LogicalChannel_setFilterSetPtr
newCallback_LogicalChannel_setFilterSet(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_setFilterSet<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicalChannel_setFilterSetPtr
newCallback_LogicalChannel_setFilterSet(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_setFilterSet<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_LogicalChannel_setFilterSetPtr
newCallback_LogicalChannel_setFilterSet(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_setFilterSet<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicalChannel_setFilterSetPtr
newCallback_LogicalChannel_setFilterSet(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_setFilterSet<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicalChannel_setFilterSet : public Callback_LogicalChannel_setFilterSet_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_LogicalChannel_setFilterSet(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_LogicalChannel_setFilterSetPtr
newCallback_LogicalChannel_setFilterSet(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_setFilterSet<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicalChannel_setFilterSetPtr
newCallback_LogicalChannel_setFilterSet(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_setFilterSet<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_LogicalChannel_setFilterSetPtr
newCallback_LogicalChannel_setFilterSet(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_setFilterSet<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicalChannel_setFilterSetPtr
newCallback_LogicalChannel_setFilterSet(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_setFilterSet<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_LogicalChannel_getSamplesPerPixel : public Callback_LogicalChannel_getSamplesPerPixel_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::RIntPtr&);

    CallbackNC_LogicalChannel_getSamplesPerPixel(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::LogicalChannelPrx __proxy = ::omero::model::LogicalChannelPrx::uncheckedCast(__result->getProxy());
        ::omero::RIntPtr __ret;
        try
        {
            __ret = __proxy->end_getSamplesPerPixel(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_LogicalChannel_getSamplesPerPixelPtr
newCallback_LogicalChannel_getSamplesPerPixel(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RIntPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_getSamplesPerPixel<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicalChannel_getSamplesPerPixelPtr
newCallback_LogicalChannel_getSamplesPerPixel(T* instance, void (T::*cb)(const ::omero::RIntPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_getSamplesPerPixel<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicalChannel_getSamplesPerPixel : public Callback_LogicalChannel_getSamplesPerPixel_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::RIntPtr&, const CT&);

    Callback_LogicalChannel_getSamplesPerPixel(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::LogicalChannelPrx __proxy = ::omero::model::LogicalChannelPrx::uncheckedCast(__result->getProxy());
        ::omero::RIntPtr __ret;
        try
        {
            __ret = __proxy->end_getSamplesPerPixel(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_LogicalChannel_getSamplesPerPixelPtr
newCallback_LogicalChannel_getSamplesPerPixel(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RIntPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_getSamplesPerPixel<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicalChannel_getSamplesPerPixelPtr
newCallback_LogicalChannel_getSamplesPerPixel(T* instance, void (T::*cb)(const ::omero::RIntPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_getSamplesPerPixel<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_LogicalChannel_setSamplesPerPixel : public Callback_LogicalChannel_setSamplesPerPixel_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_LogicalChannel_setSamplesPerPixel(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_LogicalChannel_setSamplesPerPixelPtr
newCallback_LogicalChannel_setSamplesPerPixel(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_setSamplesPerPixel<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicalChannel_setSamplesPerPixelPtr
newCallback_LogicalChannel_setSamplesPerPixel(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_setSamplesPerPixel<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_LogicalChannel_setSamplesPerPixelPtr
newCallback_LogicalChannel_setSamplesPerPixel(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_setSamplesPerPixel<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicalChannel_setSamplesPerPixelPtr
newCallback_LogicalChannel_setSamplesPerPixel(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_setSamplesPerPixel<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicalChannel_setSamplesPerPixel : public Callback_LogicalChannel_setSamplesPerPixel_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_LogicalChannel_setSamplesPerPixel(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_LogicalChannel_setSamplesPerPixelPtr
newCallback_LogicalChannel_setSamplesPerPixel(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_setSamplesPerPixel<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicalChannel_setSamplesPerPixelPtr
newCallback_LogicalChannel_setSamplesPerPixel(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_setSamplesPerPixel<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_LogicalChannel_setSamplesPerPixelPtr
newCallback_LogicalChannel_setSamplesPerPixel(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_setSamplesPerPixel<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicalChannel_setSamplesPerPixelPtr
newCallback_LogicalChannel_setSamplesPerPixel(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_setSamplesPerPixel<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_LogicalChannel_getPhotometricInterpretation : public Callback_LogicalChannel_getPhotometricInterpretation_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::model::PhotometricInterpretationPtr&);

    CallbackNC_LogicalChannel_getPhotometricInterpretation(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::LogicalChannelPrx __proxy = ::omero::model::LogicalChannelPrx::uncheckedCast(__result->getProxy());
        ::omero::model::PhotometricInterpretationPtr __ret;
        try
        {
            __ret = __proxy->end_getPhotometricInterpretation(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_LogicalChannel_getPhotometricInterpretationPtr
newCallback_LogicalChannel_getPhotometricInterpretation(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::PhotometricInterpretationPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_getPhotometricInterpretation<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicalChannel_getPhotometricInterpretationPtr
newCallback_LogicalChannel_getPhotometricInterpretation(T* instance, void (T::*cb)(const ::omero::model::PhotometricInterpretationPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_getPhotometricInterpretation<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicalChannel_getPhotometricInterpretation : public Callback_LogicalChannel_getPhotometricInterpretation_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::model::PhotometricInterpretationPtr&, const CT&);

    Callback_LogicalChannel_getPhotometricInterpretation(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::LogicalChannelPrx __proxy = ::omero::model::LogicalChannelPrx::uncheckedCast(__result->getProxy());
        ::omero::model::PhotometricInterpretationPtr __ret;
        try
        {
            __ret = __proxy->end_getPhotometricInterpretation(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_LogicalChannel_getPhotometricInterpretationPtr
newCallback_LogicalChannel_getPhotometricInterpretation(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::PhotometricInterpretationPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_getPhotometricInterpretation<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicalChannel_getPhotometricInterpretationPtr
newCallback_LogicalChannel_getPhotometricInterpretation(T* instance, void (T::*cb)(const ::omero::model::PhotometricInterpretationPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_getPhotometricInterpretation<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_LogicalChannel_setPhotometricInterpretation : public Callback_LogicalChannel_setPhotometricInterpretation_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_LogicalChannel_setPhotometricInterpretation(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_LogicalChannel_setPhotometricInterpretationPtr
newCallback_LogicalChannel_setPhotometricInterpretation(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_setPhotometricInterpretation<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicalChannel_setPhotometricInterpretationPtr
newCallback_LogicalChannel_setPhotometricInterpretation(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_setPhotometricInterpretation<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_LogicalChannel_setPhotometricInterpretationPtr
newCallback_LogicalChannel_setPhotometricInterpretation(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_setPhotometricInterpretation<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicalChannel_setPhotometricInterpretationPtr
newCallback_LogicalChannel_setPhotometricInterpretation(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_setPhotometricInterpretation<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicalChannel_setPhotometricInterpretation : public Callback_LogicalChannel_setPhotometricInterpretation_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_LogicalChannel_setPhotometricInterpretation(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_LogicalChannel_setPhotometricInterpretationPtr
newCallback_LogicalChannel_setPhotometricInterpretation(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_setPhotometricInterpretation<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicalChannel_setPhotometricInterpretationPtr
newCallback_LogicalChannel_setPhotometricInterpretation(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_setPhotometricInterpretation<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_LogicalChannel_setPhotometricInterpretationPtr
newCallback_LogicalChannel_setPhotometricInterpretation(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_setPhotometricInterpretation<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicalChannel_setPhotometricInterpretationPtr
newCallback_LogicalChannel_setPhotometricInterpretation(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_setPhotometricInterpretation<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_LogicalChannel_getMode : public Callback_LogicalChannel_getMode_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::model::AcquisitionModePtr&);

    CallbackNC_LogicalChannel_getMode(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::LogicalChannelPrx __proxy = ::omero::model::LogicalChannelPrx::uncheckedCast(__result->getProxy());
        ::omero::model::AcquisitionModePtr __ret;
        try
        {
            __ret = __proxy->end_getMode(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_LogicalChannel_getModePtr
newCallback_LogicalChannel_getMode(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::AcquisitionModePtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_getMode<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicalChannel_getModePtr
newCallback_LogicalChannel_getMode(T* instance, void (T::*cb)(const ::omero::model::AcquisitionModePtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_getMode<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicalChannel_getMode : public Callback_LogicalChannel_getMode_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::model::AcquisitionModePtr&, const CT&);

    Callback_LogicalChannel_getMode(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::LogicalChannelPrx __proxy = ::omero::model::LogicalChannelPrx::uncheckedCast(__result->getProxy());
        ::omero::model::AcquisitionModePtr __ret;
        try
        {
            __ret = __proxy->end_getMode(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_LogicalChannel_getModePtr
newCallback_LogicalChannel_getMode(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::AcquisitionModePtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_getMode<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicalChannel_getModePtr
newCallback_LogicalChannel_getMode(T* instance, void (T::*cb)(const ::omero::model::AcquisitionModePtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_getMode<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_LogicalChannel_setMode : public Callback_LogicalChannel_setMode_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_LogicalChannel_setMode(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_LogicalChannel_setModePtr
newCallback_LogicalChannel_setMode(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_setMode<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicalChannel_setModePtr
newCallback_LogicalChannel_setMode(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_setMode<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_LogicalChannel_setModePtr
newCallback_LogicalChannel_setMode(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_setMode<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicalChannel_setModePtr
newCallback_LogicalChannel_setMode(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_setMode<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicalChannel_setMode : public Callback_LogicalChannel_setMode_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_LogicalChannel_setMode(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_LogicalChannel_setModePtr
newCallback_LogicalChannel_setMode(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_setMode<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicalChannel_setModePtr
newCallback_LogicalChannel_setMode(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_setMode<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_LogicalChannel_setModePtr
newCallback_LogicalChannel_setMode(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_setMode<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicalChannel_setModePtr
newCallback_LogicalChannel_setMode(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_setMode<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_LogicalChannel_getPockelCellSetting : public Callback_LogicalChannel_getPockelCellSetting_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::RIntPtr&);

    CallbackNC_LogicalChannel_getPockelCellSetting(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::LogicalChannelPrx __proxy = ::omero::model::LogicalChannelPrx::uncheckedCast(__result->getProxy());
        ::omero::RIntPtr __ret;
        try
        {
            __ret = __proxy->end_getPockelCellSetting(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_LogicalChannel_getPockelCellSettingPtr
newCallback_LogicalChannel_getPockelCellSetting(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RIntPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_getPockelCellSetting<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicalChannel_getPockelCellSettingPtr
newCallback_LogicalChannel_getPockelCellSetting(T* instance, void (T::*cb)(const ::omero::RIntPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_getPockelCellSetting<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicalChannel_getPockelCellSetting : public Callback_LogicalChannel_getPockelCellSetting_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::RIntPtr&, const CT&);

    Callback_LogicalChannel_getPockelCellSetting(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::LogicalChannelPrx __proxy = ::omero::model::LogicalChannelPrx::uncheckedCast(__result->getProxy());
        ::omero::RIntPtr __ret;
        try
        {
            __ret = __proxy->end_getPockelCellSetting(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_LogicalChannel_getPockelCellSettingPtr
newCallback_LogicalChannel_getPockelCellSetting(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RIntPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_getPockelCellSetting<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicalChannel_getPockelCellSettingPtr
newCallback_LogicalChannel_getPockelCellSetting(T* instance, void (T::*cb)(const ::omero::RIntPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_getPockelCellSetting<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_LogicalChannel_setPockelCellSetting : public Callback_LogicalChannel_setPockelCellSetting_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_LogicalChannel_setPockelCellSetting(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_LogicalChannel_setPockelCellSettingPtr
newCallback_LogicalChannel_setPockelCellSetting(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_setPockelCellSetting<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicalChannel_setPockelCellSettingPtr
newCallback_LogicalChannel_setPockelCellSetting(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_setPockelCellSetting<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_LogicalChannel_setPockelCellSettingPtr
newCallback_LogicalChannel_setPockelCellSetting(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_setPockelCellSetting<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicalChannel_setPockelCellSettingPtr
newCallback_LogicalChannel_setPockelCellSetting(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_setPockelCellSetting<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicalChannel_setPockelCellSetting : public Callback_LogicalChannel_setPockelCellSetting_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_LogicalChannel_setPockelCellSetting(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_LogicalChannel_setPockelCellSettingPtr
newCallback_LogicalChannel_setPockelCellSetting(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_setPockelCellSetting<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicalChannel_setPockelCellSettingPtr
newCallback_LogicalChannel_setPockelCellSetting(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_setPockelCellSetting<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_LogicalChannel_setPockelCellSettingPtr
newCallback_LogicalChannel_setPockelCellSetting(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_setPockelCellSetting<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicalChannel_setPockelCellSettingPtr
newCallback_LogicalChannel_setPockelCellSetting(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_setPockelCellSetting<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_LogicalChannel_unloadChannels : public Callback_LogicalChannel_unloadChannels_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_LogicalChannel_unloadChannels(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_LogicalChannel_unloadChannelsPtr
newCallback_LogicalChannel_unloadChannels(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_unloadChannels<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicalChannel_unloadChannelsPtr
newCallback_LogicalChannel_unloadChannels(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_unloadChannels<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_LogicalChannel_unloadChannelsPtr
newCallback_LogicalChannel_unloadChannels(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_unloadChannels<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicalChannel_unloadChannelsPtr
newCallback_LogicalChannel_unloadChannels(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_unloadChannels<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicalChannel_unloadChannels : public Callback_LogicalChannel_unloadChannels_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_LogicalChannel_unloadChannels(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_LogicalChannel_unloadChannelsPtr
newCallback_LogicalChannel_unloadChannels(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_unloadChannels<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicalChannel_unloadChannelsPtr
newCallback_LogicalChannel_unloadChannels(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_unloadChannels<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_LogicalChannel_unloadChannelsPtr
newCallback_LogicalChannel_unloadChannels(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_unloadChannels<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicalChannel_unloadChannelsPtr
newCallback_LogicalChannel_unloadChannels(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_unloadChannels<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_LogicalChannel_sizeOfChannels : public Callback_LogicalChannel_sizeOfChannels_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int);

    CallbackNC_LogicalChannel_sizeOfChannels(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::LogicalChannelPrx __proxy = ::omero::model::LogicalChannelPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_sizeOfChannels(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_LogicalChannel_sizeOfChannelsPtr
newCallback_LogicalChannel_sizeOfChannels(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_sizeOfChannels<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicalChannel_sizeOfChannelsPtr
newCallback_LogicalChannel_sizeOfChannels(T* instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_sizeOfChannels<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicalChannel_sizeOfChannels : public Callback_LogicalChannel_sizeOfChannels_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const CT&);

    Callback_LogicalChannel_sizeOfChannels(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::LogicalChannelPrx __proxy = ::omero::model::LogicalChannelPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_sizeOfChannels(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_LogicalChannel_sizeOfChannelsPtr
newCallback_LogicalChannel_sizeOfChannels(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_sizeOfChannels<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicalChannel_sizeOfChannelsPtr
newCallback_LogicalChannel_sizeOfChannels(T* instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_sizeOfChannels<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_LogicalChannel_copyChannels : public Callback_LogicalChannel_copyChannels_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::model::LogicalChannelChannelsSeq&);

    CallbackNC_LogicalChannel_copyChannels(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::LogicalChannelPrx __proxy = ::omero::model::LogicalChannelPrx::uncheckedCast(__result->getProxy());
        ::omero::model::LogicalChannelChannelsSeq __ret;
        try
        {
            __ret = __proxy->end_copyChannels(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_LogicalChannel_copyChannelsPtr
newCallback_LogicalChannel_copyChannels(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::LogicalChannelChannelsSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_copyChannels<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicalChannel_copyChannelsPtr
newCallback_LogicalChannel_copyChannels(T* instance, void (T::*cb)(const ::omero::model::LogicalChannelChannelsSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_copyChannels<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicalChannel_copyChannels : public Callback_LogicalChannel_copyChannels_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::model::LogicalChannelChannelsSeq&, const CT&);

    Callback_LogicalChannel_copyChannels(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::LogicalChannelPrx __proxy = ::omero::model::LogicalChannelPrx::uncheckedCast(__result->getProxy());
        ::omero::model::LogicalChannelChannelsSeq __ret;
        try
        {
            __ret = __proxy->end_copyChannels(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_LogicalChannel_copyChannelsPtr
newCallback_LogicalChannel_copyChannels(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::LogicalChannelChannelsSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_copyChannels<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicalChannel_copyChannelsPtr
newCallback_LogicalChannel_copyChannels(T* instance, void (T::*cb)(const ::omero::model::LogicalChannelChannelsSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_copyChannels<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_LogicalChannel_addChannel : public Callback_LogicalChannel_addChannel_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_LogicalChannel_addChannel(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_LogicalChannel_addChannelPtr
newCallback_LogicalChannel_addChannel(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_addChannel<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicalChannel_addChannelPtr
newCallback_LogicalChannel_addChannel(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_addChannel<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_LogicalChannel_addChannelPtr
newCallback_LogicalChannel_addChannel(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_addChannel<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicalChannel_addChannelPtr
newCallback_LogicalChannel_addChannel(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_addChannel<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicalChannel_addChannel : public Callback_LogicalChannel_addChannel_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_LogicalChannel_addChannel(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_LogicalChannel_addChannelPtr
newCallback_LogicalChannel_addChannel(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_addChannel<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicalChannel_addChannelPtr
newCallback_LogicalChannel_addChannel(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_addChannel<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_LogicalChannel_addChannelPtr
newCallback_LogicalChannel_addChannel(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_addChannel<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicalChannel_addChannelPtr
newCallback_LogicalChannel_addChannel(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_addChannel<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_LogicalChannel_addAllChannelSet : public Callback_LogicalChannel_addAllChannelSet_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_LogicalChannel_addAllChannelSet(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_LogicalChannel_addAllChannelSetPtr
newCallback_LogicalChannel_addAllChannelSet(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_addAllChannelSet<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicalChannel_addAllChannelSetPtr
newCallback_LogicalChannel_addAllChannelSet(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_addAllChannelSet<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_LogicalChannel_addAllChannelSetPtr
newCallback_LogicalChannel_addAllChannelSet(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_addAllChannelSet<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicalChannel_addAllChannelSetPtr
newCallback_LogicalChannel_addAllChannelSet(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_addAllChannelSet<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicalChannel_addAllChannelSet : public Callback_LogicalChannel_addAllChannelSet_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_LogicalChannel_addAllChannelSet(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_LogicalChannel_addAllChannelSetPtr
newCallback_LogicalChannel_addAllChannelSet(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_addAllChannelSet<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicalChannel_addAllChannelSetPtr
newCallback_LogicalChannel_addAllChannelSet(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_addAllChannelSet<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_LogicalChannel_addAllChannelSetPtr
newCallback_LogicalChannel_addAllChannelSet(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_addAllChannelSet<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicalChannel_addAllChannelSetPtr
newCallback_LogicalChannel_addAllChannelSet(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_addAllChannelSet<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_LogicalChannel_removeChannel : public Callback_LogicalChannel_removeChannel_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_LogicalChannel_removeChannel(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_LogicalChannel_removeChannelPtr
newCallback_LogicalChannel_removeChannel(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_removeChannel<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicalChannel_removeChannelPtr
newCallback_LogicalChannel_removeChannel(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_removeChannel<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_LogicalChannel_removeChannelPtr
newCallback_LogicalChannel_removeChannel(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_removeChannel<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicalChannel_removeChannelPtr
newCallback_LogicalChannel_removeChannel(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_removeChannel<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicalChannel_removeChannel : public Callback_LogicalChannel_removeChannel_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_LogicalChannel_removeChannel(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_LogicalChannel_removeChannelPtr
newCallback_LogicalChannel_removeChannel(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_removeChannel<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicalChannel_removeChannelPtr
newCallback_LogicalChannel_removeChannel(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_removeChannel<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_LogicalChannel_removeChannelPtr
newCallback_LogicalChannel_removeChannel(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_removeChannel<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicalChannel_removeChannelPtr
newCallback_LogicalChannel_removeChannel(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_removeChannel<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_LogicalChannel_removeAllChannelSet : public Callback_LogicalChannel_removeAllChannelSet_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_LogicalChannel_removeAllChannelSet(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_LogicalChannel_removeAllChannelSetPtr
newCallback_LogicalChannel_removeAllChannelSet(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_removeAllChannelSet<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicalChannel_removeAllChannelSetPtr
newCallback_LogicalChannel_removeAllChannelSet(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_removeAllChannelSet<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_LogicalChannel_removeAllChannelSetPtr
newCallback_LogicalChannel_removeAllChannelSet(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_removeAllChannelSet<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicalChannel_removeAllChannelSetPtr
newCallback_LogicalChannel_removeAllChannelSet(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_removeAllChannelSet<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicalChannel_removeAllChannelSet : public Callback_LogicalChannel_removeAllChannelSet_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_LogicalChannel_removeAllChannelSet(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_LogicalChannel_removeAllChannelSetPtr
newCallback_LogicalChannel_removeAllChannelSet(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_removeAllChannelSet<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicalChannel_removeAllChannelSetPtr
newCallback_LogicalChannel_removeAllChannelSet(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_removeAllChannelSet<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_LogicalChannel_removeAllChannelSetPtr
newCallback_LogicalChannel_removeAllChannelSet(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_removeAllChannelSet<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicalChannel_removeAllChannelSetPtr
newCallback_LogicalChannel_removeAllChannelSet(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_removeAllChannelSet<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_LogicalChannel_clearChannels : public Callback_LogicalChannel_clearChannels_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_LogicalChannel_clearChannels(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_LogicalChannel_clearChannelsPtr
newCallback_LogicalChannel_clearChannels(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_clearChannels<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicalChannel_clearChannelsPtr
newCallback_LogicalChannel_clearChannels(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_clearChannels<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_LogicalChannel_clearChannelsPtr
newCallback_LogicalChannel_clearChannels(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_clearChannels<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicalChannel_clearChannelsPtr
newCallback_LogicalChannel_clearChannels(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_clearChannels<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicalChannel_clearChannels : public Callback_LogicalChannel_clearChannels_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_LogicalChannel_clearChannels(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_LogicalChannel_clearChannelsPtr
newCallback_LogicalChannel_clearChannels(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_clearChannels<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicalChannel_clearChannelsPtr
newCallback_LogicalChannel_clearChannels(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_clearChannels<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_LogicalChannel_clearChannelsPtr
newCallback_LogicalChannel_clearChannels(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_clearChannels<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicalChannel_clearChannelsPtr
newCallback_LogicalChannel_clearChannels(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_clearChannels<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_LogicalChannel_reloadChannels : public Callback_LogicalChannel_reloadChannels_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_LogicalChannel_reloadChannels(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_LogicalChannel_reloadChannelsPtr
newCallback_LogicalChannel_reloadChannels(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_reloadChannels<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicalChannel_reloadChannelsPtr
newCallback_LogicalChannel_reloadChannels(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_reloadChannels<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_LogicalChannel_reloadChannelsPtr
newCallback_LogicalChannel_reloadChannels(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_reloadChannels<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicalChannel_reloadChannelsPtr
newCallback_LogicalChannel_reloadChannels(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_reloadChannels<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicalChannel_reloadChannels : public Callback_LogicalChannel_reloadChannels_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_LogicalChannel_reloadChannels(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_LogicalChannel_reloadChannelsPtr
newCallback_LogicalChannel_reloadChannels(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_reloadChannels<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicalChannel_reloadChannelsPtr
newCallback_LogicalChannel_reloadChannels(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_reloadChannels<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_LogicalChannel_reloadChannelsPtr
newCallback_LogicalChannel_reloadChannels(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_reloadChannels<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicalChannel_reloadChannelsPtr
newCallback_LogicalChannel_reloadChannels(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_reloadChannels<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_LogicalChannel_getLightPath : public Callback_LogicalChannel_getLightPath_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::model::LightPathPtr&);

    CallbackNC_LogicalChannel_getLightPath(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::LogicalChannelPrx __proxy = ::omero::model::LogicalChannelPrx::uncheckedCast(__result->getProxy());
        ::omero::model::LightPathPtr __ret;
        try
        {
            __ret = __proxy->end_getLightPath(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_LogicalChannel_getLightPathPtr
newCallback_LogicalChannel_getLightPath(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::LightPathPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_getLightPath<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicalChannel_getLightPathPtr
newCallback_LogicalChannel_getLightPath(T* instance, void (T::*cb)(const ::omero::model::LightPathPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_getLightPath<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicalChannel_getLightPath : public Callback_LogicalChannel_getLightPath_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::model::LightPathPtr&, const CT&);

    Callback_LogicalChannel_getLightPath(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::model::LogicalChannelPrx __proxy = ::omero::model::LogicalChannelPrx::uncheckedCast(__result->getProxy());
        ::omero::model::LightPathPtr __ret;
        try
        {
            __ret = __proxy->end_getLightPath(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_LogicalChannel_getLightPathPtr
newCallback_LogicalChannel_getLightPath(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::LightPathPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_getLightPath<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicalChannel_getLightPathPtr
newCallback_LogicalChannel_getLightPath(T* instance, void (T::*cb)(const ::omero::model::LightPathPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_getLightPath<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_LogicalChannel_setLightPath : public Callback_LogicalChannel_setLightPath_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_LogicalChannel_setLightPath(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_LogicalChannel_setLightPathPtr
newCallback_LogicalChannel_setLightPath(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_setLightPath<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicalChannel_setLightPathPtr
newCallback_LogicalChannel_setLightPath(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_setLightPath<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_LogicalChannel_setLightPathPtr
newCallback_LogicalChannel_setLightPath(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_setLightPath<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicalChannel_setLightPathPtr
newCallback_LogicalChannel_setLightPath(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicalChannel_setLightPath<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicalChannel_setLightPath : public Callback_LogicalChannel_setLightPath_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_LogicalChannel_setLightPath(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_LogicalChannel_setLightPathPtr
newCallback_LogicalChannel_setLightPath(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_setLightPath<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicalChannel_setLightPathPtr
newCallback_LogicalChannel_setLightPath(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_setLightPath<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_LogicalChannel_setLightPathPtr
newCallback_LogicalChannel_setLightPath(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_setLightPath<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicalChannel_setLightPathPtr
newCallback_LogicalChannel_setLightPath(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicalChannel_setLightPath<T, CT>(instance, 0, excb, sentcb);
}

}

}

#endif
