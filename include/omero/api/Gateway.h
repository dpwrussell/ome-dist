// **********************************************************************
//
// Copyright (c) 2003-2013 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.5.1
//
// <auto-generated>
//
// Generated from file `Gateway.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __omero_api__opt_hudson_workspace_OMERO_5_0_release_src_components_blitz_generated_omero_api_Gateway_h__
#define __omero_api__opt_hudson_workspace_OMERO_5_0_release_src_components_blitz_generated_omero_api_Gateway_h__

#include <Ice/ProxyF.h>
#include <Ice/ObjectF.h>
#include <Ice/Exception.h>
#include <Ice/LocalObject.h>
#include <Ice/StreamHelpers.h>
#include <Ice/Proxy.h>
#include <Ice/Object.h>
#include <Ice/Outgoing.h>
#include <Ice/OutgoingAsync.h>
#include <Ice/Incoming.h>
#include <Ice/IncomingAsync.h>
#include <Ice/Direct.h>
#include <Ice/FactoryTableInit.h>
#include <IceUtil/ScopedArray.h>
#include <IceUtil/Optional.h>
#include <Ice/StreamF.h>
#include <Ice/SlicedDataF.h>
#include <omero/Collections.h>
#include <omero/ServicesF.h>
#include <omero/ServerErrors.h>
#include <Ice/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 305
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 > 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 1
#       error Ice patch level mismatch!
#   endif
#endif

namespace IceProxy
{

namespace omero
{

namespace api
{

class BufferedImage;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::omero::api::BufferedImage>&);
::IceProxy::Ice::Object* upCast(::IceProxy::omero::api::BufferedImage*);

class Gateway;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::omero::api::Gateway>&);
::IceProxy::Ice::Object* upCast(::IceProxy::omero::api::Gateway*);

}

}

}

namespace omero
{

namespace api
{

class BufferedImage;
bool operator==(const BufferedImage&, const BufferedImage&);
bool operator<(const BufferedImage&, const BufferedImage&);
::Ice::Object* upCast(::omero::api::BufferedImage*);
typedef ::IceInternal::Handle< ::omero::api::BufferedImage> BufferedImagePtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::omero::api::BufferedImage> BufferedImagePrx;
void __patch(BufferedImagePtr&, const ::Ice::ObjectPtr&);

class Gateway;
bool operator==(const Gateway&, const Gateway&);
bool operator<(const Gateway&, const Gateway&);
::Ice::Object* upCast(::omero::api::Gateway*);
typedef ::IceInternal::Handle< ::omero::api::Gateway> GatewayPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::omero::api::Gateway> GatewayPrx;
void __patch(GatewayPtr&, const ::Ice::ObjectPtr&);

}

}

namespace omero
{

namespace api
{

enum ContainerClass
{
    Category,
    CategoryGroup,
    Project,
    Dataset,
    Image
};

}

}

namespace Ice
{
template<>
struct StreamableTraits< ::omero::api::ContainerClass>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 4;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

}

namespace omero
{

namespace api
{

class AMI_Gateway_getProjects : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::omero::api::ProjectList&) = 0;

    void __response(const ::omero::api::ProjectList& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_Gateway_getProjects> AMI_Gateway_getProjectsPtr;

class AMI_Gateway_getDatasets : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::omero::api::DatasetList&) = 0;

    void __response(const ::omero::api::DatasetList& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_Gateway_getDatasets> AMI_Gateway_getDatasetsPtr;

class AMI_Gateway_getDataset : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::omero::model::DatasetPtr&) = 0;

    void __response(const ::omero::model::DatasetPtr& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_Gateway_getDataset> AMI_Gateway_getDatasetPtr;

class AMI_Gateway_getPixelsFromImage : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::omero::api::PixelsList&) = 0;

    void __response(const ::omero::api::PixelsList& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_Gateway_getPixelsFromImage> AMI_Gateway_getPixelsFromImagePtr;

class AMI_Gateway_getImage : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::omero::model::ImagePtr&) = 0;

    void __response(const ::omero::model::ImagePtr& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_Gateway_getImage> AMI_Gateway_getImagePtr;

class AMI_Gateway_getImages : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::omero::api::ImageList&) = 0;

    void __response(const ::omero::api::ImageList& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_Gateway_getImages> AMI_Gateway_getImagesPtr;

class AMI_Gateway_findAllByQuery : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::omero::api::IObjectList&) = 0;

    void __response(const ::omero::api::IObjectList& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_Gateway_findAllByQuery> AMI_Gateway_findAllByQueryPtr;

class AMI_Gateway_findByQuery : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::omero::model::IObjectPtr&) = 0;

    void __response(const ::omero::model::IObjectPtr& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_Gateway_findByQuery> AMI_Gateway_findByQueryPtr;

class AMI_Gateway_getPlane : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::Ice::ByteSeq&) = 0;

    void __response(const ::Ice::ByteSeq& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_Gateway_getPlane> AMI_Gateway_getPlanePtr;

class AMI_Gateway_getPixels : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::omero::model::PixelsPtr&) = 0;

    void __response(const ::omero::model::PixelsPtr& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_Gateway_getPixels> AMI_Gateway_getPixelsPtr;

class AMI_Gateway_copyPixelsXYTZ : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(::Ice::Long) = 0;

    void __response(::Ice::Long __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_Gateway_copyPixelsXYTZ> AMI_Gateway_copyPixelsXYTZPtr;

class AMI_Gateway_copyPixels : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(::Ice::Long) = 0;

    void __response(::Ice::Long __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_Gateway_copyPixels> AMI_Gateway_copyPixelsPtr;

class AMI_Gateway_copyImage : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(::Ice::Long) = 0;

    void __response(::Ice::Long __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_Gateway_copyImage> AMI_Gateway_copyImagePtr;

class AMI_Gateway_uploadPlane : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response() = 0;

    void __response()
    {
        ice_response();
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_Gateway_uploadPlane> AMI_Gateway_uploadPlanePtr;

class AMI_Gateway_updatePixels : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::omero::model::PixelsPtr&) = 0;

    void __response(const ::omero::model::PixelsPtr& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_Gateway_updatePixels> AMI_Gateway_updatePixelsPtr;

class AMI_Gateway_getPixelTypes : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::omero::api::PixelsTypeList&) = 0;

    void __response(const ::omero::api::PixelsTypeList& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_Gateway_getPixelTypes> AMI_Gateway_getPixelTypesPtr;

class AMI_Gateway_getPixelType : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::omero::model::PixelsTypePtr&) = 0;

    void __response(const ::omero::model::PixelsTypePtr& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_Gateway_getPixelType> AMI_Gateway_getPixelTypePtr;

class AMI_Gateway_getRenderedImage : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::omero::api::IntegerArray&) = 0;

    void __response(const ::omero::api::IntegerArray& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_Gateway_getRenderedImage> AMI_Gateway_getRenderedImagePtr;

class AMI_Gateway_renderAsPackedIntAsRGBA : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::omero::api::IntegerArray&) = 0;

    void __response(const ::omero::api::IntegerArray& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_Gateway_renderAsPackedIntAsRGBA> AMI_Gateway_renderAsPackedIntAsRGBAPtr;

class AMI_Gateway_getRenderedImageMatrix : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::omero::api::IntegerArrayArrayArray&) = 0;

    void __response(const ::omero::api::IntegerArrayArrayArray& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_Gateway_getRenderedImageMatrix> AMI_Gateway_getRenderedImageMatrixPtr;

class AMI_Gateway_setActive : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response() = 0;

    void __response()
    {
        ice_response();
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_Gateway_setActive> AMI_Gateway_setActivePtr;

class AMI_Gateway_getThumbnail : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::omero::api::ByteArray&) = 0;

    void __response(const ::omero::api::ByteArray& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_Gateway_getThumbnail> AMI_Gateway_getThumbnailPtr;

class AMI_Gateway_getThumbnailSet : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::omero::api::LongByteArrayMap&) = 0;

    void __response(const ::omero::api::LongByteArrayMap& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_Gateway_getThumbnailSet> AMI_Gateway_getThumbnailSetPtr;

class AMI_Gateway_attachImageToDataset : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response() = 0;

    void __response()
    {
        ice_response();
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_Gateway_attachImageToDataset> AMI_Gateway_attachImageToDatasetPtr;

class AMI_Gateway_createImage : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(::Ice::Long) = 0;

    void __response(::Ice::Long __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_Gateway_createImage> AMI_Gateway_createImagePtr;

class AMI_Gateway_getImageFromDatasetByName : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::omero::api::ImageList&) = 0;

    void __response(const ::omero::api::ImageList& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_Gateway_getImageFromDatasetByName> AMI_Gateway_getImageFromDatasetByNamePtr;

class AMI_Gateway_getImageByName : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::omero::api::ImageList&) = 0;

    void __response(const ::omero::api::ImageList& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_Gateway_getImageByName> AMI_Gateway_getImageByNamePtr;

class AMI_Gateway_saveObject : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response() = 0;

    void __response()
    {
        ice_response();
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_Gateway_saveObject> AMI_Gateway_saveObjectPtr;

class AMI_Gateway_saveAndReturnObject : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::omero::model::IObjectPtr&) = 0;

    void __response(const ::omero::model::IObjectPtr& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_Gateway_saveAndReturnObject> AMI_Gateway_saveAndReturnObjectPtr;

class AMI_Gateway_saveArray : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response() = 0;

    void __response()
    {
        ice_response();
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_Gateway_saveArray> AMI_Gateway_saveArrayPtr;

class AMI_Gateway_saveAndReturnArray : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::omero::api::IObjectList&) = 0;

    void __response(const ::omero::api::IObjectList& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_Gateway_saveAndReturnArray> AMI_Gateway_saveAndReturnArrayPtr;

class AMI_Gateway_deleteObject : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response() = 0;

    void __response()
    {
        ice_response();
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_Gateway_deleteObject> AMI_Gateway_deleteObjectPtr;

class AMI_Gateway_keepAlive : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response() = 0;

    void __response()
    {
        ice_response();
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_Gateway_keepAlive> AMI_Gateway_keepAlivePtr;

}

}

namespace IceAsync
{

}

namespace omero
{

namespace api
{

class Callback_Gateway_getProjects_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Gateway_getProjects_Base> Callback_Gateway_getProjectsPtr;

class Callback_Gateway_getDatasets_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Gateway_getDatasets_Base> Callback_Gateway_getDatasetsPtr;

class Callback_Gateway_getDataset_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Gateway_getDataset_Base> Callback_Gateway_getDatasetPtr;

class Callback_Gateway_getPixelsFromImage_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Gateway_getPixelsFromImage_Base> Callback_Gateway_getPixelsFromImagePtr;

class Callback_Gateway_getImage_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Gateway_getImage_Base> Callback_Gateway_getImagePtr;

class Callback_Gateway_getImages_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Gateway_getImages_Base> Callback_Gateway_getImagesPtr;

class Callback_Gateway_findAllByQuery_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Gateway_findAllByQuery_Base> Callback_Gateway_findAllByQueryPtr;

class Callback_Gateway_findByQuery_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Gateway_findByQuery_Base> Callback_Gateway_findByQueryPtr;

class Callback_Gateway_getPlane_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Gateway_getPlane_Base> Callback_Gateway_getPlanePtr;

class Callback_Gateway_getPixels_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Gateway_getPixels_Base> Callback_Gateway_getPixelsPtr;

class Callback_Gateway_copyPixelsXYTZ_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Gateway_copyPixelsXYTZ_Base> Callback_Gateway_copyPixelsXYTZPtr;

class Callback_Gateway_copyPixels_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Gateway_copyPixels_Base> Callback_Gateway_copyPixelsPtr;

class Callback_Gateway_copyImage_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Gateway_copyImage_Base> Callback_Gateway_copyImagePtr;

class Callback_Gateway_uploadPlane_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Gateway_uploadPlane_Base> Callback_Gateway_uploadPlanePtr;

class Callback_Gateway_updatePixels_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Gateway_updatePixels_Base> Callback_Gateway_updatePixelsPtr;

class Callback_Gateway_getPixelTypes_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Gateway_getPixelTypes_Base> Callback_Gateway_getPixelTypesPtr;

class Callback_Gateway_getPixelType_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Gateway_getPixelType_Base> Callback_Gateway_getPixelTypePtr;

class Callback_Gateway_getRenderedImage_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Gateway_getRenderedImage_Base> Callback_Gateway_getRenderedImagePtr;

class Callback_Gateway_renderAsPackedIntAsRGBA_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Gateway_renderAsPackedIntAsRGBA_Base> Callback_Gateway_renderAsPackedIntAsRGBAPtr;

class Callback_Gateway_getRenderedImageMatrix_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Gateway_getRenderedImageMatrix_Base> Callback_Gateway_getRenderedImageMatrixPtr;

class Callback_Gateway_setActive_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Gateway_setActive_Base> Callback_Gateway_setActivePtr;

class Callback_Gateway_getThumbnail_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Gateway_getThumbnail_Base> Callback_Gateway_getThumbnailPtr;

class Callback_Gateway_getThumbnailSet_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Gateway_getThumbnailSet_Base> Callback_Gateway_getThumbnailSetPtr;

class Callback_Gateway_attachImageToDataset_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Gateway_attachImageToDataset_Base> Callback_Gateway_attachImageToDatasetPtr;

class Callback_Gateway_createImage_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Gateway_createImage_Base> Callback_Gateway_createImagePtr;

class Callback_Gateway_getImageFromDatasetByName_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Gateway_getImageFromDatasetByName_Base> Callback_Gateway_getImageFromDatasetByNamePtr;

class Callback_Gateway_getImageByName_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Gateway_getImageByName_Base> Callback_Gateway_getImageByNamePtr;

class Callback_Gateway_saveObject_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Gateway_saveObject_Base> Callback_Gateway_saveObjectPtr;

class Callback_Gateway_saveAndReturnObject_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Gateway_saveAndReturnObject_Base> Callback_Gateway_saveAndReturnObjectPtr;

class Callback_Gateway_saveArray_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Gateway_saveArray_Base> Callback_Gateway_saveArrayPtr;

class Callback_Gateway_saveAndReturnArray_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Gateway_saveAndReturnArray_Base> Callback_Gateway_saveAndReturnArrayPtr;

class Callback_Gateway_deleteObject_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Gateway_deleteObject_Base> Callback_Gateway_deleteObjectPtr;

class Callback_Gateway_keepAlive_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Gateway_keepAlive_Base> Callback_Gateway_keepAlivePtr;

}

}

namespace IceProxy
{

namespace omero
{

namespace api
{

class BufferedImage : virtual public ::IceProxy::Ice::Object
{
public:
    
    ::IceInternal::ProxyHandle<BufferedImage> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<BufferedImage*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<BufferedImage> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<BufferedImage*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<BufferedImage> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<BufferedImage*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<BufferedImage> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<BufferedImage*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<BufferedImage> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<BufferedImage*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<BufferedImage> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<BufferedImage*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<BufferedImage> ice_secure(bool __secure) const
    {
        return dynamic_cast<BufferedImage*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<BufferedImage> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<BufferedImage*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<BufferedImage> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<BufferedImage*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<BufferedImage> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<BufferedImage*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<BufferedImage> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<BufferedImage*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<BufferedImage> ice_twoway() const
    {
        return dynamic_cast<BufferedImage*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<BufferedImage> ice_oneway() const
    {
        return dynamic_cast<BufferedImage*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<BufferedImage> ice_batchOneway() const
    {
        return dynamic_cast<BufferedImage*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<BufferedImage> ice_datagram() const
    {
        return dynamic_cast<BufferedImage*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<BufferedImage> ice_batchDatagram() const
    {
        return dynamic_cast<BufferedImage*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<BufferedImage> ice_compress(bool __compress) const
    {
        return dynamic_cast<BufferedImage*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<BufferedImage> ice_timeout(int __timeout) const
    {
        return dynamic_cast<BufferedImage*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<BufferedImage> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<BufferedImage*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<BufferedImage> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<BufferedImage*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class Gateway : virtual public ::IceProxy::omero::api::StatefulServiceInterface
{
public:

    ICE_DEPRECATED_API ::omero::api::ProjectList getProjects(const ::omero::api::LongList& ids, bool withLeaves)
    {
        return getProjects(ids, withLeaves, 0);
    }
    ICE_DEPRECATED_API ::omero::api::ProjectList getProjects(const ::omero::api::LongList& ids, bool withLeaves, const ::Ice::Context& __ctx)
    {
        return getProjects(ids, withLeaves, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_getProjects(const ::omero::api::LongList& ids, bool withLeaves, const ::IceInternal::Function<void (const ::omero::api::ProjectList&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getProjects(ids, withLeaves, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getProjects(const ::omero::api::LongList& ids, bool withLeaves, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getProjects(ids, withLeaves, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_getProjects(const ::omero::api::LongList& ids, bool withLeaves, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::omero::api::ProjectList&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getProjects(ids, withLeaves, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getProjects(const ::omero::api::LongList& ids, bool withLeaves, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getProjects(ids, withLeaves, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_getProjects(const ::omero::api::LongList& ids, bool withLeaves, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::omero::api::ProjectList&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::omero::api::ProjectList&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::api::GatewayPrx __proxy = ::omero::api::GatewayPrx::uncheckedCast(__result->getProxy());
                ::omero::api::ProjectList __ret;
                try
                {
                    __ret = __proxy->end_getProjects(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::omero::api::ProjectList&)> _response;
        };
        return begin_getProjects(ids, withLeaves, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_getProjects(const ::omero::api::LongList& ids, bool withLeaves)
    {
        return begin_getProjects(ids, withLeaves, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getProjects(const ::omero::api::LongList& ids, bool withLeaves, const ::Ice::Context& __ctx)
    {
        return begin_getProjects(ids, withLeaves, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getProjects(const ::omero::api::LongList& ids, bool withLeaves, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getProjects(ids, withLeaves, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getProjects(const ::omero::api::LongList& ids, bool withLeaves, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getProjects(ids, withLeaves, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getProjects(const ::omero::api::LongList& ids, bool withLeaves, const ::omero::api::Callback_Gateway_getProjectsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getProjects(ids, withLeaves, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getProjects(const ::omero::api::LongList& ids, bool withLeaves, const ::Ice::Context& __ctx, const ::omero::api::Callback_Gateway_getProjectsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getProjects(ids, withLeaves, &__ctx, __del, __cookie);
    }

    ::omero::api::ProjectList end_getProjects(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::api::ProjectList getProjects(const ::omero::api::LongList&, bool, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getProjects(const ::omero::api::LongList&, bool, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool getProjects_async(const ::omero::api::AMI_Gateway_getProjectsPtr&, const ::omero::api::LongList&, bool);
    bool getProjects_async(const ::omero::api::AMI_Gateway_getProjectsPtr&, const ::omero::api::LongList&, bool, const ::Ice::Context&);

    ICE_DEPRECATED_API ::omero::api::DatasetList getDatasets(const ::omero::api::LongList& ids, bool withLeaves)
    {
        return getDatasets(ids, withLeaves, 0);
    }
    ICE_DEPRECATED_API ::omero::api::DatasetList getDatasets(const ::omero::api::LongList& ids, bool withLeaves, const ::Ice::Context& __ctx)
    {
        return getDatasets(ids, withLeaves, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_getDatasets(const ::omero::api::LongList& ids, bool withLeaves, const ::IceInternal::Function<void (const ::omero::api::DatasetList&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getDatasets(ids, withLeaves, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getDatasets(const ::omero::api::LongList& ids, bool withLeaves, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getDatasets(ids, withLeaves, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_getDatasets(const ::omero::api::LongList& ids, bool withLeaves, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::omero::api::DatasetList&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getDatasets(ids, withLeaves, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getDatasets(const ::omero::api::LongList& ids, bool withLeaves, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getDatasets(ids, withLeaves, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_getDatasets(const ::omero::api::LongList& ids, bool withLeaves, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::omero::api::DatasetList&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::omero::api::DatasetList&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::api::GatewayPrx __proxy = ::omero::api::GatewayPrx::uncheckedCast(__result->getProxy());
                ::omero::api::DatasetList __ret;
                try
                {
                    __ret = __proxy->end_getDatasets(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::omero::api::DatasetList&)> _response;
        };
        return begin_getDatasets(ids, withLeaves, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_getDatasets(const ::omero::api::LongList& ids, bool withLeaves)
    {
        return begin_getDatasets(ids, withLeaves, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getDatasets(const ::omero::api::LongList& ids, bool withLeaves, const ::Ice::Context& __ctx)
    {
        return begin_getDatasets(ids, withLeaves, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getDatasets(const ::omero::api::LongList& ids, bool withLeaves, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getDatasets(ids, withLeaves, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getDatasets(const ::omero::api::LongList& ids, bool withLeaves, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getDatasets(ids, withLeaves, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getDatasets(const ::omero::api::LongList& ids, bool withLeaves, const ::omero::api::Callback_Gateway_getDatasetsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getDatasets(ids, withLeaves, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getDatasets(const ::omero::api::LongList& ids, bool withLeaves, const ::Ice::Context& __ctx, const ::omero::api::Callback_Gateway_getDatasetsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getDatasets(ids, withLeaves, &__ctx, __del, __cookie);
    }

    ::omero::api::DatasetList end_getDatasets(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::api::DatasetList getDatasets(const ::omero::api::LongList&, bool, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getDatasets(const ::omero::api::LongList&, bool, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool getDatasets_async(const ::omero::api::AMI_Gateway_getDatasetsPtr&, const ::omero::api::LongList&, bool);
    bool getDatasets_async(const ::omero::api::AMI_Gateway_getDatasetsPtr&, const ::omero::api::LongList&, bool, const ::Ice::Context&);

    ICE_DEPRECATED_API ::omero::model::DatasetPtr getDataset(::Ice::Long datasetId, bool leaves)
    {
        return getDataset(datasetId, leaves, 0);
    }
    ICE_DEPRECATED_API ::omero::model::DatasetPtr getDataset(::Ice::Long datasetId, bool leaves, const ::Ice::Context& __ctx)
    {
        return getDataset(datasetId, leaves, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_getDataset(::Ice::Long datasetId, bool leaves, const ::IceInternal::Function<void (const ::omero::model::DatasetPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getDataset(datasetId, leaves, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getDataset(::Ice::Long datasetId, bool leaves, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getDataset(datasetId, leaves, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_getDataset(::Ice::Long datasetId, bool leaves, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::omero::model::DatasetPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getDataset(datasetId, leaves, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getDataset(::Ice::Long datasetId, bool leaves, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getDataset(datasetId, leaves, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_getDataset(::Ice::Long datasetId, bool leaves, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::omero::model::DatasetPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::omero::model::DatasetPtr&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::api::GatewayPrx __proxy = ::omero::api::GatewayPrx::uncheckedCast(__result->getProxy());
                ::omero::model::DatasetPtr __ret;
                try
                {
                    __ret = __proxy->end_getDataset(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::omero::model::DatasetPtr&)> _response;
        };
        return begin_getDataset(datasetId, leaves, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_getDataset(::Ice::Long datasetId, bool leaves)
    {
        return begin_getDataset(datasetId, leaves, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getDataset(::Ice::Long datasetId, bool leaves, const ::Ice::Context& __ctx)
    {
        return begin_getDataset(datasetId, leaves, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getDataset(::Ice::Long datasetId, bool leaves, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getDataset(datasetId, leaves, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getDataset(::Ice::Long datasetId, bool leaves, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getDataset(datasetId, leaves, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getDataset(::Ice::Long datasetId, bool leaves, const ::omero::api::Callback_Gateway_getDatasetPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getDataset(datasetId, leaves, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getDataset(::Ice::Long datasetId, bool leaves, const ::Ice::Context& __ctx, const ::omero::api::Callback_Gateway_getDatasetPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getDataset(datasetId, leaves, &__ctx, __del, __cookie);
    }

    ::omero::model::DatasetPtr end_getDataset(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::model::DatasetPtr getDataset(::Ice::Long, bool, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getDataset(::Ice::Long, bool, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool getDataset_async(const ::omero::api::AMI_Gateway_getDatasetPtr&, ::Ice::Long, bool);
    bool getDataset_async(const ::omero::api::AMI_Gateway_getDatasetPtr&, ::Ice::Long, bool, const ::Ice::Context&);

    ICE_DEPRECATED_API ::omero::api::PixelsList getPixelsFromImage(::Ice::Long imageId)
    {
        return getPixelsFromImage(imageId, 0);
    }
    ICE_DEPRECATED_API ::omero::api::PixelsList getPixelsFromImage(::Ice::Long imageId, const ::Ice::Context& __ctx)
    {
        return getPixelsFromImage(imageId, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_getPixelsFromImage(::Ice::Long imageId, const ::IceInternal::Function<void (const ::omero::api::PixelsList&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getPixelsFromImage(imageId, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getPixelsFromImage(::Ice::Long imageId, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getPixelsFromImage(imageId, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_getPixelsFromImage(::Ice::Long imageId, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::omero::api::PixelsList&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getPixelsFromImage(imageId, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getPixelsFromImage(::Ice::Long imageId, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getPixelsFromImage(imageId, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_getPixelsFromImage(::Ice::Long imageId, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::omero::api::PixelsList&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::omero::api::PixelsList&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::api::GatewayPrx __proxy = ::omero::api::GatewayPrx::uncheckedCast(__result->getProxy());
                ::omero::api::PixelsList __ret;
                try
                {
                    __ret = __proxy->end_getPixelsFromImage(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::omero::api::PixelsList&)> _response;
        };
        return begin_getPixelsFromImage(imageId, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_getPixelsFromImage(::Ice::Long imageId)
    {
        return begin_getPixelsFromImage(imageId, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getPixelsFromImage(::Ice::Long imageId, const ::Ice::Context& __ctx)
    {
        return begin_getPixelsFromImage(imageId, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getPixelsFromImage(::Ice::Long imageId, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getPixelsFromImage(imageId, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getPixelsFromImage(::Ice::Long imageId, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getPixelsFromImage(imageId, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getPixelsFromImage(::Ice::Long imageId, const ::omero::api::Callback_Gateway_getPixelsFromImagePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getPixelsFromImage(imageId, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getPixelsFromImage(::Ice::Long imageId, const ::Ice::Context& __ctx, const ::omero::api::Callback_Gateway_getPixelsFromImagePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getPixelsFromImage(imageId, &__ctx, __del, __cookie);
    }

    ::omero::api::PixelsList end_getPixelsFromImage(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::api::PixelsList getPixelsFromImage(::Ice::Long, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getPixelsFromImage(::Ice::Long, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool getPixelsFromImage_async(const ::omero::api::AMI_Gateway_getPixelsFromImagePtr&, ::Ice::Long);
    bool getPixelsFromImage_async(const ::omero::api::AMI_Gateway_getPixelsFromImagePtr&, ::Ice::Long, const ::Ice::Context&);

    ICE_DEPRECATED_API ::omero::model::ImagePtr getImage(::Ice::Long id)
    {
        return getImage(id, 0);
    }
    ICE_DEPRECATED_API ::omero::model::ImagePtr getImage(::Ice::Long id, const ::Ice::Context& __ctx)
    {
        return getImage(id, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_getImage(::Ice::Long id, const ::IceInternal::Function<void (const ::omero::model::ImagePtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getImage(id, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getImage(::Ice::Long id, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getImage(id, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_getImage(::Ice::Long id, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::omero::model::ImagePtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getImage(id, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getImage(::Ice::Long id, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getImage(id, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_getImage(::Ice::Long id, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::omero::model::ImagePtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::omero::model::ImagePtr&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::api::GatewayPrx __proxy = ::omero::api::GatewayPrx::uncheckedCast(__result->getProxy());
                ::omero::model::ImagePtr __ret;
                try
                {
                    __ret = __proxy->end_getImage(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::omero::model::ImagePtr&)> _response;
        };
        return begin_getImage(id, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_getImage(::Ice::Long id)
    {
        return begin_getImage(id, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getImage(::Ice::Long id, const ::Ice::Context& __ctx)
    {
        return begin_getImage(id, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getImage(::Ice::Long id, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getImage(id, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getImage(::Ice::Long id, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getImage(id, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getImage(::Ice::Long id, const ::omero::api::Callback_Gateway_getImagePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getImage(id, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getImage(::Ice::Long id, const ::Ice::Context& __ctx, const ::omero::api::Callback_Gateway_getImagePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getImage(id, &__ctx, __del, __cookie);
    }

    ::omero::model::ImagePtr end_getImage(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::model::ImagePtr getImage(::Ice::Long, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getImage(::Ice::Long, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool getImage_async(const ::omero::api::AMI_Gateway_getImagePtr&, ::Ice::Long);
    bool getImage_async(const ::omero::api::AMI_Gateway_getImagePtr&, ::Ice::Long, const ::Ice::Context&);

    ICE_DEPRECATED_API ::omero::api::ImageList getImages(::omero::api::ContainerClass parentType, const ::omero::api::LongList& ids)
    {
        return getImages(parentType, ids, 0);
    }
    ICE_DEPRECATED_API ::omero::api::ImageList getImages(::omero::api::ContainerClass parentType, const ::omero::api::LongList& ids, const ::Ice::Context& __ctx)
    {
        return getImages(parentType, ids, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_getImages(::omero::api::ContainerClass parentType, const ::omero::api::LongList& ids, const ::IceInternal::Function<void (const ::omero::api::ImageList&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getImages(parentType, ids, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getImages(::omero::api::ContainerClass parentType, const ::omero::api::LongList& ids, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getImages(parentType, ids, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_getImages(::omero::api::ContainerClass parentType, const ::omero::api::LongList& ids, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::omero::api::ImageList&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getImages(parentType, ids, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getImages(::omero::api::ContainerClass parentType, const ::omero::api::LongList& ids, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getImages(parentType, ids, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_getImages(::omero::api::ContainerClass parentType, const ::omero::api::LongList& ids, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::omero::api::ImageList&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::omero::api::ImageList&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::api::GatewayPrx __proxy = ::omero::api::GatewayPrx::uncheckedCast(__result->getProxy());
                ::omero::api::ImageList __ret;
                try
                {
                    __ret = __proxy->end_getImages(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::omero::api::ImageList&)> _response;
        };
        return begin_getImages(parentType, ids, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_getImages(::omero::api::ContainerClass parentType, const ::omero::api::LongList& ids)
    {
        return begin_getImages(parentType, ids, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getImages(::omero::api::ContainerClass parentType, const ::omero::api::LongList& ids, const ::Ice::Context& __ctx)
    {
        return begin_getImages(parentType, ids, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getImages(::omero::api::ContainerClass parentType, const ::omero::api::LongList& ids, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getImages(parentType, ids, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getImages(::omero::api::ContainerClass parentType, const ::omero::api::LongList& ids, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getImages(parentType, ids, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getImages(::omero::api::ContainerClass parentType, const ::omero::api::LongList& ids, const ::omero::api::Callback_Gateway_getImagesPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getImages(parentType, ids, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getImages(::omero::api::ContainerClass parentType, const ::omero::api::LongList& ids, const ::Ice::Context& __ctx, const ::omero::api::Callback_Gateway_getImagesPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getImages(parentType, ids, &__ctx, __del, __cookie);
    }

    ::omero::api::ImageList end_getImages(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::api::ImageList getImages(::omero::api::ContainerClass, const ::omero::api::LongList&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getImages(::omero::api::ContainerClass, const ::omero::api::LongList&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool getImages_async(const ::omero::api::AMI_Gateway_getImagesPtr&, ::omero::api::ContainerClass, const ::omero::api::LongList&);
    bool getImages_async(const ::omero::api::AMI_Gateway_getImagesPtr&, ::omero::api::ContainerClass, const ::omero::api::LongList&, const ::Ice::Context&);

    ICE_DEPRECATED_API ::omero::api::IObjectList findAllByQuery(const ::std::string& myQuery)
    {
        return findAllByQuery(myQuery, 0);
    }
    ICE_DEPRECATED_API ::omero::api::IObjectList findAllByQuery(const ::std::string& myQuery, const ::Ice::Context& __ctx)
    {
        return findAllByQuery(myQuery, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_findAllByQuery(const ::std::string& myQuery, const ::IceInternal::Function<void (const ::omero::api::IObjectList&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_findAllByQuery(myQuery, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_findAllByQuery(const ::std::string& myQuery, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_findAllByQuery(myQuery, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_findAllByQuery(const ::std::string& myQuery, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::omero::api::IObjectList&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_findAllByQuery(myQuery, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_findAllByQuery(const ::std::string& myQuery, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_findAllByQuery(myQuery, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_findAllByQuery(const ::std::string& myQuery, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::omero::api::IObjectList&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::omero::api::IObjectList&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::api::GatewayPrx __proxy = ::omero::api::GatewayPrx::uncheckedCast(__result->getProxy());
                ::omero::api::IObjectList __ret;
                try
                {
                    __ret = __proxy->end_findAllByQuery(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::omero::api::IObjectList&)> _response;
        };
        return begin_findAllByQuery(myQuery, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_findAllByQuery(const ::std::string& myQuery)
    {
        return begin_findAllByQuery(myQuery, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_findAllByQuery(const ::std::string& myQuery, const ::Ice::Context& __ctx)
    {
        return begin_findAllByQuery(myQuery, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_findAllByQuery(const ::std::string& myQuery, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_findAllByQuery(myQuery, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_findAllByQuery(const ::std::string& myQuery, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_findAllByQuery(myQuery, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_findAllByQuery(const ::std::string& myQuery, const ::omero::api::Callback_Gateway_findAllByQueryPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_findAllByQuery(myQuery, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_findAllByQuery(const ::std::string& myQuery, const ::Ice::Context& __ctx, const ::omero::api::Callback_Gateway_findAllByQueryPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_findAllByQuery(myQuery, &__ctx, __del, __cookie);
    }

    ::omero::api::IObjectList end_findAllByQuery(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::api::IObjectList findAllByQuery(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_findAllByQuery(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool findAllByQuery_async(const ::omero::api::AMI_Gateway_findAllByQueryPtr&, const ::std::string&);
    bool findAllByQuery_async(const ::omero::api::AMI_Gateway_findAllByQueryPtr&, const ::std::string&, const ::Ice::Context&);

    ICE_DEPRECATED_API ::omero::model::IObjectPtr findByQuery(const ::std::string& myQuery)
    {
        return findByQuery(myQuery, 0);
    }
    ICE_DEPRECATED_API ::omero::model::IObjectPtr findByQuery(const ::std::string& myQuery, const ::Ice::Context& __ctx)
    {
        return findByQuery(myQuery, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_findByQuery(const ::std::string& myQuery, const ::IceInternal::Function<void (const ::omero::model::IObjectPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_findByQuery(myQuery, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_findByQuery(const ::std::string& myQuery, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_findByQuery(myQuery, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_findByQuery(const ::std::string& myQuery, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::omero::model::IObjectPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_findByQuery(myQuery, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_findByQuery(const ::std::string& myQuery, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_findByQuery(myQuery, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_findByQuery(const ::std::string& myQuery, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::omero::model::IObjectPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::omero::model::IObjectPtr&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::api::GatewayPrx __proxy = ::omero::api::GatewayPrx::uncheckedCast(__result->getProxy());
                ::omero::model::IObjectPtr __ret;
                try
                {
                    __ret = __proxy->end_findByQuery(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::omero::model::IObjectPtr&)> _response;
        };
        return begin_findByQuery(myQuery, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_findByQuery(const ::std::string& myQuery)
    {
        return begin_findByQuery(myQuery, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_findByQuery(const ::std::string& myQuery, const ::Ice::Context& __ctx)
    {
        return begin_findByQuery(myQuery, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_findByQuery(const ::std::string& myQuery, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_findByQuery(myQuery, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_findByQuery(const ::std::string& myQuery, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_findByQuery(myQuery, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_findByQuery(const ::std::string& myQuery, const ::omero::api::Callback_Gateway_findByQueryPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_findByQuery(myQuery, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_findByQuery(const ::std::string& myQuery, const ::Ice::Context& __ctx, const ::omero::api::Callback_Gateway_findByQueryPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_findByQuery(myQuery, &__ctx, __del, __cookie);
    }

    ::omero::model::IObjectPtr end_findByQuery(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::model::IObjectPtr findByQuery(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_findByQuery(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool findByQuery_async(const ::omero::api::AMI_Gateway_findByQueryPtr&, const ::std::string&);
    bool findByQuery_async(const ::omero::api::AMI_Gateway_findByQueryPtr&, const ::std::string&, const ::Ice::Context&);

    ICE_DEPRECATED_API ::Ice::ByteSeq getPlane(::Ice::Long pixelsId, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t)
    {
        return getPlane(pixelsId, z, c, t, 0);
    }
    ICE_DEPRECATED_API ::Ice::ByteSeq getPlane(::Ice::Long pixelsId, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::Ice::Context& __ctx)
    {
        return getPlane(pixelsId, z, c, t, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_getPlane(::Ice::Long pixelsId, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::IceInternal::Function<void (const ::Ice::ByteSeq&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getPlane(pixelsId, z, c, t, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getPlane(::Ice::Long pixelsId, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getPlane(pixelsId, z, c, t, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_getPlane(::Ice::Long pixelsId, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::ByteSeq&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getPlane(pixelsId, z, c, t, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getPlane(::Ice::Long pixelsId, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getPlane(pixelsId, z, c, t, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_getPlane(::Ice::Long pixelsId, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Ice::ByteSeq&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::Ice::ByteSeq&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::api::GatewayPrx __proxy = ::omero::api::GatewayPrx::uncheckedCast(__result->getProxy());
                ::Ice::ByteSeq __ret;
                try
                {
                    __ret = __proxy->end_getPlane(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::Ice::ByteSeq&)> _response;
        };
        return begin_getPlane(pixelsId, z, c, t, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_getPlane(::Ice::Long pixelsId, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t)
    {
        return begin_getPlane(pixelsId, z, c, t, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getPlane(::Ice::Long pixelsId, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::Ice::Context& __ctx)
    {
        return begin_getPlane(pixelsId, z, c, t, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getPlane(::Ice::Long pixelsId, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getPlane(pixelsId, z, c, t, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getPlane(::Ice::Long pixelsId, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getPlane(pixelsId, z, c, t, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getPlane(::Ice::Long pixelsId, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::omero::api::Callback_Gateway_getPlanePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getPlane(pixelsId, z, c, t, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getPlane(::Ice::Long pixelsId, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::Ice::Context& __ctx, const ::omero::api::Callback_Gateway_getPlanePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getPlane(pixelsId, z, c, t, &__ctx, __del, __cookie);
    }

    ::Ice::ByteSeq end_getPlane(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::ByteSeq getPlane(::Ice::Long, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getPlane(::Ice::Long, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool getPlane_async(const ::omero::api::AMI_Gateway_getPlanePtr&, ::Ice::Long, ::Ice::Int, ::Ice::Int, ::Ice::Int);
    bool getPlane_async(const ::omero::api::AMI_Gateway_getPlanePtr&, ::Ice::Long, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Context&);

    ICE_DEPRECATED_API ::omero::model::PixelsPtr getPixels(::Ice::Long pixelsId)
    {
        return getPixels(pixelsId, 0);
    }
    ICE_DEPRECATED_API ::omero::model::PixelsPtr getPixels(::Ice::Long pixelsId, const ::Ice::Context& __ctx)
    {
        return getPixels(pixelsId, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_getPixels(::Ice::Long pixelsId, const ::IceInternal::Function<void (const ::omero::model::PixelsPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getPixels(pixelsId, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getPixels(::Ice::Long pixelsId, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getPixels(pixelsId, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_getPixels(::Ice::Long pixelsId, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::omero::model::PixelsPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getPixels(pixelsId, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getPixels(::Ice::Long pixelsId, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getPixels(pixelsId, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_getPixels(::Ice::Long pixelsId, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::omero::model::PixelsPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::omero::model::PixelsPtr&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::api::GatewayPrx __proxy = ::omero::api::GatewayPrx::uncheckedCast(__result->getProxy());
                ::omero::model::PixelsPtr __ret;
                try
                {
                    __ret = __proxy->end_getPixels(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::omero::model::PixelsPtr&)> _response;
        };
        return begin_getPixels(pixelsId, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_getPixels(::Ice::Long pixelsId)
    {
        return begin_getPixels(pixelsId, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getPixels(::Ice::Long pixelsId, const ::Ice::Context& __ctx)
    {
        return begin_getPixels(pixelsId, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getPixels(::Ice::Long pixelsId, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getPixels(pixelsId, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getPixels(::Ice::Long pixelsId, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getPixels(pixelsId, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getPixels(::Ice::Long pixelsId, const ::omero::api::Callback_Gateway_getPixelsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getPixels(pixelsId, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getPixels(::Ice::Long pixelsId, const ::Ice::Context& __ctx, const ::omero::api::Callback_Gateway_getPixelsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getPixels(pixelsId, &__ctx, __del, __cookie);
    }

    ::omero::model::PixelsPtr end_getPixels(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::model::PixelsPtr getPixels(::Ice::Long, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getPixels(::Ice::Long, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool getPixels_async(const ::omero::api::AMI_Gateway_getPixelsPtr&, ::Ice::Long);
    bool getPixels_async(const ::omero::api::AMI_Gateway_getPixelsPtr&, ::Ice::Long, const ::Ice::Context&);

    ICE_DEPRECATED_API ::Ice::Long copyPixelsXYTZ(::Ice::Long pixelsID, ::Ice::Int x, ::Ice::Int y, ::Ice::Int t, ::Ice::Int z, const ::omero::api::IntegerList& channelList, const ::std::string& methodology)
    {
        return copyPixelsXYTZ(pixelsID, x, y, t, z, channelList, methodology, 0);
    }
    ICE_DEPRECATED_API ::Ice::Long copyPixelsXYTZ(::Ice::Long pixelsID, ::Ice::Int x, ::Ice::Int y, ::Ice::Int t, ::Ice::Int z, const ::omero::api::IntegerList& channelList, const ::std::string& methodology, const ::Ice::Context& __ctx)
    {
        return copyPixelsXYTZ(pixelsID, x, y, t, z, channelList, methodology, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_copyPixelsXYTZ(::Ice::Long pixelsID, ::Ice::Int x, ::Ice::Int y, ::Ice::Int t, ::Ice::Int z, const ::omero::api::IntegerList& channelList, const ::std::string& methodology, const ::IceInternal::Function<void (::Ice::Long)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_copyPixelsXYTZ(pixelsID, x, y, t, z, channelList, methodology, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_copyPixelsXYTZ(::Ice::Long pixelsID, ::Ice::Int x, ::Ice::Int y, ::Ice::Int t, ::Ice::Int z, const ::omero::api::IntegerList& channelList, const ::std::string& methodology, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_copyPixelsXYTZ(pixelsID, x, y, t, z, channelList, methodology, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_copyPixelsXYTZ(::Ice::Long pixelsID, ::Ice::Int x, ::Ice::Int y, ::Ice::Int t, ::Ice::Int z, const ::omero::api::IntegerList& channelList, const ::std::string& methodology, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (::Ice::Long)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_copyPixelsXYTZ(pixelsID, x, y, t, z, channelList, methodology, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_copyPixelsXYTZ(::Ice::Long pixelsID, ::Ice::Int x, ::Ice::Int y, ::Ice::Int t, ::Ice::Int z, const ::omero::api::IntegerList& channelList, const ::std::string& methodology, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_copyPixelsXYTZ(pixelsID, x, y, t, z, channelList, methodology, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_copyPixelsXYTZ(::Ice::Long pixelsID, ::Ice::Int x, ::Ice::Int y, ::Ice::Int t, ::Ice::Int z, const ::omero::api::IntegerList& channelList, const ::std::string& methodology, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (::Ice::Long)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (::Ice::Long)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::api::GatewayPrx __proxy = ::omero::api::GatewayPrx::uncheckedCast(__result->getProxy());
                ::Ice::Long __ret;
                try
                {
                    __ret = __proxy->end_copyPixelsXYTZ(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (::Ice::Long)> _response;
        };
        return begin_copyPixelsXYTZ(pixelsID, x, y, t, z, channelList, methodology, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_copyPixelsXYTZ(::Ice::Long pixelsID, ::Ice::Int x, ::Ice::Int y, ::Ice::Int t, ::Ice::Int z, const ::omero::api::IntegerList& channelList, const ::std::string& methodology)
    {
        return begin_copyPixelsXYTZ(pixelsID, x, y, t, z, channelList, methodology, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_copyPixelsXYTZ(::Ice::Long pixelsID, ::Ice::Int x, ::Ice::Int y, ::Ice::Int t, ::Ice::Int z, const ::omero::api::IntegerList& channelList, const ::std::string& methodology, const ::Ice::Context& __ctx)
    {
        return begin_copyPixelsXYTZ(pixelsID, x, y, t, z, channelList, methodology, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_copyPixelsXYTZ(::Ice::Long pixelsID, ::Ice::Int x, ::Ice::Int y, ::Ice::Int t, ::Ice::Int z, const ::omero::api::IntegerList& channelList, const ::std::string& methodology, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_copyPixelsXYTZ(pixelsID, x, y, t, z, channelList, methodology, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_copyPixelsXYTZ(::Ice::Long pixelsID, ::Ice::Int x, ::Ice::Int y, ::Ice::Int t, ::Ice::Int z, const ::omero::api::IntegerList& channelList, const ::std::string& methodology, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_copyPixelsXYTZ(pixelsID, x, y, t, z, channelList, methodology, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_copyPixelsXYTZ(::Ice::Long pixelsID, ::Ice::Int x, ::Ice::Int y, ::Ice::Int t, ::Ice::Int z, const ::omero::api::IntegerList& channelList, const ::std::string& methodology, const ::omero::api::Callback_Gateway_copyPixelsXYTZPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_copyPixelsXYTZ(pixelsID, x, y, t, z, channelList, methodology, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_copyPixelsXYTZ(::Ice::Long pixelsID, ::Ice::Int x, ::Ice::Int y, ::Ice::Int t, ::Ice::Int z, const ::omero::api::IntegerList& channelList, const ::std::string& methodology, const ::Ice::Context& __ctx, const ::omero::api::Callback_Gateway_copyPixelsXYTZPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_copyPixelsXYTZ(pixelsID, x, y, t, z, channelList, methodology, &__ctx, __del, __cookie);
    }

    ::Ice::Long end_copyPixelsXYTZ(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Long copyPixelsXYTZ(::Ice::Long, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::omero::api::IntegerList&, const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_copyPixelsXYTZ(::Ice::Long, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::omero::api::IntegerList&, const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool copyPixelsXYTZ_async(const ::omero::api::AMI_Gateway_copyPixelsXYTZPtr&, ::Ice::Long, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::omero::api::IntegerList&, const ::std::string&);
    bool copyPixelsXYTZ_async(const ::omero::api::AMI_Gateway_copyPixelsXYTZPtr&, ::Ice::Long, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::omero::api::IntegerList&, const ::std::string&, const ::Ice::Context&);

    ICE_DEPRECATED_API ::Ice::Long copyPixels(::Ice::Long pixelsID, const ::omero::api::IntegerList& channelList, const ::std::string& methodology)
    {
        return copyPixels(pixelsID, channelList, methodology, 0);
    }
    ICE_DEPRECATED_API ::Ice::Long copyPixels(::Ice::Long pixelsID, const ::omero::api::IntegerList& channelList, const ::std::string& methodology, const ::Ice::Context& __ctx)
    {
        return copyPixels(pixelsID, channelList, methodology, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_copyPixels(::Ice::Long pixelsID, const ::omero::api::IntegerList& channelList, const ::std::string& methodology, const ::IceInternal::Function<void (::Ice::Long)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_copyPixels(pixelsID, channelList, methodology, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_copyPixels(::Ice::Long pixelsID, const ::omero::api::IntegerList& channelList, const ::std::string& methodology, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_copyPixels(pixelsID, channelList, methodology, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_copyPixels(::Ice::Long pixelsID, const ::omero::api::IntegerList& channelList, const ::std::string& methodology, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (::Ice::Long)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_copyPixels(pixelsID, channelList, methodology, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_copyPixels(::Ice::Long pixelsID, const ::omero::api::IntegerList& channelList, const ::std::string& methodology, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_copyPixels(pixelsID, channelList, methodology, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_copyPixels(::Ice::Long pixelsID, const ::omero::api::IntegerList& channelList, const ::std::string& methodology, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (::Ice::Long)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (::Ice::Long)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::api::GatewayPrx __proxy = ::omero::api::GatewayPrx::uncheckedCast(__result->getProxy());
                ::Ice::Long __ret;
                try
                {
                    __ret = __proxy->end_copyPixels(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (::Ice::Long)> _response;
        };
        return begin_copyPixels(pixelsID, channelList, methodology, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_copyPixels(::Ice::Long pixelsID, const ::omero::api::IntegerList& channelList, const ::std::string& methodology)
    {
        return begin_copyPixels(pixelsID, channelList, methodology, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_copyPixels(::Ice::Long pixelsID, const ::omero::api::IntegerList& channelList, const ::std::string& methodology, const ::Ice::Context& __ctx)
    {
        return begin_copyPixels(pixelsID, channelList, methodology, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_copyPixels(::Ice::Long pixelsID, const ::omero::api::IntegerList& channelList, const ::std::string& methodology, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_copyPixels(pixelsID, channelList, methodology, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_copyPixels(::Ice::Long pixelsID, const ::omero::api::IntegerList& channelList, const ::std::string& methodology, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_copyPixels(pixelsID, channelList, methodology, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_copyPixels(::Ice::Long pixelsID, const ::omero::api::IntegerList& channelList, const ::std::string& methodology, const ::omero::api::Callback_Gateway_copyPixelsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_copyPixels(pixelsID, channelList, methodology, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_copyPixels(::Ice::Long pixelsID, const ::omero::api::IntegerList& channelList, const ::std::string& methodology, const ::Ice::Context& __ctx, const ::omero::api::Callback_Gateway_copyPixelsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_copyPixels(pixelsID, channelList, methodology, &__ctx, __del, __cookie);
    }

    ::Ice::Long end_copyPixels(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Long copyPixels(::Ice::Long, const ::omero::api::IntegerList&, const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_copyPixels(::Ice::Long, const ::omero::api::IntegerList&, const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool copyPixels_async(const ::omero::api::AMI_Gateway_copyPixelsPtr&, ::Ice::Long, const ::omero::api::IntegerList&, const ::std::string&);
    bool copyPixels_async(const ::omero::api::AMI_Gateway_copyPixelsPtr&, ::Ice::Long, const ::omero::api::IntegerList&, const ::std::string&, const ::Ice::Context&);

    ICE_DEPRECATED_API ::Ice::Long copyImage(::Ice::Long imageId, ::Ice::Int x, ::Ice::Int y, ::Ice::Int t, ::Ice::Int z, const ::omero::api::IntegerList& channelList, const ::std::string& imageName)
    {
        return copyImage(imageId, x, y, t, z, channelList, imageName, 0);
    }
    ICE_DEPRECATED_API ::Ice::Long copyImage(::Ice::Long imageId, ::Ice::Int x, ::Ice::Int y, ::Ice::Int t, ::Ice::Int z, const ::omero::api::IntegerList& channelList, const ::std::string& imageName, const ::Ice::Context& __ctx)
    {
        return copyImage(imageId, x, y, t, z, channelList, imageName, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_copyImage(::Ice::Long imageId, ::Ice::Int x, ::Ice::Int y, ::Ice::Int t, ::Ice::Int z, const ::omero::api::IntegerList& channelList, const ::std::string& imageName, const ::IceInternal::Function<void (::Ice::Long)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_copyImage(imageId, x, y, t, z, channelList, imageName, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_copyImage(::Ice::Long imageId, ::Ice::Int x, ::Ice::Int y, ::Ice::Int t, ::Ice::Int z, const ::omero::api::IntegerList& channelList, const ::std::string& imageName, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_copyImage(imageId, x, y, t, z, channelList, imageName, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_copyImage(::Ice::Long imageId, ::Ice::Int x, ::Ice::Int y, ::Ice::Int t, ::Ice::Int z, const ::omero::api::IntegerList& channelList, const ::std::string& imageName, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (::Ice::Long)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_copyImage(imageId, x, y, t, z, channelList, imageName, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_copyImage(::Ice::Long imageId, ::Ice::Int x, ::Ice::Int y, ::Ice::Int t, ::Ice::Int z, const ::omero::api::IntegerList& channelList, const ::std::string& imageName, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_copyImage(imageId, x, y, t, z, channelList, imageName, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_copyImage(::Ice::Long imageId, ::Ice::Int x, ::Ice::Int y, ::Ice::Int t, ::Ice::Int z, const ::omero::api::IntegerList& channelList, const ::std::string& imageName, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (::Ice::Long)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (::Ice::Long)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::api::GatewayPrx __proxy = ::omero::api::GatewayPrx::uncheckedCast(__result->getProxy());
                ::Ice::Long __ret;
                try
                {
                    __ret = __proxy->end_copyImage(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (::Ice::Long)> _response;
        };
        return begin_copyImage(imageId, x, y, t, z, channelList, imageName, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_copyImage(::Ice::Long imageId, ::Ice::Int x, ::Ice::Int y, ::Ice::Int t, ::Ice::Int z, const ::omero::api::IntegerList& channelList, const ::std::string& imageName)
    {
        return begin_copyImage(imageId, x, y, t, z, channelList, imageName, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_copyImage(::Ice::Long imageId, ::Ice::Int x, ::Ice::Int y, ::Ice::Int t, ::Ice::Int z, const ::omero::api::IntegerList& channelList, const ::std::string& imageName, const ::Ice::Context& __ctx)
    {
        return begin_copyImage(imageId, x, y, t, z, channelList, imageName, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_copyImage(::Ice::Long imageId, ::Ice::Int x, ::Ice::Int y, ::Ice::Int t, ::Ice::Int z, const ::omero::api::IntegerList& channelList, const ::std::string& imageName, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_copyImage(imageId, x, y, t, z, channelList, imageName, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_copyImage(::Ice::Long imageId, ::Ice::Int x, ::Ice::Int y, ::Ice::Int t, ::Ice::Int z, const ::omero::api::IntegerList& channelList, const ::std::string& imageName, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_copyImage(imageId, x, y, t, z, channelList, imageName, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_copyImage(::Ice::Long imageId, ::Ice::Int x, ::Ice::Int y, ::Ice::Int t, ::Ice::Int z, const ::omero::api::IntegerList& channelList, const ::std::string& imageName, const ::omero::api::Callback_Gateway_copyImagePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_copyImage(imageId, x, y, t, z, channelList, imageName, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_copyImage(::Ice::Long imageId, ::Ice::Int x, ::Ice::Int y, ::Ice::Int t, ::Ice::Int z, const ::omero::api::IntegerList& channelList, const ::std::string& imageName, const ::Ice::Context& __ctx, const ::omero::api::Callback_Gateway_copyImagePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_copyImage(imageId, x, y, t, z, channelList, imageName, &__ctx, __del, __cookie);
    }

    ::Ice::Long end_copyImage(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Long copyImage(::Ice::Long, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::omero::api::IntegerList&, const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_copyImage(::Ice::Long, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::omero::api::IntegerList&, const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool copyImage_async(const ::omero::api::AMI_Gateway_copyImagePtr&, ::Ice::Long, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::omero::api::IntegerList&, const ::std::string&);
    bool copyImage_async(const ::omero::api::AMI_Gateway_copyImagePtr&, ::Ice::Long, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::omero::api::IntegerList&, const ::std::string&, const ::Ice::Context&);

    ICE_DEPRECATED_API void uploadPlane(::Ice::Long pixelsId, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::Ice::ByteSeq& data)
    {
        uploadPlane(pixelsId, z, c, t, data, 0);
    }
    ICE_DEPRECATED_API void uploadPlane(::Ice::Long pixelsId, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::Ice::ByteSeq& data, const ::Ice::Context& __ctx)
    {
        uploadPlane(pixelsId, z, c, t, data, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_uploadPlane(::Ice::Long pixelsId, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::Ice::ByteSeq& data, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_uploadPlane(pixelsId, z, c, t, data, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_uploadPlane(::Ice::Long pixelsId, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::Ice::ByteSeq& data, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_uploadPlane(pixelsId, z, c, t, data, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_uploadPlane(::Ice::Long pixelsId, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::Ice::ByteSeq& data, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_uploadPlane(pixelsId, z, c, t, data, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_uploadPlane(::Ice::Long pixelsId, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::Ice::ByteSeq& data, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_uploadPlane(pixelsId, z, c, t, data, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_uploadPlane(::Ice::Long pixelsId, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::Ice::ByteSeq& data, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::api::GatewayPrx __proxy = ::omero::api::GatewayPrx::uncheckedCast(__result->getProxy());
                try
                {
                    __proxy->end_uploadPlane(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response();
                }
            }
        
        private:
            
            ::std::function<void ()> _response;
        };
        return begin_uploadPlane(pixelsId, z, c, t, data, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_uploadPlane(::Ice::Long pixelsId, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::Ice::ByteSeq& data)
    {
        return begin_uploadPlane(pixelsId, z, c, t, data, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_uploadPlane(::Ice::Long pixelsId, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::Ice::ByteSeq& data, const ::Ice::Context& __ctx)
    {
        return begin_uploadPlane(pixelsId, z, c, t, data, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_uploadPlane(::Ice::Long pixelsId, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::Ice::ByteSeq& data, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_uploadPlane(pixelsId, z, c, t, data, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_uploadPlane(::Ice::Long pixelsId, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::Ice::ByteSeq& data, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_uploadPlane(pixelsId, z, c, t, data, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_uploadPlane(::Ice::Long pixelsId, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::Ice::ByteSeq& data, const ::omero::api::Callback_Gateway_uploadPlanePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_uploadPlane(pixelsId, z, c, t, data, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_uploadPlane(::Ice::Long pixelsId, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::Ice::ByteSeq& data, const ::Ice::Context& __ctx, const ::omero::api::Callback_Gateway_uploadPlanePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_uploadPlane(pixelsId, z, c, t, data, &__ctx, __del, __cookie);
    }

    void end_uploadPlane(const ::Ice::AsyncResultPtr&);
    
private:

    void uploadPlane(::Ice::Long, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::ByteSeq&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_uploadPlane(::Ice::Long, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::ByteSeq&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool uploadPlane_async(const ::omero::api::AMI_Gateway_uploadPlanePtr&, ::Ice::Long, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::ByteSeq&);
    bool uploadPlane_async(const ::omero::api::AMI_Gateway_uploadPlanePtr&, ::Ice::Long, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::ByteSeq&, const ::Ice::Context&);

    ICE_DEPRECATED_API ::omero::model::PixelsPtr updatePixels(const ::omero::model::PixelsPtr& pixels)
    {
        return updatePixels(pixels, 0);
    }
    ICE_DEPRECATED_API ::omero::model::PixelsPtr updatePixels(const ::omero::model::PixelsPtr& pixels, const ::Ice::Context& __ctx)
    {
        return updatePixels(pixels, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_updatePixels(const ::omero::model::PixelsPtr& pixels, const ::IceInternal::Function<void (const ::omero::model::PixelsPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_updatePixels(pixels, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_updatePixels(const ::omero::model::PixelsPtr& pixels, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_updatePixels(pixels, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_updatePixels(const ::omero::model::PixelsPtr& pixels, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::omero::model::PixelsPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_updatePixels(pixels, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_updatePixels(const ::omero::model::PixelsPtr& pixels, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_updatePixels(pixels, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_updatePixels(const ::omero::model::PixelsPtr& pixels, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::omero::model::PixelsPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::omero::model::PixelsPtr&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::api::GatewayPrx __proxy = ::omero::api::GatewayPrx::uncheckedCast(__result->getProxy());
                ::omero::model::PixelsPtr __ret;
                try
                {
                    __ret = __proxy->end_updatePixels(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::omero::model::PixelsPtr&)> _response;
        };
        return begin_updatePixels(pixels, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_updatePixels(const ::omero::model::PixelsPtr& pixels)
    {
        return begin_updatePixels(pixels, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_updatePixels(const ::omero::model::PixelsPtr& pixels, const ::Ice::Context& __ctx)
    {
        return begin_updatePixels(pixels, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_updatePixels(const ::omero::model::PixelsPtr& pixels, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_updatePixels(pixels, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_updatePixels(const ::omero::model::PixelsPtr& pixels, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_updatePixels(pixels, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_updatePixels(const ::omero::model::PixelsPtr& pixels, const ::omero::api::Callback_Gateway_updatePixelsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_updatePixels(pixels, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_updatePixels(const ::omero::model::PixelsPtr& pixels, const ::Ice::Context& __ctx, const ::omero::api::Callback_Gateway_updatePixelsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_updatePixels(pixels, &__ctx, __del, __cookie);
    }

    ::omero::model::PixelsPtr end_updatePixels(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::model::PixelsPtr updatePixels(const ::omero::model::PixelsPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_updatePixels(const ::omero::model::PixelsPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool updatePixels_async(const ::omero::api::AMI_Gateway_updatePixelsPtr&, const ::omero::model::PixelsPtr&);
    bool updatePixels_async(const ::omero::api::AMI_Gateway_updatePixelsPtr&, const ::omero::model::PixelsPtr&, const ::Ice::Context&);

    ICE_DEPRECATED_API ::omero::api::PixelsTypeList getPixelTypes()
    {
        return getPixelTypes(0);
    }
    ICE_DEPRECATED_API ::omero::api::PixelsTypeList getPixelTypes(const ::Ice::Context& __ctx)
    {
        return getPixelTypes(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_getPixelTypes(const ::IceInternal::Function<void (const ::omero::api::PixelsTypeList&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getPixelTypes(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getPixelTypes(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getPixelTypes(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_getPixelTypes(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::omero::api::PixelsTypeList&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getPixelTypes(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getPixelTypes(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getPixelTypes(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_getPixelTypes(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::omero::api::PixelsTypeList&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::omero::api::PixelsTypeList&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::api::GatewayPrx __proxy = ::omero::api::GatewayPrx::uncheckedCast(__result->getProxy());
                ::omero::api::PixelsTypeList __ret;
                try
                {
                    __ret = __proxy->end_getPixelTypes(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::omero::api::PixelsTypeList&)> _response;
        };
        return begin_getPixelTypes(__ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_getPixelTypes()
    {
        return begin_getPixelTypes(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getPixelTypes(const ::Ice::Context& __ctx)
    {
        return begin_getPixelTypes(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getPixelTypes(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getPixelTypes(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getPixelTypes(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getPixelTypes(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getPixelTypes(const ::omero::api::Callback_Gateway_getPixelTypesPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getPixelTypes(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getPixelTypes(const ::Ice::Context& __ctx, const ::omero::api::Callback_Gateway_getPixelTypesPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getPixelTypes(&__ctx, __del, __cookie);
    }

    ::omero::api::PixelsTypeList end_getPixelTypes(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::api::PixelsTypeList getPixelTypes(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getPixelTypes(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool getPixelTypes_async(const ::omero::api::AMI_Gateway_getPixelTypesPtr&);
    bool getPixelTypes_async(const ::omero::api::AMI_Gateway_getPixelTypesPtr&, const ::Ice::Context&);

    ICE_DEPRECATED_API ::omero::model::PixelsTypePtr getPixelType(const ::std::string& type)
    {
        return getPixelType(type, 0);
    }
    ICE_DEPRECATED_API ::omero::model::PixelsTypePtr getPixelType(const ::std::string& type, const ::Ice::Context& __ctx)
    {
        return getPixelType(type, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_getPixelType(const ::std::string& type, const ::IceInternal::Function<void (const ::omero::model::PixelsTypePtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getPixelType(type, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getPixelType(const ::std::string& type, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getPixelType(type, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_getPixelType(const ::std::string& type, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::omero::model::PixelsTypePtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getPixelType(type, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getPixelType(const ::std::string& type, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getPixelType(type, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_getPixelType(const ::std::string& type, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::omero::model::PixelsTypePtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::omero::model::PixelsTypePtr&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::api::GatewayPrx __proxy = ::omero::api::GatewayPrx::uncheckedCast(__result->getProxy());
                ::omero::model::PixelsTypePtr __ret;
                try
                {
                    __ret = __proxy->end_getPixelType(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::omero::model::PixelsTypePtr&)> _response;
        };
        return begin_getPixelType(type, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_getPixelType(const ::std::string& type)
    {
        return begin_getPixelType(type, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getPixelType(const ::std::string& type, const ::Ice::Context& __ctx)
    {
        return begin_getPixelType(type, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getPixelType(const ::std::string& type, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getPixelType(type, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getPixelType(const ::std::string& type, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getPixelType(type, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getPixelType(const ::std::string& type, const ::omero::api::Callback_Gateway_getPixelTypePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getPixelType(type, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getPixelType(const ::std::string& type, const ::Ice::Context& __ctx, const ::omero::api::Callback_Gateway_getPixelTypePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getPixelType(type, &__ctx, __del, __cookie);
    }

    ::omero::model::PixelsTypePtr end_getPixelType(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::model::PixelsTypePtr getPixelType(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getPixelType(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool getPixelType_async(const ::omero::api::AMI_Gateway_getPixelTypePtr&, const ::std::string&);
    bool getPixelType_async(const ::omero::api::AMI_Gateway_getPixelTypePtr&, const ::std::string&, const ::Ice::Context&);

    ICE_DEPRECATED_API ::omero::api::IntegerArray getRenderedImage(::Ice::Long pixelsId, ::Ice::Int z, ::Ice::Int t)
    {
        return getRenderedImage(pixelsId, z, t, 0);
    }
    ICE_DEPRECATED_API ::omero::api::IntegerArray getRenderedImage(::Ice::Long pixelsId, ::Ice::Int z, ::Ice::Int t, const ::Ice::Context& __ctx)
    {
        return getRenderedImage(pixelsId, z, t, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_getRenderedImage(::Ice::Long pixelsId, ::Ice::Int z, ::Ice::Int t, const ::IceInternal::Function<void (const ::omero::api::IntegerArray&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getRenderedImage(pixelsId, z, t, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getRenderedImage(::Ice::Long pixelsId, ::Ice::Int z, ::Ice::Int t, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getRenderedImage(pixelsId, z, t, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_getRenderedImage(::Ice::Long pixelsId, ::Ice::Int z, ::Ice::Int t, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::omero::api::IntegerArray&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getRenderedImage(pixelsId, z, t, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getRenderedImage(::Ice::Long pixelsId, ::Ice::Int z, ::Ice::Int t, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getRenderedImage(pixelsId, z, t, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_getRenderedImage(::Ice::Long pixelsId, ::Ice::Int z, ::Ice::Int t, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::omero::api::IntegerArray&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::omero::api::IntegerArray&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::api::GatewayPrx __proxy = ::omero::api::GatewayPrx::uncheckedCast(__result->getProxy());
                ::omero::api::IntegerArray __ret;
                try
                {
                    __ret = __proxy->end_getRenderedImage(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::omero::api::IntegerArray&)> _response;
        };
        return begin_getRenderedImage(pixelsId, z, t, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_getRenderedImage(::Ice::Long pixelsId, ::Ice::Int z, ::Ice::Int t)
    {
        return begin_getRenderedImage(pixelsId, z, t, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getRenderedImage(::Ice::Long pixelsId, ::Ice::Int z, ::Ice::Int t, const ::Ice::Context& __ctx)
    {
        return begin_getRenderedImage(pixelsId, z, t, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getRenderedImage(::Ice::Long pixelsId, ::Ice::Int z, ::Ice::Int t, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getRenderedImage(pixelsId, z, t, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getRenderedImage(::Ice::Long pixelsId, ::Ice::Int z, ::Ice::Int t, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getRenderedImage(pixelsId, z, t, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getRenderedImage(::Ice::Long pixelsId, ::Ice::Int z, ::Ice::Int t, const ::omero::api::Callback_Gateway_getRenderedImagePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getRenderedImage(pixelsId, z, t, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getRenderedImage(::Ice::Long pixelsId, ::Ice::Int z, ::Ice::Int t, const ::Ice::Context& __ctx, const ::omero::api::Callback_Gateway_getRenderedImagePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getRenderedImage(pixelsId, z, t, &__ctx, __del, __cookie);
    }

    ::omero::api::IntegerArray end_getRenderedImage(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::api::IntegerArray getRenderedImage(::Ice::Long, ::Ice::Int, ::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getRenderedImage(::Ice::Long, ::Ice::Int, ::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool getRenderedImage_async(const ::omero::api::AMI_Gateway_getRenderedImagePtr&, ::Ice::Long, ::Ice::Int, ::Ice::Int);
    bool getRenderedImage_async(const ::omero::api::AMI_Gateway_getRenderedImagePtr&, ::Ice::Long, ::Ice::Int, ::Ice::Int, const ::Ice::Context&);

    ICE_DEPRECATED_API ::omero::api::IntegerArray renderAsPackedIntAsRGBA(::Ice::Long pixelsId, ::Ice::Int z, ::Ice::Int t)
    {
        return renderAsPackedIntAsRGBA(pixelsId, z, t, 0);
    }
    ICE_DEPRECATED_API ::omero::api::IntegerArray renderAsPackedIntAsRGBA(::Ice::Long pixelsId, ::Ice::Int z, ::Ice::Int t, const ::Ice::Context& __ctx)
    {
        return renderAsPackedIntAsRGBA(pixelsId, z, t, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_renderAsPackedIntAsRGBA(::Ice::Long pixelsId, ::Ice::Int z, ::Ice::Int t, const ::IceInternal::Function<void (const ::omero::api::IntegerArray&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_renderAsPackedIntAsRGBA(pixelsId, z, t, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_renderAsPackedIntAsRGBA(::Ice::Long pixelsId, ::Ice::Int z, ::Ice::Int t, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_renderAsPackedIntAsRGBA(pixelsId, z, t, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_renderAsPackedIntAsRGBA(::Ice::Long pixelsId, ::Ice::Int z, ::Ice::Int t, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::omero::api::IntegerArray&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_renderAsPackedIntAsRGBA(pixelsId, z, t, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_renderAsPackedIntAsRGBA(::Ice::Long pixelsId, ::Ice::Int z, ::Ice::Int t, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_renderAsPackedIntAsRGBA(pixelsId, z, t, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_renderAsPackedIntAsRGBA(::Ice::Long pixelsId, ::Ice::Int z, ::Ice::Int t, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::omero::api::IntegerArray&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::omero::api::IntegerArray&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::api::GatewayPrx __proxy = ::omero::api::GatewayPrx::uncheckedCast(__result->getProxy());
                ::omero::api::IntegerArray __ret;
                try
                {
                    __ret = __proxy->end_renderAsPackedIntAsRGBA(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::omero::api::IntegerArray&)> _response;
        };
        return begin_renderAsPackedIntAsRGBA(pixelsId, z, t, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_renderAsPackedIntAsRGBA(::Ice::Long pixelsId, ::Ice::Int z, ::Ice::Int t)
    {
        return begin_renderAsPackedIntAsRGBA(pixelsId, z, t, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_renderAsPackedIntAsRGBA(::Ice::Long pixelsId, ::Ice::Int z, ::Ice::Int t, const ::Ice::Context& __ctx)
    {
        return begin_renderAsPackedIntAsRGBA(pixelsId, z, t, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_renderAsPackedIntAsRGBA(::Ice::Long pixelsId, ::Ice::Int z, ::Ice::Int t, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_renderAsPackedIntAsRGBA(pixelsId, z, t, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_renderAsPackedIntAsRGBA(::Ice::Long pixelsId, ::Ice::Int z, ::Ice::Int t, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_renderAsPackedIntAsRGBA(pixelsId, z, t, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_renderAsPackedIntAsRGBA(::Ice::Long pixelsId, ::Ice::Int z, ::Ice::Int t, const ::omero::api::Callback_Gateway_renderAsPackedIntAsRGBAPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_renderAsPackedIntAsRGBA(pixelsId, z, t, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_renderAsPackedIntAsRGBA(::Ice::Long pixelsId, ::Ice::Int z, ::Ice::Int t, const ::Ice::Context& __ctx, const ::omero::api::Callback_Gateway_renderAsPackedIntAsRGBAPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_renderAsPackedIntAsRGBA(pixelsId, z, t, &__ctx, __del, __cookie);
    }

    ::omero::api::IntegerArray end_renderAsPackedIntAsRGBA(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::api::IntegerArray renderAsPackedIntAsRGBA(::Ice::Long, ::Ice::Int, ::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_renderAsPackedIntAsRGBA(::Ice::Long, ::Ice::Int, ::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool renderAsPackedIntAsRGBA_async(const ::omero::api::AMI_Gateway_renderAsPackedIntAsRGBAPtr&, ::Ice::Long, ::Ice::Int, ::Ice::Int);
    bool renderAsPackedIntAsRGBA_async(const ::omero::api::AMI_Gateway_renderAsPackedIntAsRGBAPtr&, ::Ice::Long, ::Ice::Int, ::Ice::Int, const ::Ice::Context&);

    ICE_DEPRECATED_API ::omero::api::IntegerArrayArrayArray getRenderedImageMatrix(::Ice::Long pixelsId, ::Ice::Int z, ::Ice::Int t)
    {
        return getRenderedImageMatrix(pixelsId, z, t, 0);
    }
    ICE_DEPRECATED_API ::omero::api::IntegerArrayArrayArray getRenderedImageMatrix(::Ice::Long pixelsId, ::Ice::Int z, ::Ice::Int t, const ::Ice::Context& __ctx)
    {
        return getRenderedImageMatrix(pixelsId, z, t, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_getRenderedImageMatrix(::Ice::Long pixelsId, ::Ice::Int z, ::Ice::Int t, const ::IceInternal::Function<void (const ::omero::api::IntegerArrayArrayArray&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getRenderedImageMatrix(pixelsId, z, t, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getRenderedImageMatrix(::Ice::Long pixelsId, ::Ice::Int z, ::Ice::Int t, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getRenderedImageMatrix(pixelsId, z, t, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_getRenderedImageMatrix(::Ice::Long pixelsId, ::Ice::Int z, ::Ice::Int t, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::omero::api::IntegerArrayArrayArray&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getRenderedImageMatrix(pixelsId, z, t, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getRenderedImageMatrix(::Ice::Long pixelsId, ::Ice::Int z, ::Ice::Int t, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getRenderedImageMatrix(pixelsId, z, t, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_getRenderedImageMatrix(::Ice::Long pixelsId, ::Ice::Int z, ::Ice::Int t, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::omero::api::IntegerArrayArrayArray&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::omero::api::IntegerArrayArrayArray&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::api::GatewayPrx __proxy = ::omero::api::GatewayPrx::uncheckedCast(__result->getProxy());
                ::omero::api::IntegerArrayArrayArray __ret;
                try
                {
                    __ret = __proxy->end_getRenderedImageMatrix(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::omero::api::IntegerArrayArrayArray&)> _response;
        };
        return begin_getRenderedImageMatrix(pixelsId, z, t, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_getRenderedImageMatrix(::Ice::Long pixelsId, ::Ice::Int z, ::Ice::Int t)
    {
        return begin_getRenderedImageMatrix(pixelsId, z, t, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getRenderedImageMatrix(::Ice::Long pixelsId, ::Ice::Int z, ::Ice::Int t, const ::Ice::Context& __ctx)
    {
        return begin_getRenderedImageMatrix(pixelsId, z, t, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getRenderedImageMatrix(::Ice::Long pixelsId, ::Ice::Int z, ::Ice::Int t, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getRenderedImageMatrix(pixelsId, z, t, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getRenderedImageMatrix(::Ice::Long pixelsId, ::Ice::Int z, ::Ice::Int t, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getRenderedImageMatrix(pixelsId, z, t, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getRenderedImageMatrix(::Ice::Long pixelsId, ::Ice::Int z, ::Ice::Int t, const ::omero::api::Callback_Gateway_getRenderedImageMatrixPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getRenderedImageMatrix(pixelsId, z, t, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getRenderedImageMatrix(::Ice::Long pixelsId, ::Ice::Int z, ::Ice::Int t, const ::Ice::Context& __ctx, const ::omero::api::Callback_Gateway_getRenderedImageMatrixPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getRenderedImageMatrix(pixelsId, z, t, &__ctx, __del, __cookie);
    }

    ::omero::api::IntegerArrayArrayArray end_getRenderedImageMatrix(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::api::IntegerArrayArrayArray getRenderedImageMatrix(::Ice::Long, ::Ice::Int, ::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getRenderedImageMatrix(::Ice::Long, ::Ice::Int, ::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool getRenderedImageMatrix_async(const ::omero::api::AMI_Gateway_getRenderedImageMatrixPtr&, ::Ice::Long, ::Ice::Int, ::Ice::Int);
    bool getRenderedImageMatrix_async(const ::omero::api::AMI_Gateway_getRenderedImageMatrixPtr&, ::Ice::Long, ::Ice::Int, ::Ice::Int, const ::Ice::Context&);

    ICE_DEPRECATED_API void setActive(::Ice::Long pixelsId, ::Ice::Int w, bool active)
    {
        setActive(pixelsId, w, active, 0);
    }
    ICE_DEPRECATED_API void setActive(::Ice::Long pixelsId, ::Ice::Int w, bool active, const ::Ice::Context& __ctx)
    {
        setActive(pixelsId, w, active, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_setActive(::Ice::Long pixelsId, ::Ice::Int w, bool active, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_setActive(pixelsId, w, active, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_setActive(::Ice::Long pixelsId, ::Ice::Int w, bool active, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_setActive(pixelsId, w, active, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_setActive(::Ice::Long pixelsId, ::Ice::Int w, bool active, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_setActive(pixelsId, w, active, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_setActive(::Ice::Long pixelsId, ::Ice::Int w, bool active, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_setActive(pixelsId, w, active, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_setActive(::Ice::Long pixelsId, ::Ice::Int w, bool active, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::api::GatewayPrx __proxy = ::omero::api::GatewayPrx::uncheckedCast(__result->getProxy());
                try
                {
                    __proxy->end_setActive(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response();
                }
            }
        
        private:
            
            ::std::function<void ()> _response;
        };
        return begin_setActive(pixelsId, w, active, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_setActive(::Ice::Long pixelsId, ::Ice::Int w, bool active)
    {
        return begin_setActive(pixelsId, w, active, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setActive(::Ice::Long pixelsId, ::Ice::Int w, bool active, const ::Ice::Context& __ctx)
    {
        return begin_setActive(pixelsId, w, active, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setActive(::Ice::Long pixelsId, ::Ice::Int w, bool active, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setActive(pixelsId, w, active, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setActive(::Ice::Long pixelsId, ::Ice::Int w, bool active, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setActive(pixelsId, w, active, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setActive(::Ice::Long pixelsId, ::Ice::Int w, bool active, const ::omero::api::Callback_Gateway_setActivePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setActive(pixelsId, w, active, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setActive(::Ice::Long pixelsId, ::Ice::Int w, bool active, const ::Ice::Context& __ctx, const ::omero::api::Callback_Gateway_setActivePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setActive(pixelsId, w, active, &__ctx, __del, __cookie);
    }

    void end_setActive(const ::Ice::AsyncResultPtr&);
    
private:

    void setActive(::Ice::Long, ::Ice::Int, bool, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setActive(::Ice::Long, ::Ice::Int, bool, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool setActive_async(const ::omero::api::AMI_Gateway_setActivePtr&, ::Ice::Long, ::Ice::Int, bool);
    bool setActive_async(const ::omero::api::AMI_Gateway_setActivePtr&, ::Ice::Long, ::Ice::Int, bool, const ::Ice::Context&);

    ICE_DEPRECATED_API ::omero::api::ByteArray getThumbnail(::Ice::Long pixelsId, const ::omero::RIntPtr& sizeX, const ::omero::RIntPtr& sizeY)
    {
        return getThumbnail(pixelsId, sizeX, sizeY, 0);
    }
    ICE_DEPRECATED_API ::omero::api::ByteArray getThumbnail(::Ice::Long pixelsId, const ::omero::RIntPtr& sizeX, const ::omero::RIntPtr& sizeY, const ::Ice::Context& __ctx)
    {
        return getThumbnail(pixelsId, sizeX, sizeY, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_getThumbnail(::Ice::Long pixelsId, const ::omero::RIntPtr& sizeX, const ::omero::RIntPtr& sizeY, const ::IceInternal::Function<void (const ::omero::api::ByteArray&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getThumbnail(pixelsId, sizeX, sizeY, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getThumbnail(::Ice::Long pixelsId, const ::omero::RIntPtr& sizeX, const ::omero::RIntPtr& sizeY, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getThumbnail(pixelsId, sizeX, sizeY, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_getThumbnail(::Ice::Long pixelsId, const ::omero::RIntPtr& sizeX, const ::omero::RIntPtr& sizeY, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::omero::api::ByteArray&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getThumbnail(pixelsId, sizeX, sizeY, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getThumbnail(::Ice::Long pixelsId, const ::omero::RIntPtr& sizeX, const ::omero::RIntPtr& sizeY, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getThumbnail(pixelsId, sizeX, sizeY, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_getThumbnail(::Ice::Long pixelsId, const ::omero::RIntPtr& sizeX, const ::omero::RIntPtr& sizeY, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::omero::api::ByteArray&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::omero::api::ByteArray&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::api::GatewayPrx __proxy = ::omero::api::GatewayPrx::uncheckedCast(__result->getProxy());
                ::omero::api::ByteArray __ret;
                try
                {
                    __ret = __proxy->end_getThumbnail(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::omero::api::ByteArray&)> _response;
        };
        return begin_getThumbnail(pixelsId, sizeX, sizeY, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_getThumbnail(::Ice::Long pixelsId, const ::omero::RIntPtr& sizeX, const ::omero::RIntPtr& sizeY)
    {
        return begin_getThumbnail(pixelsId, sizeX, sizeY, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getThumbnail(::Ice::Long pixelsId, const ::omero::RIntPtr& sizeX, const ::omero::RIntPtr& sizeY, const ::Ice::Context& __ctx)
    {
        return begin_getThumbnail(pixelsId, sizeX, sizeY, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getThumbnail(::Ice::Long pixelsId, const ::omero::RIntPtr& sizeX, const ::omero::RIntPtr& sizeY, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getThumbnail(pixelsId, sizeX, sizeY, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getThumbnail(::Ice::Long pixelsId, const ::omero::RIntPtr& sizeX, const ::omero::RIntPtr& sizeY, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getThumbnail(pixelsId, sizeX, sizeY, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getThumbnail(::Ice::Long pixelsId, const ::omero::RIntPtr& sizeX, const ::omero::RIntPtr& sizeY, const ::omero::api::Callback_Gateway_getThumbnailPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getThumbnail(pixelsId, sizeX, sizeY, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getThumbnail(::Ice::Long pixelsId, const ::omero::RIntPtr& sizeX, const ::omero::RIntPtr& sizeY, const ::Ice::Context& __ctx, const ::omero::api::Callback_Gateway_getThumbnailPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getThumbnail(pixelsId, sizeX, sizeY, &__ctx, __del, __cookie);
    }

    ::omero::api::ByteArray end_getThumbnail(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::api::ByteArray getThumbnail(::Ice::Long, const ::omero::RIntPtr&, const ::omero::RIntPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getThumbnail(::Ice::Long, const ::omero::RIntPtr&, const ::omero::RIntPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool getThumbnail_async(const ::omero::api::AMI_Gateway_getThumbnailPtr&, ::Ice::Long, const ::omero::RIntPtr&, const ::omero::RIntPtr&);
    bool getThumbnail_async(const ::omero::api::AMI_Gateway_getThumbnailPtr&, ::Ice::Long, const ::omero::RIntPtr&, const ::omero::RIntPtr&, const ::Ice::Context&);

    ICE_DEPRECATED_API ::omero::api::LongByteArrayMap getThumbnailSet(const ::omero::RIntPtr& sizeX, const ::omero::RIntPtr& sizeY, const ::omero::api::LongList& pixelsIds)
    {
        return getThumbnailSet(sizeX, sizeY, pixelsIds, 0);
    }
    ICE_DEPRECATED_API ::omero::api::LongByteArrayMap getThumbnailSet(const ::omero::RIntPtr& sizeX, const ::omero::RIntPtr& sizeY, const ::omero::api::LongList& pixelsIds, const ::Ice::Context& __ctx)
    {
        return getThumbnailSet(sizeX, sizeY, pixelsIds, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_getThumbnailSet(const ::omero::RIntPtr& sizeX, const ::omero::RIntPtr& sizeY, const ::omero::api::LongList& pixelsIds, const ::IceInternal::Function<void (const ::omero::api::LongByteArrayMap&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getThumbnailSet(sizeX, sizeY, pixelsIds, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getThumbnailSet(const ::omero::RIntPtr& sizeX, const ::omero::RIntPtr& sizeY, const ::omero::api::LongList& pixelsIds, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getThumbnailSet(sizeX, sizeY, pixelsIds, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_getThumbnailSet(const ::omero::RIntPtr& sizeX, const ::omero::RIntPtr& sizeY, const ::omero::api::LongList& pixelsIds, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::omero::api::LongByteArrayMap&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getThumbnailSet(sizeX, sizeY, pixelsIds, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getThumbnailSet(const ::omero::RIntPtr& sizeX, const ::omero::RIntPtr& sizeY, const ::omero::api::LongList& pixelsIds, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getThumbnailSet(sizeX, sizeY, pixelsIds, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_getThumbnailSet(const ::omero::RIntPtr& sizeX, const ::omero::RIntPtr& sizeY, const ::omero::api::LongList& pixelsIds, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::omero::api::LongByteArrayMap&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::omero::api::LongByteArrayMap&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::api::GatewayPrx __proxy = ::omero::api::GatewayPrx::uncheckedCast(__result->getProxy());
                ::omero::api::LongByteArrayMap __ret;
                try
                {
                    __ret = __proxy->end_getThumbnailSet(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::omero::api::LongByteArrayMap&)> _response;
        };
        return begin_getThumbnailSet(sizeX, sizeY, pixelsIds, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_getThumbnailSet(const ::omero::RIntPtr& sizeX, const ::omero::RIntPtr& sizeY, const ::omero::api::LongList& pixelsIds)
    {
        return begin_getThumbnailSet(sizeX, sizeY, pixelsIds, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getThumbnailSet(const ::omero::RIntPtr& sizeX, const ::omero::RIntPtr& sizeY, const ::omero::api::LongList& pixelsIds, const ::Ice::Context& __ctx)
    {
        return begin_getThumbnailSet(sizeX, sizeY, pixelsIds, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getThumbnailSet(const ::omero::RIntPtr& sizeX, const ::omero::RIntPtr& sizeY, const ::omero::api::LongList& pixelsIds, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getThumbnailSet(sizeX, sizeY, pixelsIds, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getThumbnailSet(const ::omero::RIntPtr& sizeX, const ::omero::RIntPtr& sizeY, const ::omero::api::LongList& pixelsIds, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getThumbnailSet(sizeX, sizeY, pixelsIds, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getThumbnailSet(const ::omero::RIntPtr& sizeX, const ::omero::RIntPtr& sizeY, const ::omero::api::LongList& pixelsIds, const ::omero::api::Callback_Gateway_getThumbnailSetPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getThumbnailSet(sizeX, sizeY, pixelsIds, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getThumbnailSet(const ::omero::RIntPtr& sizeX, const ::omero::RIntPtr& sizeY, const ::omero::api::LongList& pixelsIds, const ::Ice::Context& __ctx, const ::omero::api::Callback_Gateway_getThumbnailSetPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getThumbnailSet(sizeX, sizeY, pixelsIds, &__ctx, __del, __cookie);
    }

    ::omero::api::LongByteArrayMap end_getThumbnailSet(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::api::LongByteArrayMap getThumbnailSet(const ::omero::RIntPtr&, const ::omero::RIntPtr&, const ::omero::api::LongList&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getThumbnailSet(const ::omero::RIntPtr&, const ::omero::RIntPtr&, const ::omero::api::LongList&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool getThumbnailSet_async(const ::omero::api::AMI_Gateway_getThumbnailSetPtr&, const ::omero::RIntPtr&, const ::omero::RIntPtr&, const ::omero::api::LongList&);
    bool getThumbnailSet_async(const ::omero::api::AMI_Gateway_getThumbnailSetPtr&, const ::omero::RIntPtr&, const ::omero::RIntPtr&, const ::omero::api::LongList&, const ::Ice::Context&);

    ICE_DEPRECATED_API void attachImageToDataset(const ::omero::model::DatasetPtr& dataset, const ::omero::model::ImagePtr& image)
    {
        attachImageToDataset(dataset, image, 0);
    }
    ICE_DEPRECATED_API void attachImageToDataset(const ::omero::model::DatasetPtr& dataset, const ::omero::model::ImagePtr& image, const ::Ice::Context& __ctx)
    {
        attachImageToDataset(dataset, image, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_attachImageToDataset(const ::omero::model::DatasetPtr& dataset, const ::omero::model::ImagePtr& image, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_attachImageToDataset(dataset, image, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_attachImageToDataset(const ::omero::model::DatasetPtr& dataset, const ::omero::model::ImagePtr& image, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_attachImageToDataset(dataset, image, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_attachImageToDataset(const ::omero::model::DatasetPtr& dataset, const ::omero::model::ImagePtr& image, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_attachImageToDataset(dataset, image, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_attachImageToDataset(const ::omero::model::DatasetPtr& dataset, const ::omero::model::ImagePtr& image, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_attachImageToDataset(dataset, image, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_attachImageToDataset(const ::omero::model::DatasetPtr& dataset, const ::omero::model::ImagePtr& image, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::api::GatewayPrx __proxy = ::omero::api::GatewayPrx::uncheckedCast(__result->getProxy());
                try
                {
                    __proxy->end_attachImageToDataset(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response();
                }
            }
        
        private:
            
            ::std::function<void ()> _response;
        };
        return begin_attachImageToDataset(dataset, image, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_attachImageToDataset(const ::omero::model::DatasetPtr& dataset, const ::omero::model::ImagePtr& image)
    {
        return begin_attachImageToDataset(dataset, image, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_attachImageToDataset(const ::omero::model::DatasetPtr& dataset, const ::omero::model::ImagePtr& image, const ::Ice::Context& __ctx)
    {
        return begin_attachImageToDataset(dataset, image, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_attachImageToDataset(const ::omero::model::DatasetPtr& dataset, const ::omero::model::ImagePtr& image, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_attachImageToDataset(dataset, image, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_attachImageToDataset(const ::omero::model::DatasetPtr& dataset, const ::omero::model::ImagePtr& image, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_attachImageToDataset(dataset, image, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_attachImageToDataset(const ::omero::model::DatasetPtr& dataset, const ::omero::model::ImagePtr& image, const ::omero::api::Callback_Gateway_attachImageToDatasetPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_attachImageToDataset(dataset, image, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_attachImageToDataset(const ::omero::model::DatasetPtr& dataset, const ::omero::model::ImagePtr& image, const ::Ice::Context& __ctx, const ::omero::api::Callback_Gateway_attachImageToDatasetPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_attachImageToDataset(dataset, image, &__ctx, __del, __cookie);
    }

    void end_attachImageToDataset(const ::Ice::AsyncResultPtr&);
    
private:

    void attachImageToDataset(const ::omero::model::DatasetPtr&, const ::omero::model::ImagePtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_attachImageToDataset(const ::omero::model::DatasetPtr&, const ::omero::model::ImagePtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool attachImageToDataset_async(const ::omero::api::AMI_Gateway_attachImageToDatasetPtr&, const ::omero::model::DatasetPtr&, const ::omero::model::ImagePtr&);
    bool attachImageToDataset_async(const ::omero::api::AMI_Gateway_attachImageToDatasetPtr&, const ::omero::model::DatasetPtr&, const ::omero::model::ImagePtr&, const ::Ice::Context&);

    ICE_DEPRECATED_API ::Ice::Long createImage(::Ice::Int sizeX, ::Ice::Int sizeY, ::Ice::Int sizeZ, ::Ice::Int sizeT, const ::omero::api::IntegerList& channelList, const ::omero::model::PixelsTypePtr& pixelsType, const ::std::string& name, const ::std::string& description)
    {
        return createImage(sizeX, sizeY, sizeZ, sizeT, channelList, pixelsType, name, description, 0);
    }
    ICE_DEPRECATED_API ::Ice::Long createImage(::Ice::Int sizeX, ::Ice::Int sizeY, ::Ice::Int sizeZ, ::Ice::Int sizeT, const ::omero::api::IntegerList& channelList, const ::omero::model::PixelsTypePtr& pixelsType, const ::std::string& name, const ::std::string& description, const ::Ice::Context& __ctx)
    {
        return createImage(sizeX, sizeY, sizeZ, sizeT, channelList, pixelsType, name, description, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_createImage(::Ice::Int sizeX, ::Ice::Int sizeY, ::Ice::Int sizeZ, ::Ice::Int sizeT, const ::omero::api::IntegerList& channelList, const ::omero::model::PixelsTypePtr& pixelsType, const ::std::string& name, const ::std::string& description, const ::IceInternal::Function<void (::Ice::Long)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_createImage(sizeX, sizeY, sizeZ, sizeT, channelList, pixelsType, name, description, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_createImage(::Ice::Int sizeX, ::Ice::Int sizeY, ::Ice::Int sizeZ, ::Ice::Int sizeT, const ::omero::api::IntegerList& channelList, const ::omero::model::PixelsTypePtr& pixelsType, const ::std::string& name, const ::std::string& description, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_createImage(sizeX, sizeY, sizeZ, sizeT, channelList, pixelsType, name, description, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_createImage(::Ice::Int sizeX, ::Ice::Int sizeY, ::Ice::Int sizeZ, ::Ice::Int sizeT, const ::omero::api::IntegerList& channelList, const ::omero::model::PixelsTypePtr& pixelsType, const ::std::string& name, const ::std::string& description, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (::Ice::Long)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_createImage(sizeX, sizeY, sizeZ, sizeT, channelList, pixelsType, name, description, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_createImage(::Ice::Int sizeX, ::Ice::Int sizeY, ::Ice::Int sizeZ, ::Ice::Int sizeT, const ::omero::api::IntegerList& channelList, const ::omero::model::PixelsTypePtr& pixelsType, const ::std::string& name, const ::std::string& description, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_createImage(sizeX, sizeY, sizeZ, sizeT, channelList, pixelsType, name, description, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_createImage(::Ice::Int sizeX, ::Ice::Int sizeY, ::Ice::Int sizeZ, ::Ice::Int sizeT, const ::omero::api::IntegerList& channelList, const ::omero::model::PixelsTypePtr& pixelsType, const ::std::string& name, const ::std::string& description, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (::Ice::Long)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (::Ice::Long)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::api::GatewayPrx __proxy = ::omero::api::GatewayPrx::uncheckedCast(__result->getProxy());
                ::Ice::Long __ret;
                try
                {
                    __ret = __proxy->end_createImage(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (::Ice::Long)> _response;
        };
        return begin_createImage(sizeX, sizeY, sizeZ, sizeT, channelList, pixelsType, name, description, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_createImage(::Ice::Int sizeX, ::Ice::Int sizeY, ::Ice::Int sizeZ, ::Ice::Int sizeT, const ::omero::api::IntegerList& channelList, const ::omero::model::PixelsTypePtr& pixelsType, const ::std::string& name, const ::std::string& description)
    {
        return begin_createImage(sizeX, sizeY, sizeZ, sizeT, channelList, pixelsType, name, description, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_createImage(::Ice::Int sizeX, ::Ice::Int sizeY, ::Ice::Int sizeZ, ::Ice::Int sizeT, const ::omero::api::IntegerList& channelList, const ::omero::model::PixelsTypePtr& pixelsType, const ::std::string& name, const ::std::string& description, const ::Ice::Context& __ctx)
    {
        return begin_createImage(sizeX, sizeY, sizeZ, sizeT, channelList, pixelsType, name, description, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_createImage(::Ice::Int sizeX, ::Ice::Int sizeY, ::Ice::Int sizeZ, ::Ice::Int sizeT, const ::omero::api::IntegerList& channelList, const ::omero::model::PixelsTypePtr& pixelsType, const ::std::string& name, const ::std::string& description, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createImage(sizeX, sizeY, sizeZ, sizeT, channelList, pixelsType, name, description, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_createImage(::Ice::Int sizeX, ::Ice::Int sizeY, ::Ice::Int sizeZ, ::Ice::Int sizeT, const ::omero::api::IntegerList& channelList, const ::omero::model::PixelsTypePtr& pixelsType, const ::std::string& name, const ::std::string& description, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createImage(sizeX, sizeY, sizeZ, sizeT, channelList, pixelsType, name, description, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_createImage(::Ice::Int sizeX, ::Ice::Int sizeY, ::Ice::Int sizeZ, ::Ice::Int sizeT, const ::omero::api::IntegerList& channelList, const ::omero::model::PixelsTypePtr& pixelsType, const ::std::string& name, const ::std::string& description, const ::omero::api::Callback_Gateway_createImagePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createImage(sizeX, sizeY, sizeZ, sizeT, channelList, pixelsType, name, description, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_createImage(::Ice::Int sizeX, ::Ice::Int sizeY, ::Ice::Int sizeZ, ::Ice::Int sizeT, const ::omero::api::IntegerList& channelList, const ::omero::model::PixelsTypePtr& pixelsType, const ::std::string& name, const ::std::string& description, const ::Ice::Context& __ctx, const ::omero::api::Callback_Gateway_createImagePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createImage(sizeX, sizeY, sizeZ, sizeT, channelList, pixelsType, name, description, &__ctx, __del, __cookie);
    }

    ::Ice::Long end_createImage(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Long createImage(::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::omero::api::IntegerList&, const ::omero::model::PixelsTypePtr&, const ::std::string&, const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_createImage(::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::omero::api::IntegerList&, const ::omero::model::PixelsTypePtr&, const ::std::string&, const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool createImage_async(const ::omero::api::AMI_Gateway_createImagePtr&, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::omero::api::IntegerList&, const ::omero::model::PixelsTypePtr&, const ::std::string&, const ::std::string&);
    bool createImage_async(const ::omero::api::AMI_Gateway_createImagePtr&, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::omero::api::IntegerList&, const ::omero::model::PixelsTypePtr&, const ::std::string&, const ::std::string&, const ::Ice::Context&);

    ICE_DEPRECATED_API ::omero::api::ImageList getImageFromDatasetByName(::Ice::Long datasetId, const ::std::string& imageName)
    {
        return getImageFromDatasetByName(datasetId, imageName, 0);
    }
    ICE_DEPRECATED_API ::omero::api::ImageList getImageFromDatasetByName(::Ice::Long datasetId, const ::std::string& imageName, const ::Ice::Context& __ctx)
    {
        return getImageFromDatasetByName(datasetId, imageName, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_getImageFromDatasetByName(::Ice::Long datasetId, const ::std::string& imageName, const ::IceInternal::Function<void (const ::omero::api::ImageList&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getImageFromDatasetByName(datasetId, imageName, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getImageFromDatasetByName(::Ice::Long datasetId, const ::std::string& imageName, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getImageFromDatasetByName(datasetId, imageName, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_getImageFromDatasetByName(::Ice::Long datasetId, const ::std::string& imageName, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::omero::api::ImageList&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getImageFromDatasetByName(datasetId, imageName, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getImageFromDatasetByName(::Ice::Long datasetId, const ::std::string& imageName, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getImageFromDatasetByName(datasetId, imageName, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_getImageFromDatasetByName(::Ice::Long datasetId, const ::std::string& imageName, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::omero::api::ImageList&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::omero::api::ImageList&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::api::GatewayPrx __proxy = ::omero::api::GatewayPrx::uncheckedCast(__result->getProxy());
                ::omero::api::ImageList __ret;
                try
                {
                    __ret = __proxy->end_getImageFromDatasetByName(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::omero::api::ImageList&)> _response;
        };
        return begin_getImageFromDatasetByName(datasetId, imageName, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_getImageFromDatasetByName(::Ice::Long datasetId, const ::std::string& imageName)
    {
        return begin_getImageFromDatasetByName(datasetId, imageName, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getImageFromDatasetByName(::Ice::Long datasetId, const ::std::string& imageName, const ::Ice::Context& __ctx)
    {
        return begin_getImageFromDatasetByName(datasetId, imageName, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getImageFromDatasetByName(::Ice::Long datasetId, const ::std::string& imageName, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getImageFromDatasetByName(datasetId, imageName, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getImageFromDatasetByName(::Ice::Long datasetId, const ::std::string& imageName, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getImageFromDatasetByName(datasetId, imageName, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getImageFromDatasetByName(::Ice::Long datasetId, const ::std::string& imageName, const ::omero::api::Callback_Gateway_getImageFromDatasetByNamePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getImageFromDatasetByName(datasetId, imageName, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getImageFromDatasetByName(::Ice::Long datasetId, const ::std::string& imageName, const ::Ice::Context& __ctx, const ::omero::api::Callback_Gateway_getImageFromDatasetByNamePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getImageFromDatasetByName(datasetId, imageName, &__ctx, __del, __cookie);
    }

    ::omero::api::ImageList end_getImageFromDatasetByName(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::api::ImageList getImageFromDatasetByName(::Ice::Long, const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getImageFromDatasetByName(::Ice::Long, const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool getImageFromDatasetByName_async(const ::omero::api::AMI_Gateway_getImageFromDatasetByNamePtr&, ::Ice::Long, const ::std::string&);
    bool getImageFromDatasetByName_async(const ::omero::api::AMI_Gateway_getImageFromDatasetByNamePtr&, ::Ice::Long, const ::std::string&, const ::Ice::Context&);

    ICE_DEPRECATED_API ::omero::api::ImageList getImageByName(const ::std::string& imageName)
    {
        return getImageByName(imageName, 0);
    }
    ICE_DEPRECATED_API ::omero::api::ImageList getImageByName(const ::std::string& imageName, const ::Ice::Context& __ctx)
    {
        return getImageByName(imageName, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_getImageByName(const ::std::string& imageName, const ::IceInternal::Function<void (const ::omero::api::ImageList&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getImageByName(imageName, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getImageByName(const ::std::string& imageName, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getImageByName(imageName, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_getImageByName(const ::std::string& imageName, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::omero::api::ImageList&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getImageByName(imageName, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getImageByName(const ::std::string& imageName, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getImageByName(imageName, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_getImageByName(const ::std::string& imageName, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::omero::api::ImageList&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::omero::api::ImageList&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::api::GatewayPrx __proxy = ::omero::api::GatewayPrx::uncheckedCast(__result->getProxy());
                ::omero::api::ImageList __ret;
                try
                {
                    __ret = __proxy->end_getImageByName(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::omero::api::ImageList&)> _response;
        };
        return begin_getImageByName(imageName, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_getImageByName(const ::std::string& imageName)
    {
        return begin_getImageByName(imageName, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getImageByName(const ::std::string& imageName, const ::Ice::Context& __ctx)
    {
        return begin_getImageByName(imageName, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getImageByName(const ::std::string& imageName, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getImageByName(imageName, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getImageByName(const ::std::string& imageName, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getImageByName(imageName, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getImageByName(const ::std::string& imageName, const ::omero::api::Callback_Gateway_getImageByNamePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getImageByName(imageName, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getImageByName(const ::std::string& imageName, const ::Ice::Context& __ctx, const ::omero::api::Callback_Gateway_getImageByNamePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getImageByName(imageName, &__ctx, __del, __cookie);
    }

    ::omero::api::ImageList end_getImageByName(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::api::ImageList getImageByName(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getImageByName(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool getImageByName_async(const ::omero::api::AMI_Gateway_getImageByNamePtr&, const ::std::string&);
    bool getImageByName_async(const ::omero::api::AMI_Gateway_getImageByNamePtr&, const ::std::string&, const ::Ice::Context&);

    ICE_DEPRECATED_API void saveObject(const ::omero::model::IObjectPtr& obj)
    {
        saveObject(obj, 0);
    }
    ICE_DEPRECATED_API void saveObject(const ::omero::model::IObjectPtr& obj, const ::Ice::Context& __ctx)
    {
        saveObject(obj, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_saveObject(const ::omero::model::IObjectPtr& obj, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_saveObject(obj, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_saveObject(const ::omero::model::IObjectPtr& obj, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_saveObject(obj, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_saveObject(const ::omero::model::IObjectPtr& obj, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_saveObject(obj, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_saveObject(const ::omero::model::IObjectPtr& obj, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_saveObject(obj, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_saveObject(const ::omero::model::IObjectPtr& obj, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::api::GatewayPrx __proxy = ::omero::api::GatewayPrx::uncheckedCast(__result->getProxy());
                try
                {
                    __proxy->end_saveObject(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response();
                }
            }
        
        private:
            
            ::std::function<void ()> _response;
        };
        return begin_saveObject(obj, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_saveObject(const ::omero::model::IObjectPtr& obj)
    {
        return begin_saveObject(obj, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_saveObject(const ::omero::model::IObjectPtr& obj, const ::Ice::Context& __ctx)
    {
        return begin_saveObject(obj, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_saveObject(const ::omero::model::IObjectPtr& obj, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_saveObject(obj, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_saveObject(const ::omero::model::IObjectPtr& obj, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_saveObject(obj, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_saveObject(const ::omero::model::IObjectPtr& obj, const ::omero::api::Callback_Gateway_saveObjectPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_saveObject(obj, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_saveObject(const ::omero::model::IObjectPtr& obj, const ::Ice::Context& __ctx, const ::omero::api::Callback_Gateway_saveObjectPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_saveObject(obj, &__ctx, __del, __cookie);
    }

    void end_saveObject(const ::Ice::AsyncResultPtr&);
    
private:

    void saveObject(const ::omero::model::IObjectPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_saveObject(const ::omero::model::IObjectPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool saveObject_async(const ::omero::api::AMI_Gateway_saveObjectPtr&, const ::omero::model::IObjectPtr&);
    bool saveObject_async(const ::omero::api::AMI_Gateway_saveObjectPtr&, const ::omero::model::IObjectPtr&, const ::Ice::Context&);

    ICE_DEPRECATED_API ::omero::model::IObjectPtr saveAndReturnObject(const ::omero::model::IObjectPtr& obj)
    {
        return saveAndReturnObject(obj, 0);
    }
    ICE_DEPRECATED_API ::omero::model::IObjectPtr saveAndReturnObject(const ::omero::model::IObjectPtr& obj, const ::Ice::Context& __ctx)
    {
        return saveAndReturnObject(obj, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_saveAndReturnObject(const ::omero::model::IObjectPtr& obj, const ::IceInternal::Function<void (const ::omero::model::IObjectPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_saveAndReturnObject(obj, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_saveAndReturnObject(const ::omero::model::IObjectPtr& obj, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_saveAndReturnObject(obj, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_saveAndReturnObject(const ::omero::model::IObjectPtr& obj, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::omero::model::IObjectPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_saveAndReturnObject(obj, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_saveAndReturnObject(const ::omero::model::IObjectPtr& obj, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_saveAndReturnObject(obj, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_saveAndReturnObject(const ::omero::model::IObjectPtr& obj, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::omero::model::IObjectPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::omero::model::IObjectPtr&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::api::GatewayPrx __proxy = ::omero::api::GatewayPrx::uncheckedCast(__result->getProxy());
                ::omero::model::IObjectPtr __ret;
                try
                {
                    __ret = __proxy->end_saveAndReturnObject(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::omero::model::IObjectPtr&)> _response;
        };
        return begin_saveAndReturnObject(obj, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_saveAndReturnObject(const ::omero::model::IObjectPtr& obj)
    {
        return begin_saveAndReturnObject(obj, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_saveAndReturnObject(const ::omero::model::IObjectPtr& obj, const ::Ice::Context& __ctx)
    {
        return begin_saveAndReturnObject(obj, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_saveAndReturnObject(const ::omero::model::IObjectPtr& obj, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_saveAndReturnObject(obj, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_saveAndReturnObject(const ::omero::model::IObjectPtr& obj, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_saveAndReturnObject(obj, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_saveAndReturnObject(const ::omero::model::IObjectPtr& obj, const ::omero::api::Callback_Gateway_saveAndReturnObjectPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_saveAndReturnObject(obj, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_saveAndReturnObject(const ::omero::model::IObjectPtr& obj, const ::Ice::Context& __ctx, const ::omero::api::Callback_Gateway_saveAndReturnObjectPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_saveAndReturnObject(obj, &__ctx, __del, __cookie);
    }

    ::omero::model::IObjectPtr end_saveAndReturnObject(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::model::IObjectPtr saveAndReturnObject(const ::omero::model::IObjectPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_saveAndReturnObject(const ::omero::model::IObjectPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool saveAndReturnObject_async(const ::omero::api::AMI_Gateway_saveAndReturnObjectPtr&, const ::omero::model::IObjectPtr&);
    bool saveAndReturnObject_async(const ::omero::api::AMI_Gateway_saveAndReturnObjectPtr&, const ::omero::model::IObjectPtr&, const ::Ice::Context&);

    ICE_DEPRECATED_API void saveArray(const ::omero::api::IObjectList& graph)
    {
        saveArray(graph, 0);
    }
    ICE_DEPRECATED_API void saveArray(const ::omero::api::IObjectList& graph, const ::Ice::Context& __ctx)
    {
        saveArray(graph, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_saveArray(const ::omero::api::IObjectList& graph, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_saveArray(graph, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_saveArray(const ::omero::api::IObjectList& graph, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_saveArray(graph, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_saveArray(const ::omero::api::IObjectList& graph, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_saveArray(graph, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_saveArray(const ::omero::api::IObjectList& graph, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_saveArray(graph, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_saveArray(const ::omero::api::IObjectList& graph, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::api::GatewayPrx __proxy = ::omero::api::GatewayPrx::uncheckedCast(__result->getProxy());
                try
                {
                    __proxy->end_saveArray(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response();
                }
            }
        
        private:
            
            ::std::function<void ()> _response;
        };
        return begin_saveArray(graph, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_saveArray(const ::omero::api::IObjectList& graph)
    {
        return begin_saveArray(graph, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_saveArray(const ::omero::api::IObjectList& graph, const ::Ice::Context& __ctx)
    {
        return begin_saveArray(graph, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_saveArray(const ::omero::api::IObjectList& graph, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_saveArray(graph, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_saveArray(const ::omero::api::IObjectList& graph, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_saveArray(graph, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_saveArray(const ::omero::api::IObjectList& graph, const ::omero::api::Callback_Gateway_saveArrayPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_saveArray(graph, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_saveArray(const ::omero::api::IObjectList& graph, const ::Ice::Context& __ctx, const ::omero::api::Callback_Gateway_saveArrayPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_saveArray(graph, &__ctx, __del, __cookie);
    }

    void end_saveArray(const ::Ice::AsyncResultPtr&);
    
private:

    void saveArray(const ::omero::api::IObjectList&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_saveArray(const ::omero::api::IObjectList&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool saveArray_async(const ::omero::api::AMI_Gateway_saveArrayPtr&, const ::omero::api::IObjectList&);
    bool saveArray_async(const ::omero::api::AMI_Gateway_saveArrayPtr&, const ::omero::api::IObjectList&, const ::Ice::Context&);

    ICE_DEPRECATED_API ::omero::api::IObjectList saveAndReturnArray(const ::omero::api::IObjectList& graph)
    {
        return saveAndReturnArray(graph, 0);
    }
    ICE_DEPRECATED_API ::omero::api::IObjectList saveAndReturnArray(const ::omero::api::IObjectList& graph, const ::Ice::Context& __ctx)
    {
        return saveAndReturnArray(graph, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_saveAndReturnArray(const ::omero::api::IObjectList& graph, const ::IceInternal::Function<void (const ::omero::api::IObjectList&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_saveAndReturnArray(graph, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_saveAndReturnArray(const ::omero::api::IObjectList& graph, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_saveAndReturnArray(graph, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_saveAndReturnArray(const ::omero::api::IObjectList& graph, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::omero::api::IObjectList&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_saveAndReturnArray(graph, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_saveAndReturnArray(const ::omero::api::IObjectList& graph, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_saveAndReturnArray(graph, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_saveAndReturnArray(const ::omero::api::IObjectList& graph, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::omero::api::IObjectList&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::omero::api::IObjectList&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::api::GatewayPrx __proxy = ::omero::api::GatewayPrx::uncheckedCast(__result->getProxy());
                ::omero::api::IObjectList __ret;
                try
                {
                    __ret = __proxy->end_saveAndReturnArray(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::omero::api::IObjectList&)> _response;
        };
        return begin_saveAndReturnArray(graph, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_saveAndReturnArray(const ::omero::api::IObjectList& graph)
    {
        return begin_saveAndReturnArray(graph, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_saveAndReturnArray(const ::omero::api::IObjectList& graph, const ::Ice::Context& __ctx)
    {
        return begin_saveAndReturnArray(graph, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_saveAndReturnArray(const ::omero::api::IObjectList& graph, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_saveAndReturnArray(graph, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_saveAndReturnArray(const ::omero::api::IObjectList& graph, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_saveAndReturnArray(graph, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_saveAndReturnArray(const ::omero::api::IObjectList& graph, const ::omero::api::Callback_Gateway_saveAndReturnArrayPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_saveAndReturnArray(graph, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_saveAndReturnArray(const ::omero::api::IObjectList& graph, const ::Ice::Context& __ctx, const ::omero::api::Callback_Gateway_saveAndReturnArrayPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_saveAndReturnArray(graph, &__ctx, __del, __cookie);
    }

    ::omero::api::IObjectList end_saveAndReturnArray(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::api::IObjectList saveAndReturnArray(const ::omero::api::IObjectList&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_saveAndReturnArray(const ::omero::api::IObjectList&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool saveAndReturnArray_async(const ::omero::api::AMI_Gateway_saveAndReturnArrayPtr&, const ::omero::api::IObjectList&);
    bool saveAndReturnArray_async(const ::omero::api::AMI_Gateway_saveAndReturnArrayPtr&, const ::omero::api::IObjectList&, const ::Ice::Context&);

    ICE_DEPRECATED_API void deleteObject(const ::omero::model::IObjectPtr& row)
    {
        deleteObject(row, 0);
    }
    ICE_DEPRECATED_API void deleteObject(const ::omero::model::IObjectPtr& row, const ::Ice::Context& __ctx)
    {
        deleteObject(row, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_deleteObject(const ::omero::model::IObjectPtr& row, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_deleteObject(row, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_deleteObject(const ::omero::model::IObjectPtr& row, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_deleteObject(row, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_deleteObject(const ::omero::model::IObjectPtr& row, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_deleteObject(row, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_deleteObject(const ::omero::model::IObjectPtr& row, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_deleteObject(row, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_deleteObject(const ::omero::model::IObjectPtr& row, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::api::GatewayPrx __proxy = ::omero::api::GatewayPrx::uncheckedCast(__result->getProxy());
                try
                {
                    __proxy->end_deleteObject(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response();
                }
            }
        
        private:
            
            ::std::function<void ()> _response;
        };
        return begin_deleteObject(row, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_deleteObject(const ::omero::model::IObjectPtr& row)
    {
        return begin_deleteObject(row, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_deleteObject(const ::omero::model::IObjectPtr& row, const ::Ice::Context& __ctx)
    {
        return begin_deleteObject(row, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_deleteObject(const ::omero::model::IObjectPtr& row, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_deleteObject(row, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_deleteObject(const ::omero::model::IObjectPtr& row, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_deleteObject(row, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_deleteObject(const ::omero::model::IObjectPtr& row, const ::omero::api::Callback_Gateway_deleteObjectPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_deleteObject(row, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_deleteObject(const ::omero::model::IObjectPtr& row, const ::Ice::Context& __ctx, const ::omero::api::Callback_Gateway_deleteObjectPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_deleteObject(row, &__ctx, __del, __cookie);
    }

    void end_deleteObject(const ::Ice::AsyncResultPtr&);
    
private:

    void deleteObject(const ::omero::model::IObjectPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_deleteObject(const ::omero::model::IObjectPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool deleteObject_async(const ::omero::api::AMI_Gateway_deleteObjectPtr&, const ::omero::model::IObjectPtr&);
    bool deleteObject_async(const ::omero::api::AMI_Gateway_deleteObjectPtr&, const ::omero::model::IObjectPtr&, const ::Ice::Context&);

    ICE_DEPRECATED_API void keepAlive()
    {
        keepAlive(0);
    }
    ICE_DEPRECATED_API void keepAlive(const ::Ice::Context& __ctx)
    {
        keepAlive(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_keepAlive(const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_keepAlive(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_keepAlive(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_keepAlive(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_keepAlive(const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_keepAlive(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_keepAlive(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_keepAlive(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_keepAlive(const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::api::GatewayPrx __proxy = ::omero::api::GatewayPrx::uncheckedCast(__result->getProxy());
                try
                {
                    __proxy->end_keepAlive(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response();
                }
            }
        
        private:
            
            ::std::function<void ()> _response;
        };
        return begin_keepAlive(__ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_keepAlive()
    {
        return begin_keepAlive(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_keepAlive(const ::Ice::Context& __ctx)
    {
        return begin_keepAlive(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_keepAlive(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_keepAlive(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_keepAlive(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_keepAlive(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_keepAlive(const ::omero::api::Callback_Gateway_keepAlivePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_keepAlive(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_keepAlive(const ::Ice::Context& __ctx, const ::omero::api::Callback_Gateway_keepAlivePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_keepAlive(&__ctx, __del, __cookie);
    }

    void end_keepAlive(const ::Ice::AsyncResultPtr&);
    
private:

    void keepAlive(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_keepAlive(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool keepAlive_async(const ::omero::api::AMI_Gateway_keepAlivePtr&);
    bool keepAlive_async(const ::omero::api::AMI_Gateway_keepAlivePtr&, const ::Ice::Context&);
    
    ::IceInternal::ProxyHandle<Gateway> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<Gateway*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<Gateway> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<Gateway*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<Gateway> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<Gateway*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<Gateway> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<Gateway*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<Gateway> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<Gateway*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<Gateway> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<Gateway*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<Gateway> ice_secure(bool __secure) const
    {
        return dynamic_cast<Gateway*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<Gateway> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<Gateway*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<Gateway> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<Gateway*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<Gateway> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<Gateway*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<Gateway> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<Gateway*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<Gateway> ice_twoway() const
    {
        return dynamic_cast<Gateway*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<Gateway> ice_oneway() const
    {
        return dynamic_cast<Gateway*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<Gateway> ice_batchOneway() const
    {
        return dynamic_cast<Gateway*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<Gateway> ice_datagram() const
    {
        return dynamic_cast<Gateway*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<Gateway> ice_batchDatagram() const
    {
        return dynamic_cast<Gateway*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<Gateway> ice_compress(bool __compress) const
    {
        return dynamic_cast<Gateway*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<Gateway> ice_timeout(int __timeout) const
    {
        return dynamic_cast<Gateway*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<Gateway> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<Gateway*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<Gateway> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<Gateway*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

}

}

}

namespace IceDelegate
{

namespace omero
{

namespace api
{

class BufferedImage : virtual public ::IceDelegate::Ice::Object
{
public:
};

class Gateway : virtual public ::IceDelegate::omero::api::StatefulServiceInterface
{
public:

    virtual ::omero::api::ProjectList getProjects(const ::omero::api::LongList&, bool, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::omero::api::DatasetList getDatasets(const ::omero::api::LongList&, bool, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::omero::model::DatasetPtr getDataset(::Ice::Long, bool, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::omero::api::PixelsList getPixelsFromImage(::Ice::Long, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::omero::model::ImagePtr getImage(::Ice::Long, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::omero::api::ImageList getImages(::omero::api::ContainerClass, const ::omero::api::LongList&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::omero::api::IObjectList findAllByQuery(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::omero::model::IObjectPtr findByQuery(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Ice::ByteSeq getPlane(::Ice::Long, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::omero::model::PixelsPtr getPixels(::Ice::Long, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Ice::Long copyPixelsXYTZ(::Ice::Long, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::omero::api::IntegerList&, const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Ice::Long copyPixels(::Ice::Long, const ::omero::api::IntegerList&, const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Ice::Long copyImage(::Ice::Long, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::omero::api::IntegerList&, const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual void uploadPlane(::Ice::Long, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::ByteSeq&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::omero::model::PixelsPtr updatePixels(const ::omero::model::PixelsPtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::omero::api::PixelsTypeList getPixelTypes(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::omero::model::PixelsTypePtr getPixelType(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::omero::api::IntegerArray getRenderedImage(::Ice::Long, ::Ice::Int, ::Ice::Int, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::omero::api::IntegerArray renderAsPackedIntAsRGBA(::Ice::Long, ::Ice::Int, ::Ice::Int, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::omero::api::IntegerArrayArrayArray getRenderedImageMatrix(::Ice::Long, ::Ice::Int, ::Ice::Int, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual void setActive(::Ice::Long, ::Ice::Int, bool, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::omero::api::ByteArray getThumbnail(::Ice::Long, const ::omero::RIntPtr&, const ::omero::RIntPtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::omero::api::LongByteArrayMap getThumbnailSet(const ::omero::RIntPtr&, const ::omero::RIntPtr&, const ::omero::api::LongList&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual void attachImageToDataset(const ::omero::model::DatasetPtr&, const ::omero::model::ImagePtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Ice::Long createImage(::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::omero::api::IntegerList&, const ::omero::model::PixelsTypePtr&, const ::std::string&, const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::omero::api::ImageList getImageFromDatasetByName(::Ice::Long, const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::omero::api::ImageList getImageByName(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual void saveObject(const ::omero::model::IObjectPtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::omero::model::IObjectPtr saveAndReturnObject(const ::omero::model::IObjectPtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual void saveArray(const ::omero::api::IObjectList&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::omero::api::IObjectList saveAndReturnArray(const ::omero::api::IObjectList&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual void deleteObject(const ::omero::model::IObjectPtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual void keepAlive(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;
};

}

}

}

namespace IceDelegateM
{

namespace omero
{

namespace api
{

class BufferedImage : virtual public ::IceDelegate::omero::api::BufferedImage,
                      virtual public ::IceDelegateM::Ice::Object
{
public:
};

class Gateway : virtual public ::IceDelegate::omero::api::Gateway,
                virtual public ::IceDelegateM::omero::api::StatefulServiceInterface
{
public:

    virtual ::omero::api::ProjectList getProjects(const ::omero::api::LongList&, bool, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::api::DatasetList getDatasets(const ::omero::api::LongList&, bool, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::model::DatasetPtr getDataset(::Ice::Long, bool, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::api::PixelsList getPixelsFromImage(::Ice::Long, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::model::ImagePtr getImage(::Ice::Long, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::api::ImageList getImages(::omero::api::ContainerClass, const ::omero::api::LongList&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::api::IObjectList findAllByQuery(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::model::IObjectPtr findByQuery(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Ice::ByteSeq getPlane(::Ice::Long, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::model::PixelsPtr getPixels(::Ice::Long, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Ice::Long copyPixelsXYTZ(::Ice::Long, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::omero::api::IntegerList&, const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Ice::Long copyPixels(::Ice::Long, const ::omero::api::IntegerList&, const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Ice::Long copyImage(::Ice::Long, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::omero::api::IntegerList&, const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void uploadPlane(::Ice::Long, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::ByteSeq&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::model::PixelsPtr updatePixels(const ::omero::model::PixelsPtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::api::PixelsTypeList getPixelTypes(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::model::PixelsTypePtr getPixelType(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::api::IntegerArray getRenderedImage(::Ice::Long, ::Ice::Int, ::Ice::Int, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::api::IntegerArray renderAsPackedIntAsRGBA(::Ice::Long, ::Ice::Int, ::Ice::Int, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::api::IntegerArrayArrayArray getRenderedImageMatrix(::Ice::Long, ::Ice::Int, ::Ice::Int, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void setActive(::Ice::Long, ::Ice::Int, bool, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::api::ByteArray getThumbnail(::Ice::Long, const ::omero::RIntPtr&, const ::omero::RIntPtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::api::LongByteArrayMap getThumbnailSet(const ::omero::RIntPtr&, const ::omero::RIntPtr&, const ::omero::api::LongList&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void attachImageToDataset(const ::omero::model::DatasetPtr&, const ::omero::model::ImagePtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Ice::Long createImage(::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::omero::api::IntegerList&, const ::omero::model::PixelsTypePtr&, const ::std::string&, const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::api::ImageList getImageFromDatasetByName(::Ice::Long, const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::api::ImageList getImageByName(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void saveObject(const ::omero::model::IObjectPtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::model::IObjectPtr saveAndReturnObject(const ::omero::model::IObjectPtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void saveArray(const ::omero::api::IObjectList&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::api::IObjectList saveAndReturnArray(const ::omero::api::IObjectList&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void deleteObject(const ::omero::model::IObjectPtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void keepAlive(const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

}

}

}

namespace IceDelegateD
{

namespace omero
{

namespace api
{

class BufferedImage : virtual public ::IceDelegate::omero::api::BufferedImage,
                      virtual public ::IceDelegateD::Ice::Object
{
public:
};

class Gateway : virtual public ::IceDelegate::omero::api::Gateway,
                virtual public ::IceDelegateD::omero::api::StatefulServiceInterface
{
public:

    virtual ::omero::api::ProjectList getProjects(const ::omero::api::LongList&, bool, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::api::DatasetList getDatasets(const ::omero::api::LongList&, bool, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::model::DatasetPtr getDataset(::Ice::Long, bool, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::api::PixelsList getPixelsFromImage(::Ice::Long, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::model::ImagePtr getImage(::Ice::Long, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::api::ImageList getImages(::omero::api::ContainerClass, const ::omero::api::LongList&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::api::IObjectList findAllByQuery(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::model::IObjectPtr findByQuery(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Ice::ByteSeq getPlane(::Ice::Long, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::model::PixelsPtr getPixels(::Ice::Long, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Ice::Long copyPixelsXYTZ(::Ice::Long, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::omero::api::IntegerList&, const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Ice::Long copyPixels(::Ice::Long, const ::omero::api::IntegerList&, const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Ice::Long copyImage(::Ice::Long, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::omero::api::IntegerList&, const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void uploadPlane(::Ice::Long, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::ByteSeq&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::model::PixelsPtr updatePixels(const ::omero::model::PixelsPtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::api::PixelsTypeList getPixelTypes(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::model::PixelsTypePtr getPixelType(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::api::IntegerArray getRenderedImage(::Ice::Long, ::Ice::Int, ::Ice::Int, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::api::IntegerArray renderAsPackedIntAsRGBA(::Ice::Long, ::Ice::Int, ::Ice::Int, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::api::IntegerArrayArrayArray getRenderedImageMatrix(::Ice::Long, ::Ice::Int, ::Ice::Int, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void setActive(::Ice::Long, ::Ice::Int, bool, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::api::ByteArray getThumbnail(::Ice::Long, const ::omero::RIntPtr&, const ::omero::RIntPtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::api::LongByteArrayMap getThumbnailSet(const ::omero::RIntPtr&, const ::omero::RIntPtr&, const ::omero::api::LongList&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void attachImageToDataset(const ::omero::model::DatasetPtr&, const ::omero::model::ImagePtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Ice::Long createImage(::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::omero::api::IntegerList&, const ::omero::model::PixelsTypePtr&, const ::std::string&, const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::api::ImageList getImageFromDatasetByName(::Ice::Long, const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::api::ImageList getImageByName(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void saveObject(const ::omero::model::IObjectPtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::model::IObjectPtr saveAndReturnObject(const ::omero::model::IObjectPtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void saveArray(const ::omero::api::IObjectList&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::api::IObjectList saveAndReturnArray(const ::omero::api::IObjectList&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void deleteObject(const ::omero::model::IObjectPtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void keepAlive(const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

}

}

}

namespace omero
{

namespace api
{

class BufferedImage : virtual public ::Ice::Object
{
public:

    typedef BufferedImagePrx ProxyType;
    typedef BufferedImagePtr PointerType;

    BufferedImage()
    {
    }

    explicit BufferedImage(const ::omero::api::IntegerArray& __ice_packedInts) :
        packedInts(__ice_packedInts)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();


    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif

public:

    ::omero::api::IntegerArray packedInts;

protected:

    virtual ~BufferedImage() {}

    friend class BufferedImage__staticInit;
};

class BufferedImage__staticInit
{
public:

    ::omero::api::BufferedImage _init;
};

static BufferedImage__staticInit _BufferedImage_init;

inline bool operator==(const BufferedImage& l, const BufferedImage& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const BufferedImage& l, const BufferedImage& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class Gateway : virtual public ::omero::api::StatefulServiceInterface
{
public:

    typedef GatewayPrx ProxyType;
    typedef GatewayPtr PointerType;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    ICE_DEPRECATED_API virtual ::omero::api::ProjectList getProjects(const ::omero::api::LongList&, bool, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getProjects(::IceInternal::Incoming&, const ::Ice::Current&);

    ICE_DEPRECATED_API virtual ::omero::api::DatasetList getDatasets(const ::omero::api::LongList&, bool, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getDatasets(::IceInternal::Incoming&, const ::Ice::Current&);

    ICE_DEPRECATED_API virtual ::omero::model::DatasetPtr getDataset(::Ice::Long, bool, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getDataset(::IceInternal::Incoming&, const ::Ice::Current&);

    ICE_DEPRECATED_API virtual ::omero::api::PixelsList getPixelsFromImage(::Ice::Long, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getPixelsFromImage(::IceInternal::Incoming&, const ::Ice::Current&);

    ICE_DEPRECATED_API virtual ::omero::model::ImagePtr getImage(::Ice::Long, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getImage(::IceInternal::Incoming&, const ::Ice::Current&);

    ICE_DEPRECATED_API virtual ::omero::api::ImageList getImages(::omero::api::ContainerClass, const ::omero::api::LongList&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getImages(::IceInternal::Incoming&, const ::Ice::Current&);

    ICE_DEPRECATED_API virtual ::omero::api::IObjectList findAllByQuery(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___findAllByQuery(::IceInternal::Incoming&, const ::Ice::Current&);

    ICE_DEPRECATED_API virtual ::omero::model::IObjectPtr findByQuery(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___findByQuery(::IceInternal::Incoming&, const ::Ice::Current&);

    ICE_DEPRECATED_API virtual ::Ice::ByteSeq getPlane(::Ice::Long, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getPlane(::IceInternal::Incoming&, const ::Ice::Current&);

    ICE_DEPRECATED_API virtual ::omero::model::PixelsPtr getPixels(::Ice::Long, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getPixels(::IceInternal::Incoming&, const ::Ice::Current&);

    ICE_DEPRECATED_API virtual ::Ice::Long copyPixelsXYTZ(::Ice::Long, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::omero::api::IntegerList&, const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___copyPixelsXYTZ(::IceInternal::Incoming&, const ::Ice::Current&);

    ICE_DEPRECATED_API virtual ::Ice::Long copyPixels(::Ice::Long, const ::omero::api::IntegerList&, const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___copyPixels(::IceInternal::Incoming&, const ::Ice::Current&);

    ICE_DEPRECATED_API virtual ::Ice::Long copyImage(::Ice::Long, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::omero::api::IntegerList&, const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___copyImage(::IceInternal::Incoming&, const ::Ice::Current&);

    ICE_DEPRECATED_API virtual void uploadPlane(::Ice::Long, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::ByteSeq&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___uploadPlane(::IceInternal::Incoming&, const ::Ice::Current&);

    ICE_DEPRECATED_API virtual ::omero::model::PixelsPtr updatePixels(const ::omero::model::PixelsPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___updatePixels(::IceInternal::Incoming&, const ::Ice::Current&);

    ICE_DEPRECATED_API virtual ::omero::api::PixelsTypeList getPixelTypes(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getPixelTypes(::IceInternal::Incoming&, const ::Ice::Current&);

    ICE_DEPRECATED_API virtual ::omero::model::PixelsTypePtr getPixelType(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getPixelType(::IceInternal::Incoming&, const ::Ice::Current&);

    ICE_DEPRECATED_API virtual ::omero::api::IntegerArray getRenderedImage(::Ice::Long, ::Ice::Int, ::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getRenderedImage(::IceInternal::Incoming&, const ::Ice::Current&);

    ICE_DEPRECATED_API virtual ::omero::api::IntegerArray renderAsPackedIntAsRGBA(::Ice::Long, ::Ice::Int, ::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___renderAsPackedIntAsRGBA(::IceInternal::Incoming&, const ::Ice::Current&);

    ICE_DEPRECATED_API virtual ::omero::api::IntegerArrayArrayArray getRenderedImageMatrix(::Ice::Long, ::Ice::Int, ::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getRenderedImageMatrix(::IceInternal::Incoming&, const ::Ice::Current&);

    ICE_DEPRECATED_API virtual void setActive(::Ice::Long, ::Ice::Int, bool, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setActive(::IceInternal::Incoming&, const ::Ice::Current&);

    ICE_DEPRECATED_API virtual ::omero::api::ByteArray getThumbnail(::Ice::Long, const ::omero::RIntPtr&, const ::omero::RIntPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getThumbnail(::IceInternal::Incoming&, const ::Ice::Current&);

    ICE_DEPRECATED_API virtual ::omero::api::LongByteArrayMap getThumbnailSet(const ::omero::RIntPtr&, const ::omero::RIntPtr&, const ::omero::api::LongList&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getThumbnailSet(::IceInternal::Incoming&, const ::Ice::Current&);

    ICE_DEPRECATED_API virtual void attachImageToDataset(const ::omero::model::DatasetPtr&, const ::omero::model::ImagePtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___attachImageToDataset(::IceInternal::Incoming&, const ::Ice::Current&);

    ICE_DEPRECATED_API virtual ::Ice::Long createImage(::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::omero::api::IntegerList&, const ::omero::model::PixelsTypePtr&, const ::std::string&, const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___createImage(::IceInternal::Incoming&, const ::Ice::Current&);

    ICE_DEPRECATED_API virtual ::omero::api::ImageList getImageFromDatasetByName(::Ice::Long, const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getImageFromDatasetByName(::IceInternal::Incoming&, const ::Ice::Current&);

    ICE_DEPRECATED_API virtual ::omero::api::ImageList getImageByName(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getImageByName(::IceInternal::Incoming&, const ::Ice::Current&);

    ICE_DEPRECATED_API virtual void saveObject(const ::omero::model::IObjectPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___saveObject(::IceInternal::Incoming&, const ::Ice::Current&);

    ICE_DEPRECATED_API virtual ::omero::model::IObjectPtr saveAndReturnObject(const ::omero::model::IObjectPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___saveAndReturnObject(::IceInternal::Incoming&, const ::Ice::Current&);

    ICE_DEPRECATED_API virtual void saveArray(const ::omero::api::IObjectList&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___saveArray(::IceInternal::Incoming&, const ::Ice::Current&);

    ICE_DEPRECATED_API virtual ::omero::api::IObjectList saveAndReturnArray(const ::omero::api::IObjectList&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___saveAndReturnArray(::IceInternal::Incoming&, const ::Ice::Current&);

    ICE_DEPRECATED_API virtual void deleteObject(const ::omero::model::IObjectPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___deleteObject(::IceInternal::Incoming&, const ::Ice::Current&);

    ICE_DEPRECATED_API virtual void keepAlive(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___keepAlive(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif
};

inline bool operator==(const Gateway& l, const Gateway& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const Gateway& l, const Gateway& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

}

}

namespace omero
{

namespace api
{

template<class T>
class CallbackNC_Gateway_getProjects : public Callback_Gateway_getProjects_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::api::ProjectList&);

    CallbackNC_Gateway_getProjects(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::GatewayPrx __proxy = ::omero::api::GatewayPrx::uncheckedCast(__result->getProxy());
        ::omero::api::ProjectList __ret;
        try
        {
            __ret = __proxy->end_getProjects(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_Gateway_getProjectsPtr
newCallback_Gateway_getProjects(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::ProjectList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gateway_getProjects<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Gateway_getProjectsPtr
newCallback_Gateway_getProjects(T* instance, void (T::*cb)(const ::omero::api::ProjectList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gateway_getProjects<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Gateway_getProjects : public Callback_Gateway_getProjects_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::api::ProjectList&, const CT&);

    Callback_Gateway_getProjects(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::GatewayPrx __proxy = ::omero::api::GatewayPrx::uncheckedCast(__result->getProxy());
        ::omero::api::ProjectList __ret;
        try
        {
            __ret = __proxy->end_getProjects(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Gateway_getProjectsPtr
newCallback_Gateway_getProjects(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::ProjectList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gateway_getProjects<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Gateway_getProjectsPtr
newCallback_Gateway_getProjects(T* instance, void (T::*cb)(const ::omero::api::ProjectList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gateway_getProjects<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Gateway_getDatasets : public Callback_Gateway_getDatasets_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::api::DatasetList&);

    CallbackNC_Gateway_getDatasets(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::GatewayPrx __proxy = ::omero::api::GatewayPrx::uncheckedCast(__result->getProxy());
        ::omero::api::DatasetList __ret;
        try
        {
            __ret = __proxy->end_getDatasets(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_Gateway_getDatasetsPtr
newCallback_Gateway_getDatasets(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::DatasetList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gateway_getDatasets<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Gateway_getDatasetsPtr
newCallback_Gateway_getDatasets(T* instance, void (T::*cb)(const ::omero::api::DatasetList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gateway_getDatasets<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Gateway_getDatasets : public Callback_Gateway_getDatasets_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::api::DatasetList&, const CT&);

    Callback_Gateway_getDatasets(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::GatewayPrx __proxy = ::omero::api::GatewayPrx::uncheckedCast(__result->getProxy());
        ::omero::api::DatasetList __ret;
        try
        {
            __ret = __proxy->end_getDatasets(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Gateway_getDatasetsPtr
newCallback_Gateway_getDatasets(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::DatasetList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gateway_getDatasets<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Gateway_getDatasetsPtr
newCallback_Gateway_getDatasets(T* instance, void (T::*cb)(const ::omero::api::DatasetList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gateway_getDatasets<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Gateway_getDataset : public Callback_Gateway_getDataset_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::model::DatasetPtr&);

    CallbackNC_Gateway_getDataset(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::GatewayPrx __proxy = ::omero::api::GatewayPrx::uncheckedCast(__result->getProxy());
        ::omero::model::DatasetPtr __ret;
        try
        {
            __ret = __proxy->end_getDataset(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_Gateway_getDatasetPtr
newCallback_Gateway_getDataset(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::DatasetPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gateway_getDataset<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Gateway_getDatasetPtr
newCallback_Gateway_getDataset(T* instance, void (T::*cb)(const ::omero::model::DatasetPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gateway_getDataset<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Gateway_getDataset : public Callback_Gateway_getDataset_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::model::DatasetPtr&, const CT&);

    Callback_Gateway_getDataset(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::GatewayPrx __proxy = ::omero::api::GatewayPrx::uncheckedCast(__result->getProxy());
        ::omero::model::DatasetPtr __ret;
        try
        {
            __ret = __proxy->end_getDataset(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Gateway_getDatasetPtr
newCallback_Gateway_getDataset(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::DatasetPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gateway_getDataset<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Gateway_getDatasetPtr
newCallback_Gateway_getDataset(T* instance, void (T::*cb)(const ::omero::model::DatasetPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gateway_getDataset<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Gateway_getPixelsFromImage : public Callback_Gateway_getPixelsFromImage_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::api::PixelsList&);

    CallbackNC_Gateway_getPixelsFromImage(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::GatewayPrx __proxy = ::omero::api::GatewayPrx::uncheckedCast(__result->getProxy());
        ::omero::api::PixelsList __ret;
        try
        {
            __ret = __proxy->end_getPixelsFromImage(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_Gateway_getPixelsFromImagePtr
newCallback_Gateway_getPixelsFromImage(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::PixelsList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gateway_getPixelsFromImage<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Gateway_getPixelsFromImagePtr
newCallback_Gateway_getPixelsFromImage(T* instance, void (T::*cb)(const ::omero::api::PixelsList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gateway_getPixelsFromImage<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Gateway_getPixelsFromImage : public Callback_Gateway_getPixelsFromImage_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::api::PixelsList&, const CT&);

    Callback_Gateway_getPixelsFromImage(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::GatewayPrx __proxy = ::omero::api::GatewayPrx::uncheckedCast(__result->getProxy());
        ::omero::api::PixelsList __ret;
        try
        {
            __ret = __proxy->end_getPixelsFromImage(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Gateway_getPixelsFromImagePtr
newCallback_Gateway_getPixelsFromImage(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::PixelsList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gateway_getPixelsFromImage<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Gateway_getPixelsFromImagePtr
newCallback_Gateway_getPixelsFromImage(T* instance, void (T::*cb)(const ::omero::api::PixelsList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gateway_getPixelsFromImage<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Gateway_getImage : public Callback_Gateway_getImage_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::model::ImagePtr&);

    CallbackNC_Gateway_getImage(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::GatewayPrx __proxy = ::omero::api::GatewayPrx::uncheckedCast(__result->getProxy());
        ::omero::model::ImagePtr __ret;
        try
        {
            __ret = __proxy->end_getImage(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_Gateway_getImagePtr
newCallback_Gateway_getImage(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::ImagePtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gateway_getImage<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Gateway_getImagePtr
newCallback_Gateway_getImage(T* instance, void (T::*cb)(const ::omero::model::ImagePtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gateway_getImage<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Gateway_getImage : public Callback_Gateway_getImage_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::model::ImagePtr&, const CT&);

    Callback_Gateway_getImage(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::GatewayPrx __proxy = ::omero::api::GatewayPrx::uncheckedCast(__result->getProxy());
        ::omero::model::ImagePtr __ret;
        try
        {
            __ret = __proxy->end_getImage(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Gateway_getImagePtr
newCallback_Gateway_getImage(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::ImagePtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gateway_getImage<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Gateway_getImagePtr
newCallback_Gateway_getImage(T* instance, void (T::*cb)(const ::omero::model::ImagePtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gateway_getImage<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Gateway_getImages : public Callback_Gateway_getImages_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::api::ImageList&);

    CallbackNC_Gateway_getImages(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::GatewayPrx __proxy = ::omero::api::GatewayPrx::uncheckedCast(__result->getProxy());
        ::omero::api::ImageList __ret;
        try
        {
            __ret = __proxy->end_getImages(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_Gateway_getImagesPtr
newCallback_Gateway_getImages(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::ImageList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gateway_getImages<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Gateway_getImagesPtr
newCallback_Gateway_getImages(T* instance, void (T::*cb)(const ::omero::api::ImageList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gateway_getImages<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Gateway_getImages : public Callback_Gateway_getImages_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::api::ImageList&, const CT&);

    Callback_Gateway_getImages(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::GatewayPrx __proxy = ::omero::api::GatewayPrx::uncheckedCast(__result->getProxy());
        ::omero::api::ImageList __ret;
        try
        {
            __ret = __proxy->end_getImages(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Gateway_getImagesPtr
newCallback_Gateway_getImages(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::ImageList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gateway_getImages<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Gateway_getImagesPtr
newCallback_Gateway_getImages(T* instance, void (T::*cb)(const ::omero::api::ImageList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gateway_getImages<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Gateway_findAllByQuery : public Callback_Gateway_findAllByQuery_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::api::IObjectList&);

    CallbackNC_Gateway_findAllByQuery(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::GatewayPrx __proxy = ::omero::api::GatewayPrx::uncheckedCast(__result->getProxy());
        ::omero::api::IObjectList __ret;
        try
        {
            __ret = __proxy->end_findAllByQuery(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_Gateway_findAllByQueryPtr
newCallback_Gateway_findAllByQuery(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::IObjectList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gateway_findAllByQuery<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Gateway_findAllByQueryPtr
newCallback_Gateway_findAllByQuery(T* instance, void (T::*cb)(const ::omero::api::IObjectList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gateway_findAllByQuery<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Gateway_findAllByQuery : public Callback_Gateway_findAllByQuery_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::api::IObjectList&, const CT&);

    Callback_Gateway_findAllByQuery(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::GatewayPrx __proxy = ::omero::api::GatewayPrx::uncheckedCast(__result->getProxy());
        ::omero::api::IObjectList __ret;
        try
        {
            __ret = __proxy->end_findAllByQuery(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Gateway_findAllByQueryPtr
newCallback_Gateway_findAllByQuery(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::IObjectList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gateway_findAllByQuery<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Gateway_findAllByQueryPtr
newCallback_Gateway_findAllByQuery(T* instance, void (T::*cb)(const ::omero::api::IObjectList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gateway_findAllByQuery<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Gateway_findByQuery : public Callback_Gateway_findByQuery_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::model::IObjectPtr&);

    CallbackNC_Gateway_findByQuery(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::GatewayPrx __proxy = ::omero::api::GatewayPrx::uncheckedCast(__result->getProxy());
        ::omero::model::IObjectPtr __ret;
        try
        {
            __ret = __proxy->end_findByQuery(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_Gateway_findByQueryPtr
newCallback_Gateway_findByQuery(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::IObjectPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gateway_findByQuery<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Gateway_findByQueryPtr
newCallback_Gateway_findByQuery(T* instance, void (T::*cb)(const ::omero::model::IObjectPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gateway_findByQuery<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Gateway_findByQuery : public Callback_Gateway_findByQuery_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::model::IObjectPtr&, const CT&);

    Callback_Gateway_findByQuery(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::GatewayPrx __proxy = ::omero::api::GatewayPrx::uncheckedCast(__result->getProxy());
        ::omero::model::IObjectPtr __ret;
        try
        {
            __ret = __proxy->end_findByQuery(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Gateway_findByQueryPtr
newCallback_Gateway_findByQuery(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::IObjectPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gateway_findByQuery<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Gateway_findByQueryPtr
newCallback_Gateway_findByQuery(T* instance, void (T::*cb)(const ::omero::model::IObjectPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gateway_findByQuery<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Gateway_getPlane : public Callback_Gateway_getPlane_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Ice::ByteSeq&);

    CallbackNC_Gateway_getPlane(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::GatewayPrx __proxy = ::omero::api::GatewayPrx::uncheckedCast(__result->getProxy());
        ::Ice::ByteSeq __ret;
        try
        {
            __ret = __proxy->end_getPlane(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_Gateway_getPlanePtr
newCallback_Gateway_getPlane(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Ice::ByteSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gateway_getPlane<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Gateway_getPlanePtr
newCallback_Gateway_getPlane(T* instance, void (T::*cb)(const ::Ice::ByteSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gateway_getPlane<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Gateway_getPlane : public Callback_Gateway_getPlane_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Ice::ByteSeq&, const CT&);

    Callback_Gateway_getPlane(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::GatewayPrx __proxy = ::omero::api::GatewayPrx::uncheckedCast(__result->getProxy());
        ::Ice::ByteSeq __ret;
        try
        {
            __ret = __proxy->end_getPlane(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Gateway_getPlanePtr
newCallback_Gateway_getPlane(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Ice::ByteSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gateway_getPlane<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Gateway_getPlanePtr
newCallback_Gateway_getPlane(T* instance, void (T::*cb)(const ::Ice::ByteSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gateway_getPlane<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Gateway_getPixels : public Callback_Gateway_getPixels_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::model::PixelsPtr&);

    CallbackNC_Gateway_getPixels(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::GatewayPrx __proxy = ::omero::api::GatewayPrx::uncheckedCast(__result->getProxy());
        ::omero::model::PixelsPtr __ret;
        try
        {
            __ret = __proxy->end_getPixels(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_Gateway_getPixelsPtr
newCallback_Gateway_getPixels(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::PixelsPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gateway_getPixels<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Gateway_getPixelsPtr
newCallback_Gateway_getPixels(T* instance, void (T::*cb)(const ::omero::model::PixelsPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gateway_getPixels<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Gateway_getPixels : public Callback_Gateway_getPixels_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::model::PixelsPtr&, const CT&);

    Callback_Gateway_getPixels(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::GatewayPrx __proxy = ::omero::api::GatewayPrx::uncheckedCast(__result->getProxy());
        ::omero::model::PixelsPtr __ret;
        try
        {
            __ret = __proxy->end_getPixels(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Gateway_getPixelsPtr
newCallback_Gateway_getPixels(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::PixelsPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gateway_getPixels<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Gateway_getPixelsPtr
newCallback_Gateway_getPixels(T* instance, void (T::*cb)(const ::omero::model::PixelsPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gateway_getPixels<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Gateway_copyPixelsXYTZ : public Callback_Gateway_copyPixelsXYTZ_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Long);

    CallbackNC_Gateway_copyPixelsXYTZ(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::GatewayPrx __proxy = ::omero::api::GatewayPrx::uncheckedCast(__result->getProxy());
        ::Ice::Long __ret;
        try
        {
            __ret = __proxy->end_copyPixelsXYTZ(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_Gateway_copyPixelsXYTZPtr
newCallback_Gateway_copyPixelsXYTZ(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Long), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gateway_copyPixelsXYTZ<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Gateway_copyPixelsXYTZPtr
newCallback_Gateway_copyPixelsXYTZ(T* instance, void (T::*cb)(::Ice::Long), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gateway_copyPixelsXYTZ<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Gateway_copyPixelsXYTZ : public Callback_Gateway_copyPixelsXYTZ_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Long, const CT&);

    Callback_Gateway_copyPixelsXYTZ(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::GatewayPrx __proxy = ::omero::api::GatewayPrx::uncheckedCast(__result->getProxy());
        ::Ice::Long __ret;
        try
        {
            __ret = __proxy->end_copyPixelsXYTZ(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Gateway_copyPixelsXYTZPtr
newCallback_Gateway_copyPixelsXYTZ(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Long, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gateway_copyPixelsXYTZ<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Gateway_copyPixelsXYTZPtr
newCallback_Gateway_copyPixelsXYTZ(T* instance, void (T::*cb)(::Ice::Long, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gateway_copyPixelsXYTZ<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Gateway_copyPixels : public Callback_Gateway_copyPixels_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Long);

    CallbackNC_Gateway_copyPixels(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::GatewayPrx __proxy = ::omero::api::GatewayPrx::uncheckedCast(__result->getProxy());
        ::Ice::Long __ret;
        try
        {
            __ret = __proxy->end_copyPixels(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_Gateway_copyPixelsPtr
newCallback_Gateway_copyPixels(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Long), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gateway_copyPixels<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Gateway_copyPixelsPtr
newCallback_Gateway_copyPixels(T* instance, void (T::*cb)(::Ice::Long), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gateway_copyPixels<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Gateway_copyPixels : public Callback_Gateway_copyPixels_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Long, const CT&);

    Callback_Gateway_copyPixels(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::GatewayPrx __proxy = ::omero::api::GatewayPrx::uncheckedCast(__result->getProxy());
        ::Ice::Long __ret;
        try
        {
            __ret = __proxy->end_copyPixels(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Gateway_copyPixelsPtr
newCallback_Gateway_copyPixels(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Long, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gateway_copyPixels<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Gateway_copyPixelsPtr
newCallback_Gateway_copyPixels(T* instance, void (T::*cb)(::Ice::Long, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gateway_copyPixels<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Gateway_copyImage : public Callback_Gateway_copyImage_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Long);

    CallbackNC_Gateway_copyImage(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::GatewayPrx __proxy = ::omero::api::GatewayPrx::uncheckedCast(__result->getProxy());
        ::Ice::Long __ret;
        try
        {
            __ret = __proxy->end_copyImage(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_Gateway_copyImagePtr
newCallback_Gateway_copyImage(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Long), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gateway_copyImage<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Gateway_copyImagePtr
newCallback_Gateway_copyImage(T* instance, void (T::*cb)(::Ice::Long), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gateway_copyImage<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Gateway_copyImage : public Callback_Gateway_copyImage_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Long, const CT&);

    Callback_Gateway_copyImage(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::GatewayPrx __proxy = ::omero::api::GatewayPrx::uncheckedCast(__result->getProxy());
        ::Ice::Long __ret;
        try
        {
            __ret = __proxy->end_copyImage(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Gateway_copyImagePtr
newCallback_Gateway_copyImage(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Long, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gateway_copyImage<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Gateway_copyImagePtr
newCallback_Gateway_copyImage(T* instance, void (T::*cb)(::Ice::Long, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gateway_copyImage<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Gateway_uploadPlane : public Callback_Gateway_uploadPlane_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Gateway_uploadPlane(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::GatewayPrx __proxy = ::omero::api::GatewayPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_uploadPlane(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
        }
    }

    Response response;
};

template<class T> Callback_Gateway_uploadPlanePtr
newCallback_Gateway_uploadPlane(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gateway_uploadPlane<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Gateway_uploadPlanePtr
newCallback_Gateway_uploadPlane(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gateway_uploadPlane<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Gateway_uploadPlanePtr
newCallback_Gateway_uploadPlane(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gateway_uploadPlane<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Gateway_uploadPlanePtr
newCallback_Gateway_uploadPlane(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gateway_uploadPlane<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Gateway_uploadPlane : public Callback_Gateway_uploadPlane_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Gateway_uploadPlane(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::GatewayPrx __proxy = ::omero::api::GatewayPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_uploadPlane(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Gateway_uploadPlanePtr
newCallback_Gateway_uploadPlane(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gateway_uploadPlane<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Gateway_uploadPlanePtr
newCallback_Gateway_uploadPlane(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gateway_uploadPlane<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Gateway_uploadPlanePtr
newCallback_Gateway_uploadPlane(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gateway_uploadPlane<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Gateway_uploadPlanePtr
newCallback_Gateway_uploadPlane(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gateway_uploadPlane<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Gateway_updatePixels : public Callback_Gateway_updatePixels_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::model::PixelsPtr&);

    CallbackNC_Gateway_updatePixels(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::GatewayPrx __proxy = ::omero::api::GatewayPrx::uncheckedCast(__result->getProxy());
        ::omero::model::PixelsPtr __ret;
        try
        {
            __ret = __proxy->end_updatePixels(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_Gateway_updatePixelsPtr
newCallback_Gateway_updatePixels(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::PixelsPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gateway_updatePixels<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Gateway_updatePixelsPtr
newCallback_Gateway_updatePixels(T* instance, void (T::*cb)(const ::omero::model::PixelsPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gateway_updatePixels<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Gateway_updatePixels : public Callback_Gateway_updatePixels_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::model::PixelsPtr&, const CT&);

    Callback_Gateway_updatePixels(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::GatewayPrx __proxy = ::omero::api::GatewayPrx::uncheckedCast(__result->getProxy());
        ::omero::model::PixelsPtr __ret;
        try
        {
            __ret = __proxy->end_updatePixels(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Gateway_updatePixelsPtr
newCallback_Gateway_updatePixels(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::PixelsPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gateway_updatePixels<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Gateway_updatePixelsPtr
newCallback_Gateway_updatePixels(T* instance, void (T::*cb)(const ::omero::model::PixelsPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gateway_updatePixels<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Gateway_getPixelTypes : public Callback_Gateway_getPixelTypes_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::api::PixelsTypeList&);

    CallbackNC_Gateway_getPixelTypes(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::GatewayPrx __proxy = ::omero::api::GatewayPrx::uncheckedCast(__result->getProxy());
        ::omero::api::PixelsTypeList __ret;
        try
        {
            __ret = __proxy->end_getPixelTypes(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_Gateway_getPixelTypesPtr
newCallback_Gateway_getPixelTypes(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::PixelsTypeList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gateway_getPixelTypes<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Gateway_getPixelTypesPtr
newCallback_Gateway_getPixelTypes(T* instance, void (T::*cb)(const ::omero::api::PixelsTypeList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gateway_getPixelTypes<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Gateway_getPixelTypes : public Callback_Gateway_getPixelTypes_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::api::PixelsTypeList&, const CT&);

    Callback_Gateway_getPixelTypes(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::GatewayPrx __proxy = ::omero::api::GatewayPrx::uncheckedCast(__result->getProxy());
        ::omero::api::PixelsTypeList __ret;
        try
        {
            __ret = __proxy->end_getPixelTypes(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Gateway_getPixelTypesPtr
newCallback_Gateway_getPixelTypes(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::PixelsTypeList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gateway_getPixelTypes<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Gateway_getPixelTypesPtr
newCallback_Gateway_getPixelTypes(T* instance, void (T::*cb)(const ::omero::api::PixelsTypeList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gateway_getPixelTypes<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Gateway_getPixelType : public Callback_Gateway_getPixelType_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::model::PixelsTypePtr&);

    CallbackNC_Gateway_getPixelType(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::GatewayPrx __proxy = ::omero::api::GatewayPrx::uncheckedCast(__result->getProxy());
        ::omero::model::PixelsTypePtr __ret;
        try
        {
            __ret = __proxy->end_getPixelType(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_Gateway_getPixelTypePtr
newCallback_Gateway_getPixelType(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::PixelsTypePtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gateway_getPixelType<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Gateway_getPixelTypePtr
newCallback_Gateway_getPixelType(T* instance, void (T::*cb)(const ::omero::model::PixelsTypePtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gateway_getPixelType<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Gateway_getPixelType : public Callback_Gateway_getPixelType_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::model::PixelsTypePtr&, const CT&);

    Callback_Gateway_getPixelType(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::GatewayPrx __proxy = ::omero::api::GatewayPrx::uncheckedCast(__result->getProxy());
        ::omero::model::PixelsTypePtr __ret;
        try
        {
            __ret = __proxy->end_getPixelType(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Gateway_getPixelTypePtr
newCallback_Gateway_getPixelType(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::PixelsTypePtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gateway_getPixelType<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Gateway_getPixelTypePtr
newCallback_Gateway_getPixelType(T* instance, void (T::*cb)(const ::omero::model::PixelsTypePtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gateway_getPixelType<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Gateway_getRenderedImage : public Callback_Gateway_getRenderedImage_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::api::IntegerArray&);

    CallbackNC_Gateway_getRenderedImage(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::GatewayPrx __proxy = ::omero::api::GatewayPrx::uncheckedCast(__result->getProxy());
        ::omero::api::IntegerArray __ret;
        try
        {
            __ret = __proxy->end_getRenderedImage(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_Gateway_getRenderedImagePtr
newCallback_Gateway_getRenderedImage(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::IntegerArray&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gateway_getRenderedImage<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Gateway_getRenderedImagePtr
newCallback_Gateway_getRenderedImage(T* instance, void (T::*cb)(const ::omero::api::IntegerArray&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gateway_getRenderedImage<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Gateway_getRenderedImage : public Callback_Gateway_getRenderedImage_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::api::IntegerArray&, const CT&);

    Callback_Gateway_getRenderedImage(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::GatewayPrx __proxy = ::omero::api::GatewayPrx::uncheckedCast(__result->getProxy());
        ::omero::api::IntegerArray __ret;
        try
        {
            __ret = __proxy->end_getRenderedImage(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Gateway_getRenderedImagePtr
newCallback_Gateway_getRenderedImage(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::IntegerArray&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gateway_getRenderedImage<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Gateway_getRenderedImagePtr
newCallback_Gateway_getRenderedImage(T* instance, void (T::*cb)(const ::omero::api::IntegerArray&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gateway_getRenderedImage<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Gateway_renderAsPackedIntAsRGBA : public Callback_Gateway_renderAsPackedIntAsRGBA_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::api::IntegerArray&);

    CallbackNC_Gateway_renderAsPackedIntAsRGBA(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::GatewayPrx __proxy = ::omero::api::GatewayPrx::uncheckedCast(__result->getProxy());
        ::omero::api::IntegerArray __ret;
        try
        {
            __ret = __proxy->end_renderAsPackedIntAsRGBA(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_Gateway_renderAsPackedIntAsRGBAPtr
newCallback_Gateway_renderAsPackedIntAsRGBA(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::IntegerArray&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gateway_renderAsPackedIntAsRGBA<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Gateway_renderAsPackedIntAsRGBAPtr
newCallback_Gateway_renderAsPackedIntAsRGBA(T* instance, void (T::*cb)(const ::omero::api::IntegerArray&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gateway_renderAsPackedIntAsRGBA<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Gateway_renderAsPackedIntAsRGBA : public Callback_Gateway_renderAsPackedIntAsRGBA_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::api::IntegerArray&, const CT&);

    Callback_Gateway_renderAsPackedIntAsRGBA(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::GatewayPrx __proxy = ::omero::api::GatewayPrx::uncheckedCast(__result->getProxy());
        ::omero::api::IntegerArray __ret;
        try
        {
            __ret = __proxy->end_renderAsPackedIntAsRGBA(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Gateway_renderAsPackedIntAsRGBAPtr
newCallback_Gateway_renderAsPackedIntAsRGBA(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::IntegerArray&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gateway_renderAsPackedIntAsRGBA<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Gateway_renderAsPackedIntAsRGBAPtr
newCallback_Gateway_renderAsPackedIntAsRGBA(T* instance, void (T::*cb)(const ::omero::api::IntegerArray&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gateway_renderAsPackedIntAsRGBA<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Gateway_getRenderedImageMatrix : public Callback_Gateway_getRenderedImageMatrix_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::api::IntegerArrayArrayArray&);

    CallbackNC_Gateway_getRenderedImageMatrix(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::GatewayPrx __proxy = ::omero::api::GatewayPrx::uncheckedCast(__result->getProxy());
        ::omero::api::IntegerArrayArrayArray __ret;
        try
        {
            __ret = __proxy->end_getRenderedImageMatrix(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_Gateway_getRenderedImageMatrixPtr
newCallback_Gateway_getRenderedImageMatrix(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::IntegerArrayArrayArray&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gateway_getRenderedImageMatrix<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Gateway_getRenderedImageMatrixPtr
newCallback_Gateway_getRenderedImageMatrix(T* instance, void (T::*cb)(const ::omero::api::IntegerArrayArrayArray&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gateway_getRenderedImageMatrix<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Gateway_getRenderedImageMatrix : public Callback_Gateway_getRenderedImageMatrix_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::api::IntegerArrayArrayArray&, const CT&);

    Callback_Gateway_getRenderedImageMatrix(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::GatewayPrx __proxy = ::omero::api::GatewayPrx::uncheckedCast(__result->getProxy());
        ::omero::api::IntegerArrayArrayArray __ret;
        try
        {
            __ret = __proxy->end_getRenderedImageMatrix(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Gateway_getRenderedImageMatrixPtr
newCallback_Gateway_getRenderedImageMatrix(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::IntegerArrayArrayArray&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gateway_getRenderedImageMatrix<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Gateway_getRenderedImageMatrixPtr
newCallback_Gateway_getRenderedImageMatrix(T* instance, void (T::*cb)(const ::omero::api::IntegerArrayArrayArray&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gateway_getRenderedImageMatrix<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Gateway_setActive : public Callback_Gateway_setActive_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Gateway_setActive(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::GatewayPrx __proxy = ::omero::api::GatewayPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_setActive(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
        }
    }

    Response response;
};

template<class T> Callback_Gateway_setActivePtr
newCallback_Gateway_setActive(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gateway_setActive<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Gateway_setActivePtr
newCallback_Gateway_setActive(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gateway_setActive<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Gateway_setActivePtr
newCallback_Gateway_setActive(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gateway_setActive<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Gateway_setActivePtr
newCallback_Gateway_setActive(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gateway_setActive<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Gateway_setActive : public Callback_Gateway_setActive_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Gateway_setActive(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::GatewayPrx __proxy = ::omero::api::GatewayPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_setActive(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Gateway_setActivePtr
newCallback_Gateway_setActive(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gateway_setActive<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Gateway_setActivePtr
newCallback_Gateway_setActive(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gateway_setActive<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Gateway_setActivePtr
newCallback_Gateway_setActive(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gateway_setActive<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Gateway_setActivePtr
newCallback_Gateway_setActive(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gateway_setActive<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Gateway_getThumbnail : public Callback_Gateway_getThumbnail_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::api::ByteArray&);

    CallbackNC_Gateway_getThumbnail(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::GatewayPrx __proxy = ::omero::api::GatewayPrx::uncheckedCast(__result->getProxy());
        ::omero::api::ByteArray __ret;
        try
        {
            __ret = __proxy->end_getThumbnail(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_Gateway_getThumbnailPtr
newCallback_Gateway_getThumbnail(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::ByteArray&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gateway_getThumbnail<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Gateway_getThumbnailPtr
newCallback_Gateway_getThumbnail(T* instance, void (T::*cb)(const ::omero::api::ByteArray&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gateway_getThumbnail<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Gateway_getThumbnail : public Callback_Gateway_getThumbnail_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::api::ByteArray&, const CT&);

    Callback_Gateway_getThumbnail(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::GatewayPrx __proxy = ::omero::api::GatewayPrx::uncheckedCast(__result->getProxy());
        ::omero::api::ByteArray __ret;
        try
        {
            __ret = __proxy->end_getThumbnail(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Gateway_getThumbnailPtr
newCallback_Gateway_getThumbnail(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::ByteArray&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gateway_getThumbnail<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Gateway_getThumbnailPtr
newCallback_Gateway_getThumbnail(T* instance, void (T::*cb)(const ::omero::api::ByteArray&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gateway_getThumbnail<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Gateway_getThumbnailSet : public Callback_Gateway_getThumbnailSet_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::api::LongByteArrayMap&);

    CallbackNC_Gateway_getThumbnailSet(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::GatewayPrx __proxy = ::omero::api::GatewayPrx::uncheckedCast(__result->getProxy());
        ::omero::api::LongByteArrayMap __ret;
        try
        {
            __ret = __proxy->end_getThumbnailSet(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_Gateway_getThumbnailSetPtr
newCallback_Gateway_getThumbnailSet(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::LongByteArrayMap&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gateway_getThumbnailSet<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Gateway_getThumbnailSetPtr
newCallback_Gateway_getThumbnailSet(T* instance, void (T::*cb)(const ::omero::api::LongByteArrayMap&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gateway_getThumbnailSet<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Gateway_getThumbnailSet : public Callback_Gateway_getThumbnailSet_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::api::LongByteArrayMap&, const CT&);

    Callback_Gateway_getThumbnailSet(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::GatewayPrx __proxy = ::omero::api::GatewayPrx::uncheckedCast(__result->getProxy());
        ::omero::api::LongByteArrayMap __ret;
        try
        {
            __ret = __proxy->end_getThumbnailSet(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Gateway_getThumbnailSetPtr
newCallback_Gateway_getThumbnailSet(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::LongByteArrayMap&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gateway_getThumbnailSet<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Gateway_getThumbnailSetPtr
newCallback_Gateway_getThumbnailSet(T* instance, void (T::*cb)(const ::omero::api::LongByteArrayMap&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gateway_getThumbnailSet<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Gateway_attachImageToDataset : public Callback_Gateway_attachImageToDataset_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Gateway_attachImageToDataset(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::GatewayPrx __proxy = ::omero::api::GatewayPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_attachImageToDataset(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
        }
    }

    Response response;
};

template<class T> Callback_Gateway_attachImageToDatasetPtr
newCallback_Gateway_attachImageToDataset(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gateway_attachImageToDataset<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Gateway_attachImageToDatasetPtr
newCallback_Gateway_attachImageToDataset(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gateway_attachImageToDataset<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Gateway_attachImageToDatasetPtr
newCallback_Gateway_attachImageToDataset(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gateway_attachImageToDataset<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Gateway_attachImageToDatasetPtr
newCallback_Gateway_attachImageToDataset(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gateway_attachImageToDataset<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Gateway_attachImageToDataset : public Callback_Gateway_attachImageToDataset_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Gateway_attachImageToDataset(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::GatewayPrx __proxy = ::omero::api::GatewayPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_attachImageToDataset(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Gateway_attachImageToDatasetPtr
newCallback_Gateway_attachImageToDataset(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gateway_attachImageToDataset<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Gateway_attachImageToDatasetPtr
newCallback_Gateway_attachImageToDataset(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gateway_attachImageToDataset<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Gateway_attachImageToDatasetPtr
newCallback_Gateway_attachImageToDataset(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gateway_attachImageToDataset<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Gateway_attachImageToDatasetPtr
newCallback_Gateway_attachImageToDataset(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gateway_attachImageToDataset<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Gateway_createImage : public Callback_Gateway_createImage_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Long);

    CallbackNC_Gateway_createImage(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::GatewayPrx __proxy = ::omero::api::GatewayPrx::uncheckedCast(__result->getProxy());
        ::Ice::Long __ret;
        try
        {
            __ret = __proxy->end_createImage(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_Gateway_createImagePtr
newCallback_Gateway_createImage(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Long), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gateway_createImage<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Gateway_createImagePtr
newCallback_Gateway_createImage(T* instance, void (T::*cb)(::Ice::Long), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gateway_createImage<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Gateway_createImage : public Callback_Gateway_createImage_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Long, const CT&);

    Callback_Gateway_createImage(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::GatewayPrx __proxy = ::omero::api::GatewayPrx::uncheckedCast(__result->getProxy());
        ::Ice::Long __ret;
        try
        {
            __ret = __proxy->end_createImage(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Gateway_createImagePtr
newCallback_Gateway_createImage(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Long, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gateway_createImage<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Gateway_createImagePtr
newCallback_Gateway_createImage(T* instance, void (T::*cb)(::Ice::Long, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gateway_createImage<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Gateway_getImageFromDatasetByName : public Callback_Gateway_getImageFromDatasetByName_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::api::ImageList&);

    CallbackNC_Gateway_getImageFromDatasetByName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::GatewayPrx __proxy = ::omero::api::GatewayPrx::uncheckedCast(__result->getProxy());
        ::omero::api::ImageList __ret;
        try
        {
            __ret = __proxy->end_getImageFromDatasetByName(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_Gateway_getImageFromDatasetByNamePtr
newCallback_Gateway_getImageFromDatasetByName(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::ImageList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gateway_getImageFromDatasetByName<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Gateway_getImageFromDatasetByNamePtr
newCallback_Gateway_getImageFromDatasetByName(T* instance, void (T::*cb)(const ::omero::api::ImageList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gateway_getImageFromDatasetByName<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Gateway_getImageFromDatasetByName : public Callback_Gateway_getImageFromDatasetByName_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::api::ImageList&, const CT&);

    Callback_Gateway_getImageFromDatasetByName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::GatewayPrx __proxy = ::omero::api::GatewayPrx::uncheckedCast(__result->getProxy());
        ::omero::api::ImageList __ret;
        try
        {
            __ret = __proxy->end_getImageFromDatasetByName(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Gateway_getImageFromDatasetByNamePtr
newCallback_Gateway_getImageFromDatasetByName(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::ImageList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gateway_getImageFromDatasetByName<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Gateway_getImageFromDatasetByNamePtr
newCallback_Gateway_getImageFromDatasetByName(T* instance, void (T::*cb)(const ::omero::api::ImageList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gateway_getImageFromDatasetByName<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Gateway_getImageByName : public Callback_Gateway_getImageByName_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::api::ImageList&);

    CallbackNC_Gateway_getImageByName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::GatewayPrx __proxy = ::omero::api::GatewayPrx::uncheckedCast(__result->getProxy());
        ::omero::api::ImageList __ret;
        try
        {
            __ret = __proxy->end_getImageByName(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_Gateway_getImageByNamePtr
newCallback_Gateway_getImageByName(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::ImageList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gateway_getImageByName<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Gateway_getImageByNamePtr
newCallback_Gateway_getImageByName(T* instance, void (T::*cb)(const ::omero::api::ImageList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gateway_getImageByName<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Gateway_getImageByName : public Callback_Gateway_getImageByName_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::api::ImageList&, const CT&);

    Callback_Gateway_getImageByName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::GatewayPrx __proxy = ::omero::api::GatewayPrx::uncheckedCast(__result->getProxy());
        ::omero::api::ImageList __ret;
        try
        {
            __ret = __proxy->end_getImageByName(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Gateway_getImageByNamePtr
newCallback_Gateway_getImageByName(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::ImageList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gateway_getImageByName<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Gateway_getImageByNamePtr
newCallback_Gateway_getImageByName(T* instance, void (T::*cb)(const ::omero::api::ImageList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gateway_getImageByName<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Gateway_saveObject : public Callback_Gateway_saveObject_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Gateway_saveObject(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::GatewayPrx __proxy = ::omero::api::GatewayPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_saveObject(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
        }
    }

    Response response;
};

template<class T> Callback_Gateway_saveObjectPtr
newCallback_Gateway_saveObject(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gateway_saveObject<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Gateway_saveObjectPtr
newCallback_Gateway_saveObject(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gateway_saveObject<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Gateway_saveObjectPtr
newCallback_Gateway_saveObject(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gateway_saveObject<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Gateway_saveObjectPtr
newCallback_Gateway_saveObject(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gateway_saveObject<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Gateway_saveObject : public Callback_Gateway_saveObject_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Gateway_saveObject(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::GatewayPrx __proxy = ::omero::api::GatewayPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_saveObject(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Gateway_saveObjectPtr
newCallback_Gateway_saveObject(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gateway_saveObject<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Gateway_saveObjectPtr
newCallback_Gateway_saveObject(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gateway_saveObject<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Gateway_saveObjectPtr
newCallback_Gateway_saveObject(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gateway_saveObject<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Gateway_saveObjectPtr
newCallback_Gateway_saveObject(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gateway_saveObject<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Gateway_saveAndReturnObject : public Callback_Gateway_saveAndReturnObject_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::model::IObjectPtr&);

    CallbackNC_Gateway_saveAndReturnObject(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::GatewayPrx __proxy = ::omero::api::GatewayPrx::uncheckedCast(__result->getProxy());
        ::omero::model::IObjectPtr __ret;
        try
        {
            __ret = __proxy->end_saveAndReturnObject(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_Gateway_saveAndReturnObjectPtr
newCallback_Gateway_saveAndReturnObject(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::IObjectPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gateway_saveAndReturnObject<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Gateway_saveAndReturnObjectPtr
newCallback_Gateway_saveAndReturnObject(T* instance, void (T::*cb)(const ::omero::model::IObjectPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gateway_saveAndReturnObject<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Gateway_saveAndReturnObject : public Callback_Gateway_saveAndReturnObject_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::model::IObjectPtr&, const CT&);

    Callback_Gateway_saveAndReturnObject(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::GatewayPrx __proxy = ::omero::api::GatewayPrx::uncheckedCast(__result->getProxy());
        ::omero::model::IObjectPtr __ret;
        try
        {
            __ret = __proxy->end_saveAndReturnObject(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Gateway_saveAndReturnObjectPtr
newCallback_Gateway_saveAndReturnObject(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::IObjectPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gateway_saveAndReturnObject<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Gateway_saveAndReturnObjectPtr
newCallback_Gateway_saveAndReturnObject(T* instance, void (T::*cb)(const ::omero::model::IObjectPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gateway_saveAndReturnObject<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Gateway_saveArray : public Callback_Gateway_saveArray_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Gateway_saveArray(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::GatewayPrx __proxy = ::omero::api::GatewayPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_saveArray(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
        }
    }

    Response response;
};

template<class T> Callback_Gateway_saveArrayPtr
newCallback_Gateway_saveArray(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gateway_saveArray<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Gateway_saveArrayPtr
newCallback_Gateway_saveArray(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gateway_saveArray<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Gateway_saveArrayPtr
newCallback_Gateway_saveArray(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gateway_saveArray<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Gateway_saveArrayPtr
newCallback_Gateway_saveArray(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gateway_saveArray<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Gateway_saveArray : public Callback_Gateway_saveArray_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Gateway_saveArray(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::GatewayPrx __proxy = ::omero::api::GatewayPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_saveArray(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Gateway_saveArrayPtr
newCallback_Gateway_saveArray(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gateway_saveArray<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Gateway_saveArrayPtr
newCallback_Gateway_saveArray(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gateway_saveArray<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Gateway_saveArrayPtr
newCallback_Gateway_saveArray(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gateway_saveArray<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Gateway_saveArrayPtr
newCallback_Gateway_saveArray(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gateway_saveArray<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Gateway_saveAndReturnArray : public Callback_Gateway_saveAndReturnArray_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::api::IObjectList&);

    CallbackNC_Gateway_saveAndReturnArray(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::GatewayPrx __proxy = ::omero::api::GatewayPrx::uncheckedCast(__result->getProxy());
        ::omero::api::IObjectList __ret;
        try
        {
            __ret = __proxy->end_saveAndReturnArray(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_Gateway_saveAndReturnArrayPtr
newCallback_Gateway_saveAndReturnArray(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::IObjectList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gateway_saveAndReturnArray<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Gateway_saveAndReturnArrayPtr
newCallback_Gateway_saveAndReturnArray(T* instance, void (T::*cb)(const ::omero::api::IObjectList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gateway_saveAndReturnArray<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Gateway_saveAndReturnArray : public Callback_Gateway_saveAndReturnArray_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::api::IObjectList&, const CT&);

    Callback_Gateway_saveAndReturnArray(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::GatewayPrx __proxy = ::omero::api::GatewayPrx::uncheckedCast(__result->getProxy());
        ::omero::api::IObjectList __ret;
        try
        {
            __ret = __proxy->end_saveAndReturnArray(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Gateway_saveAndReturnArrayPtr
newCallback_Gateway_saveAndReturnArray(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::IObjectList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gateway_saveAndReturnArray<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Gateway_saveAndReturnArrayPtr
newCallback_Gateway_saveAndReturnArray(T* instance, void (T::*cb)(const ::omero::api::IObjectList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gateway_saveAndReturnArray<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Gateway_deleteObject : public Callback_Gateway_deleteObject_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Gateway_deleteObject(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::GatewayPrx __proxy = ::omero::api::GatewayPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_deleteObject(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
        }
    }

    Response response;
};

template<class T> Callback_Gateway_deleteObjectPtr
newCallback_Gateway_deleteObject(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gateway_deleteObject<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Gateway_deleteObjectPtr
newCallback_Gateway_deleteObject(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gateway_deleteObject<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Gateway_deleteObjectPtr
newCallback_Gateway_deleteObject(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gateway_deleteObject<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Gateway_deleteObjectPtr
newCallback_Gateway_deleteObject(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gateway_deleteObject<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Gateway_deleteObject : public Callback_Gateway_deleteObject_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Gateway_deleteObject(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::GatewayPrx __proxy = ::omero::api::GatewayPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_deleteObject(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Gateway_deleteObjectPtr
newCallback_Gateway_deleteObject(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gateway_deleteObject<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Gateway_deleteObjectPtr
newCallback_Gateway_deleteObject(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gateway_deleteObject<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Gateway_deleteObjectPtr
newCallback_Gateway_deleteObject(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gateway_deleteObject<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Gateway_deleteObjectPtr
newCallback_Gateway_deleteObject(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gateway_deleteObject<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Gateway_keepAlive : public Callback_Gateway_keepAlive_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Gateway_keepAlive(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::GatewayPrx __proxy = ::omero::api::GatewayPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_keepAlive(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
        }
    }

    Response response;
};

template<class T> Callback_Gateway_keepAlivePtr
newCallback_Gateway_keepAlive(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gateway_keepAlive<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Gateway_keepAlivePtr
newCallback_Gateway_keepAlive(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gateway_keepAlive<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Gateway_keepAlivePtr
newCallback_Gateway_keepAlive(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gateway_keepAlive<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Gateway_keepAlivePtr
newCallback_Gateway_keepAlive(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gateway_keepAlive<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Gateway_keepAlive : public Callback_Gateway_keepAlive_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Gateway_keepAlive(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::GatewayPrx __proxy = ::omero::api::GatewayPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_keepAlive(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Gateway_keepAlivePtr
newCallback_Gateway_keepAlive(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gateway_keepAlive<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Gateway_keepAlivePtr
newCallback_Gateway_keepAlive(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gateway_keepAlive<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Gateway_keepAlivePtr
newCallback_Gateway_keepAlive(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gateway_keepAlive<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Gateway_keepAlivePtr
newCallback_Gateway_keepAlive(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gateway_keepAlive<T, CT>(instance, 0, excb, sentcb);
}

}

}

#endif
