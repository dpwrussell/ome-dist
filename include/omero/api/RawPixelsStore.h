// **********************************************************************
//
// Copyright (c) 2003-2013 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.5.1
//
// <auto-generated>
//
// Generated from file `RawPixelsStore.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __omero_api__opt_hudson_workspace_OMERO_5_0_release_src_components_blitz_generated_omero_api_RawPixelsStore_h__
#define __omero_api__opt_hudson_workspace_OMERO_5_0_release_src_components_blitz_generated_omero_api_RawPixelsStore_h__

#include <Ice/ProxyF.h>
#include <Ice/ObjectF.h>
#include <Ice/Exception.h>
#include <Ice/LocalObject.h>
#include <Ice/StreamHelpers.h>
#include <Ice/Proxy.h>
#include <Ice/Object.h>
#include <Ice/Outgoing.h>
#include <Ice/OutgoingAsync.h>
#include <Ice/Incoming.h>
#include <Ice/IncomingAsync.h>
#include <Ice/Direct.h>
#include <Ice/FactoryTableInit.h>
#include <IceUtil/ScopedArray.h>
#include <IceUtil/Optional.h>
#include <Ice/StreamF.h>
#include <Ice/SlicedDataF.h>
#include <omero/ModelF.h>
#include <omero/Collections.h>
#include <omero/api/PyramidService.h>
#include <Ice/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 305
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 > 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 1
#       error Ice patch level mismatch!
#   endif
#endif

namespace IceProxy
{

namespace omero
{

namespace api
{

class RawPixelsStore;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::omero::api::RawPixelsStore>&);
::IceProxy::Ice::Object* upCast(::IceProxy::omero::api::RawPixelsStore*);

}

}

}

namespace omero
{

namespace api
{

class RawPixelsStore;
bool operator==(const RawPixelsStore&, const RawPixelsStore&);
bool operator<(const RawPixelsStore&, const RawPixelsStore&);
::Ice::Object* upCast(::omero::api::RawPixelsStore*);
typedef ::IceInternal::Handle< ::omero::api::RawPixelsStore> RawPixelsStorePtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::omero::api::RawPixelsStore> RawPixelsStorePrx;
void __patch(RawPixelsStorePtr&, const ::Ice::ObjectPtr&);

}

}

namespace omero
{

namespace api
{

class AMI_RawPixelsStore_setPixelsId : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response() = 0;

    void __response()
    {
        ice_response();
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_RawPixelsStore_setPixelsId> AMI_RawPixelsStore_setPixelsIdPtr;

class AMD_RawPixelsStore_setPixelsId : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::omero::api::AMD_RawPixelsStore_setPixelsId> AMD_RawPixelsStore_setPixelsIdPtr;

class AMI_RawPixelsStore_getPixelsId : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(::Ice::Long) = 0;

    void __response(::Ice::Long __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_RawPixelsStore_getPixelsId> AMI_RawPixelsStore_getPixelsIdPtr;

class AMD_RawPixelsStore_getPixelsId : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(::Ice::Long) = 0;
};

typedef ::IceUtil::Handle< ::omero::api::AMD_RawPixelsStore_getPixelsId> AMD_RawPixelsStore_getPixelsIdPtr;

class AMI_RawPixelsStore_getPixelsPath : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::std::string&) = 0;

    void __response(const ::std::string& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_RawPixelsStore_getPixelsPath> AMI_RawPixelsStore_getPixelsPathPtr;

class AMD_RawPixelsStore_getPixelsPath : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const ::std::string&) = 0;
};

typedef ::IceUtil::Handle< ::omero::api::AMD_RawPixelsStore_getPixelsPath> AMD_RawPixelsStore_getPixelsPathPtr;

class AMI_RawPixelsStore_prepare : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response() = 0;

    void __response()
    {
        ice_response();
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_RawPixelsStore_prepare> AMI_RawPixelsStore_preparePtr;

class AMD_RawPixelsStore_prepare : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::omero::api::AMD_RawPixelsStore_prepare> AMD_RawPixelsStore_preparePtr;

class AMI_RawPixelsStore_getPlaneSize : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(::Ice::Long) = 0;

    void __response(::Ice::Long __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_RawPixelsStore_getPlaneSize> AMI_RawPixelsStore_getPlaneSizePtr;

class AMD_RawPixelsStore_getPlaneSize : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(::Ice::Long) = 0;
};

typedef ::IceUtil::Handle< ::omero::api::AMD_RawPixelsStore_getPlaneSize> AMD_RawPixelsStore_getPlaneSizePtr;

class AMI_RawPixelsStore_getRowSize : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(::Ice::Int) = 0;

    void __response(::Ice::Int __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_RawPixelsStore_getRowSize> AMI_RawPixelsStore_getRowSizePtr;

class AMD_RawPixelsStore_getRowSize : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(::Ice::Int) = 0;
};

typedef ::IceUtil::Handle< ::omero::api::AMD_RawPixelsStore_getRowSize> AMD_RawPixelsStore_getRowSizePtr;

class AMI_RawPixelsStore_getStackSize : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(::Ice::Long) = 0;

    void __response(::Ice::Long __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_RawPixelsStore_getStackSize> AMI_RawPixelsStore_getStackSizePtr;

class AMD_RawPixelsStore_getStackSize : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(::Ice::Long) = 0;
};

typedef ::IceUtil::Handle< ::omero::api::AMD_RawPixelsStore_getStackSize> AMD_RawPixelsStore_getStackSizePtr;

class AMI_RawPixelsStore_getTimepointSize : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(::Ice::Long) = 0;

    void __response(::Ice::Long __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_RawPixelsStore_getTimepointSize> AMI_RawPixelsStore_getTimepointSizePtr;

class AMD_RawPixelsStore_getTimepointSize : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(::Ice::Long) = 0;
};

typedef ::IceUtil::Handle< ::omero::api::AMD_RawPixelsStore_getTimepointSize> AMD_RawPixelsStore_getTimepointSizePtr;

class AMI_RawPixelsStore_getTotalSize : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(::Ice::Long) = 0;

    void __response(::Ice::Long __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_RawPixelsStore_getTotalSize> AMI_RawPixelsStore_getTotalSizePtr;

class AMD_RawPixelsStore_getTotalSize : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(::Ice::Long) = 0;
};

typedef ::IceUtil::Handle< ::omero::api::AMD_RawPixelsStore_getTotalSize> AMD_RawPixelsStore_getTotalSizePtr;

class AMI_RawPixelsStore_getRowOffset : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(::Ice::Long) = 0;

    void __response(::Ice::Long __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_RawPixelsStore_getRowOffset> AMI_RawPixelsStore_getRowOffsetPtr;

class AMD_RawPixelsStore_getRowOffset : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(::Ice::Long) = 0;
};

typedef ::IceUtil::Handle< ::omero::api::AMD_RawPixelsStore_getRowOffset> AMD_RawPixelsStore_getRowOffsetPtr;

class AMI_RawPixelsStore_getPlaneOffset : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(::Ice::Long) = 0;

    void __response(::Ice::Long __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_RawPixelsStore_getPlaneOffset> AMI_RawPixelsStore_getPlaneOffsetPtr;

class AMD_RawPixelsStore_getPlaneOffset : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(::Ice::Long) = 0;
};

typedef ::IceUtil::Handle< ::omero::api::AMD_RawPixelsStore_getPlaneOffset> AMD_RawPixelsStore_getPlaneOffsetPtr;

class AMI_RawPixelsStore_getStackOffset : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(::Ice::Long) = 0;

    void __response(::Ice::Long __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_RawPixelsStore_getStackOffset> AMI_RawPixelsStore_getStackOffsetPtr;

class AMD_RawPixelsStore_getStackOffset : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(::Ice::Long) = 0;
};

typedef ::IceUtil::Handle< ::omero::api::AMD_RawPixelsStore_getStackOffset> AMD_RawPixelsStore_getStackOffsetPtr;

class AMI_RawPixelsStore_getTimepointOffset : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(::Ice::Long) = 0;

    void __response(::Ice::Long __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_RawPixelsStore_getTimepointOffset> AMI_RawPixelsStore_getTimepointOffsetPtr;

class AMD_RawPixelsStore_getTimepointOffset : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(::Ice::Long) = 0;
};

typedef ::IceUtil::Handle< ::omero::api::AMD_RawPixelsStore_getTimepointOffset> AMD_RawPixelsStore_getTimepointOffsetPtr;

class AMI_RawPixelsStore_getTile : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::Ice::ByteSeq&) = 0;

    void __response(const ::Ice::ByteSeq& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_RawPixelsStore_getTile> AMI_RawPixelsStore_getTilePtr;

class AMD_RawPixelsStore_getTile : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const ::Ice::ByteSeq&) = 0;
};

typedef ::IceUtil::Handle< ::omero::api::AMD_RawPixelsStore_getTile> AMD_RawPixelsStore_getTilePtr;

class AMI_RawPixelsStore_getHypercube : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::Ice::ByteSeq&) = 0;

    void __response(const ::Ice::ByteSeq& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_RawPixelsStore_getHypercube> AMI_RawPixelsStore_getHypercubePtr;

class AMD_RawPixelsStore_getHypercube : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const ::Ice::ByteSeq&) = 0;
};

typedef ::IceUtil::Handle< ::omero::api::AMD_RawPixelsStore_getHypercube> AMD_RawPixelsStore_getHypercubePtr;

class AMI_RawPixelsStore_getRegion : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::Ice::ByteSeq&) = 0;

    void __response(const ::Ice::ByteSeq& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_RawPixelsStore_getRegion> AMI_RawPixelsStore_getRegionPtr;

class AMD_RawPixelsStore_getRegion : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const ::Ice::ByteSeq&) = 0;
};

typedef ::IceUtil::Handle< ::omero::api::AMD_RawPixelsStore_getRegion> AMD_RawPixelsStore_getRegionPtr;

class AMI_RawPixelsStore_getRow : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::Ice::ByteSeq&) = 0;

    void __response(const ::Ice::ByteSeq& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_RawPixelsStore_getRow> AMI_RawPixelsStore_getRowPtr;

class AMD_RawPixelsStore_getRow : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const ::Ice::ByteSeq&) = 0;
};

typedef ::IceUtil::Handle< ::omero::api::AMD_RawPixelsStore_getRow> AMD_RawPixelsStore_getRowPtr;

class AMI_RawPixelsStore_getCol : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::Ice::ByteSeq&) = 0;

    void __response(const ::Ice::ByteSeq& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_RawPixelsStore_getCol> AMI_RawPixelsStore_getColPtr;

class AMD_RawPixelsStore_getCol : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const ::Ice::ByteSeq&) = 0;
};

typedef ::IceUtil::Handle< ::omero::api::AMD_RawPixelsStore_getCol> AMD_RawPixelsStore_getColPtr;

class AMI_RawPixelsStore_getPlane : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::Ice::ByteSeq&) = 0;

    void __response(const ::Ice::ByteSeq& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_RawPixelsStore_getPlane> AMI_RawPixelsStore_getPlanePtr;

class AMD_RawPixelsStore_getPlane : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const ::Ice::ByteSeq&) = 0;
};

typedef ::IceUtil::Handle< ::omero::api::AMD_RawPixelsStore_getPlane> AMD_RawPixelsStore_getPlanePtr;

class AMI_RawPixelsStore_getPlaneRegion : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::Ice::ByteSeq&) = 0;

    void __response(const ::Ice::ByteSeq& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_RawPixelsStore_getPlaneRegion> AMI_RawPixelsStore_getPlaneRegionPtr;

class AMD_RawPixelsStore_getPlaneRegion : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const ::Ice::ByteSeq&) = 0;
};

typedef ::IceUtil::Handle< ::omero::api::AMD_RawPixelsStore_getPlaneRegion> AMD_RawPixelsStore_getPlaneRegionPtr;

class AMI_RawPixelsStore_getStack : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::Ice::ByteSeq&) = 0;

    void __response(const ::Ice::ByteSeq& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_RawPixelsStore_getStack> AMI_RawPixelsStore_getStackPtr;

class AMD_RawPixelsStore_getStack : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const ::Ice::ByteSeq&) = 0;
};

typedef ::IceUtil::Handle< ::omero::api::AMD_RawPixelsStore_getStack> AMD_RawPixelsStore_getStackPtr;

class AMI_RawPixelsStore_getTimepoint : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::Ice::ByteSeq&) = 0;

    void __response(const ::Ice::ByteSeq& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_RawPixelsStore_getTimepoint> AMI_RawPixelsStore_getTimepointPtr;

class AMD_RawPixelsStore_getTimepoint : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const ::Ice::ByteSeq&) = 0;
};

typedef ::IceUtil::Handle< ::omero::api::AMD_RawPixelsStore_getTimepoint> AMD_RawPixelsStore_getTimepointPtr;

class AMI_RawPixelsStore_setTile : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response() = 0;

    void __response()
    {
        ice_response();
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_RawPixelsStore_setTile> AMI_RawPixelsStore_setTilePtr;

class AMD_RawPixelsStore_setTile : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::omero::api::AMD_RawPixelsStore_setTile> AMD_RawPixelsStore_setTilePtr;

class AMI_RawPixelsStore_setRegion : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response() = 0;

    void __response()
    {
        ice_response();
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_RawPixelsStore_setRegion> AMI_RawPixelsStore_setRegionPtr;

class AMD_RawPixelsStore_setRegion : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::omero::api::AMD_RawPixelsStore_setRegion> AMD_RawPixelsStore_setRegionPtr;

class AMI_RawPixelsStore_setRow : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response() = 0;

    void __response()
    {
        ice_response();
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_RawPixelsStore_setRow> AMI_RawPixelsStore_setRowPtr;

class AMD_RawPixelsStore_setRow : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::omero::api::AMD_RawPixelsStore_setRow> AMD_RawPixelsStore_setRowPtr;

class AMI_RawPixelsStore_setPlane : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response() = 0;

    void __response()
    {
        ice_response();
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_RawPixelsStore_setPlane> AMI_RawPixelsStore_setPlanePtr;

class AMD_RawPixelsStore_setPlane : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::omero::api::AMD_RawPixelsStore_setPlane> AMD_RawPixelsStore_setPlanePtr;

class AMI_RawPixelsStore_setStack : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response() = 0;

    void __response()
    {
        ice_response();
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_RawPixelsStore_setStack> AMI_RawPixelsStore_setStackPtr;

class AMD_RawPixelsStore_setStack : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::omero::api::AMD_RawPixelsStore_setStack> AMD_RawPixelsStore_setStackPtr;

class AMI_RawPixelsStore_setTimepoint : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response() = 0;

    void __response()
    {
        ice_response();
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_RawPixelsStore_setTimepoint> AMI_RawPixelsStore_setTimepointPtr;

class AMD_RawPixelsStore_setTimepoint : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::omero::api::AMD_RawPixelsStore_setTimepoint> AMD_RawPixelsStore_setTimepointPtr;

class AMI_RawPixelsStore_getByteWidth : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(::Ice::Int) = 0;

    void __response(::Ice::Int __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_RawPixelsStore_getByteWidth> AMI_RawPixelsStore_getByteWidthPtr;

class AMD_RawPixelsStore_getByteWidth : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(::Ice::Int) = 0;
};

typedef ::IceUtil::Handle< ::omero::api::AMD_RawPixelsStore_getByteWidth> AMD_RawPixelsStore_getByteWidthPtr;

class AMI_RawPixelsStore_isSigned : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(bool) = 0;

    void __response(bool __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_RawPixelsStore_isSigned> AMI_RawPixelsStore_isSignedPtr;

class AMD_RawPixelsStore_isSigned : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(bool) = 0;
};

typedef ::IceUtil::Handle< ::omero::api::AMD_RawPixelsStore_isSigned> AMD_RawPixelsStore_isSignedPtr;

class AMI_RawPixelsStore_isFloat : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(bool) = 0;

    void __response(bool __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_RawPixelsStore_isFloat> AMI_RawPixelsStore_isFloatPtr;

class AMD_RawPixelsStore_isFloat : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(bool) = 0;
};

typedef ::IceUtil::Handle< ::omero::api::AMD_RawPixelsStore_isFloat> AMD_RawPixelsStore_isFloatPtr;

class AMI_RawPixelsStore_calculateMessageDigest : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::Ice::ByteSeq&) = 0;

    void __response(const ::Ice::ByteSeq& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_RawPixelsStore_calculateMessageDigest> AMI_RawPixelsStore_calculateMessageDigestPtr;

class AMD_RawPixelsStore_calculateMessageDigest : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const ::Ice::ByteSeq&) = 0;
};

typedef ::IceUtil::Handle< ::omero::api::AMD_RawPixelsStore_calculateMessageDigest> AMD_RawPixelsStore_calculateMessageDigestPtr;

class AMI_RawPixelsStore_save : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::omero::model::PixelsPtr&) = 0;

    void __response(const ::omero::model::PixelsPtr& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_RawPixelsStore_save> AMI_RawPixelsStore_savePtr;

class AMD_RawPixelsStore_save : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const ::omero::model::PixelsPtr&) = 0;
};

typedef ::IceUtil::Handle< ::omero::api::AMD_RawPixelsStore_save> AMD_RawPixelsStore_savePtr;

}

}

namespace IceAsync
{

namespace omero
{

namespace api
{

class AMD_RawPixelsStore_setPixelsId : public ::omero::api::AMD_RawPixelsStore_setPixelsId, public ::IceInternal::IncomingAsync
{
public:

    AMD_RawPixelsStore_setPixelsId(::IceInternal::Incoming&);

    virtual void ice_response();
    // COMPILERFIX: The using directive avoid compiler warnings with -Woverloaded-virtual
    using ::IceInternal::IncomingAsync::ice_exception;
    virtual void ice_exception(const ::std::exception&);
};

class AMD_RawPixelsStore_getPixelsId : public ::omero::api::AMD_RawPixelsStore_getPixelsId, public ::IceInternal::IncomingAsync
{
public:

    AMD_RawPixelsStore_getPixelsId(::IceInternal::Incoming&);

    virtual void ice_response(::Ice::Long);
    // COMPILERFIX: The using directive avoid compiler warnings with -Woverloaded-virtual
    using ::IceInternal::IncomingAsync::ice_exception;
    virtual void ice_exception(const ::std::exception&);
};

class AMD_RawPixelsStore_getPixelsPath : public ::omero::api::AMD_RawPixelsStore_getPixelsPath, public ::IceInternal::IncomingAsync
{
public:

    AMD_RawPixelsStore_getPixelsPath(::IceInternal::Incoming&);

    virtual void ice_response(const ::std::string&);
    // COMPILERFIX: The using directive avoid compiler warnings with -Woverloaded-virtual
    using ::IceInternal::IncomingAsync::ice_exception;
    virtual void ice_exception(const ::std::exception&);
};

class AMD_RawPixelsStore_prepare : public ::omero::api::AMD_RawPixelsStore_prepare, public ::IceInternal::IncomingAsync
{
public:

    AMD_RawPixelsStore_prepare(::IceInternal::Incoming&);

    virtual void ice_response();
    // COMPILERFIX: The using directive avoid compiler warnings with -Woverloaded-virtual
    using ::IceInternal::IncomingAsync::ice_exception;
    virtual void ice_exception(const ::std::exception&);
};

class AMD_RawPixelsStore_getPlaneSize : public ::omero::api::AMD_RawPixelsStore_getPlaneSize, public ::IceInternal::IncomingAsync
{
public:

    AMD_RawPixelsStore_getPlaneSize(::IceInternal::Incoming&);

    virtual void ice_response(::Ice::Long);
    // COMPILERFIX: The using directive avoid compiler warnings with -Woverloaded-virtual
    using ::IceInternal::IncomingAsync::ice_exception;
    virtual void ice_exception(const ::std::exception&);
};

class AMD_RawPixelsStore_getRowSize : public ::omero::api::AMD_RawPixelsStore_getRowSize, public ::IceInternal::IncomingAsync
{
public:

    AMD_RawPixelsStore_getRowSize(::IceInternal::Incoming&);

    virtual void ice_response(::Ice::Int);
    // COMPILERFIX: The using directive avoid compiler warnings with -Woverloaded-virtual
    using ::IceInternal::IncomingAsync::ice_exception;
    virtual void ice_exception(const ::std::exception&);
};

class AMD_RawPixelsStore_getStackSize : public ::omero::api::AMD_RawPixelsStore_getStackSize, public ::IceInternal::IncomingAsync
{
public:

    AMD_RawPixelsStore_getStackSize(::IceInternal::Incoming&);

    virtual void ice_response(::Ice::Long);
    // COMPILERFIX: The using directive avoid compiler warnings with -Woverloaded-virtual
    using ::IceInternal::IncomingAsync::ice_exception;
    virtual void ice_exception(const ::std::exception&);
};

class AMD_RawPixelsStore_getTimepointSize : public ::omero::api::AMD_RawPixelsStore_getTimepointSize, public ::IceInternal::IncomingAsync
{
public:

    AMD_RawPixelsStore_getTimepointSize(::IceInternal::Incoming&);

    virtual void ice_response(::Ice::Long);
    // COMPILERFIX: The using directive avoid compiler warnings with -Woverloaded-virtual
    using ::IceInternal::IncomingAsync::ice_exception;
    virtual void ice_exception(const ::std::exception&);
};

class AMD_RawPixelsStore_getTotalSize : public ::omero::api::AMD_RawPixelsStore_getTotalSize, public ::IceInternal::IncomingAsync
{
public:

    AMD_RawPixelsStore_getTotalSize(::IceInternal::Incoming&);

    virtual void ice_response(::Ice::Long);
    // COMPILERFIX: The using directive avoid compiler warnings with -Woverloaded-virtual
    using ::IceInternal::IncomingAsync::ice_exception;
    virtual void ice_exception(const ::std::exception&);
};

class AMD_RawPixelsStore_getRowOffset : public ::omero::api::AMD_RawPixelsStore_getRowOffset, public ::IceInternal::IncomingAsync
{
public:

    AMD_RawPixelsStore_getRowOffset(::IceInternal::Incoming&);

    virtual void ice_response(::Ice::Long);
    // COMPILERFIX: The using directive avoid compiler warnings with -Woverloaded-virtual
    using ::IceInternal::IncomingAsync::ice_exception;
    virtual void ice_exception(const ::std::exception&);
};

class AMD_RawPixelsStore_getPlaneOffset : public ::omero::api::AMD_RawPixelsStore_getPlaneOffset, public ::IceInternal::IncomingAsync
{
public:

    AMD_RawPixelsStore_getPlaneOffset(::IceInternal::Incoming&);

    virtual void ice_response(::Ice::Long);
    // COMPILERFIX: The using directive avoid compiler warnings with -Woverloaded-virtual
    using ::IceInternal::IncomingAsync::ice_exception;
    virtual void ice_exception(const ::std::exception&);
};

class AMD_RawPixelsStore_getStackOffset : public ::omero::api::AMD_RawPixelsStore_getStackOffset, public ::IceInternal::IncomingAsync
{
public:

    AMD_RawPixelsStore_getStackOffset(::IceInternal::Incoming&);

    virtual void ice_response(::Ice::Long);
    // COMPILERFIX: The using directive avoid compiler warnings with -Woverloaded-virtual
    using ::IceInternal::IncomingAsync::ice_exception;
    virtual void ice_exception(const ::std::exception&);
};

class AMD_RawPixelsStore_getTimepointOffset : public ::omero::api::AMD_RawPixelsStore_getTimepointOffset, public ::IceInternal::IncomingAsync
{
public:

    AMD_RawPixelsStore_getTimepointOffset(::IceInternal::Incoming&);

    virtual void ice_response(::Ice::Long);
    // COMPILERFIX: The using directive avoid compiler warnings with -Woverloaded-virtual
    using ::IceInternal::IncomingAsync::ice_exception;
    virtual void ice_exception(const ::std::exception&);
};

class AMD_RawPixelsStore_getTile : public ::omero::api::AMD_RawPixelsStore_getTile, public ::IceInternal::IncomingAsync
{
public:

    AMD_RawPixelsStore_getTile(::IceInternal::Incoming&);

    virtual void ice_response(const ::Ice::ByteSeq&);
    // COMPILERFIX: The using directive avoid compiler warnings with -Woverloaded-virtual
    using ::IceInternal::IncomingAsync::ice_exception;
    virtual void ice_exception(const ::std::exception&);
};

class AMD_RawPixelsStore_getHypercube : public ::omero::api::AMD_RawPixelsStore_getHypercube, public ::IceInternal::IncomingAsync
{
public:

    AMD_RawPixelsStore_getHypercube(::IceInternal::Incoming&);

    virtual void ice_response(const ::Ice::ByteSeq&);
    // COMPILERFIX: The using directive avoid compiler warnings with -Woverloaded-virtual
    using ::IceInternal::IncomingAsync::ice_exception;
    virtual void ice_exception(const ::std::exception&);
};

class AMD_RawPixelsStore_getRegion : public ::omero::api::AMD_RawPixelsStore_getRegion, public ::IceInternal::IncomingAsync
{
public:

    AMD_RawPixelsStore_getRegion(::IceInternal::Incoming&);

    virtual void ice_response(const ::Ice::ByteSeq&);
    // COMPILERFIX: The using directive avoid compiler warnings with -Woverloaded-virtual
    using ::IceInternal::IncomingAsync::ice_exception;
    virtual void ice_exception(const ::std::exception&);
};

class AMD_RawPixelsStore_getRow : public ::omero::api::AMD_RawPixelsStore_getRow, public ::IceInternal::IncomingAsync
{
public:

    AMD_RawPixelsStore_getRow(::IceInternal::Incoming&);

    virtual void ice_response(const ::Ice::ByteSeq&);
    // COMPILERFIX: The using directive avoid compiler warnings with -Woverloaded-virtual
    using ::IceInternal::IncomingAsync::ice_exception;
    virtual void ice_exception(const ::std::exception&);
};

class AMD_RawPixelsStore_getCol : public ::omero::api::AMD_RawPixelsStore_getCol, public ::IceInternal::IncomingAsync
{
public:

    AMD_RawPixelsStore_getCol(::IceInternal::Incoming&);

    virtual void ice_response(const ::Ice::ByteSeq&);
    // COMPILERFIX: The using directive avoid compiler warnings with -Woverloaded-virtual
    using ::IceInternal::IncomingAsync::ice_exception;
    virtual void ice_exception(const ::std::exception&);
};

class AMD_RawPixelsStore_getPlane : public ::omero::api::AMD_RawPixelsStore_getPlane, public ::IceInternal::IncomingAsync
{
public:

    AMD_RawPixelsStore_getPlane(::IceInternal::Incoming&);

    virtual void ice_response(const ::Ice::ByteSeq&);
    // COMPILERFIX: The using directive avoid compiler warnings with -Woverloaded-virtual
    using ::IceInternal::IncomingAsync::ice_exception;
    virtual void ice_exception(const ::std::exception&);
};

class AMD_RawPixelsStore_getPlaneRegion : public ::omero::api::AMD_RawPixelsStore_getPlaneRegion, public ::IceInternal::IncomingAsync
{
public:

    AMD_RawPixelsStore_getPlaneRegion(::IceInternal::Incoming&);

    virtual void ice_response(const ::Ice::ByteSeq&);
    // COMPILERFIX: The using directive avoid compiler warnings with -Woverloaded-virtual
    using ::IceInternal::IncomingAsync::ice_exception;
    virtual void ice_exception(const ::std::exception&);
};

class AMD_RawPixelsStore_getStack : public ::omero::api::AMD_RawPixelsStore_getStack, public ::IceInternal::IncomingAsync
{
public:

    AMD_RawPixelsStore_getStack(::IceInternal::Incoming&);

    virtual void ice_response(const ::Ice::ByteSeq&);
    // COMPILERFIX: The using directive avoid compiler warnings with -Woverloaded-virtual
    using ::IceInternal::IncomingAsync::ice_exception;
    virtual void ice_exception(const ::std::exception&);
};

class AMD_RawPixelsStore_getTimepoint : public ::omero::api::AMD_RawPixelsStore_getTimepoint, public ::IceInternal::IncomingAsync
{
public:

    AMD_RawPixelsStore_getTimepoint(::IceInternal::Incoming&);

    virtual void ice_response(const ::Ice::ByteSeq&);
    // COMPILERFIX: The using directive avoid compiler warnings with -Woverloaded-virtual
    using ::IceInternal::IncomingAsync::ice_exception;
    virtual void ice_exception(const ::std::exception&);
};

class AMD_RawPixelsStore_setTile : public ::omero::api::AMD_RawPixelsStore_setTile, public ::IceInternal::IncomingAsync
{
public:

    AMD_RawPixelsStore_setTile(::IceInternal::Incoming&);

    virtual void ice_response();
    // COMPILERFIX: The using directive avoid compiler warnings with -Woverloaded-virtual
    using ::IceInternal::IncomingAsync::ice_exception;
    virtual void ice_exception(const ::std::exception&);
};

class AMD_RawPixelsStore_setRegion : public ::omero::api::AMD_RawPixelsStore_setRegion, public ::IceInternal::IncomingAsync
{
public:

    AMD_RawPixelsStore_setRegion(::IceInternal::Incoming&);

    virtual void ice_response();
    // COMPILERFIX: The using directive avoid compiler warnings with -Woverloaded-virtual
    using ::IceInternal::IncomingAsync::ice_exception;
    virtual void ice_exception(const ::std::exception&);
};

class AMD_RawPixelsStore_setRow : public ::omero::api::AMD_RawPixelsStore_setRow, public ::IceInternal::IncomingAsync
{
public:

    AMD_RawPixelsStore_setRow(::IceInternal::Incoming&);

    virtual void ice_response();
    // COMPILERFIX: The using directive avoid compiler warnings with -Woverloaded-virtual
    using ::IceInternal::IncomingAsync::ice_exception;
    virtual void ice_exception(const ::std::exception&);
};

class AMD_RawPixelsStore_setPlane : public ::omero::api::AMD_RawPixelsStore_setPlane, public ::IceInternal::IncomingAsync
{
public:

    AMD_RawPixelsStore_setPlane(::IceInternal::Incoming&);

    virtual void ice_response();
    // COMPILERFIX: The using directive avoid compiler warnings with -Woverloaded-virtual
    using ::IceInternal::IncomingAsync::ice_exception;
    virtual void ice_exception(const ::std::exception&);
};

class AMD_RawPixelsStore_setStack : public ::omero::api::AMD_RawPixelsStore_setStack, public ::IceInternal::IncomingAsync
{
public:

    AMD_RawPixelsStore_setStack(::IceInternal::Incoming&);

    virtual void ice_response();
    // COMPILERFIX: The using directive avoid compiler warnings with -Woverloaded-virtual
    using ::IceInternal::IncomingAsync::ice_exception;
    virtual void ice_exception(const ::std::exception&);
};

class AMD_RawPixelsStore_setTimepoint : public ::omero::api::AMD_RawPixelsStore_setTimepoint, public ::IceInternal::IncomingAsync
{
public:

    AMD_RawPixelsStore_setTimepoint(::IceInternal::Incoming&);

    virtual void ice_response();
    // COMPILERFIX: The using directive avoid compiler warnings with -Woverloaded-virtual
    using ::IceInternal::IncomingAsync::ice_exception;
    virtual void ice_exception(const ::std::exception&);
};

class AMD_RawPixelsStore_getByteWidth : public ::omero::api::AMD_RawPixelsStore_getByteWidth, public ::IceInternal::IncomingAsync
{
public:

    AMD_RawPixelsStore_getByteWidth(::IceInternal::Incoming&);

    virtual void ice_response(::Ice::Int);
    // COMPILERFIX: The using directive avoid compiler warnings with -Woverloaded-virtual
    using ::IceInternal::IncomingAsync::ice_exception;
    virtual void ice_exception(const ::std::exception&);
};

class AMD_RawPixelsStore_isSigned : public ::omero::api::AMD_RawPixelsStore_isSigned, public ::IceInternal::IncomingAsync
{
public:

    AMD_RawPixelsStore_isSigned(::IceInternal::Incoming&);

    virtual void ice_response(bool);
    // COMPILERFIX: The using directive avoid compiler warnings with -Woverloaded-virtual
    using ::IceInternal::IncomingAsync::ice_exception;
    virtual void ice_exception(const ::std::exception&);
};

class AMD_RawPixelsStore_isFloat : public ::omero::api::AMD_RawPixelsStore_isFloat, public ::IceInternal::IncomingAsync
{
public:

    AMD_RawPixelsStore_isFloat(::IceInternal::Incoming&);

    virtual void ice_response(bool);
    // COMPILERFIX: The using directive avoid compiler warnings with -Woverloaded-virtual
    using ::IceInternal::IncomingAsync::ice_exception;
    virtual void ice_exception(const ::std::exception&);
};

class AMD_RawPixelsStore_calculateMessageDigest : public ::omero::api::AMD_RawPixelsStore_calculateMessageDigest, public ::IceInternal::IncomingAsync
{
public:

    AMD_RawPixelsStore_calculateMessageDigest(::IceInternal::Incoming&);

    virtual void ice_response(const ::Ice::ByteSeq&);
    // COMPILERFIX: The using directive avoid compiler warnings with -Woverloaded-virtual
    using ::IceInternal::IncomingAsync::ice_exception;
    virtual void ice_exception(const ::std::exception&);
};

class AMD_RawPixelsStore_save : public ::omero::api::AMD_RawPixelsStore_save, public ::IceInternal::IncomingAsync
{
public:

    AMD_RawPixelsStore_save(::IceInternal::Incoming&);

    virtual void ice_response(const ::omero::model::PixelsPtr&);
    // COMPILERFIX: The using directive avoid compiler warnings with -Woverloaded-virtual
    using ::IceInternal::IncomingAsync::ice_exception;
    virtual void ice_exception(const ::std::exception&);
};

}

}

}

namespace omero
{

namespace api
{

class Callback_RawPixelsStore_setPixelsId_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RawPixelsStore_setPixelsId_Base> Callback_RawPixelsStore_setPixelsIdPtr;

class Callback_RawPixelsStore_getPixelsId_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RawPixelsStore_getPixelsId_Base> Callback_RawPixelsStore_getPixelsIdPtr;

class Callback_RawPixelsStore_getPixelsPath_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RawPixelsStore_getPixelsPath_Base> Callback_RawPixelsStore_getPixelsPathPtr;

class Callback_RawPixelsStore_prepare_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RawPixelsStore_prepare_Base> Callback_RawPixelsStore_preparePtr;

class Callback_RawPixelsStore_getPlaneSize_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RawPixelsStore_getPlaneSize_Base> Callback_RawPixelsStore_getPlaneSizePtr;

class Callback_RawPixelsStore_getRowSize_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RawPixelsStore_getRowSize_Base> Callback_RawPixelsStore_getRowSizePtr;

class Callback_RawPixelsStore_getStackSize_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RawPixelsStore_getStackSize_Base> Callback_RawPixelsStore_getStackSizePtr;

class Callback_RawPixelsStore_getTimepointSize_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RawPixelsStore_getTimepointSize_Base> Callback_RawPixelsStore_getTimepointSizePtr;

class Callback_RawPixelsStore_getTotalSize_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RawPixelsStore_getTotalSize_Base> Callback_RawPixelsStore_getTotalSizePtr;

class Callback_RawPixelsStore_getRowOffset_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RawPixelsStore_getRowOffset_Base> Callback_RawPixelsStore_getRowOffsetPtr;

class Callback_RawPixelsStore_getPlaneOffset_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RawPixelsStore_getPlaneOffset_Base> Callback_RawPixelsStore_getPlaneOffsetPtr;

class Callback_RawPixelsStore_getStackOffset_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RawPixelsStore_getStackOffset_Base> Callback_RawPixelsStore_getStackOffsetPtr;

class Callback_RawPixelsStore_getTimepointOffset_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RawPixelsStore_getTimepointOffset_Base> Callback_RawPixelsStore_getTimepointOffsetPtr;

class Callback_RawPixelsStore_getTile_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RawPixelsStore_getTile_Base> Callback_RawPixelsStore_getTilePtr;

class Callback_RawPixelsStore_getHypercube_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RawPixelsStore_getHypercube_Base> Callback_RawPixelsStore_getHypercubePtr;

class Callback_RawPixelsStore_getRegion_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RawPixelsStore_getRegion_Base> Callback_RawPixelsStore_getRegionPtr;

class Callback_RawPixelsStore_getRow_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RawPixelsStore_getRow_Base> Callback_RawPixelsStore_getRowPtr;

class Callback_RawPixelsStore_getCol_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RawPixelsStore_getCol_Base> Callback_RawPixelsStore_getColPtr;

class Callback_RawPixelsStore_getPlane_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RawPixelsStore_getPlane_Base> Callback_RawPixelsStore_getPlanePtr;

class Callback_RawPixelsStore_getPlaneRegion_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RawPixelsStore_getPlaneRegion_Base> Callback_RawPixelsStore_getPlaneRegionPtr;

class Callback_RawPixelsStore_getStack_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RawPixelsStore_getStack_Base> Callback_RawPixelsStore_getStackPtr;

class Callback_RawPixelsStore_getTimepoint_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RawPixelsStore_getTimepoint_Base> Callback_RawPixelsStore_getTimepointPtr;

class Callback_RawPixelsStore_setTile_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RawPixelsStore_setTile_Base> Callback_RawPixelsStore_setTilePtr;

class Callback_RawPixelsStore_setRegion_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RawPixelsStore_setRegion_Base> Callback_RawPixelsStore_setRegionPtr;

class Callback_RawPixelsStore_setRow_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RawPixelsStore_setRow_Base> Callback_RawPixelsStore_setRowPtr;

class Callback_RawPixelsStore_setPlane_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RawPixelsStore_setPlane_Base> Callback_RawPixelsStore_setPlanePtr;

class Callback_RawPixelsStore_setStack_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RawPixelsStore_setStack_Base> Callback_RawPixelsStore_setStackPtr;

class Callback_RawPixelsStore_setTimepoint_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RawPixelsStore_setTimepoint_Base> Callback_RawPixelsStore_setTimepointPtr;

class Callback_RawPixelsStore_getByteWidth_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RawPixelsStore_getByteWidth_Base> Callback_RawPixelsStore_getByteWidthPtr;

class Callback_RawPixelsStore_isSigned_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RawPixelsStore_isSigned_Base> Callback_RawPixelsStore_isSignedPtr;

class Callback_RawPixelsStore_isFloat_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RawPixelsStore_isFloat_Base> Callback_RawPixelsStore_isFloatPtr;

class Callback_RawPixelsStore_calculateMessageDigest_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RawPixelsStore_calculateMessageDigest_Base> Callback_RawPixelsStore_calculateMessageDigestPtr;

class Callback_RawPixelsStore_save_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RawPixelsStore_save_Base> Callback_RawPixelsStore_savePtr;

}

}

namespace IceProxy
{

namespace omero
{

namespace api
{

class RawPixelsStore : virtual public ::IceProxy::omero::api::PyramidService
{
public:

    void setPixelsId(::Ice::Long pixelsId, bool bypassOriginalFile)
    {
        setPixelsId(pixelsId, bypassOriginalFile, 0);
    }
    void setPixelsId(::Ice::Long pixelsId, bool bypassOriginalFile, const ::Ice::Context& __ctx)
    {
        setPixelsId(pixelsId, bypassOriginalFile, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_setPixelsId(::Ice::Long pixelsId, bool bypassOriginalFile, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_setPixelsId(pixelsId, bypassOriginalFile, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_setPixelsId(::Ice::Long pixelsId, bool bypassOriginalFile, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_setPixelsId(pixelsId, bypassOriginalFile, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_setPixelsId(::Ice::Long pixelsId, bool bypassOriginalFile, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_setPixelsId(pixelsId, bypassOriginalFile, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_setPixelsId(::Ice::Long pixelsId, bool bypassOriginalFile, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_setPixelsId(pixelsId, bypassOriginalFile, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_setPixelsId(::Ice::Long pixelsId, bool bypassOriginalFile, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::api::RawPixelsStorePrx __proxy = ::omero::api::RawPixelsStorePrx::uncheckedCast(__result->getProxy());
                try
                {
                    __proxy->end_setPixelsId(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response();
                }
            }
        
        private:
            
            ::std::function<void ()> _response;
        };
        return begin_setPixelsId(pixelsId, bypassOriginalFile, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_setPixelsId(::Ice::Long pixelsId, bool bypassOriginalFile)
    {
        return begin_setPixelsId(pixelsId, bypassOriginalFile, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setPixelsId(::Ice::Long pixelsId, bool bypassOriginalFile, const ::Ice::Context& __ctx)
    {
        return begin_setPixelsId(pixelsId, bypassOriginalFile, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setPixelsId(::Ice::Long pixelsId, bool bypassOriginalFile, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setPixelsId(pixelsId, bypassOriginalFile, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setPixelsId(::Ice::Long pixelsId, bool bypassOriginalFile, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setPixelsId(pixelsId, bypassOriginalFile, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setPixelsId(::Ice::Long pixelsId, bool bypassOriginalFile, const ::omero::api::Callback_RawPixelsStore_setPixelsIdPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setPixelsId(pixelsId, bypassOriginalFile, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setPixelsId(::Ice::Long pixelsId, bool bypassOriginalFile, const ::Ice::Context& __ctx, const ::omero::api::Callback_RawPixelsStore_setPixelsIdPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setPixelsId(pixelsId, bypassOriginalFile, &__ctx, __del, __cookie);
    }

    void end_setPixelsId(const ::Ice::AsyncResultPtr&);
    
private:

    void setPixelsId(::Ice::Long, bool, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setPixelsId(::Ice::Long, bool, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool setPixelsId_async(const ::omero::api::AMI_RawPixelsStore_setPixelsIdPtr&, ::Ice::Long, bool);
    bool setPixelsId_async(const ::omero::api::AMI_RawPixelsStore_setPixelsIdPtr&, ::Ice::Long, bool, const ::Ice::Context&);

    ::Ice::Long getPixelsId()
    {
        return getPixelsId(0);
    }
    ::Ice::Long getPixelsId(const ::Ice::Context& __ctx)
    {
        return getPixelsId(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_getPixelsId(const ::IceInternal::Function<void (::Ice::Long)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getPixelsId(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getPixelsId(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getPixelsId(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_getPixelsId(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (::Ice::Long)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getPixelsId(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getPixelsId(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getPixelsId(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_getPixelsId(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (::Ice::Long)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (::Ice::Long)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::api::RawPixelsStorePrx __proxy = ::omero::api::RawPixelsStorePrx::uncheckedCast(__result->getProxy());
                ::Ice::Long __ret;
                try
                {
                    __ret = __proxy->end_getPixelsId(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (::Ice::Long)> _response;
        };
        return begin_getPixelsId(__ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_getPixelsId()
    {
        return begin_getPixelsId(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getPixelsId(const ::Ice::Context& __ctx)
    {
        return begin_getPixelsId(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getPixelsId(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getPixelsId(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getPixelsId(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getPixelsId(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getPixelsId(const ::omero::api::Callback_RawPixelsStore_getPixelsIdPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getPixelsId(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getPixelsId(const ::Ice::Context& __ctx, const ::omero::api::Callback_RawPixelsStore_getPixelsIdPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getPixelsId(&__ctx, __del, __cookie);
    }

    ::Ice::Long end_getPixelsId(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Long getPixelsId(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getPixelsId(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool getPixelsId_async(const ::omero::api::AMI_RawPixelsStore_getPixelsIdPtr&);
    bool getPixelsId_async(const ::omero::api::AMI_RawPixelsStore_getPixelsIdPtr&, const ::Ice::Context&);

    ::std::string getPixelsPath()
    {
        return getPixelsPath(0);
    }
    ::std::string getPixelsPath(const ::Ice::Context& __ctx)
    {
        return getPixelsPath(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_getPixelsPath(const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getPixelsPath(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getPixelsPath(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getPixelsPath(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_getPixelsPath(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getPixelsPath(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getPixelsPath(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getPixelsPath(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_getPixelsPath(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::std::string&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::api::RawPixelsStorePrx __proxy = ::omero::api::RawPixelsStorePrx::uncheckedCast(__result->getProxy());
                ::std::string __ret;
                try
                {
                    __ret = __proxy->end_getPixelsPath(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::std::string&)> _response;
        };
        return begin_getPixelsPath(__ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_getPixelsPath()
    {
        return begin_getPixelsPath(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getPixelsPath(const ::Ice::Context& __ctx)
    {
        return begin_getPixelsPath(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getPixelsPath(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getPixelsPath(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getPixelsPath(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getPixelsPath(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getPixelsPath(const ::omero::api::Callback_RawPixelsStore_getPixelsPathPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getPixelsPath(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getPixelsPath(const ::Ice::Context& __ctx, const ::omero::api::Callback_RawPixelsStore_getPixelsPathPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getPixelsPath(&__ctx, __del, __cookie);
    }

    ::std::string end_getPixelsPath(const ::Ice::AsyncResultPtr&);
    
private:

    ::std::string getPixelsPath(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getPixelsPath(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool getPixelsPath_async(const ::omero::api::AMI_RawPixelsStore_getPixelsPathPtr&);
    bool getPixelsPath_async(const ::omero::api::AMI_RawPixelsStore_getPixelsPathPtr&, const ::Ice::Context&);

    void prepare(const ::omero::sys::LongList& pixelsIds)
    {
        prepare(pixelsIds, 0);
    }
    void prepare(const ::omero::sys::LongList& pixelsIds, const ::Ice::Context& __ctx)
    {
        prepare(pixelsIds, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_prepare(const ::omero::sys::LongList& pixelsIds, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_prepare(pixelsIds, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_prepare(const ::omero::sys::LongList& pixelsIds, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_prepare(pixelsIds, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_prepare(const ::omero::sys::LongList& pixelsIds, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_prepare(pixelsIds, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_prepare(const ::omero::sys::LongList& pixelsIds, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_prepare(pixelsIds, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_prepare(const ::omero::sys::LongList& pixelsIds, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::api::RawPixelsStorePrx __proxy = ::omero::api::RawPixelsStorePrx::uncheckedCast(__result->getProxy());
                try
                {
                    __proxy->end_prepare(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response();
                }
            }
        
        private:
            
            ::std::function<void ()> _response;
        };
        return begin_prepare(pixelsIds, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_prepare(const ::omero::sys::LongList& pixelsIds)
    {
        return begin_prepare(pixelsIds, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_prepare(const ::omero::sys::LongList& pixelsIds, const ::Ice::Context& __ctx)
    {
        return begin_prepare(pixelsIds, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_prepare(const ::omero::sys::LongList& pixelsIds, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_prepare(pixelsIds, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_prepare(const ::omero::sys::LongList& pixelsIds, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_prepare(pixelsIds, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_prepare(const ::omero::sys::LongList& pixelsIds, const ::omero::api::Callback_RawPixelsStore_preparePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_prepare(pixelsIds, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_prepare(const ::omero::sys::LongList& pixelsIds, const ::Ice::Context& __ctx, const ::omero::api::Callback_RawPixelsStore_preparePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_prepare(pixelsIds, &__ctx, __del, __cookie);
    }

    void end_prepare(const ::Ice::AsyncResultPtr&);
    
private:

    void prepare(const ::omero::sys::LongList&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_prepare(const ::omero::sys::LongList&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool prepare_async(const ::omero::api::AMI_RawPixelsStore_preparePtr&, const ::omero::sys::LongList&);
    bool prepare_async(const ::omero::api::AMI_RawPixelsStore_preparePtr&, const ::omero::sys::LongList&, const ::Ice::Context&);

    ::Ice::Long getPlaneSize()
    {
        return getPlaneSize(0);
    }
    ::Ice::Long getPlaneSize(const ::Ice::Context& __ctx)
    {
        return getPlaneSize(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_getPlaneSize(const ::IceInternal::Function<void (::Ice::Long)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getPlaneSize(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getPlaneSize(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getPlaneSize(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_getPlaneSize(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (::Ice::Long)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getPlaneSize(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getPlaneSize(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getPlaneSize(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_getPlaneSize(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (::Ice::Long)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (::Ice::Long)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::api::RawPixelsStorePrx __proxy = ::omero::api::RawPixelsStorePrx::uncheckedCast(__result->getProxy());
                ::Ice::Long __ret;
                try
                {
                    __ret = __proxy->end_getPlaneSize(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (::Ice::Long)> _response;
        };
        return begin_getPlaneSize(__ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_getPlaneSize()
    {
        return begin_getPlaneSize(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getPlaneSize(const ::Ice::Context& __ctx)
    {
        return begin_getPlaneSize(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getPlaneSize(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getPlaneSize(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getPlaneSize(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getPlaneSize(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getPlaneSize(const ::omero::api::Callback_RawPixelsStore_getPlaneSizePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getPlaneSize(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getPlaneSize(const ::Ice::Context& __ctx, const ::omero::api::Callback_RawPixelsStore_getPlaneSizePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getPlaneSize(&__ctx, __del, __cookie);
    }

    ::Ice::Long end_getPlaneSize(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Long getPlaneSize(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getPlaneSize(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool getPlaneSize_async(const ::omero::api::AMI_RawPixelsStore_getPlaneSizePtr&);
    bool getPlaneSize_async(const ::omero::api::AMI_RawPixelsStore_getPlaneSizePtr&, const ::Ice::Context&);

    ::Ice::Int getRowSize()
    {
        return getRowSize(0);
    }
    ::Ice::Int getRowSize(const ::Ice::Context& __ctx)
    {
        return getRowSize(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_getRowSize(const ::IceInternal::Function<void (::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getRowSize(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getRowSize(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getRowSize(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_getRowSize(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getRowSize(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getRowSize(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getRowSize(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_getRowSize(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (::Ice::Int)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::api::RawPixelsStorePrx __proxy = ::omero::api::RawPixelsStorePrx::uncheckedCast(__result->getProxy());
                ::Ice::Int __ret;
                try
                {
                    __ret = __proxy->end_getRowSize(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (::Ice::Int)> _response;
        };
        return begin_getRowSize(__ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_getRowSize()
    {
        return begin_getRowSize(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getRowSize(const ::Ice::Context& __ctx)
    {
        return begin_getRowSize(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getRowSize(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getRowSize(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getRowSize(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getRowSize(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getRowSize(const ::omero::api::Callback_RawPixelsStore_getRowSizePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getRowSize(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getRowSize(const ::Ice::Context& __ctx, const ::omero::api::Callback_RawPixelsStore_getRowSizePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getRowSize(&__ctx, __del, __cookie);
    }

    ::Ice::Int end_getRowSize(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int getRowSize(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getRowSize(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool getRowSize_async(const ::omero::api::AMI_RawPixelsStore_getRowSizePtr&);
    bool getRowSize_async(const ::omero::api::AMI_RawPixelsStore_getRowSizePtr&, const ::Ice::Context&);

    ::Ice::Long getStackSize()
    {
        return getStackSize(0);
    }
    ::Ice::Long getStackSize(const ::Ice::Context& __ctx)
    {
        return getStackSize(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_getStackSize(const ::IceInternal::Function<void (::Ice::Long)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getStackSize(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getStackSize(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getStackSize(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_getStackSize(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (::Ice::Long)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getStackSize(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getStackSize(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getStackSize(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_getStackSize(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (::Ice::Long)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (::Ice::Long)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::api::RawPixelsStorePrx __proxy = ::omero::api::RawPixelsStorePrx::uncheckedCast(__result->getProxy());
                ::Ice::Long __ret;
                try
                {
                    __ret = __proxy->end_getStackSize(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (::Ice::Long)> _response;
        };
        return begin_getStackSize(__ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_getStackSize()
    {
        return begin_getStackSize(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getStackSize(const ::Ice::Context& __ctx)
    {
        return begin_getStackSize(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getStackSize(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getStackSize(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getStackSize(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getStackSize(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getStackSize(const ::omero::api::Callback_RawPixelsStore_getStackSizePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getStackSize(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getStackSize(const ::Ice::Context& __ctx, const ::omero::api::Callback_RawPixelsStore_getStackSizePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getStackSize(&__ctx, __del, __cookie);
    }

    ::Ice::Long end_getStackSize(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Long getStackSize(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getStackSize(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool getStackSize_async(const ::omero::api::AMI_RawPixelsStore_getStackSizePtr&);
    bool getStackSize_async(const ::omero::api::AMI_RawPixelsStore_getStackSizePtr&, const ::Ice::Context&);

    ::Ice::Long getTimepointSize()
    {
        return getTimepointSize(0);
    }
    ::Ice::Long getTimepointSize(const ::Ice::Context& __ctx)
    {
        return getTimepointSize(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_getTimepointSize(const ::IceInternal::Function<void (::Ice::Long)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getTimepointSize(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getTimepointSize(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getTimepointSize(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_getTimepointSize(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (::Ice::Long)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getTimepointSize(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getTimepointSize(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getTimepointSize(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_getTimepointSize(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (::Ice::Long)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (::Ice::Long)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::api::RawPixelsStorePrx __proxy = ::omero::api::RawPixelsStorePrx::uncheckedCast(__result->getProxy());
                ::Ice::Long __ret;
                try
                {
                    __ret = __proxy->end_getTimepointSize(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (::Ice::Long)> _response;
        };
        return begin_getTimepointSize(__ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_getTimepointSize()
    {
        return begin_getTimepointSize(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getTimepointSize(const ::Ice::Context& __ctx)
    {
        return begin_getTimepointSize(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getTimepointSize(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getTimepointSize(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getTimepointSize(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getTimepointSize(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getTimepointSize(const ::omero::api::Callback_RawPixelsStore_getTimepointSizePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getTimepointSize(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getTimepointSize(const ::Ice::Context& __ctx, const ::omero::api::Callback_RawPixelsStore_getTimepointSizePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getTimepointSize(&__ctx, __del, __cookie);
    }

    ::Ice::Long end_getTimepointSize(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Long getTimepointSize(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getTimepointSize(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool getTimepointSize_async(const ::omero::api::AMI_RawPixelsStore_getTimepointSizePtr&);
    bool getTimepointSize_async(const ::omero::api::AMI_RawPixelsStore_getTimepointSizePtr&, const ::Ice::Context&);

    ::Ice::Long getTotalSize()
    {
        return getTotalSize(0);
    }
    ::Ice::Long getTotalSize(const ::Ice::Context& __ctx)
    {
        return getTotalSize(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_getTotalSize(const ::IceInternal::Function<void (::Ice::Long)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getTotalSize(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getTotalSize(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getTotalSize(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_getTotalSize(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (::Ice::Long)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getTotalSize(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getTotalSize(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getTotalSize(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_getTotalSize(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (::Ice::Long)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (::Ice::Long)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::api::RawPixelsStorePrx __proxy = ::omero::api::RawPixelsStorePrx::uncheckedCast(__result->getProxy());
                ::Ice::Long __ret;
                try
                {
                    __ret = __proxy->end_getTotalSize(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (::Ice::Long)> _response;
        };
        return begin_getTotalSize(__ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_getTotalSize()
    {
        return begin_getTotalSize(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getTotalSize(const ::Ice::Context& __ctx)
    {
        return begin_getTotalSize(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getTotalSize(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getTotalSize(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getTotalSize(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getTotalSize(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getTotalSize(const ::omero::api::Callback_RawPixelsStore_getTotalSizePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getTotalSize(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getTotalSize(const ::Ice::Context& __ctx, const ::omero::api::Callback_RawPixelsStore_getTotalSizePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getTotalSize(&__ctx, __del, __cookie);
    }

    ::Ice::Long end_getTotalSize(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Long getTotalSize(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getTotalSize(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool getTotalSize_async(const ::omero::api::AMI_RawPixelsStore_getTotalSizePtr&);
    bool getTotalSize_async(const ::omero::api::AMI_RawPixelsStore_getTotalSizePtr&, const ::Ice::Context&);

    ::Ice::Long getRowOffset(::Ice::Int y, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t)
    {
        return getRowOffset(y, z, c, t, 0);
    }
    ::Ice::Long getRowOffset(::Ice::Int y, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::Ice::Context& __ctx)
    {
        return getRowOffset(y, z, c, t, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_getRowOffset(::Ice::Int y, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::IceInternal::Function<void (::Ice::Long)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getRowOffset(y, z, c, t, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getRowOffset(::Ice::Int y, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getRowOffset(y, z, c, t, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_getRowOffset(::Ice::Int y, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (::Ice::Long)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getRowOffset(y, z, c, t, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getRowOffset(::Ice::Int y, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getRowOffset(y, z, c, t, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_getRowOffset(::Ice::Int y, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (::Ice::Long)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (::Ice::Long)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::api::RawPixelsStorePrx __proxy = ::omero::api::RawPixelsStorePrx::uncheckedCast(__result->getProxy());
                ::Ice::Long __ret;
                try
                {
                    __ret = __proxy->end_getRowOffset(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (::Ice::Long)> _response;
        };
        return begin_getRowOffset(y, z, c, t, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_getRowOffset(::Ice::Int y, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t)
    {
        return begin_getRowOffset(y, z, c, t, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getRowOffset(::Ice::Int y, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::Ice::Context& __ctx)
    {
        return begin_getRowOffset(y, z, c, t, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getRowOffset(::Ice::Int y, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getRowOffset(y, z, c, t, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getRowOffset(::Ice::Int y, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getRowOffset(y, z, c, t, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getRowOffset(::Ice::Int y, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::omero::api::Callback_RawPixelsStore_getRowOffsetPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getRowOffset(y, z, c, t, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getRowOffset(::Ice::Int y, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::Ice::Context& __ctx, const ::omero::api::Callback_RawPixelsStore_getRowOffsetPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getRowOffset(y, z, c, t, &__ctx, __del, __cookie);
    }

    ::Ice::Long end_getRowOffset(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Long getRowOffset(::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getRowOffset(::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool getRowOffset_async(const ::omero::api::AMI_RawPixelsStore_getRowOffsetPtr&, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int);
    bool getRowOffset_async(const ::omero::api::AMI_RawPixelsStore_getRowOffsetPtr&, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Context&);

    ::Ice::Long getPlaneOffset(::Ice::Int z, ::Ice::Int c, ::Ice::Int t)
    {
        return getPlaneOffset(z, c, t, 0);
    }
    ::Ice::Long getPlaneOffset(::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::Ice::Context& __ctx)
    {
        return getPlaneOffset(z, c, t, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_getPlaneOffset(::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::IceInternal::Function<void (::Ice::Long)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getPlaneOffset(z, c, t, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getPlaneOffset(::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getPlaneOffset(z, c, t, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_getPlaneOffset(::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (::Ice::Long)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getPlaneOffset(z, c, t, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getPlaneOffset(::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getPlaneOffset(z, c, t, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_getPlaneOffset(::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (::Ice::Long)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (::Ice::Long)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::api::RawPixelsStorePrx __proxy = ::omero::api::RawPixelsStorePrx::uncheckedCast(__result->getProxy());
                ::Ice::Long __ret;
                try
                {
                    __ret = __proxy->end_getPlaneOffset(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (::Ice::Long)> _response;
        };
        return begin_getPlaneOffset(z, c, t, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_getPlaneOffset(::Ice::Int z, ::Ice::Int c, ::Ice::Int t)
    {
        return begin_getPlaneOffset(z, c, t, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getPlaneOffset(::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::Ice::Context& __ctx)
    {
        return begin_getPlaneOffset(z, c, t, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getPlaneOffset(::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getPlaneOffset(z, c, t, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getPlaneOffset(::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getPlaneOffset(z, c, t, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getPlaneOffset(::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::omero::api::Callback_RawPixelsStore_getPlaneOffsetPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getPlaneOffset(z, c, t, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getPlaneOffset(::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::Ice::Context& __ctx, const ::omero::api::Callback_RawPixelsStore_getPlaneOffsetPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getPlaneOffset(z, c, t, &__ctx, __del, __cookie);
    }

    ::Ice::Long end_getPlaneOffset(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Long getPlaneOffset(::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getPlaneOffset(::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool getPlaneOffset_async(const ::omero::api::AMI_RawPixelsStore_getPlaneOffsetPtr&, ::Ice::Int, ::Ice::Int, ::Ice::Int);
    bool getPlaneOffset_async(const ::omero::api::AMI_RawPixelsStore_getPlaneOffsetPtr&, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Context&);

    ::Ice::Long getStackOffset(::Ice::Int c, ::Ice::Int t)
    {
        return getStackOffset(c, t, 0);
    }
    ::Ice::Long getStackOffset(::Ice::Int c, ::Ice::Int t, const ::Ice::Context& __ctx)
    {
        return getStackOffset(c, t, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_getStackOffset(::Ice::Int c, ::Ice::Int t, const ::IceInternal::Function<void (::Ice::Long)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getStackOffset(c, t, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getStackOffset(::Ice::Int c, ::Ice::Int t, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getStackOffset(c, t, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_getStackOffset(::Ice::Int c, ::Ice::Int t, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (::Ice::Long)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getStackOffset(c, t, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getStackOffset(::Ice::Int c, ::Ice::Int t, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getStackOffset(c, t, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_getStackOffset(::Ice::Int c, ::Ice::Int t, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (::Ice::Long)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (::Ice::Long)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::api::RawPixelsStorePrx __proxy = ::omero::api::RawPixelsStorePrx::uncheckedCast(__result->getProxy());
                ::Ice::Long __ret;
                try
                {
                    __ret = __proxy->end_getStackOffset(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (::Ice::Long)> _response;
        };
        return begin_getStackOffset(c, t, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_getStackOffset(::Ice::Int c, ::Ice::Int t)
    {
        return begin_getStackOffset(c, t, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getStackOffset(::Ice::Int c, ::Ice::Int t, const ::Ice::Context& __ctx)
    {
        return begin_getStackOffset(c, t, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getStackOffset(::Ice::Int c, ::Ice::Int t, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getStackOffset(c, t, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getStackOffset(::Ice::Int c, ::Ice::Int t, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getStackOffset(c, t, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getStackOffset(::Ice::Int c, ::Ice::Int t, const ::omero::api::Callback_RawPixelsStore_getStackOffsetPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getStackOffset(c, t, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getStackOffset(::Ice::Int c, ::Ice::Int t, const ::Ice::Context& __ctx, const ::omero::api::Callback_RawPixelsStore_getStackOffsetPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getStackOffset(c, t, &__ctx, __del, __cookie);
    }

    ::Ice::Long end_getStackOffset(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Long getStackOffset(::Ice::Int, ::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getStackOffset(::Ice::Int, ::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool getStackOffset_async(const ::omero::api::AMI_RawPixelsStore_getStackOffsetPtr&, ::Ice::Int, ::Ice::Int);
    bool getStackOffset_async(const ::omero::api::AMI_RawPixelsStore_getStackOffsetPtr&, ::Ice::Int, ::Ice::Int, const ::Ice::Context&);

    ::Ice::Long getTimepointOffset(::Ice::Int t)
    {
        return getTimepointOffset(t, 0);
    }
    ::Ice::Long getTimepointOffset(::Ice::Int t, const ::Ice::Context& __ctx)
    {
        return getTimepointOffset(t, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_getTimepointOffset(::Ice::Int t, const ::IceInternal::Function<void (::Ice::Long)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getTimepointOffset(t, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getTimepointOffset(::Ice::Int t, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getTimepointOffset(t, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_getTimepointOffset(::Ice::Int t, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (::Ice::Long)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getTimepointOffset(t, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getTimepointOffset(::Ice::Int t, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getTimepointOffset(t, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_getTimepointOffset(::Ice::Int t, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (::Ice::Long)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (::Ice::Long)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::api::RawPixelsStorePrx __proxy = ::omero::api::RawPixelsStorePrx::uncheckedCast(__result->getProxy());
                ::Ice::Long __ret;
                try
                {
                    __ret = __proxy->end_getTimepointOffset(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (::Ice::Long)> _response;
        };
        return begin_getTimepointOffset(t, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_getTimepointOffset(::Ice::Int t)
    {
        return begin_getTimepointOffset(t, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getTimepointOffset(::Ice::Int t, const ::Ice::Context& __ctx)
    {
        return begin_getTimepointOffset(t, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getTimepointOffset(::Ice::Int t, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getTimepointOffset(t, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getTimepointOffset(::Ice::Int t, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getTimepointOffset(t, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getTimepointOffset(::Ice::Int t, const ::omero::api::Callback_RawPixelsStore_getTimepointOffsetPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getTimepointOffset(t, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getTimepointOffset(::Ice::Int t, const ::Ice::Context& __ctx, const ::omero::api::Callback_RawPixelsStore_getTimepointOffsetPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getTimepointOffset(t, &__ctx, __del, __cookie);
    }

    ::Ice::Long end_getTimepointOffset(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Long getTimepointOffset(::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getTimepointOffset(::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool getTimepointOffset_async(const ::omero::api::AMI_RawPixelsStore_getTimepointOffsetPtr&, ::Ice::Int);
    bool getTimepointOffset_async(const ::omero::api::AMI_RawPixelsStore_getTimepointOffsetPtr&, ::Ice::Int, const ::Ice::Context&);

    ::Ice::ByteSeq getTile(::Ice::Int z, ::Ice::Int c, ::Ice::Int t, ::Ice::Int x, ::Ice::Int y, ::Ice::Int w, ::Ice::Int h)
    {
        return getTile(z, c, t, x, y, w, h, 0);
    }
    ::Ice::ByteSeq getTile(::Ice::Int z, ::Ice::Int c, ::Ice::Int t, ::Ice::Int x, ::Ice::Int y, ::Ice::Int w, ::Ice::Int h, const ::Ice::Context& __ctx)
    {
        return getTile(z, c, t, x, y, w, h, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_getTile(::Ice::Int z, ::Ice::Int c, ::Ice::Int t, ::Ice::Int x, ::Ice::Int y, ::Ice::Int w, ::Ice::Int h, const ::IceInternal::Function<void (const ::Ice::ByteSeq&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getTile(z, c, t, x, y, w, h, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getTile(::Ice::Int z, ::Ice::Int c, ::Ice::Int t, ::Ice::Int x, ::Ice::Int y, ::Ice::Int w, ::Ice::Int h, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getTile(z, c, t, x, y, w, h, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_getTile(::Ice::Int z, ::Ice::Int c, ::Ice::Int t, ::Ice::Int x, ::Ice::Int y, ::Ice::Int w, ::Ice::Int h, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::ByteSeq&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getTile(z, c, t, x, y, w, h, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getTile(::Ice::Int z, ::Ice::Int c, ::Ice::Int t, ::Ice::Int x, ::Ice::Int y, ::Ice::Int w, ::Ice::Int h, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getTile(z, c, t, x, y, w, h, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_getTile(::Ice::Int z, ::Ice::Int c, ::Ice::Int t, ::Ice::Int x, ::Ice::Int y, ::Ice::Int w, ::Ice::Int h, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Ice::ByteSeq&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::Ice::ByteSeq&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::api::RawPixelsStorePrx __proxy = ::omero::api::RawPixelsStorePrx::uncheckedCast(__result->getProxy());
                ::Ice::ByteSeq __ret;
                try
                {
                    __ret = __proxy->end_getTile(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::Ice::ByteSeq&)> _response;
        };
        return begin_getTile(z, c, t, x, y, w, h, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_getTile(::Ice::Int z, ::Ice::Int c, ::Ice::Int t, ::Ice::Int x, ::Ice::Int y, ::Ice::Int w, ::Ice::Int h)
    {
        return begin_getTile(z, c, t, x, y, w, h, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getTile(::Ice::Int z, ::Ice::Int c, ::Ice::Int t, ::Ice::Int x, ::Ice::Int y, ::Ice::Int w, ::Ice::Int h, const ::Ice::Context& __ctx)
    {
        return begin_getTile(z, c, t, x, y, w, h, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getTile(::Ice::Int z, ::Ice::Int c, ::Ice::Int t, ::Ice::Int x, ::Ice::Int y, ::Ice::Int w, ::Ice::Int h, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getTile(z, c, t, x, y, w, h, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getTile(::Ice::Int z, ::Ice::Int c, ::Ice::Int t, ::Ice::Int x, ::Ice::Int y, ::Ice::Int w, ::Ice::Int h, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getTile(z, c, t, x, y, w, h, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getTile(::Ice::Int z, ::Ice::Int c, ::Ice::Int t, ::Ice::Int x, ::Ice::Int y, ::Ice::Int w, ::Ice::Int h, const ::omero::api::Callback_RawPixelsStore_getTilePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getTile(z, c, t, x, y, w, h, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getTile(::Ice::Int z, ::Ice::Int c, ::Ice::Int t, ::Ice::Int x, ::Ice::Int y, ::Ice::Int w, ::Ice::Int h, const ::Ice::Context& __ctx, const ::omero::api::Callback_RawPixelsStore_getTilePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getTile(z, c, t, x, y, w, h, &__ctx, __del, __cookie);
    }

    ::Ice::ByteSeq end_getTile(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::ByteSeq getTile(::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getTile(::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool getTile_async(const ::omero::api::AMI_RawPixelsStore_getTilePtr&, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int);
    bool getTile_async(const ::omero::api::AMI_RawPixelsStore_getTilePtr&, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Context&);

    ::Ice::ByteSeq getHypercube(const ::omero::sys::IntList& offset, const ::omero::sys::IntList& size, const ::omero::sys::IntList& step)
    {
        return getHypercube(offset, size, step, 0);
    }
    ::Ice::ByteSeq getHypercube(const ::omero::sys::IntList& offset, const ::omero::sys::IntList& size, const ::omero::sys::IntList& step, const ::Ice::Context& __ctx)
    {
        return getHypercube(offset, size, step, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_getHypercube(const ::omero::sys::IntList& offset, const ::omero::sys::IntList& size, const ::omero::sys::IntList& step, const ::IceInternal::Function<void (const ::Ice::ByteSeq&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getHypercube(offset, size, step, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getHypercube(const ::omero::sys::IntList& offset, const ::omero::sys::IntList& size, const ::omero::sys::IntList& step, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getHypercube(offset, size, step, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_getHypercube(const ::omero::sys::IntList& offset, const ::omero::sys::IntList& size, const ::omero::sys::IntList& step, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::ByteSeq&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getHypercube(offset, size, step, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getHypercube(const ::omero::sys::IntList& offset, const ::omero::sys::IntList& size, const ::omero::sys::IntList& step, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getHypercube(offset, size, step, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_getHypercube(const ::omero::sys::IntList& offset, const ::omero::sys::IntList& size, const ::omero::sys::IntList& step, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Ice::ByteSeq&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::Ice::ByteSeq&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::api::RawPixelsStorePrx __proxy = ::omero::api::RawPixelsStorePrx::uncheckedCast(__result->getProxy());
                ::Ice::ByteSeq __ret;
                try
                {
                    __ret = __proxy->end_getHypercube(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::Ice::ByteSeq&)> _response;
        };
        return begin_getHypercube(offset, size, step, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_getHypercube(const ::omero::sys::IntList& offset, const ::omero::sys::IntList& size, const ::omero::sys::IntList& step)
    {
        return begin_getHypercube(offset, size, step, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getHypercube(const ::omero::sys::IntList& offset, const ::omero::sys::IntList& size, const ::omero::sys::IntList& step, const ::Ice::Context& __ctx)
    {
        return begin_getHypercube(offset, size, step, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getHypercube(const ::omero::sys::IntList& offset, const ::omero::sys::IntList& size, const ::omero::sys::IntList& step, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getHypercube(offset, size, step, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getHypercube(const ::omero::sys::IntList& offset, const ::omero::sys::IntList& size, const ::omero::sys::IntList& step, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getHypercube(offset, size, step, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getHypercube(const ::omero::sys::IntList& offset, const ::omero::sys::IntList& size, const ::omero::sys::IntList& step, const ::omero::api::Callback_RawPixelsStore_getHypercubePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getHypercube(offset, size, step, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getHypercube(const ::omero::sys::IntList& offset, const ::omero::sys::IntList& size, const ::omero::sys::IntList& step, const ::Ice::Context& __ctx, const ::omero::api::Callback_RawPixelsStore_getHypercubePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getHypercube(offset, size, step, &__ctx, __del, __cookie);
    }

    ::Ice::ByteSeq end_getHypercube(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::ByteSeq getHypercube(const ::omero::sys::IntList&, const ::omero::sys::IntList&, const ::omero::sys::IntList&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getHypercube(const ::omero::sys::IntList&, const ::omero::sys::IntList&, const ::omero::sys::IntList&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool getHypercube_async(const ::omero::api::AMI_RawPixelsStore_getHypercubePtr&, const ::omero::sys::IntList&, const ::omero::sys::IntList&, const ::omero::sys::IntList&);
    bool getHypercube_async(const ::omero::api::AMI_RawPixelsStore_getHypercubePtr&, const ::omero::sys::IntList&, const ::omero::sys::IntList&, const ::omero::sys::IntList&, const ::Ice::Context&);

    ::Ice::ByteSeq getRegion(::Ice::Int size, ::Ice::Long offset)
    {
        return getRegion(size, offset, 0);
    }
    ::Ice::ByteSeq getRegion(::Ice::Int size, ::Ice::Long offset, const ::Ice::Context& __ctx)
    {
        return getRegion(size, offset, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_getRegion(::Ice::Int size, ::Ice::Long offset, const ::IceInternal::Function<void (const ::Ice::ByteSeq&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getRegion(size, offset, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getRegion(::Ice::Int size, ::Ice::Long offset, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getRegion(size, offset, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_getRegion(::Ice::Int size, ::Ice::Long offset, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::ByteSeq&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getRegion(size, offset, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getRegion(::Ice::Int size, ::Ice::Long offset, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getRegion(size, offset, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_getRegion(::Ice::Int size, ::Ice::Long offset, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Ice::ByteSeq&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::Ice::ByteSeq&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::api::RawPixelsStorePrx __proxy = ::omero::api::RawPixelsStorePrx::uncheckedCast(__result->getProxy());
                ::Ice::ByteSeq __ret;
                try
                {
                    __ret = __proxy->end_getRegion(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::Ice::ByteSeq&)> _response;
        };
        return begin_getRegion(size, offset, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_getRegion(::Ice::Int size, ::Ice::Long offset)
    {
        return begin_getRegion(size, offset, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getRegion(::Ice::Int size, ::Ice::Long offset, const ::Ice::Context& __ctx)
    {
        return begin_getRegion(size, offset, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getRegion(::Ice::Int size, ::Ice::Long offset, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getRegion(size, offset, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getRegion(::Ice::Int size, ::Ice::Long offset, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getRegion(size, offset, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getRegion(::Ice::Int size, ::Ice::Long offset, const ::omero::api::Callback_RawPixelsStore_getRegionPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getRegion(size, offset, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getRegion(::Ice::Int size, ::Ice::Long offset, const ::Ice::Context& __ctx, const ::omero::api::Callback_RawPixelsStore_getRegionPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getRegion(size, offset, &__ctx, __del, __cookie);
    }

    ::Ice::ByteSeq end_getRegion(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::ByteSeq getRegion(::Ice::Int, ::Ice::Long, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getRegion(::Ice::Int, ::Ice::Long, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool getRegion_async(const ::omero::api::AMI_RawPixelsStore_getRegionPtr&, ::Ice::Int, ::Ice::Long);
    bool getRegion_async(const ::omero::api::AMI_RawPixelsStore_getRegionPtr&, ::Ice::Int, ::Ice::Long, const ::Ice::Context&);

    ::Ice::ByteSeq getRow(::Ice::Int y, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t)
    {
        return getRow(y, z, c, t, 0);
    }
    ::Ice::ByteSeq getRow(::Ice::Int y, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::Ice::Context& __ctx)
    {
        return getRow(y, z, c, t, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_getRow(::Ice::Int y, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::IceInternal::Function<void (const ::Ice::ByteSeq&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getRow(y, z, c, t, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getRow(::Ice::Int y, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getRow(y, z, c, t, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_getRow(::Ice::Int y, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::ByteSeq&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getRow(y, z, c, t, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getRow(::Ice::Int y, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getRow(y, z, c, t, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_getRow(::Ice::Int y, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Ice::ByteSeq&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::Ice::ByteSeq&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::api::RawPixelsStorePrx __proxy = ::omero::api::RawPixelsStorePrx::uncheckedCast(__result->getProxy());
                ::Ice::ByteSeq __ret;
                try
                {
                    __ret = __proxy->end_getRow(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::Ice::ByteSeq&)> _response;
        };
        return begin_getRow(y, z, c, t, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_getRow(::Ice::Int y, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t)
    {
        return begin_getRow(y, z, c, t, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getRow(::Ice::Int y, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::Ice::Context& __ctx)
    {
        return begin_getRow(y, z, c, t, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getRow(::Ice::Int y, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getRow(y, z, c, t, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getRow(::Ice::Int y, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getRow(y, z, c, t, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getRow(::Ice::Int y, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::omero::api::Callback_RawPixelsStore_getRowPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getRow(y, z, c, t, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getRow(::Ice::Int y, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::Ice::Context& __ctx, const ::omero::api::Callback_RawPixelsStore_getRowPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getRow(y, z, c, t, &__ctx, __del, __cookie);
    }

    ::Ice::ByteSeq end_getRow(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::ByteSeq getRow(::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getRow(::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool getRow_async(const ::omero::api::AMI_RawPixelsStore_getRowPtr&, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int);
    bool getRow_async(const ::omero::api::AMI_RawPixelsStore_getRowPtr&, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Context&);

    ::Ice::ByteSeq getCol(::Ice::Int x, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t)
    {
        return getCol(x, z, c, t, 0);
    }
    ::Ice::ByteSeq getCol(::Ice::Int x, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::Ice::Context& __ctx)
    {
        return getCol(x, z, c, t, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_getCol(::Ice::Int x, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::IceInternal::Function<void (const ::Ice::ByteSeq&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getCol(x, z, c, t, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getCol(::Ice::Int x, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getCol(x, z, c, t, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_getCol(::Ice::Int x, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::ByteSeq&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getCol(x, z, c, t, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getCol(::Ice::Int x, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getCol(x, z, c, t, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_getCol(::Ice::Int x, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Ice::ByteSeq&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::Ice::ByteSeq&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::api::RawPixelsStorePrx __proxy = ::omero::api::RawPixelsStorePrx::uncheckedCast(__result->getProxy());
                ::Ice::ByteSeq __ret;
                try
                {
                    __ret = __proxy->end_getCol(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::Ice::ByteSeq&)> _response;
        };
        return begin_getCol(x, z, c, t, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_getCol(::Ice::Int x, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t)
    {
        return begin_getCol(x, z, c, t, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getCol(::Ice::Int x, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::Ice::Context& __ctx)
    {
        return begin_getCol(x, z, c, t, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getCol(::Ice::Int x, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getCol(x, z, c, t, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getCol(::Ice::Int x, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getCol(x, z, c, t, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getCol(::Ice::Int x, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::omero::api::Callback_RawPixelsStore_getColPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getCol(x, z, c, t, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getCol(::Ice::Int x, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::Ice::Context& __ctx, const ::omero::api::Callback_RawPixelsStore_getColPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getCol(x, z, c, t, &__ctx, __del, __cookie);
    }

    ::Ice::ByteSeq end_getCol(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::ByteSeq getCol(::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getCol(::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool getCol_async(const ::omero::api::AMI_RawPixelsStore_getColPtr&, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int);
    bool getCol_async(const ::omero::api::AMI_RawPixelsStore_getColPtr&, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Context&);

    ::Ice::ByteSeq getPlane(::Ice::Int z, ::Ice::Int c, ::Ice::Int t)
    {
        return getPlane(z, c, t, 0);
    }
    ::Ice::ByteSeq getPlane(::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::Ice::Context& __ctx)
    {
        return getPlane(z, c, t, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_getPlane(::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::IceInternal::Function<void (const ::Ice::ByteSeq&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getPlane(z, c, t, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getPlane(::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getPlane(z, c, t, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_getPlane(::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::ByteSeq&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getPlane(z, c, t, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getPlane(::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getPlane(z, c, t, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_getPlane(::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Ice::ByteSeq&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::Ice::ByteSeq&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::api::RawPixelsStorePrx __proxy = ::omero::api::RawPixelsStorePrx::uncheckedCast(__result->getProxy());
                ::Ice::ByteSeq __ret;
                try
                {
                    __ret = __proxy->end_getPlane(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::Ice::ByteSeq&)> _response;
        };
        return begin_getPlane(z, c, t, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_getPlane(::Ice::Int z, ::Ice::Int c, ::Ice::Int t)
    {
        return begin_getPlane(z, c, t, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getPlane(::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::Ice::Context& __ctx)
    {
        return begin_getPlane(z, c, t, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getPlane(::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getPlane(z, c, t, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getPlane(::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getPlane(z, c, t, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getPlane(::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::omero::api::Callback_RawPixelsStore_getPlanePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getPlane(z, c, t, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getPlane(::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::Ice::Context& __ctx, const ::omero::api::Callback_RawPixelsStore_getPlanePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getPlane(z, c, t, &__ctx, __del, __cookie);
    }

    ::Ice::ByteSeq end_getPlane(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::ByteSeq getPlane(::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getPlane(::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool getPlane_async(const ::omero::api::AMI_RawPixelsStore_getPlanePtr&, ::Ice::Int, ::Ice::Int, ::Ice::Int);
    bool getPlane_async(const ::omero::api::AMI_RawPixelsStore_getPlanePtr&, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Context&);

    ::Ice::ByteSeq getPlaneRegion(::Ice::Int z, ::Ice::Int c, ::Ice::Int t, ::Ice::Int size, ::Ice::Int offset)
    {
        return getPlaneRegion(z, c, t, size, offset, 0);
    }
    ::Ice::ByteSeq getPlaneRegion(::Ice::Int z, ::Ice::Int c, ::Ice::Int t, ::Ice::Int size, ::Ice::Int offset, const ::Ice::Context& __ctx)
    {
        return getPlaneRegion(z, c, t, size, offset, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_getPlaneRegion(::Ice::Int z, ::Ice::Int c, ::Ice::Int t, ::Ice::Int size, ::Ice::Int offset, const ::IceInternal::Function<void (const ::Ice::ByteSeq&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getPlaneRegion(z, c, t, size, offset, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getPlaneRegion(::Ice::Int z, ::Ice::Int c, ::Ice::Int t, ::Ice::Int size, ::Ice::Int offset, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getPlaneRegion(z, c, t, size, offset, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_getPlaneRegion(::Ice::Int z, ::Ice::Int c, ::Ice::Int t, ::Ice::Int size, ::Ice::Int offset, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::ByteSeq&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getPlaneRegion(z, c, t, size, offset, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getPlaneRegion(::Ice::Int z, ::Ice::Int c, ::Ice::Int t, ::Ice::Int size, ::Ice::Int offset, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getPlaneRegion(z, c, t, size, offset, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_getPlaneRegion(::Ice::Int z, ::Ice::Int c, ::Ice::Int t, ::Ice::Int size, ::Ice::Int offset, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Ice::ByteSeq&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::Ice::ByteSeq&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::api::RawPixelsStorePrx __proxy = ::omero::api::RawPixelsStorePrx::uncheckedCast(__result->getProxy());
                ::Ice::ByteSeq __ret;
                try
                {
                    __ret = __proxy->end_getPlaneRegion(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::Ice::ByteSeq&)> _response;
        };
        return begin_getPlaneRegion(z, c, t, size, offset, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_getPlaneRegion(::Ice::Int z, ::Ice::Int c, ::Ice::Int t, ::Ice::Int size, ::Ice::Int offset)
    {
        return begin_getPlaneRegion(z, c, t, size, offset, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getPlaneRegion(::Ice::Int z, ::Ice::Int c, ::Ice::Int t, ::Ice::Int size, ::Ice::Int offset, const ::Ice::Context& __ctx)
    {
        return begin_getPlaneRegion(z, c, t, size, offset, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getPlaneRegion(::Ice::Int z, ::Ice::Int c, ::Ice::Int t, ::Ice::Int size, ::Ice::Int offset, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getPlaneRegion(z, c, t, size, offset, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getPlaneRegion(::Ice::Int z, ::Ice::Int c, ::Ice::Int t, ::Ice::Int size, ::Ice::Int offset, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getPlaneRegion(z, c, t, size, offset, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getPlaneRegion(::Ice::Int z, ::Ice::Int c, ::Ice::Int t, ::Ice::Int size, ::Ice::Int offset, const ::omero::api::Callback_RawPixelsStore_getPlaneRegionPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getPlaneRegion(z, c, t, size, offset, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getPlaneRegion(::Ice::Int z, ::Ice::Int c, ::Ice::Int t, ::Ice::Int size, ::Ice::Int offset, const ::Ice::Context& __ctx, const ::omero::api::Callback_RawPixelsStore_getPlaneRegionPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getPlaneRegion(z, c, t, size, offset, &__ctx, __del, __cookie);
    }

    ::Ice::ByteSeq end_getPlaneRegion(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::ByteSeq getPlaneRegion(::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getPlaneRegion(::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool getPlaneRegion_async(const ::omero::api::AMI_RawPixelsStore_getPlaneRegionPtr&, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int);
    bool getPlaneRegion_async(const ::omero::api::AMI_RawPixelsStore_getPlaneRegionPtr&, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Context&);

    ::Ice::ByteSeq getStack(::Ice::Int c, ::Ice::Int t)
    {
        return getStack(c, t, 0);
    }
    ::Ice::ByteSeq getStack(::Ice::Int c, ::Ice::Int t, const ::Ice::Context& __ctx)
    {
        return getStack(c, t, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_getStack(::Ice::Int c, ::Ice::Int t, const ::IceInternal::Function<void (const ::Ice::ByteSeq&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getStack(c, t, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getStack(::Ice::Int c, ::Ice::Int t, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getStack(c, t, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_getStack(::Ice::Int c, ::Ice::Int t, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::ByteSeq&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getStack(c, t, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getStack(::Ice::Int c, ::Ice::Int t, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getStack(c, t, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_getStack(::Ice::Int c, ::Ice::Int t, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Ice::ByteSeq&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::Ice::ByteSeq&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::api::RawPixelsStorePrx __proxy = ::omero::api::RawPixelsStorePrx::uncheckedCast(__result->getProxy());
                ::Ice::ByteSeq __ret;
                try
                {
                    __ret = __proxy->end_getStack(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::Ice::ByteSeq&)> _response;
        };
        return begin_getStack(c, t, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_getStack(::Ice::Int c, ::Ice::Int t)
    {
        return begin_getStack(c, t, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getStack(::Ice::Int c, ::Ice::Int t, const ::Ice::Context& __ctx)
    {
        return begin_getStack(c, t, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getStack(::Ice::Int c, ::Ice::Int t, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getStack(c, t, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getStack(::Ice::Int c, ::Ice::Int t, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getStack(c, t, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getStack(::Ice::Int c, ::Ice::Int t, const ::omero::api::Callback_RawPixelsStore_getStackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getStack(c, t, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getStack(::Ice::Int c, ::Ice::Int t, const ::Ice::Context& __ctx, const ::omero::api::Callback_RawPixelsStore_getStackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getStack(c, t, &__ctx, __del, __cookie);
    }

    ::Ice::ByteSeq end_getStack(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::ByteSeq getStack(::Ice::Int, ::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getStack(::Ice::Int, ::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool getStack_async(const ::omero::api::AMI_RawPixelsStore_getStackPtr&, ::Ice::Int, ::Ice::Int);
    bool getStack_async(const ::omero::api::AMI_RawPixelsStore_getStackPtr&, ::Ice::Int, ::Ice::Int, const ::Ice::Context&);

    ::Ice::ByteSeq getTimepoint(::Ice::Int t)
    {
        return getTimepoint(t, 0);
    }
    ::Ice::ByteSeq getTimepoint(::Ice::Int t, const ::Ice::Context& __ctx)
    {
        return getTimepoint(t, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_getTimepoint(::Ice::Int t, const ::IceInternal::Function<void (const ::Ice::ByteSeq&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getTimepoint(t, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getTimepoint(::Ice::Int t, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getTimepoint(t, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_getTimepoint(::Ice::Int t, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::ByteSeq&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getTimepoint(t, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getTimepoint(::Ice::Int t, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getTimepoint(t, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_getTimepoint(::Ice::Int t, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Ice::ByteSeq&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::Ice::ByteSeq&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::api::RawPixelsStorePrx __proxy = ::omero::api::RawPixelsStorePrx::uncheckedCast(__result->getProxy());
                ::Ice::ByteSeq __ret;
                try
                {
                    __ret = __proxy->end_getTimepoint(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::Ice::ByteSeq&)> _response;
        };
        return begin_getTimepoint(t, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_getTimepoint(::Ice::Int t)
    {
        return begin_getTimepoint(t, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getTimepoint(::Ice::Int t, const ::Ice::Context& __ctx)
    {
        return begin_getTimepoint(t, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getTimepoint(::Ice::Int t, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getTimepoint(t, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getTimepoint(::Ice::Int t, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getTimepoint(t, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getTimepoint(::Ice::Int t, const ::omero::api::Callback_RawPixelsStore_getTimepointPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getTimepoint(t, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getTimepoint(::Ice::Int t, const ::Ice::Context& __ctx, const ::omero::api::Callback_RawPixelsStore_getTimepointPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getTimepoint(t, &__ctx, __del, __cookie);
    }

    ::Ice::ByteSeq end_getTimepoint(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::ByteSeq getTimepoint(::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getTimepoint(::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool getTimepoint_async(const ::omero::api::AMI_RawPixelsStore_getTimepointPtr&, ::Ice::Int);
    bool getTimepoint_async(const ::omero::api::AMI_RawPixelsStore_getTimepointPtr&, ::Ice::Int, const ::Ice::Context&);

    void setTile(const ::Ice::ByteSeq& buf, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t, ::Ice::Int x, ::Ice::Int y, ::Ice::Int w, ::Ice::Int h)
    {
        setTile(buf, z, c, t, x, y, w, h, 0);
    }
    void setTile(const ::Ice::ByteSeq& buf, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t, ::Ice::Int x, ::Ice::Int y, ::Ice::Int w, ::Ice::Int h, const ::Ice::Context& __ctx)
    {
        setTile(buf, z, c, t, x, y, w, h, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_setTile(const ::Ice::ByteSeq& buf, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t, ::Ice::Int x, ::Ice::Int y, ::Ice::Int w, ::Ice::Int h, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_setTile(buf, z, c, t, x, y, w, h, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_setTile(const ::Ice::ByteSeq& buf, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t, ::Ice::Int x, ::Ice::Int y, ::Ice::Int w, ::Ice::Int h, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_setTile(buf, z, c, t, x, y, w, h, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_setTile(const ::Ice::ByteSeq& buf, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t, ::Ice::Int x, ::Ice::Int y, ::Ice::Int w, ::Ice::Int h, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_setTile(buf, z, c, t, x, y, w, h, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_setTile(const ::Ice::ByteSeq& buf, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t, ::Ice::Int x, ::Ice::Int y, ::Ice::Int w, ::Ice::Int h, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_setTile(buf, z, c, t, x, y, w, h, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_setTile(const ::Ice::ByteSeq& buf, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t, ::Ice::Int x, ::Ice::Int y, ::Ice::Int w, ::Ice::Int h, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::api::RawPixelsStorePrx __proxy = ::omero::api::RawPixelsStorePrx::uncheckedCast(__result->getProxy());
                try
                {
                    __proxy->end_setTile(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response();
                }
            }
        
        private:
            
            ::std::function<void ()> _response;
        };
        return begin_setTile(buf, z, c, t, x, y, w, h, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_setTile(const ::Ice::ByteSeq& buf, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t, ::Ice::Int x, ::Ice::Int y, ::Ice::Int w, ::Ice::Int h)
    {
        return begin_setTile(buf, z, c, t, x, y, w, h, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setTile(const ::Ice::ByteSeq& buf, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t, ::Ice::Int x, ::Ice::Int y, ::Ice::Int w, ::Ice::Int h, const ::Ice::Context& __ctx)
    {
        return begin_setTile(buf, z, c, t, x, y, w, h, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setTile(const ::Ice::ByteSeq& buf, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t, ::Ice::Int x, ::Ice::Int y, ::Ice::Int w, ::Ice::Int h, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setTile(buf, z, c, t, x, y, w, h, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setTile(const ::Ice::ByteSeq& buf, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t, ::Ice::Int x, ::Ice::Int y, ::Ice::Int w, ::Ice::Int h, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setTile(buf, z, c, t, x, y, w, h, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setTile(const ::Ice::ByteSeq& buf, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t, ::Ice::Int x, ::Ice::Int y, ::Ice::Int w, ::Ice::Int h, const ::omero::api::Callback_RawPixelsStore_setTilePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setTile(buf, z, c, t, x, y, w, h, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setTile(const ::Ice::ByteSeq& buf, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t, ::Ice::Int x, ::Ice::Int y, ::Ice::Int w, ::Ice::Int h, const ::Ice::Context& __ctx, const ::omero::api::Callback_RawPixelsStore_setTilePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setTile(buf, z, c, t, x, y, w, h, &__ctx, __del, __cookie);
    }

    void end_setTile(const ::Ice::AsyncResultPtr&);
    
private:

    void setTile(const ::Ice::ByteSeq&, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setTile(const ::Ice::ByteSeq&, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool setTile_async(const ::omero::api::AMI_RawPixelsStore_setTilePtr&, const ::Ice::ByteSeq&, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int);
    bool setTile_async(const ::omero::api::AMI_RawPixelsStore_setTilePtr&, const ::Ice::ByteSeq&, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Context&);

    void setRegion(::Ice::Int size, ::Ice::Long offset, const ::Ice::ByteSeq& buf)
    {
        setRegion(size, offset, buf, 0);
    }
    void setRegion(::Ice::Int size, ::Ice::Long offset, const ::Ice::ByteSeq& buf, const ::Ice::Context& __ctx)
    {
        setRegion(size, offset, buf, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_setRegion(::Ice::Int size, ::Ice::Long offset, const ::Ice::ByteSeq& buf, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_setRegion(size, offset, buf, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_setRegion(::Ice::Int size, ::Ice::Long offset, const ::Ice::ByteSeq& buf, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_setRegion(size, offset, buf, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_setRegion(::Ice::Int size, ::Ice::Long offset, const ::Ice::ByteSeq& buf, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_setRegion(size, offset, buf, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_setRegion(::Ice::Int size, ::Ice::Long offset, const ::Ice::ByteSeq& buf, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_setRegion(size, offset, buf, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_setRegion(::Ice::Int size, ::Ice::Long offset, const ::Ice::ByteSeq& buf, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::api::RawPixelsStorePrx __proxy = ::omero::api::RawPixelsStorePrx::uncheckedCast(__result->getProxy());
                try
                {
                    __proxy->end_setRegion(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response();
                }
            }
        
        private:
            
            ::std::function<void ()> _response;
        };
        return begin_setRegion(size, offset, buf, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_setRegion(::Ice::Int size, ::Ice::Long offset, const ::Ice::ByteSeq& buf)
    {
        return begin_setRegion(size, offset, buf, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setRegion(::Ice::Int size, ::Ice::Long offset, const ::Ice::ByteSeq& buf, const ::Ice::Context& __ctx)
    {
        return begin_setRegion(size, offset, buf, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setRegion(::Ice::Int size, ::Ice::Long offset, const ::Ice::ByteSeq& buf, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setRegion(size, offset, buf, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setRegion(::Ice::Int size, ::Ice::Long offset, const ::Ice::ByteSeq& buf, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setRegion(size, offset, buf, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setRegion(::Ice::Int size, ::Ice::Long offset, const ::Ice::ByteSeq& buf, const ::omero::api::Callback_RawPixelsStore_setRegionPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setRegion(size, offset, buf, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setRegion(::Ice::Int size, ::Ice::Long offset, const ::Ice::ByteSeq& buf, const ::Ice::Context& __ctx, const ::omero::api::Callback_RawPixelsStore_setRegionPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setRegion(size, offset, buf, &__ctx, __del, __cookie);
    }

    void end_setRegion(const ::Ice::AsyncResultPtr&);
    
private:

    void setRegion(::Ice::Int, ::Ice::Long, const ::Ice::ByteSeq&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setRegion(::Ice::Int, ::Ice::Long, const ::Ice::ByteSeq&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool setRegion_async(const ::omero::api::AMI_RawPixelsStore_setRegionPtr&, ::Ice::Int, ::Ice::Long, const ::Ice::ByteSeq&);
    bool setRegion_async(const ::omero::api::AMI_RawPixelsStore_setRegionPtr&, ::Ice::Int, ::Ice::Long, const ::Ice::ByteSeq&, const ::Ice::Context&);

    void setRow(const ::Ice::ByteSeq& buf, ::Ice::Int y, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t)
    {
        setRow(buf, y, z, c, t, 0);
    }
    void setRow(const ::Ice::ByteSeq& buf, ::Ice::Int y, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::Ice::Context& __ctx)
    {
        setRow(buf, y, z, c, t, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_setRow(const ::Ice::ByteSeq& buf, ::Ice::Int y, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_setRow(buf, y, z, c, t, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_setRow(const ::Ice::ByteSeq& buf, ::Ice::Int y, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_setRow(buf, y, z, c, t, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_setRow(const ::Ice::ByteSeq& buf, ::Ice::Int y, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_setRow(buf, y, z, c, t, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_setRow(const ::Ice::ByteSeq& buf, ::Ice::Int y, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_setRow(buf, y, z, c, t, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_setRow(const ::Ice::ByteSeq& buf, ::Ice::Int y, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::api::RawPixelsStorePrx __proxy = ::omero::api::RawPixelsStorePrx::uncheckedCast(__result->getProxy());
                try
                {
                    __proxy->end_setRow(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response();
                }
            }
        
        private:
            
            ::std::function<void ()> _response;
        };
        return begin_setRow(buf, y, z, c, t, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_setRow(const ::Ice::ByteSeq& buf, ::Ice::Int y, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t)
    {
        return begin_setRow(buf, y, z, c, t, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setRow(const ::Ice::ByteSeq& buf, ::Ice::Int y, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::Ice::Context& __ctx)
    {
        return begin_setRow(buf, y, z, c, t, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setRow(const ::Ice::ByteSeq& buf, ::Ice::Int y, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setRow(buf, y, z, c, t, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setRow(const ::Ice::ByteSeq& buf, ::Ice::Int y, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setRow(buf, y, z, c, t, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setRow(const ::Ice::ByteSeq& buf, ::Ice::Int y, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::omero::api::Callback_RawPixelsStore_setRowPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setRow(buf, y, z, c, t, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setRow(const ::Ice::ByteSeq& buf, ::Ice::Int y, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::Ice::Context& __ctx, const ::omero::api::Callback_RawPixelsStore_setRowPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setRow(buf, y, z, c, t, &__ctx, __del, __cookie);
    }

    void end_setRow(const ::Ice::AsyncResultPtr&);
    
private:

    void setRow(const ::Ice::ByteSeq&, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setRow(const ::Ice::ByteSeq&, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool setRow_async(const ::omero::api::AMI_RawPixelsStore_setRowPtr&, const ::Ice::ByteSeq&, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int);
    bool setRow_async(const ::omero::api::AMI_RawPixelsStore_setRowPtr&, const ::Ice::ByteSeq&, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Context&);

    void setPlane(const ::Ice::ByteSeq& buf, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t)
    {
        setPlane(buf, z, c, t, 0);
    }
    void setPlane(const ::Ice::ByteSeq& buf, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::Ice::Context& __ctx)
    {
        setPlane(buf, z, c, t, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_setPlane(const ::Ice::ByteSeq& buf, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_setPlane(buf, z, c, t, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_setPlane(const ::Ice::ByteSeq& buf, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_setPlane(buf, z, c, t, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_setPlane(const ::Ice::ByteSeq& buf, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_setPlane(buf, z, c, t, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_setPlane(const ::Ice::ByteSeq& buf, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_setPlane(buf, z, c, t, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_setPlane(const ::Ice::ByteSeq& buf, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::api::RawPixelsStorePrx __proxy = ::omero::api::RawPixelsStorePrx::uncheckedCast(__result->getProxy());
                try
                {
                    __proxy->end_setPlane(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response();
                }
            }
        
        private:
            
            ::std::function<void ()> _response;
        };
        return begin_setPlane(buf, z, c, t, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_setPlane(const ::Ice::ByteSeq& buf, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t)
    {
        return begin_setPlane(buf, z, c, t, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setPlane(const ::Ice::ByteSeq& buf, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::Ice::Context& __ctx)
    {
        return begin_setPlane(buf, z, c, t, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setPlane(const ::Ice::ByteSeq& buf, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setPlane(buf, z, c, t, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setPlane(const ::Ice::ByteSeq& buf, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setPlane(buf, z, c, t, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setPlane(const ::Ice::ByteSeq& buf, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::omero::api::Callback_RawPixelsStore_setPlanePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setPlane(buf, z, c, t, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setPlane(const ::Ice::ByteSeq& buf, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::Ice::Context& __ctx, const ::omero::api::Callback_RawPixelsStore_setPlanePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setPlane(buf, z, c, t, &__ctx, __del, __cookie);
    }

    void end_setPlane(const ::Ice::AsyncResultPtr&);
    
private:

    void setPlane(const ::Ice::ByteSeq&, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setPlane(const ::Ice::ByteSeq&, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool setPlane_async(const ::omero::api::AMI_RawPixelsStore_setPlanePtr&, const ::Ice::ByteSeq&, ::Ice::Int, ::Ice::Int, ::Ice::Int);
    bool setPlane_async(const ::omero::api::AMI_RawPixelsStore_setPlanePtr&, const ::Ice::ByteSeq&, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Context&);

    void setStack(const ::Ice::ByteSeq& buf, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t)
    {
        setStack(buf, z, c, t, 0);
    }
    void setStack(const ::Ice::ByteSeq& buf, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::Ice::Context& __ctx)
    {
        setStack(buf, z, c, t, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_setStack(const ::Ice::ByteSeq& buf, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_setStack(buf, z, c, t, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_setStack(const ::Ice::ByteSeq& buf, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_setStack(buf, z, c, t, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_setStack(const ::Ice::ByteSeq& buf, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_setStack(buf, z, c, t, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_setStack(const ::Ice::ByteSeq& buf, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_setStack(buf, z, c, t, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_setStack(const ::Ice::ByteSeq& buf, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::api::RawPixelsStorePrx __proxy = ::omero::api::RawPixelsStorePrx::uncheckedCast(__result->getProxy());
                try
                {
                    __proxy->end_setStack(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response();
                }
            }
        
        private:
            
            ::std::function<void ()> _response;
        };
        return begin_setStack(buf, z, c, t, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_setStack(const ::Ice::ByteSeq& buf, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t)
    {
        return begin_setStack(buf, z, c, t, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setStack(const ::Ice::ByteSeq& buf, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::Ice::Context& __ctx)
    {
        return begin_setStack(buf, z, c, t, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setStack(const ::Ice::ByteSeq& buf, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setStack(buf, z, c, t, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setStack(const ::Ice::ByteSeq& buf, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setStack(buf, z, c, t, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setStack(const ::Ice::ByteSeq& buf, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::omero::api::Callback_RawPixelsStore_setStackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setStack(buf, z, c, t, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setStack(const ::Ice::ByteSeq& buf, ::Ice::Int z, ::Ice::Int c, ::Ice::Int t, const ::Ice::Context& __ctx, const ::omero::api::Callback_RawPixelsStore_setStackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setStack(buf, z, c, t, &__ctx, __del, __cookie);
    }

    void end_setStack(const ::Ice::AsyncResultPtr&);
    
private:

    void setStack(const ::Ice::ByteSeq&, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setStack(const ::Ice::ByteSeq&, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool setStack_async(const ::omero::api::AMI_RawPixelsStore_setStackPtr&, const ::Ice::ByteSeq&, ::Ice::Int, ::Ice::Int, ::Ice::Int);
    bool setStack_async(const ::omero::api::AMI_RawPixelsStore_setStackPtr&, const ::Ice::ByteSeq&, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Context&);

    void setTimepoint(const ::Ice::ByteSeq& buf, ::Ice::Int t)
    {
        setTimepoint(buf, t, 0);
    }
    void setTimepoint(const ::Ice::ByteSeq& buf, ::Ice::Int t, const ::Ice::Context& __ctx)
    {
        setTimepoint(buf, t, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_setTimepoint(const ::Ice::ByteSeq& buf, ::Ice::Int t, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_setTimepoint(buf, t, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_setTimepoint(const ::Ice::ByteSeq& buf, ::Ice::Int t, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_setTimepoint(buf, t, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_setTimepoint(const ::Ice::ByteSeq& buf, ::Ice::Int t, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_setTimepoint(buf, t, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_setTimepoint(const ::Ice::ByteSeq& buf, ::Ice::Int t, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_setTimepoint(buf, t, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_setTimepoint(const ::Ice::ByteSeq& buf, ::Ice::Int t, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::api::RawPixelsStorePrx __proxy = ::omero::api::RawPixelsStorePrx::uncheckedCast(__result->getProxy());
                try
                {
                    __proxy->end_setTimepoint(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response();
                }
            }
        
        private:
            
            ::std::function<void ()> _response;
        };
        return begin_setTimepoint(buf, t, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_setTimepoint(const ::Ice::ByteSeq& buf, ::Ice::Int t)
    {
        return begin_setTimepoint(buf, t, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setTimepoint(const ::Ice::ByteSeq& buf, ::Ice::Int t, const ::Ice::Context& __ctx)
    {
        return begin_setTimepoint(buf, t, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setTimepoint(const ::Ice::ByteSeq& buf, ::Ice::Int t, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setTimepoint(buf, t, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setTimepoint(const ::Ice::ByteSeq& buf, ::Ice::Int t, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setTimepoint(buf, t, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setTimepoint(const ::Ice::ByteSeq& buf, ::Ice::Int t, const ::omero::api::Callback_RawPixelsStore_setTimepointPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setTimepoint(buf, t, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setTimepoint(const ::Ice::ByteSeq& buf, ::Ice::Int t, const ::Ice::Context& __ctx, const ::omero::api::Callback_RawPixelsStore_setTimepointPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setTimepoint(buf, t, &__ctx, __del, __cookie);
    }

    void end_setTimepoint(const ::Ice::AsyncResultPtr&);
    
private:

    void setTimepoint(const ::Ice::ByteSeq&, ::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setTimepoint(const ::Ice::ByteSeq&, ::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool setTimepoint_async(const ::omero::api::AMI_RawPixelsStore_setTimepointPtr&, const ::Ice::ByteSeq&, ::Ice::Int);
    bool setTimepoint_async(const ::omero::api::AMI_RawPixelsStore_setTimepointPtr&, const ::Ice::ByteSeq&, ::Ice::Int, const ::Ice::Context&);

    ::Ice::Int getByteWidth()
    {
        return getByteWidth(0);
    }
    ::Ice::Int getByteWidth(const ::Ice::Context& __ctx)
    {
        return getByteWidth(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_getByteWidth(const ::IceInternal::Function<void (::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getByteWidth(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getByteWidth(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getByteWidth(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_getByteWidth(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getByteWidth(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getByteWidth(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getByteWidth(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_getByteWidth(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (::Ice::Int)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::api::RawPixelsStorePrx __proxy = ::omero::api::RawPixelsStorePrx::uncheckedCast(__result->getProxy());
                ::Ice::Int __ret;
                try
                {
                    __ret = __proxy->end_getByteWidth(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (::Ice::Int)> _response;
        };
        return begin_getByteWidth(__ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_getByteWidth()
    {
        return begin_getByteWidth(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getByteWidth(const ::Ice::Context& __ctx)
    {
        return begin_getByteWidth(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getByteWidth(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getByteWidth(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getByteWidth(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getByteWidth(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getByteWidth(const ::omero::api::Callback_RawPixelsStore_getByteWidthPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getByteWidth(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getByteWidth(const ::Ice::Context& __ctx, const ::omero::api::Callback_RawPixelsStore_getByteWidthPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getByteWidth(&__ctx, __del, __cookie);
    }

    ::Ice::Int end_getByteWidth(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int getByteWidth(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getByteWidth(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool getByteWidth_async(const ::omero::api::AMI_RawPixelsStore_getByteWidthPtr&);
    bool getByteWidth_async(const ::omero::api::AMI_RawPixelsStore_getByteWidthPtr&, const ::Ice::Context&);

    bool isSigned()
    {
        return isSigned(0);
    }
    bool isSigned(const ::Ice::Context& __ctx)
    {
        return isSigned(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_isSigned(const ::IceInternal::Function<void (bool)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_isSigned(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_isSigned(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_isSigned(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_isSigned(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (bool)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_isSigned(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_isSigned(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_isSigned(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_isSigned(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (bool)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (bool)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::api::RawPixelsStorePrx __proxy = ::omero::api::RawPixelsStorePrx::uncheckedCast(__result->getProxy());
                bool __ret;
                try
                {
                    __ret = __proxy->end_isSigned(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (bool)> _response;
        };
        return begin_isSigned(__ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_isSigned()
    {
        return begin_isSigned(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_isSigned(const ::Ice::Context& __ctx)
    {
        return begin_isSigned(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_isSigned(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_isSigned(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_isSigned(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_isSigned(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_isSigned(const ::omero::api::Callback_RawPixelsStore_isSignedPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_isSigned(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_isSigned(const ::Ice::Context& __ctx, const ::omero::api::Callback_RawPixelsStore_isSignedPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_isSigned(&__ctx, __del, __cookie);
    }

    bool end_isSigned(const ::Ice::AsyncResultPtr&);
    
private:

    bool isSigned(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_isSigned(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool isSigned_async(const ::omero::api::AMI_RawPixelsStore_isSignedPtr&);
    bool isSigned_async(const ::omero::api::AMI_RawPixelsStore_isSignedPtr&, const ::Ice::Context&);

    bool isFloat()
    {
        return isFloat(0);
    }
    bool isFloat(const ::Ice::Context& __ctx)
    {
        return isFloat(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_isFloat(const ::IceInternal::Function<void (bool)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_isFloat(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_isFloat(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_isFloat(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_isFloat(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (bool)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_isFloat(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_isFloat(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_isFloat(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_isFloat(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (bool)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (bool)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::api::RawPixelsStorePrx __proxy = ::omero::api::RawPixelsStorePrx::uncheckedCast(__result->getProxy());
                bool __ret;
                try
                {
                    __ret = __proxy->end_isFloat(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (bool)> _response;
        };
        return begin_isFloat(__ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_isFloat()
    {
        return begin_isFloat(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_isFloat(const ::Ice::Context& __ctx)
    {
        return begin_isFloat(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_isFloat(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_isFloat(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_isFloat(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_isFloat(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_isFloat(const ::omero::api::Callback_RawPixelsStore_isFloatPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_isFloat(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_isFloat(const ::Ice::Context& __ctx, const ::omero::api::Callback_RawPixelsStore_isFloatPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_isFloat(&__ctx, __del, __cookie);
    }

    bool end_isFloat(const ::Ice::AsyncResultPtr&);
    
private:

    bool isFloat(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_isFloat(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool isFloat_async(const ::omero::api::AMI_RawPixelsStore_isFloatPtr&);
    bool isFloat_async(const ::omero::api::AMI_RawPixelsStore_isFloatPtr&, const ::Ice::Context&);

    ::Ice::ByteSeq calculateMessageDigest()
    {
        return calculateMessageDigest(0);
    }
    ::Ice::ByteSeq calculateMessageDigest(const ::Ice::Context& __ctx)
    {
        return calculateMessageDigest(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_calculateMessageDigest(const ::IceInternal::Function<void (const ::Ice::ByteSeq&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_calculateMessageDigest(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_calculateMessageDigest(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_calculateMessageDigest(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_calculateMessageDigest(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::ByteSeq&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_calculateMessageDigest(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_calculateMessageDigest(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_calculateMessageDigest(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_calculateMessageDigest(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Ice::ByteSeq&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::Ice::ByteSeq&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::api::RawPixelsStorePrx __proxy = ::omero::api::RawPixelsStorePrx::uncheckedCast(__result->getProxy());
                ::Ice::ByteSeq __ret;
                try
                {
                    __ret = __proxy->end_calculateMessageDigest(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::Ice::ByteSeq&)> _response;
        };
        return begin_calculateMessageDigest(__ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_calculateMessageDigest()
    {
        return begin_calculateMessageDigest(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_calculateMessageDigest(const ::Ice::Context& __ctx)
    {
        return begin_calculateMessageDigest(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_calculateMessageDigest(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_calculateMessageDigest(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_calculateMessageDigest(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_calculateMessageDigest(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_calculateMessageDigest(const ::omero::api::Callback_RawPixelsStore_calculateMessageDigestPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_calculateMessageDigest(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_calculateMessageDigest(const ::Ice::Context& __ctx, const ::omero::api::Callback_RawPixelsStore_calculateMessageDigestPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_calculateMessageDigest(&__ctx, __del, __cookie);
    }

    ::Ice::ByteSeq end_calculateMessageDigest(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::ByteSeq calculateMessageDigest(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_calculateMessageDigest(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool calculateMessageDigest_async(const ::omero::api::AMI_RawPixelsStore_calculateMessageDigestPtr&);
    bool calculateMessageDigest_async(const ::omero::api::AMI_RawPixelsStore_calculateMessageDigestPtr&, const ::Ice::Context&);

    ::omero::model::PixelsPtr save()
    {
        return save(0);
    }
    ::omero::model::PixelsPtr save(const ::Ice::Context& __ctx)
    {
        return save(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_save(const ::IceInternal::Function<void (const ::omero::model::PixelsPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_save(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_save(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_save(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_save(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::omero::model::PixelsPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_save(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_save(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_save(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_save(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::omero::model::PixelsPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::omero::model::PixelsPtr&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::api::RawPixelsStorePrx __proxy = ::omero::api::RawPixelsStorePrx::uncheckedCast(__result->getProxy());
                ::omero::model::PixelsPtr __ret;
                try
                {
                    __ret = __proxy->end_save(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::omero::model::PixelsPtr&)> _response;
        };
        return begin_save(__ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_save()
    {
        return begin_save(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_save(const ::Ice::Context& __ctx)
    {
        return begin_save(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_save(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_save(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_save(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_save(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_save(const ::omero::api::Callback_RawPixelsStore_savePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_save(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_save(const ::Ice::Context& __ctx, const ::omero::api::Callback_RawPixelsStore_savePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_save(&__ctx, __del, __cookie);
    }

    ::omero::model::PixelsPtr end_save(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::model::PixelsPtr save(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_save(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool save_async(const ::omero::api::AMI_RawPixelsStore_savePtr&);
    bool save_async(const ::omero::api::AMI_RawPixelsStore_savePtr&, const ::Ice::Context&);
    
    ::IceInternal::ProxyHandle<RawPixelsStore> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<RawPixelsStore*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<RawPixelsStore> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<RawPixelsStore*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<RawPixelsStore> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<RawPixelsStore*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<RawPixelsStore> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<RawPixelsStore*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<RawPixelsStore> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<RawPixelsStore*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<RawPixelsStore> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<RawPixelsStore*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<RawPixelsStore> ice_secure(bool __secure) const
    {
        return dynamic_cast<RawPixelsStore*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<RawPixelsStore> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<RawPixelsStore*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<RawPixelsStore> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<RawPixelsStore*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<RawPixelsStore> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<RawPixelsStore*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<RawPixelsStore> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<RawPixelsStore*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<RawPixelsStore> ice_twoway() const
    {
        return dynamic_cast<RawPixelsStore*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<RawPixelsStore> ice_oneway() const
    {
        return dynamic_cast<RawPixelsStore*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<RawPixelsStore> ice_batchOneway() const
    {
        return dynamic_cast<RawPixelsStore*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<RawPixelsStore> ice_datagram() const
    {
        return dynamic_cast<RawPixelsStore*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<RawPixelsStore> ice_batchDatagram() const
    {
        return dynamic_cast<RawPixelsStore*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<RawPixelsStore> ice_compress(bool __compress) const
    {
        return dynamic_cast<RawPixelsStore*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<RawPixelsStore> ice_timeout(int __timeout) const
    {
        return dynamic_cast<RawPixelsStore*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<RawPixelsStore> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<RawPixelsStore*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<RawPixelsStore> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<RawPixelsStore*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

}

}

}

namespace IceDelegate
{

namespace omero
{

namespace api
{

class RawPixelsStore : virtual public ::IceDelegate::omero::api::PyramidService
{
public:

    virtual void setPixelsId(::Ice::Long, bool, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Ice::Long getPixelsId(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::std::string getPixelsPath(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual void prepare(const ::omero::sys::LongList&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Ice::Long getPlaneSize(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Ice::Int getRowSize(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Ice::Long getStackSize(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Ice::Long getTimepointSize(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Ice::Long getTotalSize(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Ice::Long getRowOffset(::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Ice::Long getPlaneOffset(::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Ice::Long getStackOffset(::Ice::Int, ::Ice::Int, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Ice::Long getTimepointOffset(::Ice::Int, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Ice::ByteSeq getTile(::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Ice::ByteSeq getHypercube(const ::omero::sys::IntList&, const ::omero::sys::IntList&, const ::omero::sys::IntList&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Ice::ByteSeq getRegion(::Ice::Int, ::Ice::Long, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Ice::ByteSeq getRow(::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Ice::ByteSeq getCol(::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Ice::ByteSeq getPlane(::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Ice::ByteSeq getPlaneRegion(::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Ice::ByteSeq getStack(::Ice::Int, ::Ice::Int, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Ice::ByteSeq getTimepoint(::Ice::Int, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual void setTile(const ::Ice::ByteSeq&, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual void setRegion(::Ice::Int, ::Ice::Long, const ::Ice::ByteSeq&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual void setRow(const ::Ice::ByteSeq&, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual void setPlane(const ::Ice::ByteSeq&, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual void setStack(const ::Ice::ByteSeq&, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual void setTimepoint(const ::Ice::ByteSeq&, ::Ice::Int, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Ice::Int getByteWidth(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual bool isSigned(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual bool isFloat(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Ice::ByteSeq calculateMessageDigest(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::omero::model::PixelsPtr save(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;
};

}

}

}

namespace IceDelegateM
{

namespace omero
{

namespace api
{

class RawPixelsStore : virtual public ::IceDelegate::omero::api::RawPixelsStore,
                       virtual public ::IceDelegateM::omero::api::PyramidService
{
public:

    virtual void setPixelsId(::Ice::Long, bool, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Ice::Long getPixelsId(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::std::string getPixelsPath(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void prepare(const ::omero::sys::LongList&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Ice::Long getPlaneSize(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Ice::Int getRowSize(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Ice::Long getStackSize(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Ice::Long getTimepointSize(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Ice::Long getTotalSize(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Ice::Long getRowOffset(::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Ice::Long getPlaneOffset(::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Ice::Long getStackOffset(::Ice::Int, ::Ice::Int, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Ice::Long getTimepointOffset(::Ice::Int, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Ice::ByteSeq getTile(::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Ice::ByteSeq getHypercube(const ::omero::sys::IntList&, const ::omero::sys::IntList&, const ::omero::sys::IntList&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Ice::ByteSeq getRegion(::Ice::Int, ::Ice::Long, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Ice::ByteSeq getRow(::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Ice::ByteSeq getCol(::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Ice::ByteSeq getPlane(::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Ice::ByteSeq getPlaneRegion(::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Ice::ByteSeq getStack(::Ice::Int, ::Ice::Int, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Ice::ByteSeq getTimepoint(::Ice::Int, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void setTile(const ::Ice::ByteSeq&, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void setRegion(::Ice::Int, ::Ice::Long, const ::Ice::ByteSeq&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void setRow(const ::Ice::ByteSeq&, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void setPlane(const ::Ice::ByteSeq&, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void setStack(const ::Ice::ByteSeq&, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void setTimepoint(const ::Ice::ByteSeq&, ::Ice::Int, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Ice::Int getByteWidth(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual bool isSigned(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual bool isFloat(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Ice::ByteSeq calculateMessageDigest(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::model::PixelsPtr save(const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

}

}

}

namespace IceDelegateD
{

namespace omero
{

namespace api
{

class RawPixelsStore : virtual public ::IceDelegate::omero::api::RawPixelsStore,
                       virtual public ::IceDelegateD::omero::api::PyramidService
{
public:

    virtual void setPixelsId(::Ice::Long, bool, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Ice::Long getPixelsId(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::std::string getPixelsPath(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void prepare(const ::omero::sys::LongList&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Ice::Long getPlaneSize(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Ice::Int getRowSize(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Ice::Long getStackSize(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Ice::Long getTimepointSize(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Ice::Long getTotalSize(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Ice::Long getRowOffset(::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Ice::Long getPlaneOffset(::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Ice::Long getStackOffset(::Ice::Int, ::Ice::Int, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Ice::Long getTimepointOffset(::Ice::Int, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Ice::ByteSeq getTile(::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Ice::ByteSeq getHypercube(const ::omero::sys::IntList&, const ::omero::sys::IntList&, const ::omero::sys::IntList&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Ice::ByteSeq getRegion(::Ice::Int, ::Ice::Long, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Ice::ByteSeq getRow(::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Ice::ByteSeq getCol(::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Ice::ByteSeq getPlane(::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Ice::ByteSeq getPlaneRegion(::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Ice::ByteSeq getStack(::Ice::Int, ::Ice::Int, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Ice::ByteSeq getTimepoint(::Ice::Int, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void setTile(const ::Ice::ByteSeq&, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void setRegion(::Ice::Int, ::Ice::Long, const ::Ice::ByteSeq&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void setRow(const ::Ice::ByteSeq&, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void setPlane(const ::Ice::ByteSeq&, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void setStack(const ::Ice::ByteSeq&, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void setTimepoint(const ::Ice::ByteSeq&, ::Ice::Int, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Ice::Int getByteWidth(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual bool isSigned(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual bool isFloat(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Ice::ByteSeq calculateMessageDigest(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::model::PixelsPtr save(const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

}

}

}

namespace omero
{

namespace api
{

class RawPixelsStore : virtual public ::omero::api::PyramidService
{
public:

    typedef RawPixelsStorePrx ProxyType;
    typedef RawPixelsStorePtr PointerType;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void setPixelsId_async(const ::omero::api::AMD_RawPixelsStore_setPixelsIdPtr&, ::Ice::Long, bool, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setPixelsId(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void getPixelsId_async(const ::omero::api::AMD_RawPixelsStore_getPixelsIdPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getPixelsId(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void getPixelsPath_async(const ::omero::api::AMD_RawPixelsStore_getPixelsPathPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getPixelsPath(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void prepare_async(const ::omero::api::AMD_RawPixelsStore_preparePtr&, const ::omero::sys::LongList&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___prepare(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void getPlaneSize_async(const ::omero::api::AMD_RawPixelsStore_getPlaneSizePtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getPlaneSize(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void getRowSize_async(const ::omero::api::AMD_RawPixelsStore_getRowSizePtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getRowSize(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void getStackSize_async(const ::omero::api::AMD_RawPixelsStore_getStackSizePtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getStackSize(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void getTimepointSize_async(const ::omero::api::AMD_RawPixelsStore_getTimepointSizePtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getTimepointSize(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void getTotalSize_async(const ::omero::api::AMD_RawPixelsStore_getTotalSizePtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getTotalSize(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void getRowOffset_async(const ::omero::api::AMD_RawPixelsStore_getRowOffsetPtr&, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getRowOffset(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void getPlaneOffset_async(const ::omero::api::AMD_RawPixelsStore_getPlaneOffsetPtr&, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getPlaneOffset(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void getStackOffset_async(const ::omero::api::AMD_RawPixelsStore_getStackOffsetPtr&, ::Ice::Int, ::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getStackOffset(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void getTimepointOffset_async(const ::omero::api::AMD_RawPixelsStore_getTimepointOffsetPtr&, ::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getTimepointOffset(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void getTile_async(const ::omero::api::AMD_RawPixelsStore_getTilePtr&, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getTile(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void getHypercube_async(const ::omero::api::AMD_RawPixelsStore_getHypercubePtr&, const ::omero::sys::IntList&, const ::omero::sys::IntList&, const ::omero::sys::IntList&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getHypercube(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void getRegion_async(const ::omero::api::AMD_RawPixelsStore_getRegionPtr&, ::Ice::Int, ::Ice::Long, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getRegion(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void getRow_async(const ::omero::api::AMD_RawPixelsStore_getRowPtr&, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getRow(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void getCol_async(const ::omero::api::AMD_RawPixelsStore_getColPtr&, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getCol(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void getPlane_async(const ::omero::api::AMD_RawPixelsStore_getPlanePtr&, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getPlane(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void getPlaneRegion_async(const ::omero::api::AMD_RawPixelsStore_getPlaneRegionPtr&, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getPlaneRegion(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void getStack_async(const ::omero::api::AMD_RawPixelsStore_getStackPtr&, ::Ice::Int, ::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getStack(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void getTimepoint_async(const ::omero::api::AMD_RawPixelsStore_getTimepointPtr&, ::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getTimepoint(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setTile_async(const ::omero::api::AMD_RawPixelsStore_setTilePtr&, const ::Ice::ByteSeq&, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setTile(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setRegion_async(const ::omero::api::AMD_RawPixelsStore_setRegionPtr&, ::Ice::Int, ::Ice::Long, const ::Ice::ByteSeq&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setRegion(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setRow_async(const ::omero::api::AMD_RawPixelsStore_setRowPtr&, const ::Ice::ByteSeq&, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setRow(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setPlane_async(const ::omero::api::AMD_RawPixelsStore_setPlanePtr&, const ::Ice::ByteSeq&, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setPlane(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setStack_async(const ::omero::api::AMD_RawPixelsStore_setStackPtr&, const ::Ice::ByteSeq&, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setStack(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setTimepoint_async(const ::omero::api::AMD_RawPixelsStore_setTimepointPtr&, const ::Ice::ByteSeq&, ::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setTimepoint(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void getByteWidth_async(const ::omero::api::AMD_RawPixelsStore_getByteWidthPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getByteWidth(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void isSigned_async(const ::omero::api::AMD_RawPixelsStore_isSignedPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___isSigned(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void isFloat_async(const ::omero::api::AMD_RawPixelsStore_isFloatPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___isFloat(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void calculateMessageDigest_async(const ::omero::api::AMD_RawPixelsStore_calculateMessageDigestPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___calculateMessageDigest(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void save_async(const ::omero::api::AMD_RawPixelsStore_savePtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___save(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif
};

inline bool operator==(const RawPixelsStore& l, const RawPixelsStore& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const RawPixelsStore& l, const RawPixelsStore& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

}

}

namespace omero
{

namespace api
{

template<class T>
class CallbackNC_RawPixelsStore_setPixelsId : public Callback_RawPixelsStore_setPixelsId_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_RawPixelsStore_setPixelsId(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::RawPixelsStorePrx __proxy = ::omero::api::RawPixelsStorePrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_setPixelsId(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
        }
    }

    Response response;
};

template<class T> Callback_RawPixelsStore_setPixelsIdPtr
newCallback_RawPixelsStore_setPixelsId(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RawPixelsStore_setPixelsId<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RawPixelsStore_setPixelsIdPtr
newCallback_RawPixelsStore_setPixelsId(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RawPixelsStore_setPixelsId<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_RawPixelsStore_setPixelsIdPtr
newCallback_RawPixelsStore_setPixelsId(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RawPixelsStore_setPixelsId<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RawPixelsStore_setPixelsIdPtr
newCallback_RawPixelsStore_setPixelsId(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RawPixelsStore_setPixelsId<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_RawPixelsStore_setPixelsId : public Callback_RawPixelsStore_setPixelsId_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_RawPixelsStore_setPixelsId(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::RawPixelsStorePrx __proxy = ::omero::api::RawPixelsStorePrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_setPixelsId(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RawPixelsStore_setPixelsIdPtr
newCallback_RawPixelsStore_setPixelsId(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RawPixelsStore_setPixelsId<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RawPixelsStore_setPixelsIdPtr
newCallback_RawPixelsStore_setPixelsId(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RawPixelsStore_setPixelsId<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_RawPixelsStore_setPixelsIdPtr
newCallback_RawPixelsStore_setPixelsId(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RawPixelsStore_setPixelsId<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RawPixelsStore_setPixelsIdPtr
newCallback_RawPixelsStore_setPixelsId(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RawPixelsStore_setPixelsId<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_RawPixelsStore_getPixelsId : public Callback_RawPixelsStore_getPixelsId_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Long);

    CallbackNC_RawPixelsStore_getPixelsId(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::RawPixelsStorePrx __proxy = ::omero::api::RawPixelsStorePrx::uncheckedCast(__result->getProxy());
        ::Ice::Long __ret;
        try
        {
            __ret = __proxy->end_getPixelsId(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_RawPixelsStore_getPixelsIdPtr
newCallback_RawPixelsStore_getPixelsId(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Long), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RawPixelsStore_getPixelsId<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RawPixelsStore_getPixelsIdPtr
newCallback_RawPixelsStore_getPixelsId(T* instance, void (T::*cb)(::Ice::Long), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RawPixelsStore_getPixelsId<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RawPixelsStore_getPixelsId : public Callback_RawPixelsStore_getPixelsId_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Long, const CT&);

    Callback_RawPixelsStore_getPixelsId(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::RawPixelsStorePrx __proxy = ::omero::api::RawPixelsStorePrx::uncheckedCast(__result->getProxy());
        ::Ice::Long __ret;
        try
        {
            __ret = __proxy->end_getPixelsId(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RawPixelsStore_getPixelsIdPtr
newCallback_RawPixelsStore_getPixelsId(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Long, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RawPixelsStore_getPixelsId<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RawPixelsStore_getPixelsIdPtr
newCallback_RawPixelsStore_getPixelsId(T* instance, void (T::*cb)(::Ice::Long, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RawPixelsStore_getPixelsId<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_RawPixelsStore_getPixelsPath : public Callback_RawPixelsStore_getPixelsPath_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_RawPixelsStore_getPixelsPath(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::RawPixelsStorePrx __proxy = ::omero::api::RawPixelsStorePrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_getPixelsPath(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_RawPixelsStore_getPixelsPathPtr
newCallback_RawPixelsStore_getPixelsPath(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RawPixelsStore_getPixelsPath<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RawPixelsStore_getPixelsPathPtr
newCallback_RawPixelsStore_getPixelsPath(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RawPixelsStore_getPixelsPath<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RawPixelsStore_getPixelsPath : public Callback_RawPixelsStore_getPixelsPath_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_RawPixelsStore_getPixelsPath(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::RawPixelsStorePrx __proxy = ::omero::api::RawPixelsStorePrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_getPixelsPath(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RawPixelsStore_getPixelsPathPtr
newCallback_RawPixelsStore_getPixelsPath(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RawPixelsStore_getPixelsPath<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RawPixelsStore_getPixelsPathPtr
newCallback_RawPixelsStore_getPixelsPath(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RawPixelsStore_getPixelsPath<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_RawPixelsStore_prepare : public Callback_RawPixelsStore_prepare_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_RawPixelsStore_prepare(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::RawPixelsStorePrx __proxy = ::omero::api::RawPixelsStorePrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_prepare(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
        }
    }

    Response response;
};

template<class T> Callback_RawPixelsStore_preparePtr
newCallback_RawPixelsStore_prepare(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RawPixelsStore_prepare<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RawPixelsStore_preparePtr
newCallback_RawPixelsStore_prepare(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RawPixelsStore_prepare<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_RawPixelsStore_preparePtr
newCallback_RawPixelsStore_prepare(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RawPixelsStore_prepare<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RawPixelsStore_preparePtr
newCallback_RawPixelsStore_prepare(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RawPixelsStore_prepare<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_RawPixelsStore_prepare : public Callback_RawPixelsStore_prepare_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_RawPixelsStore_prepare(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::RawPixelsStorePrx __proxy = ::omero::api::RawPixelsStorePrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_prepare(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RawPixelsStore_preparePtr
newCallback_RawPixelsStore_prepare(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RawPixelsStore_prepare<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RawPixelsStore_preparePtr
newCallback_RawPixelsStore_prepare(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RawPixelsStore_prepare<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_RawPixelsStore_preparePtr
newCallback_RawPixelsStore_prepare(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RawPixelsStore_prepare<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RawPixelsStore_preparePtr
newCallback_RawPixelsStore_prepare(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RawPixelsStore_prepare<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_RawPixelsStore_getPlaneSize : public Callback_RawPixelsStore_getPlaneSize_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Long);

    CallbackNC_RawPixelsStore_getPlaneSize(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::RawPixelsStorePrx __proxy = ::omero::api::RawPixelsStorePrx::uncheckedCast(__result->getProxy());
        ::Ice::Long __ret;
        try
        {
            __ret = __proxy->end_getPlaneSize(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_RawPixelsStore_getPlaneSizePtr
newCallback_RawPixelsStore_getPlaneSize(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Long), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RawPixelsStore_getPlaneSize<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RawPixelsStore_getPlaneSizePtr
newCallback_RawPixelsStore_getPlaneSize(T* instance, void (T::*cb)(::Ice::Long), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RawPixelsStore_getPlaneSize<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RawPixelsStore_getPlaneSize : public Callback_RawPixelsStore_getPlaneSize_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Long, const CT&);

    Callback_RawPixelsStore_getPlaneSize(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::RawPixelsStorePrx __proxy = ::omero::api::RawPixelsStorePrx::uncheckedCast(__result->getProxy());
        ::Ice::Long __ret;
        try
        {
            __ret = __proxy->end_getPlaneSize(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RawPixelsStore_getPlaneSizePtr
newCallback_RawPixelsStore_getPlaneSize(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Long, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RawPixelsStore_getPlaneSize<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RawPixelsStore_getPlaneSizePtr
newCallback_RawPixelsStore_getPlaneSize(T* instance, void (T::*cb)(::Ice::Long, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RawPixelsStore_getPlaneSize<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_RawPixelsStore_getRowSize : public Callback_RawPixelsStore_getRowSize_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int);

    CallbackNC_RawPixelsStore_getRowSize(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::RawPixelsStorePrx __proxy = ::omero::api::RawPixelsStorePrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_getRowSize(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_RawPixelsStore_getRowSizePtr
newCallback_RawPixelsStore_getRowSize(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RawPixelsStore_getRowSize<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RawPixelsStore_getRowSizePtr
newCallback_RawPixelsStore_getRowSize(T* instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RawPixelsStore_getRowSize<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RawPixelsStore_getRowSize : public Callback_RawPixelsStore_getRowSize_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const CT&);

    Callback_RawPixelsStore_getRowSize(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::RawPixelsStorePrx __proxy = ::omero::api::RawPixelsStorePrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_getRowSize(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RawPixelsStore_getRowSizePtr
newCallback_RawPixelsStore_getRowSize(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RawPixelsStore_getRowSize<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RawPixelsStore_getRowSizePtr
newCallback_RawPixelsStore_getRowSize(T* instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RawPixelsStore_getRowSize<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_RawPixelsStore_getStackSize : public Callback_RawPixelsStore_getStackSize_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Long);

    CallbackNC_RawPixelsStore_getStackSize(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::RawPixelsStorePrx __proxy = ::omero::api::RawPixelsStorePrx::uncheckedCast(__result->getProxy());
        ::Ice::Long __ret;
        try
        {
            __ret = __proxy->end_getStackSize(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_RawPixelsStore_getStackSizePtr
newCallback_RawPixelsStore_getStackSize(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Long), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RawPixelsStore_getStackSize<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RawPixelsStore_getStackSizePtr
newCallback_RawPixelsStore_getStackSize(T* instance, void (T::*cb)(::Ice::Long), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RawPixelsStore_getStackSize<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RawPixelsStore_getStackSize : public Callback_RawPixelsStore_getStackSize_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Long, const CT&);

    Callback_RawPixelsStore_getStackSize(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::RawPixelsStorePrx __proxy = ::omero::api::RawPixelsStorePrx::uncheckedCast(__result->getProxy());
        ::Ice::Long __ret;
        try
        {
            __ret = __proxy->end_getStackSize(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RawPixelsStore_getStackSizePtr
newCallback_RawPixelsStore_getStackSize(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Long, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RawPixelsStore_getStackSize<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RawPixelsStore_getStackSizePtr
newCallback_RawPixelsStore_getStackSize(T* instance, void (T::*cb)(::Ice::Long, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RawPixelsStore_getStackSize<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_RawPixelsStore_getTimepointSize : public Callback_RawPixelsStore_getTimepointSize_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Long);

    CallbackNC_RawPixelsStore_getTimepointSize(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::RawPixelsStorePrx __proxy = ::omero::api::RawPixelsStorePrx::uncheckedCast(__result->getProxy());
        ::Ice::Long __ret;
        try
        {
            __ret = __proxy->end_getTimepointSize(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_RawPixelsStore_getTimepointSizePtr
newCallback_RawPixelsStore_getTimepointSize(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Long), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RawPixelsStore_getTimepointSize<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RawPixelsStore_getTimepointSizePtr
newCallback_RawPixelsStore_getTimepointSize(T* instance, void (T::*cb)(::Ice::Long), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RawPixelsStore_getTimepointSize<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RawPixelsStore_getTimepointSize : public Callback_RawPixelsStore_getTimepointSize_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Long, const CT&);

    Callback_RawPixelsStore_getTimepointSize(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::RawPixelsStorePrx __proxy = ::omero::api::RawPixelsStorePrx::uncheckedCast(__result->getProxy());
        ::Ice::Long __ret;
        try
        {
            __ret = __proxy->end_getTimepointSize(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RawPixelsStore_getTimepointSizePtr
newCallback_RawPixelsStore_getTimepointSize(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Long, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RawPixelsStore_getTimepointSize<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RawPixelsStore_getTimepointSizePtr
newCallback_RawPixelsStore_getTimepointSize(T* instance, void (T::*cb)(::Ice::Long, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RawPixelsStore_getTimepointSize<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_RawPixelsStore_getTotalSize : public Callback_RawPixelsStore_getTotalSize_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Long);

    CallbackNC_RawPixelsStore_getTotalSize(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::RawPixelsStorePrx __proxy = ::omero::api::RawPixelsStorePrx::uncheckedCast(__result->getProxy());
        ::Ice::Long __ret;
        try
        {
            __ret = __proxy->end_getTotalSize(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_RawPixelsStore_getTotalSizePtr
newCallback_RawPixelsStore_getTotalSize(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Long), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RawPixelsStore_getTotalSize<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RawPixelsStore_getTotalSizePtr
newCallback_RawPixelsStore_getTotalSize(T* instance, void (T::*cb)(::Ice::Long), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RawPixelsStore_getTotalSize<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RawPixelsStore_getTotalSize : public Callback_RawPixelsStore_getTotalSize_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Long, const CT&);

    Callback_RawPixelsStore_getTotalSize(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::RawPixelsStorePrx __proxy = ::omero::api::RawPixelsStorePrx::uncheckedCast(__result->getProxy());
        ::Ice::Long __ret;
        try
        {
            __ret = __proxy->end_getTotalSize(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RawPixelsStore_getTotalSizePtr
newCallback_RawPixelsStore_getTotalSize(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Long, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RawPixelsStore_getTotalSize<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RawPixelsStore_getTotalSizePtr
newCallback_RawPixelsStore_getTotalSize(T* instance, void (T::*cb)(::Ice::Long, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RawPixelsStore_getTotalSize<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_RawPixelsStore_getRowOffset : public Callback_RawPixelsStore_getRowOffset_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Long);

    CallbackNC_RawPixelsStore_getRowOffset(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::RawPixelsStorePrx __proxy = ::omero::api::RawPixelsStorePrx::uncheckedCast(__result->getProxy());
        ::Ice::Long __ret;
        try
        {
            __ret = __proxy->end_getRowOffset(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_RawPixelsStore_getRowOffsetPtr
newCallback_RawPixelsStore_getRowOffset(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Long), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RawPixelsStore_getRowOffset<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RawPixelsStore_getRowOffsetPtr
newCallback_RawPixelsStore_getRowOffset(T* instance, void (T::*cb)(::Ice::Long), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RawPixelsStore_getRowOffset<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RawPixelsStore_getRowOffset : public Callback_RawPixelsStore_getRowOffset_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Long, const CT&);

    Callback_RawPixelsStore_getRowOffset(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::RawPixelsStorePrx __proxy = ::omero::api::RawPixelsStorePrx::uncheckedCast(__result->getProxy());
        ::Ice::Long __ret;
        try
        {
            __ret = __proxy->end_getRowOffset(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RawPixelsStore_getRowOffsetPtr
newCallback_RawPixelsStore_getRowOffset(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Long, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RawPixelsStore_getRowOffset<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RawPixelsStore_getRowOffsetPtr
newCallback_RawPixelsStore_getRowOffset(T* instance, void (T::*cb)(::Ice::Long, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RawPixelsStore_getRowOffset<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_RawPixelsStore_getPlaneOffset : public Callback_RawPixelsStore_getPlaneOffset_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Long);

    CallbackNC_RawPixelsStore_getPlaneOffset(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::RawPixelsStorePrx __proxy = ::omero::api::RawPixelsStorePrx::uncheckedCast(__result->getProxy());
        ::Ice::Long __ret;
        try
        {
            __ret = __proxy->end_getPlaneOffset(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_RawPixelsStore_getPlaneOffsetPtr
newCallback_RawPixelsStore_getPlaneOffset(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Long), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RawPixelsStore_getPlaneOffset<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RawPixelsStore_getPlaneOffsetPtr
newCallback_RawPixelsStore_getPlaneOffset(T* instance, void (T::*cb)(::Ice::Long), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RawPixelsStore_getPlaneOffset<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RawPixelsStore_getPlaneOffset : public Callback_RawPixelsStore_getPlaneOffset_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Long, const CT&);

    Callback_RawPixelsStore_getPlaneOffset(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::RawPixelsStorePrx __proxy = ::omero::api::RawPixelsStorePrx::uncheckedCast(__result->getProxy());
        ::Ice::Long __ret;
        try
        {
            __ret = __proxy->end_getPlaneOffset(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RawPixelsStore_getPlaneOffsetPtr
newCallback_RawPixelsStore_getPlaneOffset(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Long, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RawPixelsStore_getPlaneOffset<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RawPixelsStore_getPlaneOffsetPtr
newCallback_RawPixelsStore_getPlaneOffset(T* instance, void (T::*cb)(::Ice::Long, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RawPixelsStore_getPlaneOffset<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_RawPixelsStore_getStackOffset : public Callback_RawPixelsStore_getStackOffset_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Long);

    CallbackNC_RawPixelsStore_getStackOffset(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::RawPixelsStorePrx __proxy = ::omero::api::RawPixelsStorePrx::uncheckedCast(__result->getProxy());
        ::Ice::Long __ret;
        try
        {
            __ret = __proxy->end_getStackOffset(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_RawPixelsStore_getStackOffsetPtr
newCallback_RawPixelsStore_getStackOffset(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Long), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RawPixelsStore_getStackOffset<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RawPixelsStore_getStackOffsetPtr
newCallback_RawPixelsStore_getStackOffset(T* instance, void (T::*cb)(::Ice::Long), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RawPixelsStore_getStackOffset<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RawPixelsStore_getStackOffset : public Callback_RawPixelsStore_getStackOffset_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Long, const CT&);

    Callback_RawPixelsStore_getStackOffset(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::RawPixelsStorePrx __proxy = ::omero::api::RawPixelsStorePrx::uncheckedCast(__result->getProxy());
        ::Ice::Long __ret;
        try
        {
            __ret = __proxy->end_getStackOffset(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RawPixelsStore_getStackOffsetPtr
newCallback_RawPixelsStore_getStackOffset(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Long, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RawPixelsStore_getStackOffset<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RawPixelsStore_getStackOffsetPtr
newCallback_RawPixelsStore_getStackOffset(T* instance, void (T::*cb)(::Ice::Long, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RawPixelsStore_getStackOffset<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_RawPixelsStore_getTimepointOffset : public Callback_RawPixelsStore_getTimepointOffset_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Long);

    CallbackNC_RawPixelsStore_getTimepointOffset(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::RawPixelsStorePrx __proxy = ::omero::api::RawPixelsStorePrx::uncheckedCast(__result->getProxy());
        ::Ice::Long __ret;
        try
        {
            __ret = __proxy->end_getTimepointOffset(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_RawPixelsStore_getTimepointOffsetPtr
newCallback_RawPixelsStore_getTimepointOffset(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Long), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RawPixelsStore_getTimepointOffset<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RawPixelsStore_getTimepointOffsetPtr
newCallback_RawPixelsStore_getTimepointOffset(T* instance, void (T::*cb)(::Ice::Long), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RawPixelsStore_getTimepointOffset<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RawPixelsStore_getTimepointOffset : public Callback_RawPixelsStore_getTimepointOffset_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Long, const CT&);

    Callback_RawPixelsStore_getTimepointOffset(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::RawPixelsStorePrx __proxy = ::omero::api::RawPixelsStorePrx::uncheckedCast(__result->getProxy());
        ::Ice::Long __ret;
        try
        {
            __ret = __proxy->end_getTimepointOffset(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RawPixelsStore_getTimepointOffsetPtr
newCallback_RawPixelsStore_getTimepointOffset(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Long, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RawPixelsStore_getTimepointOffset<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RawPixelsStore_getTimepointOffsetPtr
newCallback_RawPixelsStore_getTimepointOffset(T* instance, void (T::*cb)(::Ice::Long, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RawPixelsStore_getTimepointOffset<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_RawPixelsStore_getTile : public Callback_RawPixelsStore_getTile_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Ice::ByteSeq&);

    CallbackNC_RawPixelsStore_getTile(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::RawPixelsStorePrx __proxy = ::omero::api::RawPixelsStorePrx::uncheckedCast(__result->getProxy());
        ::Ice::ByteSeq __ret;
        try
        {
            __ret = __proxy->end_getTile(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_RawPixelsStore_getTilePtr
newCallback_RawPixelsStore_getTile(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Ice::ByteSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RawPixelsStore_getTile<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RawPixelsStore_getTilePtr
newCallback_RawPixelsStore_getTile(T* instance, void (T::*cb)(const ::Ice::ByteSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RawPixelsStore_getTile<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RawPixelsStore_getTile : public Callback_RawPixelsStore_getTile_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Ice::ByteSeq&, const CT&);

    Callback_RawPixelsStore_getTile(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::RawPixelsStorePrx __proxy = ::omero::api::RawPixelsStorePrx::uncheckedCast(__result->getProxy());
        ::Ice::ByteSeq __ret;
        try
        {
            __ret = __proxy->end_getTile(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RawPixelsStore_getTilePtr
newCallback_RawPixelsStore_getTile(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Ice::ByteSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RawPixelsStore_getTile<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RawPixelsStore_getTilePtr
newCallback_RawPixelsStore_getTile(T* instance, void (T::*cb)(const ::Ice::ByteSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RawPixelsStore_getTile<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_RawPixelsStore_getHypercube : public Callback_RawPixelsStore_getHypercube_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Ice::ByteSeq&);

    CallbackNC_RawPixelsStore_getHypercube(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::RawPixelsStorePrx __proxy = ::omero::api::RawPixelsStorePrx::uncheckedCast(__result->getProxy());
        ::Ice::ByteSeq __ret;
        try
        {
            __ret = __proxy->end_getHypercube(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_RawPixelsStore_getHypercubePtr
newCallback_RawPixelsStore_getHypercube(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Ice::ByteSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RawPixelsStore_getHypercube<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RawPixelsStore_getHypercubePtr
newCallback_RawPixelsStore_getHypercube(T* instance, void (T::*cb)(const ::Ice::ByteSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RawPixelsStore_getHypercube<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RawPixelsStore_getHypercube : public Callback_RawPixelsStore_getHypercube_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Ice::ByteSeq&, const CT&);

    Callback_RawPixelsStore_getHypercube(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::RawPixelsStorePrx __proxy = ::omero::api::RawPixelsStorePrx::uncheckedCast(__result->getProxy());
        ::Ice::ByteSeq __ret;
        try
        {
            __ret = __proxy->end_getHypercube(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RawPixelsStore_getHypercubePtr
newCallback_RawPixelsStore_getHypercube(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Ice::ByteSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RawPixelsStore_getHypercube<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RawPixelsStore_getHypercubePtr
newCallback_RawPixelsStore_getHypercube(T* instance, void (T::*cb)(const ::Ice::ByteSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RawPixelsStore_getHypercube<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_RawPixelsStore_getRegion : public Callback_RawPixelsStore_getRegion_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Ice::ByteSeq&);

    CallbackNC_RawPixelsStore_getRegion(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::RawPixelsStorePrx __proxy = ::omero::api::RawPixelsStorePrx::uncheckedCast(__result->getProxy());
        ::Ice::ByteSeq __ret;
        try
        {
            __ret = __proxy->end_getRegion(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_RawPixelsStore_getRegionPtr
newCallback_RawPixelsStore_getRegion(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Ice::ByteSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RawPixelsStore_getRegion<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RawPixelsStore_getRegionPtr
newCallback_RawPixelsStore_getRegion(T* instance, void (T::*cb)(const ::Ice::ByteSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RawPixelsStore_getRegion<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RawPixelsStore_getRegion : public Callback_RawPixelsStore_getRegion_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Ice::ByteSeq&, const CT&);

    Callback_RawPixelsStore_getRegion(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::RawPixelsStorePrx __proxy = ::omero::api::RawPixelsStorePrx::uncheckedCast(__result->getProxy());
        ::Ice::ByteSeq __ret;
        try
        {
            __ret = __proxy->end_getRegion(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RawPixelsStore_getRegionPtr
newCallback_RawPixelsStore_getRegion(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Ice::ByteSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RawPixelsStore_getRegion<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RawPixelsStore_getRegionPtr
newCallback_RawPixelsStore_getRegion(T* instance, void (T::*cb)(const ::Ice::ByteSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RawPixelsStore_getRegion<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_RawPixelsStore_getRow : public Callback_RawPixelsStore_getRow_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Ice::ByteSeq&);

    CallbackNC_RawPixelsStore_getRow(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::RawPixelsStorePrx __proxy = ::omero::api::RawPixelsStorePrx::uncheckedCast(__result->getProxy());
        ::Ice::ByteSeq __ret;
        try
        {
            __ret = __proxy->end_getRow(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_RawPixelsStore_getRowPtr
newCallback_RawPixelsStore_getRow(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Ice::ByteSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RawPixelsStore_getRow<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RawPixelsStore_getRowPtr
newCallback_RawPixelsStore_getRow(T* instance, void (T::*cb)(const ::Ice::ByteSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RawPixelsStore_getRow<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RawPixelsStore_getRow : public Callback_RawPixelsStore_getRow_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Ice::ByteSeq&, const CT&);

    Callback_RawPixelsStore_getRow(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::RawPixelsStorePrx __proxy = ::omero::api::RawPixelsStorePrx::uncheckedCast(__result->getProxy());
        ::Ice::ByteSeq __ret;
        try
        {
            __ret = __proxy->end_getRow(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RawPixelsStore_getRowPtr
newCallback_RawPixelsStore_getRow(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Ice::ByteSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RawPixelsStore_getRow<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RawPixelsStore_getRowPtr
newCallback_RawPixelsStore_getRow(T* instance, void (T::*cb)(const ::Ice::ByteSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RawPixelsStore_getRow<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_RawPixelsStore_getCol : public Callback_RawPixelsStore_getCol_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Ice::ByteSeq&);

    CallbackNC_RawPixelsStore_getCol(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::RawPixelsStorePrx __proxy = ::omero::api::RawPixelsStorePrx::uncheckedCast(__result->getProxy());
        ::Ice::ByteSeq __ret;
        try
        {
            __ret = __proxy->end_getCol(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_RawPixelsStore_getColPtr
newCallback_RawPixelsStore_getCol(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Ice::ByteSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RawPixelsStore_getCol<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RawPixelsStore_getColPtr
newCallback_RawPixelsStore_getCol(T* instance, void (T::*cb)(const ::Ice::ByteSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RawPixelsStore_getCol<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RawPixelsStore_getCol : public Callback_RawPixelsStore_getCol_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Ice::ByteSeq&, const CT&);

    Callback_RawPixelsStore_getCol(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::RawPixelsStorePrx __proxy = ::omero::api::RawPixelsStorePrx::uncheckedCast(__result->getProxy());
        ::Ice::ByteSeq __ret;
        try
        {
            __ret = __proxy->end_getCol(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RawPixelsStore_getColPtr
newCallback_RawPixelsStore_getCol(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Ice::ByteSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RawPixelsStore_getCol<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RawPixelsStore_getColPtr
newCallback_RawPixelsStore_getCol(T* instance, void (T::*cb)(const ::Ice::ByteSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RawPixelsStore_getCol<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_RawPixelsStore_getPlane : public Callback_RawPixelsStore_getPlane_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Ice::ByteSeq&);

    CallbackNC_RawPixelsStore_getPlane(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::RawPixelsStorePrx __proxy = ::omero::api::RawPixelsStorePrx::uncheckedCast(__result->getProxy());
        ::Ice::ByteSeq __ret;
        try
        {
            __ret = __proxy->end_getPlane(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_RawPixelsStore_getPlanePtr
newCallback_RawPixelsStore_getPlane(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Ice::ByteSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RawPixelsStore_getPlane<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RawPixelsStore_getPlanePtr
newCallback_RawPixelsStore_getPlane(T* instance, void (T::*cb)(const ::Ice::ByteSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RawPixelsStore_getPlane<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RawPixelsStore_getPlane : public Callback_RawPixelsStore_getPlane_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Ice::ByteSeq&, const CT&);

    Callback_RawPixelsStore_getPlane(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::RawPixelsStorePrx __proxy = ::omero::api::RawPixelsStorePrx::uncheckedCast(__result->getProxy());
        ::Ice::ByteSeq __ret;
        try
        {
            __ret = __proxy->end_getPlane(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RawPixelsStore_getPlanePtr
newCallback_RawPixelsStore_getPlane(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Ice::ByteSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RawPixelsStore_getPlane<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RawPixelsStore_getPlanePtr
newCallback_RawPixelsStore_getPlane(T* instance, void (T::*cb)(const ::Ice::ByteSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RawPixelsStore_getPlane<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_RawPixelsStore_getPlaneRegion : public Callback_RawPixelsStore_getPlaneRegion_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Ice::ByteSeq&);

    CallbackNC_RawPixelsStore_getPlaneRegion(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::RawPixelsStorePrx __proxy = ::omero::api::RawPixelsStorePrx::uncheckedCast(__result->getProxy());
        ::Ice::ByteSeq __ret;
        try
        {
            __ret = __proxy->end_getPlaneRegion(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_RawPixelsStore_getPlaneRegionPtr
newCallback_RawPixelsStore_getPlaneRegion(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Ice::ByteSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RawPixelsStore_getPlaneRegion<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RawPixelsStore_getPlaneRegionPtr
newCallback_RawPixelsStore_getPlaneRegion(T* instance, void (T::*cb)(const ::Ice::ByteSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RawPixelsStore_getPlaneRegion<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RawPixelsStore_getPlaneRegion : public Callback_RawPixelsStore_getPlaneRegion_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Ice::ByteSeq&, const CT&);

    Callback_RawPixelsStore_getPlaneRegion(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::RawPixelsStorePrx __proxy = ::omero::api::RawPixelsStorePrx::uncheckedCast(__result->getProxy());
        ::Ice::ByteSeq __ret;
        try
        {
            __ret = __proxy->end_getPlaneRegion(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RawPixelsStore_getPlaneRegionPtr
newCallback_RawPixelsStore_getPlaneRegion(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Ice::ByteSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RawPixelsStore_getPlaneRegion<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RawPixelsStore_getPlaneRegionPtr
newCallback_RawPixelsStore_getPlaneRegion(T* instance, void (T::*cb)(const ::Ice::ByteSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RawPixelsStore_getPlaneRegion<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_RawPixelsStore_getStack : public Callback_RawPixelsStore_getStack_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Ice::ByteSeq&);

    CallbackNC_RawPixelsStore_getStack(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::RawPixelsStorePrx __proxy = ::omero::api::RawPixelsStorePrx::uncheckedCast(__result->getProxy());
        ::Ice::ByteSeq __ret;
        try
        {
            __ret = __proxy->end_getStack(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_RawPixelsStore_getStackPtr
newCallback_RawPixelsStore_getStack(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Ice::ByteSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RawPixelsStore_getStack<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RawPixelsStore_getStackPtr
newCallback_RawPixelsStore_getStack(T* instance, void (T::*cb)(const ::Ice::ByteSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RawPixelsStore_getStack<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RawPixelsStore_getStack : public Callback_RawPixelsStore_getStack_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Ice::ByteSeq&, const CT&);

    Callback_RawPixelsStore_getStack(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::RawPixelsStorePrx __proxy = ::omero::api::RawPixelsStorePrx::uncheckedCast(__result->getProxy());
        ::Ice::ByteSeq __ret;
        try
        {
            __ret = __proxy->end_getStack(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RawPixelsStore_getStackPtr
newCallback_RawPixelsStore_getStack(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Ice::ByteSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RawPixelsStore_getStack<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RawPixelsStore_getStackPtr
newCallback_RawPixelsStore_getStack(T* instance, void (T::*cb)(const ::Ice::ByteSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RawPixelsStore_getStack<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_RawPixelsStore_getTimepoint : public Callback_RawPixelsStore_getTimepoint_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Ice::ByteSeq&);

    CallbackNC_RawPixelsStore_getTimepoint(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::RawPixelsStorePrx __proxy = ::omero::api::RawPixelsStorePrx::uncheckedCast(__result->getProxy());
        ::Ice::ByteSeq __ret;
        try
        {
            __ret = __proxy->end_getTimepoint(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_RawPixelsStore_getTimepointPtr
newCallback_RawPixelsStore_getTimepoint(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Ice::ByteSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RawPixelsStore_getTimepoint<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RawPixelsStore_getTimepointPtr
newCallback_RawPixelsStore_getTimepoint(T* instance, void (T::*cb)(const ::Ice::ByteSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RawPixelsStore_getTimepoint<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RawPixelsStore_getTimepoint : public Callback_RawPixelsStore_getTimepoint_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Ice::ByteSeq&, const CT&);

    Callback_RawPixelsStore_getTimepoint(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::RawPixelsStorePrx __proxy = ::omero::api::RawPixelsStorePrx::uncheckedCast(__result->getProxy());
        ::Ice::ByteSeq __ret;
        try
        {
            __ret = __proxy->end_getTimepoint(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RawPixelsStore_getTimepointPtr
newCallback_RawPixelsStore_getTimepoint(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Ice::ByteSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RawPixelsStore_getTimepoint<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RawPixelsStore_getTimepointPtr
newCallback_RawPixelsStore_getTimepoint(T* instance, void (T::*cb)(const ::Ice::ByteSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RawPixelsStore_getTimepoint<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_RawPixelsStore_setTile : public Callback_RawPixelsStore_setTile_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_RawPixelsStore_setTile(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::RawPixelsStorePrx __proxy = ::omero::api::RawPixelsStorePrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_setTile(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
        }
    }

    Response response;
};

template<class T> Callback_RawPixelsStore_setTilePtr
newCallback_RawPixelsStore_setTile(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RawPixelsStore_setTile<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RawPixelsStore_setTilePtr
newCallback_RawPixelsStore_setTile(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RawPixelsStore_setTile<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_RawPixelsStore_setTilePtr
newCallback_RawPixelsStore_setTile(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RawPixelsStore_setTile<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RawPixelsStore_setTilePtr
newCallback_RawPixelsStore_setTile(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RawPixelsStore_setTile<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_RawPixelsStore_setTile : public Callback_RawPixelsStore_setTile_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_RawPixelsStore_setTile(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::RawPixelsStorePrx __proxy = ::omero::api::RawPixelsStorePrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_setTile(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RawPixelsStore_setTilePtr
newCallback_RawPixelsStore_setTile(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RawPixelsStore_setTile<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RawPixelsStore_setTilePtr
newCallback_RawPixelsStore_setTile(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RawPixelsStore_setTile<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_RawPixelsStore_setTilePtr
newCallback_RawPixelsStore_setTile(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RawPixelsStore_setTile<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RawPixelsStore_setTilePtr
newCallback_RawPixelsStore_setTile(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RawPixelsStore_setTile<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_RawPixelsStore_setRegion : public Callback_RawPixelsStore_setRegion_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_RawPixelsStore_setRegion(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::RawPixelsStorePrx __proxy = ::omero::api::RawPixelsStorePrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_setRegion(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
        }
    }

    Response response;
};

template<class T> Callback_RawPixelsStore_setRegionPtr
newCallback_RawPixelsStore_setRegion(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RawPixelsStore_setRegion<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RawPixelsStore_setRegionPtr
newCallback_RawPixelsStore_setRegion(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RawPixelsStore_setRegion<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_RawPixelsStore_setRegionPtr
newCallback_RawPixelsStore_setRegion(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RawPixelsStore_setRegion<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RawPixelsStore_setRegionPtr
newCallback_RawPixelsStore_setRegion(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RawPixelsStore_setRegion<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_RawPixelsStore_setRegion : public Callback_RawPixelsStore_setRegion_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_RawPixelsStore_setRegion(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::RawPixelsStorePrx __proxy = ::omero::api::RawPixelsStorePrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_setRegion(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RawPixelsStore_setRegionPtr
newCallback_RawPixelsStore_setRegion(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RawPixelsStore_setRegion<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RawPixelsStore_setRegionPtr
newCallback_RawPixelsStore_setRegion(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RawPixelsStore_setRegion<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_RawPixelsStore_setRegionPtr
newCallback_RawPixelsStore_setRegion(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RawPixelsStore_setRegion<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RawPixelsStore_setRegionPtr
newCallback_RawPixelsStore_setRegion(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RawPixelsStore_setRegion<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_RawPixelsStore_setRow : public Callback_RawPixelsStore_setRow_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_RawPixelsStore_setRow(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::RawPixelsStorePrx __proxy = ::omero::api::RawPixelsStorePrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_setRow(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
        }
    }

    Response response;
};

template<class T> Callback_RawPixelsStore_setRowPtr
newCallback_RawPixelsStore_setRow(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RawPixelsStore_setRow<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RawPixelsStore_setRowPtr
newCallback_RawPixelsStore_setRow(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RawPixelsStore_setRow<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_RawPixelsStore_setRowPtr
newCallback_RawPixelsStore_setRow(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RawPixelsStore_setRow<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RawPixelsStore_setRowPtr
newCallback_RawPixelsStore_setRow(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RawPixelsStore_setRow<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_RawPixelsStore_setRow : public Callback_RawPixelsStore_setRow_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_RawPixelsStore_setRow(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::RawPixelsStorePrx __proxy = ::omero::api::RawPixelsStorePrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_setRow(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RawPixelsStore_setRowPtr
newCallback_RawPixelsStore_setRow(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RawPixelsStore_setRow<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RawPixelsStore_setRowPtr
newCallback_RawPixelsStore_setRow(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RawPixelsStore_setRow<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_RawPixelsStore_setRowPtr
newCallback_RawPixelsStore_setRow(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RawPixelsStore_setRow<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RawPixelsStore_setRowPtr
newCallback_RawPixelsStore_setRow(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RawPixelsStore_setRow<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_RawPixelsStore_setPlane : public Callback_RawPixelsStore_setPlane_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_RawPixelsStore_setPlane(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::RawPixelsStorePrx __proxy = ::omero::api::RawPixelsStorePrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_setPlane(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
        }
    }

    Response response;
};

template<class T> Callback_RawPixelsStore_setPlanePtr
newCallback_RawPixelsStore_setPlane(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RawPixelsStore_setPlane<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RawPixelsStore_setPlanePtr
newCallback_RawPixelsStore_setPlane(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RawPixelsStore_setPlane<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_RawPixelsStore_setPlanePtr
newCallback_RawPixelsStore_setPlane(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RawPixelsStore_setPlane<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RawPixelsStore_setPlanePtr
newCallback_RawPixelsStore_setPlane(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RawPixelsStore_setPlane<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_RawPixelsStore_setPlane : public Callback_RawPixelsStore_setPlane_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_RawPixelsStore_setPlane(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::RawPixelsStorePrx __proxy = ::omero::api::RawPixelsStorePrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_setPlane(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RawPixelsStore_setPlanePtr
newCallback_RawPixelsStore_setPlane(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RawPixelsStore_setPlane<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RawPixelsStore_setPlanePtr
newCallback_RawPixelsStore_setPlane(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RawPixelsStore_setPlane<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_RawPixelsStore_setPlanePtr
newCallback_RawPixelsStore_setPlane(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RawPixelsStore_setPlane<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RawPixelsStore_setPlanePtr
newCallback_RawPixelsStore_setPlane(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RawPixelsStore_setPlane<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_RawPixelsStore_setStack : public Callback_RawPixelsStore_setStack_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_RawPixelsStore_setStack(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::RawPixelsStorePrx __proxy = ::omero::api::RawPixelsStorePrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_setStack(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
        }
    }

    Response response;
};

template<class T> Callback_RawPixelsStore_setStackPtr
newCallback_RawPixelsStore_setStack(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RawPixelsStore_setStack<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RawPixelsStore_setStackPtr
newCallback_RawPixelsStore_setStack(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RawPixelsStore_setStack<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_RawPixelsStore_setStackPtr
newCallback_RawPixelsStore_setStack(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RawPixelsStore_setStack<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RawPixelsStore_setStackPtr
newCallback_RawPixelsStore_setStack(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RawPixelsStore_setStack<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_RawPixelsStore_setStack : public Callback_RawPixelsStore_setStack_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_RawPixelsStore_setStack(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::RawPixelsStorePrx __proxy = ::omero::api::RawPixelsStorePrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_setStack(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RawPixelsStore_setStackPtr
newCallback_RawPixelsStore_setStack(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RawPixelsStore_setStack<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RawPixelsStore_setStackPtr
newCallback_RawPixelsStore_setStack(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RawPixelsStore_setStack<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_RawPixelsStore_setStackPtr
newCallback_RawPixelsStore_setStack(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RawPixelsStore_setStack<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RawPixelsStore_setStackPtr
newCallback_RawPixelsStore_setStack(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RawPixelsStore_setStack<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_RawPixelsStore_setTimepoint : public Callback_RawPixelsStore_setTimepoint_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_RawPixelsStore_setTimepoint(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::RawPixelsStorePrx __proxy = ::omero::api::RawPixelsStorePrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_setTimepoint(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
        }
    }

    Response response;
};

template<class T> Callback_RawPixelsStore_setTimepointPtr
newCallback_RawPixelsStore_setTimepoint(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RawPixelsStore_setTimepoint<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RawPixelsStore_setTimepointPtr
newCallback_RawPixelsStore_setTimepoint(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RawPixelsStore_setTimepoint<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_RawPixelsStore_setTimepointPtr
newCallback_RawPixelsStore_setTimepoint(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RawPixelsStore_setTimepoint<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RawPixelsStore_setTimepointPtr
newCallback_RawPixelsStore_setTimepoint(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RawPixelsStore_setTimepoint<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_RawPixelsStore_setTimepoint : public Callback_RawPixelsStore_setTimepoint_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_RawPixelsStore_setTimepoint(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::RawPixelsStorePrx __proxy = ::omero::api::RawPixelsStorePrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_setTimepoint(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RawPixelsStore_setTimepointPtr
newCallback_RawPixelsStore_setTimepoint(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RawPixelsStore_setTimepoint<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RawPixelsStore_setTimepointPtr
newCallback_RawPixelsStore_setTimepoint(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RawPixelsStore_setTimepoint<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_RawPixelsStore_setTimepointPtr
newCallback_RawPixelsStore_setTimepoint(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RawPixelsStore_setTimepoint<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RawPixelsStore_setTimepointPtr
newCallback_RawPixelsStore_setTimepoint(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RawPixelsStore_setTimepoint<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_RawPixelsStore_getByteWidth : public Callback_RawPixelsStore_getByteWidth_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int);

    CallbackNC_RawPixelsStore_getByteWidth(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::RawPixelsStorePrx __proxy = ::omero::api::RawPixelsStorePrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_getByteWidth(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_RawPixelsStore_getByteWidthPtr
newCallback_RawPixelsStore_getByteWidth(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RawPixelsStore_getByteWidth<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RawPixelsStore_getByteWidthPtr
newCallback_RawPixelsStore_getByteWidth(T* instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RawPixelsStore_getByteWidth<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RawPixelsStore_getByteWidth : public Callback_RawPixelsStore_getByteWidth_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const CT&);

    Callback_RawPixelsStore_getByteWidth(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::RawPixelsStorePrx __proxy = ::omero::api::RawPixelsStorePrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_getByteWidth(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RawPixelsStore_getByteWidthPtr
newCallback_RawPixelsStore_getByteWidth(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RawPixelsStore_getByteWidth<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RawPixelsStore_getByteWidthPtr
newCallback_RawPixelsStore_getByteWidth(T* instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RawPixelsStore_getByteWidth<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_RawPixelsStore_isSigned : public Callback_RawPixelsStore_isSigned_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_RawPixelsStore_isSigned(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::RawPixelsStorePrx __proxy = ::omero::api::RawPixelsStorePrx::uncheckedCast(__result->getProxy());
        bool __ret;
        try
        {
            __ret = __proxy->end_isSigned(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_RawPixelsStore_isSignedPtr
newCallback_RawPixelsStore_isSigned(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RawPixelsStore_isSigned<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RawPixelsStore_isSignedPtr
newCallback_RawPixelsStore_isSigned(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RawPixelsStore_isSigned<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RawPixelsStore_isSigned : public Callback_RawPixelsStore_isSigned_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_RawPixelsStore_isSigned(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::RawPixelsStorePrx __proxy = ::omero::api::RawPixelsStorePrx::uncheckedCast(__result->getProxy());
        bool __ret;
        try
        {
            __ret = __proxy->end_isSigned(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RawPixelsStore_isSignedPtr
newCallback_RawPixelsStore_isSigned(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RawPixelsStore_isSigned<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RawPixelsStore_isSignedPtr
newCallback_RawPixelsStore_isSigned(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RawPixelsStore_isSigned<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_RawPixelsStore_isFloat : public Callback_RawPixelsStore_isFloat_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_RawPixelsStore_isFloat(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::RawPixelsStorePrx __proxy = ::omero::api::RawPixelsStorePrx::uncheckedCast(__result->getProxy());
        bool __ret;
        try
        {
            __ret = __proxy->end_isFloat(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_RawPixelsStore_isFloatPtr
newCallback_RawPixelsStore_isFloat(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RawPixelsStore_isFloat<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RawPixelsStore_isFloatPtr
newCallback_RawPixelsStore_isFloat(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RawPixelsStore_isFloat<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RawPixelsStore_isFloat : public Callback_RawPixelsStore_isFloat_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_RawPixelsStore_isFloat(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::RawPixelsStorePrx __proxy = ::omero::api::RawPixelsStorePrx::uncheckedCast(__result->getProxy());
        bool __ret;
        try
        {
            __ret = __proxy->end_isFloat(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RawPixelsStore_isFloatPtr
newCallback_RawPixelsStore_isFloat(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RawPixelsStore_isFloat<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RawPixelsStore_isFloatPtr
newCallback_RawPixelsStore_isFloat(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RawPixelsStore_isFloat<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_RawPixelsStore_calculateMessageDigest : public Callback_RawPixelsStore_calculateMessageDigest_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Ice::ByteSeq&);

    CallbackNC_RawPixelsStore_calculateMessageDigest(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::RawPixelsStorePrx __proxy = ::omero::api::RawPixelsStorePrx::uncheckedCast(__result->getProxy());
        ::Ice::ByteSeq __ret;
        try
        {
            __ret = __proxy->end_calculateMessageDigest(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_RawPixelsStore_calculateMessageDigestPtr
newCallback_RawPixelsStore_calculateMessageDigest(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Ice::ByteSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RawPixelsStore_calculateMessageDigest<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RawPixelsStore_calculateMessageDigestPtr
newCallback_RawPixelsStore_calculateMessageDigest(T* instance, void (T::*cb)(const ::Ice::ByteSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RawPixelsStore_calculateMessageDigest<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RawPixelsStore_calculateMessageDigest : public Callback_RawPixelsStore_calculateMessageDigest_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Ice::ByteSeq&, const CT&);

    Callback_RawPixelsStore_calculateMessageDigest(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::RawPixelsStorePrx __proxy = ::omero::api::RawPixelsStorePrx::uncheckedCast(__result->getProxy());
        ::Ice::ByteSeq __ret;
        try
        {
            __ret = __proxy->end_calculateMessageDigest(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RawPixelsStore_calculateMessageDigestPtr
newCallback_RawPixelsStore_calculateMessageDigest(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Ice::ByteSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RawPixelsStore_calculateMessageDigest<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RawPixelsStore_calculateMessageDigestPtr
newCallback_RawPixelsStore_calculateMessageDigest(T* instance, void (T::*cb)(const ::Ice::ByteSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RawPixelsStore_calculateMessageDigest<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_RawPixelsStore_save : public Callback_RawPixelsStore_save_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::model::PixelsPtr&);

    CallbackNC_RawPixelsStore_save(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::RawPixelsStorePrx __proxy = ::omero::api::RawPixelsStorePrx::uncheckedCast(__result->getProxy());
        ::omero::model::PixelsPtr __ret;
        try
        {
            __ret = __proxy->end_save(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_RawPixelsStore_savePtr
newCallback_RawPixelsStore_save(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::PixelsPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RawPixelsStore_save<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RawPixelsStore_savePtr
newCallback_RawPixelsStore_save(T* instance, void (T::*cb)(const ::omero::model::PixelsPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RawPixelsStore_save<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RawPixelsStore_save : public Callback_RawPixelsStore_save_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::model::PixelsPtr&, const CT&);

    Callback_RawPixelsStore_save(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::RawPixelsStorePrx __proxy = ::omero::api::RawPixelsStorePrx::uncheckedCast(__result->getProxy());
        ::omero::model::PixelsPtr __ret;
        try
        {
            __ret = __proxy->end_save(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RawPixelsStore_savePtr
newCallback_RawPixelsStore_save(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::PixelsPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RawPixelsStore_save<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RawPixelsStore_savePtr
newCallback_RawPixelsStore_save(T* instance, void (T::*cb)(const ::omero::model::PixelsPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RawPixelsStore_save<T, CT>(instance, cb, excb, sentcb);
}

}

}

#endif
