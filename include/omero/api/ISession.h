// **********************************************************************
//
// Copyright (c) 2003-2013 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.5.1
//
// <auto-generated>
//
// Generated from file `ISession.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __omero_api__opt_hudson_workspace_OMERO_5_0_release_src_components_blitz_generated_omero_api_ISession_h__
#define __omero_api__opt_hudson_workspace_OMERO_5_0_release_src_components_blitz_generated_omero_api_ISession_h__

#include <Ice/ProxyF.h>
#include <Ice/ObjectF.h>
#include <Ice/Exception.h>
#include <Ice/LocalObject.h>
#include <Ice/StreamHelpers.h>
#include <Ice/Proxy.h>
#include <Ice/Object.h>
#include <Ice/Outgoing.h>
#include <Ice/OutgoingAsync.h>
#include <Ice/Incoming.h>
#include <Ice/IncomingAsync.h>
#include <Ice/Direct.h>
#include <Ice/FactoryTableInit.h>
#include <IceUtil/ScopedArray.h>
#include <IceUtil/Optional.h>
#include <Ice/StreamF.h>
#include <Ice/SlicedDataF.h>
#include <omero/ModelF.h>
#include <omero/ServicesF.h>
#include <omero/System.h>
#include <omero/Collections.h>
#include <Ice/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 305
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 > 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 1
#       error Ice patch level mismatch!
#   endif
#endif

namespace IceProxy
{

namespace omero
{

namespace api
{

class ISession;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::omero::api::ISession>&);
::IceProxy::Ice::Object* upCast(::IceProxy::omero::api::ISession*);

}

}

}

namespace omero
{

namespace api
{

class ISession;
bool operator==(const ISession&, const ISession&);
bool operator<(const ISession&, const ISession&);
::Ice::Object* upCast(::omero::api::ISession*);
typedef ::IceInternal::Handle< ::omero::api::ISession> ISessionPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::omero::api::ISession> ISessionPrx;
void __patch(ISessionPtr&, const ::Ice::ObjectPtr&);

}

}

namespace omero
{

namespace api
{

class AMI_ISession_createSession : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::omero::model::SessionPtr&) = 0;

    void __response(const ::omero::model::SessionPtr& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_ISession_createSession> AMI_ISession_createSessionPtr;

class AMD_ISession_createSession : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const ::omero::model::SessionPtr&) = 0;
};

typedef ::IceUtil::Handle< ::omero::api::AMD_ISession_createSession> AMD_ISession_createSessionPtr;

class AMI_ISession_createUserSession : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::omero::model::SessionPtr&) = 0;

    void __response(const ::omero::model::SessionPtr& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_ISession_createUserSession> AMI_ISession_createUserSessionPtr;

class AMD_ISession_createUserSession : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const ::omero::model::SessionPtr&) = 0;
};

typedef ::IceUtil::Handle< ::omero::api::AMD_ISession_createUserSession> AMD_ISession_createUserSessionPtr;

class AMI_ISession_createSessionWithTimeout : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::omero::model::SessionPtr&) = 0;

    void __response(const ::omero::model::SessionPtr& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_ISession_createSessionWithTimeout> AMI_ISession_createSessionWithTimeoutPtr;

class AMD_ISession_createSessionWithTimeout : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const ::omero::model::SessionPtr&) = 0;
};

typedef ::IceUtil::Handle< ::omero::api::AMD_ISession_createSessionWithTimeout> AMD_ISession_createSessionWithTimeoutPtr;

class AMI_ISession_createSessionWithTimeouts : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::omero::model::SessionPtr&) = 0;

    void __response(const ::omero::model::SessionPtr& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_ISession_createSessionWithTimeouts> AMI_ISession_createSessionWithTimeoutsPtr;

class AMD_ISession_createSessionWithTimeouts : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const ::omero::model::SessionPtr&) = 0;
};

typedef ::IceUtil::Handle< ::omero::api::AMD_ISession_createSessionWithTimeouts> AMD_ISession_createSessionWithTimeoutsPtr;

class AMI_ISession_getSession : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::omero::model::SessionPtr&) = 0;

    void __response(const ::omero::model::SessionPtr& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_ISession_getSession> AMI_ISession_getSessionPtr;

class AMD_ISession_getSession : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const ::omero::model::SessionPtr&) = 0;
};

typedef ::IceUtil::Handle< ::omero::api::AMD_ISession_getSession> AMD_ISession_getSessionPtr;

class AMI_ISession_getReferenceCount : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(::Ice::Int) = 0;

    void __response(::Ice::Int __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_ISession_getReferenceCount> AMI_ISession_getReferenceCountPtr;

class AMD_ISession_getReferenceCount : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(::Ice::Int) = 0;
};

typedef ::IceUtil::Handle< ::omero::api::AMD_ISession_getReferenceCount> AMD_ISession_getReferenceCountPtr;

class AMI_ISession_closeSession : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(::Ice::Int) = 0;

    void __response(::Ice::Int __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_ISession_closeSession> AMI_ISession_closeSessionPtr;

class AMD_ISession_closeSession : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(::Ice::Int) = 0;
};

typedef ::IceUtil::Handle< ::omero::api::AMD_ISession_closeSession> AMD_ISession_closeSessionPtr;

class AMI_ISession_getMyOpenSessions : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::omero::api::SessionList&) = 0;

    void __response(const ::omero::api::SessionList& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_ISession_getMyOpenSessions> AMI_ISession_getMyOpenSessionsPtr;

class AMD_ISession_getMyOpenSessions : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const ::omero::api::SessionList&) = 0;
};

typedef ::IceUtil::Handle< ::omero::api::AMD_ISession_getMyOpenSessions> AMD_ISession_getMyOpenSessionsPtr;

class AMI_ISession_getMyOpenAgentSessions : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::omero::api::SessionList&) = 0;

    void __response(const ::omero::api::SessionList& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_ISession_getMyOpenAgentSessions> AMI_ISession_getMyOpenAgentSessionsPtr;

class AMD_ISession_getMyOpenAgentSessions : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const ::omero::api::SessionList&) = 0;
};

typedef ::IceUtil::Handle< ::omero::api::AMD_ISession_getMyOpenAgentSessions> AMD_ISession_getMyOpenAgentSessionsPtr;

class AMI_ISession_getMyOpenClientSessions : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::omero::api::SessionList&) = 0;

    void __response(const ::omero::api::SessionList& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_ISession_getMyOpenClientSessions> AMI_ISession_getMyOpenClientSessionsPtr;

class AMD_ISession_getMyOpenClientSessions : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const ::omero::api::SessionList&) = 0;
};

typedef ::IceUtil::Handle< ::omero::api::AMD_ISession_getMyOpenClientSessions> AMD_ISession_getMyOpenClientSessionsPtr;

class AMI_ISession_getInput : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::omero::RTypePtr&) = 0;

    void __response(const ::omero::RTypePtr& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_ISession_getInput> AMI_ISession_getInputPtr;

class AMD_ISession_getInput : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const ::omero::RTypePtr&) = 0;
};

typedef ::IceUtil::Handle< ::omero::api::AMD_ISession_getInput> AMD_ISession_getInputPtr;

class AMI_ISession_getOutput : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::omero::RTypePtr&) = 0;

    void __response(const ::omero::RTypePtr& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_ISession_getOutput> AMI_ISession_getOutputPtr;

class AMD_ISession_getOutput : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const ::omero::RTypePtr&) = 0;
};

typedef ::IceUtil::Handle< ::omero::api::AMD_ISession_getOutput> AMD_ISession_getOutputPtr;

class AMI_ISession_setInput : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response() = 0;

    void __response()
    {
        ice_response();
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_ISession_setInput> AMI_ISession_setInputPtr;

class AMD_ISession_setInput : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::omero::api::AMD_ISession_setInput> AMD_ISession_setInputPtr;

class AMI_ISession_setOutput : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response() = 0;

    void __response()
    {
        ice_response();
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_ISession_setOutput> AMI_ISession_setOutputPtr;

class AMD_ISession_setOutput : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::omero::api::AMD_ISession_setOutput> AMD_ISession_setOutputPtr;

class AMI_ISession_getInputKeys : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::omero::api::StringSet&) = 0;

    void __response(const ::omero::api::StringSet& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_ISession_getInputKeys> AMI_ISession_getInputKeysPtr;

class AMD_ISession_getInputKeys : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const ::omero::api::StringSet&) = 0;
};

typedef ::IceUtil::Handle< ::omero::api::AMD_ISession_getInputKeys> AMD_ISession_getInputKeysPtr;

class AMI_ISession_getOutputKeys : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::omero::api::StringSet&) = 0;

    void __response(const ::omero::api::StringSet& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_ISession_getOutputKeys> AMI_ISession_getOutputKeysPtr;

class AMD_ISession_getOutputKeys : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const ::omero::api::StringSet&) = 0;
};

typedef ::IceUtil::Handle< ::omero::api::AMD_ISession_getOutputKeys> AMD_ISession_getOutputKeysPtr;

class AMI_ISession_getInputs : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::omero::RTypeDict&) = 0;

    void __response(const ::omero::RTypeDict& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_ISession_getInputs> AMI_ISession_getInputsPtr;

class AMD_ISession_getInputs : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const ::omero::RTypeDict&) = 0;
};

typedef ::IceUtil::Handle< ::omero::api::AMD_ISession_getInputs> AMD_ISession_getInputsPtr;

class AMI_ISession_getOutputs : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::omero::RTypeDict&) = 0;

    void __response(const ::omero::RTypeDict& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_ISession_getOutputs> AMI_ISession_getOutputsPtr;

class AMD_ISession_getOutputs : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const ::omero::RTypeDict&) = 0;
};

typedef ::IceUtil::Handle< ::omero::api::AMD_ISession_getOutputs> AMD_ISession_getOutputsPtr;

}

}

namespace IceAsync
{

namespace omero
{

namespace api
{

class AMD_ISession_createSession : public ::omero::api::AMD_ISession_createSession, public ::IceInternal::IncomingAsync
{
public:

    AMD_ISession_createSession(::IceInternal::Incoming&);

    virtual void ice_response(const ::omero::model::SessionPtr&);
    // COMPILERFIX: The using directive avoid compiler warnings with -Woverloaded-virtual
    using ::IceInternal::IncomingAsync::ice_exception;
    virtual void ice_exception(const ::std::exception&);
};

class AMD_ISession_createUserSession : public ::omero::api::AMD_ISession_createUserSession, public ::IceInternal::IncomingAsync
{
public:

    AMD_ISession_createUserSession(::IceInternal::Incoming&);

    virtual void ice_response(const ::omero::model::SessionPtr&);
    // COMPILERFIX: The using directive avoid compiler warnings with -Woverloaded-virtual
    using ::IceInternal::IncomingAsync::ice_exception;
    virtual void ice_exception(const ::std::exception&);
};

class AMD_ISession_createSessionWithTimeout : public ::omero::api::AMD_ISession_createSessionWithTimeout, public ::IceInternal::IncomingAsync
{
public:

    AMD_ISession_createSessionWithTimeout(::IceInternal::Incoming&);

    virtual void ice_response(const ::omero::model::SessionPtr&);
    // COMPILERFIX: The using directive avoid compiler warnings with -Woverloaded-virtual
    using ::IceInternal::IncomingAsync::ice_exception;
    virtual void ice_exception(const ::std::exception&);
};

class AMD_ISession_createSessionWithTimeouts : public ::omero::api::AMD_ISession_createSessionWithTimeouts, public ::IceInternal::IncomingAsync
{
public:

    AMD_ISession_createSessionWithTimeouts(::IceInternal::Incoming&);

    virtual void ice_response(const ::omero::model::SessionPtr&);
    // COMPILERFIX: The using directive avoid compiler warnings with -Woverloaded-virtual
    using ::IceInternal::IncomingAsync::ice_exception;
    virtual void ice_exception(const ::std::exception&);
};

class AMD_ISession_getSession : public ::omero::api::AMD_ISession_getSession, public ::IceInternal::IncomingAsync
{
public:

    AMD_ISession_getSession(::IceInternal::Incoming&);

    virtual void ice_response(const ::omero::model::SessionPtr&);
    // COMPILERFIX: The using directive avoid compiler warnings with -Woverloaded-virtual
    using ::IceInternal::IncomingAsync::ice_exception;
    virtual void ice_exception(const ::std::exception&);
};

class AMD_ISession_getReferenceCount : public ::omero::api::AMD_ISession_getReferenceCount, public ::IceInternal::IncomingAsync
{
public:

    AMD_ISession_getReferenceCount(::IceInternal::Incoming&);

    virtual void ice_response(::Ice::Int);
    // COMPILERFIX: The using directive avoid compiler warnings with -Woverloaded-virtual
    using ::IceInternal::IncomingAsync::ice_exception;
    virtual void ice_exception(const ::std::exception&);
};

class AMD_ISession_closeSession : public ::omero::api::AMD_ISession_closeSession, public ::IceInternal::IncomingAsync
{
public:

    AMD_ISession_closeSession(::IceInternal::Incoming&);

    virtual void ice_response(::Ice::Int);
    // COMPILERFIX: The using directive avoid compiler warnings with -Woverloaded-virtual
    using ::IceInternal::IncomingAsync::ice_exception;
    virtual void ice_exception(const ::std::exception&);
};

class AMD_ISession_getMyOpenSessions : public ::omero::api::AMD_ISession_getMyOpenSessions, public ::IceInternal::IncomingAsync
{
public:

    AMD_ISession_getMyOpenSessions(::IceInternal::Incoming&);

    virtual void ice_response(const ::omero::api::SessionList&);
    // COMPILERFIX: The using directive avoid compiler warnings with -Woverloaded-virtual
    using ::IceInternal::IncomingAsync::ice_exception;
    virtual void ice_exception(const ::std::exception&);
};

class AMD_ISession_getMyOpenAgentSessions : public ::omero::api::AMD_ISession_getMyOpenAgentSessions, public ::IceInternal::IncomingAsync
{
public:

    AMD_ISession_getMyOpenAgentSessions(::IceInternal::Incoming&);

    virtual void ice_response(const ::omero::api::SessionList&);
    // COMPILERFIX: The using directive avoid compiler warnings with -Woverloaded-virtual
    using ::IceInternal::IncomingAsync::ice_exception;
    virtual void ice_exception(const ::std::exception&);
};

class AMD_ISession_getMyOpenClientSessions : public ::omero::api::AMD_ISession_getMyOpenClientSessions, public ::IceInternal::IncomingAsync
{
public:

    AMD_ISession_getMyOpenClientSessions(::IceInternal::Incoming&);

    virtual void ice_response(const ::omero::api::SessionList&);
    // COMPILERFIX: The using directive avoid compiler warnings with -Woverloaded-virtual
    using ::IceInternal::IncomingAsync::ice_exception;
    virtual void ice_exception(const ::std::exception&);
};

class AMD_ISession_getInput : public ::omero::api::AMD_ISession_getInput, public ::IceInternal::IncomingAsync
{
public:

    AMD_ISession_getInput(::IceInternal::Incoming&);

    virtual void ice_response(const ::omero::RTypePtr&);
    // COMPILERFIX: The using directive avoid compiler warnings with -Woverloaded-virtual
    using ::IceInternal::IncomingAsync::ice_exception;
    virtual void ice_exception(const ::std::exception&);
};

class AMD_ISession_getOutput : public ::omero::api::AMD_ISession_getOutput, public ::IceInternal::IncomingAsync
{
public:

    AMD_ISession_getOutput(::IceInternal::Incoming&);

    virtual void ice_response(const ::omero::RTypePtr&);
    // COMPILERFIX: The using directive avoid compiler warnings with -Woverloaded-virtual
    using ::IceInternal::IncomingAsync::ice_exception;
    virtual void ice_exception(const ::std::exception&);
};

class AMD_ISession_setInput : public ::omero::api::AMD_ISession_setInput, public ::IceInternal::IncomingAsync
{
public:

    AMD_ISession_setInput(::IceInternal::Incoming&);

    virtual void ice_response();
    // COMPILERFIX: The using directive avoid compiler warnings with -Woverloaded-virtual
    using ::IceInternal::IncomingAsync::ice_exception;
    virtual void ice_exception(const ::std::exception&);
};

class AMD_ISession_setOutput : public ::omero::api::AMD_ISession_setOutput, public ::IceInternal::IncomingAsync
{
public:

    AMD_ISession_setOutput(::IceInternal::Incoming&);

    virtual void ice_response();
    // COMPILERFIX: The using directive avoid compiler warnings with -Woverloaded-virtual
    using ::IceInternal::IncomingAsync::ice_exception;
    virtual void ice_exception(const ::std::exception&);
};

class AMD_ISession_getInputKeys : public ::omero::api::AMD_ISession_getInputKeys, public ::IceInternal::IncomingAsync
{
public:

    AMD_ISession_getInputKeys(::IceInternal::Incoming&);

    virtual void ice_response(const ::omero::api::StringSet&);
    // COMPILERFIX: The using directive avoid compiler warnings with -Woverloaded-virtual
    using ::IceInternal::IncomingAsync::ice_exception;
    virtual void ice_exception(const ::std::exception&);
};

class AMD_ISession_getOutputKeys : public ::omero::api::AMD_ISession_getOutputKeys, public ::IceInternal::IncomingAsync
{
public:

    AMD_ISession_getOutputKeys(::IceInternal::Incoming&);

    virtual void ice_response(const ::omero::api::StringSet&);
    // COMPILERFIX: The using directive avoid compiler warnings with -Woverloaded-virtual
    using ::IceInternal::IncomingAsync::ice_exception;
    virtual void ice_exception(const ::std::exception&);
};

class AMD_ISession_getInputs : public ::omero::api::AMD_ISession_getInputs, public ::IceInternal::IncomingAsync
{
public:

    AMD_ISession_getInputs(::IceInternal::Incoming&);

    virtual void ice_response(const ::omero::RTypeDict&);
    // COMPILERFIX: The using directive avoid compiler warnings with -Woverloaded-virtual
    using ::IceInternal::IncomingAsync::ice_exception;
    virtual void ice_exception(const ::std::exception&);
};

class AMD_ISession_getOutputs : public ::omero::api::AMD_ISession_getOutputs, public ::IceInternal::IncomingAsync
{
public:

    AMD_ISession_getOutputs(::IceInternal::Incoming&);

    virtual void ice_response(const ::omero::RTypeDict&);
    // COMPILERFIX: The using directive avoid compiler warnings with -Woverloaded-virtual
    using ::IceInternal::IncomingAsync::ice_exception;
    virtual void ice_exception(const ::std::exception&);
};

}

}

}

namespace omero
{

namespace api
{

class Callback_ISession_createSession_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ISession_createSession_Base> Callback_ISession_createSessionPtr;

class Callback_ISession_createUserSession_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ISession_createUserSession_Base> Callback_ISession_createUserSessionPtr;

class Callback_ISession_createSessionWithTimeout_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ISession_createSessionWithTimeout_Base> Callback_ISession_createSessionWithTimeoutPtr;

class Callback_ISession_createSessionWithTimeouts_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ISession_createSessionWithTimeouts_Base> Callback_ISession_createSessionWithTimeoutsPtr;

class Callback_ISession_getSession_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ISession_getSession_Base> Callback_ISession_getSessionPtr;

class Callback_ISession_getReferenceCount_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ISession_getReferenceCount_Base> Callback_ISession_getReferenceCountPtr;

class Callback_ISession_closeSession_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ISession_closeSession_Base> Callback_ISession_closeSessionPtr;

class Callback_ISession_getMyOpenSessions_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ISession_getMyOpenSessions_Base> Callback_ISession_getMyOpenSessionsPtr;

class Callback_ISession_getMyOpenAgentSessions_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ISession_getMyOpenAgentSessions_Base> Callback_ISession_getMyOpenAgentSessionsPtr;

class Callback_ISession_getMyOpenClientSessions_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ISession_getMyOpenClientSessions_Base> Callback_ISession_getMyOpenClientSessionsPtr;

class Callback_ISession_getInput_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ISession_getInput_Base> Callback_ISession_getInputPtr;

class Callback_ISession_getOutput_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ISession_getOutput_Base> Callback_ISession_getOutputPtr;

class Callback_ISession_setInput_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ISession_setInput_Base> Callback_ISession_setInputPtr;

class Callback_ISession_setOutput_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ISession_setOutput_Base> Callback_ISession_setOutputPtr;

class Callback_ISession_getInputKeys_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ISession_getInputKeys_Base> Callback_ISession_getInputKeysPtr;

class Callback_ISession_getOutputKeys_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ISession_getOutputKeys_Base> Callback_ISession_getOutputKeysPtr;

class Callback_ISession_getInputs_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ISession_getInputs_Base> Callback_ISession_getInputsPtr;

class Callback_ISession_getOutputs_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ISession_getOutputs_Base> Callback_ISession_getOutputsPtr;

}

}

namespace IceProxy
{

namespace omero
{

namespace api
{

class ISession : virtual public ::IceProxy::omero::api::ServiceInterface
{
public:

    ::omero::model::SessionPtr createSession(const ::omero::sys::PrincipalPtr& p, const ::std::string& credentials)
    {
        return createSession(p, credentials, 0);
    }
    ::omero::model::SessionPtr createSession(const ::omero::sys::PrincipalPtr& p, const ::std::string& credentials, const ::Ice::Context& __ctx)
    {
        return createSession(p, credentials, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_createSession(const ::omero::sys::PrincipalPtr& p, const ::std::string& credentials, const ::IceInternal::Function<void (const ::omero::model::SessionPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_createSession(p, credentials, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_createSession(const ::omero::sys::PrincipalPtr& p, const ::std::string& credentials, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_createSession(p, credentials, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_createSession(const ::omero::sys::PrincipalPtr& p, const ::std::string& credentials, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::omero::model::SessionPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_createSession(p, credentials, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_createSession(const ::omero::sys::PrincipalPtr& p, const ::std::string& credentials, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_createSession(p, credentials, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_createSession(const ::omero::sys::PrincipalPtr& p, const ::std::string& credentials, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::omero::model::SessionPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::omero::model::SessionPtr&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::api::ISessionPrx __proxy = ::omero::api::ISessionPrx::uncheckedCast(__result->getProxy());
                ::omero::model::SessionPtr __ret;
                try
                {
                    __ret = __proxy->end_createSession(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::omero::model::SessionPtr&)> _response;
        };
        return begin_createSession(p, credentials, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_createSession(const ::omero::sys::PrincipalPtr& p, const ::std::string& credentials)
    {
        return begin_createSession(p, credentials, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_createSession(const ::omero::sys::PrincipalPtr& p, const ::std::string& credentials, const ::Ice::Context& __ctx)
    {
        return begin_createSession(p, credentials, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_createSession(const ::omero::sys::PrincipalPtr& p, const ::std::string& credentials, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createSession(p, credentials, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_createSession(const ::omero::sys::PrincipalPtr& p, const ::std::string& credentials, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createSession(p, credentials, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_createSession(const ::omero::sys::PrincipalPtr& p, const ::std::string& credentials, const ::omero::api::Callback_ISession_createSessionPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createSession(p, credentials, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_createSession(const ::omero::sys::PrincipalPtr& p, const ::std::string& credentials, const ::Ice::Context& __ctx, const ::omero::api::Callback_ISession_createSessionPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createSession(p, credentials, &__ctx, __del, __cookie);
    }

    ::omero::model::SessionPtr end_createSession(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::model::SessionPtr createSession(const ::omero::sys::PrincipalPtr&, const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_createSession(const ::omero::sys::PrincipalPtr&, const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool createSession_async(const ::omero::api::AMI_ISession_createSessionPtr&, const ::omero::sys::PrincipalPtr&, const ::std::string&);
    bool createSession_async(const ::omero::api::AMI_ISession_createSessionPtr&, const ::omero::sys::PrincipalPtr&, const ::std::string&, const ::Ice::Context&);

    ::omero::model::SessionPtr createUserSession(::Ice::Long timeToLiveMilliseconds, ::Ice::Long timeToIdleMilliseconds, const ::std::string& defaultGroup)
    {
        return createUserSession(timeToLiveMilliseconds, timeToIdleMilliseconds, defaultGroup, 0);
    }
    ::omero::model::SessionPtr createUserSession(::Ice::Long timeToLiveMilliseconds, ::Ice::Long timeToIdleMilliseconds, const ::std::string& defaultGroup, const ::Ice::Context& __ctx)
    {
        return createUserSession(timeToLiveMilliseconds, timeToIdleMilliseconds, defaultGroup, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_createUserSession(::Ice::Long timeToLiveMilliseconds, ::Ice::Long timeToIdleMilliseconds, const ::std::string& defaultGroup, const ::IceInternal::Function<void (const ::omero::model::SessionPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_createUserSession(timeToLiveMilliseconds, timeToIdleMilliseconds, defaultGroup, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_createUserSession(::Ice::Long timeToLiveMilliseconds, ::Ice::Long timeToIdleMilliseconds, const ::std::string& defaultGroup, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_createUserSession(timeToLiveMilliseconds, timeToIdleMilliseconds, defaultGroup, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_createUserSession(::Ice::Long timeToLiveMilliseconds, ::Ice::Long timeToIdleMilliseconds, const ::std::string& defaultGroup, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::omero::model::SessionPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_createUserSession(timeToLiveMilliseconds, timeToIdleMilliseconds, defaultGroup, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_createUserSession(::Ice::Long timeToLiveMilliseconds, ::Ice::Long timeToIdleMilliseconds, const ::std::string& defaultGroup, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_createUserSession(timeToLiveMilliseconds, timeToIdleMilliseconds, defaultGroup, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_createUserSession(::Ice::Long timeToLiveMilliseconds, ::Ice::Long timeToIdleMilliseconds, const ::std::string& defaultGroup, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::omero::model::SessionPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::omero::model::SessionPtr&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::api::ISessionPrx __proxy = ::omero::api::ISessionPrx::uncheckedCast(__result->getProxy());
                ::omero::model::SessionPtr __ret;
                try
                {
                    __ret = __proxy->end_createUserSession(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::omero::model::SessionPtr&)> _response;
        };
        return begin_createUserSession(timeToLiveMilliseconds, timeToIdleMilliseconds, defaultGroup, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_createUserSession(::Ice::Long timeToLiveMilliseconds, ::Ice::Long timeToIdleMilliseconds, const ::std::string& defaultGroup)
    {
        return begin_createUserSession(timeToLiveMilliseconds, timeToIdleMilliseconds, defaultGroup, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_createUserSession(::Ice::Long timeToLiveMilliseconds, ::Ice::Long timeToIdleMilliseconds, const ::std::string& defaultGroup, const ::Ice::Context& __ctx)
    {
        return begin_createUserSession(timeToLiveMilliseconds, timeToIdleMilliseconds, defaultGroup, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_createUserSession(::Ice::Long timeToLiveMilliseconds, ::Ice::Long timeToIdleMilliseconds, const ::std::string& defaultGroup, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createUserSession(timeToLiveMilliseconds, timeToIdleMilliseconds, defaultGroup, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_createUserSession(::Ice::Long timeToLiveMilliseconds, ::Ice::Long timeToIdleMilliseconds, const ::std::string& defaultGroup, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createUserSession(timeToLiveMilliseconds, timeToIdleMilliseconds, defaultGroup, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_createUserSession(::Ice::Long timeToLiveMilliseconds, ::Ice::Long timeToIdleMilliseconds, const ::std::string& defaultGroup, const ::omero::api::Callback_ISession_createUserSessionPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createUserSession(timeToLiveMilliseconds, timeToIdleMilliseconds, defaultGroup, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_createUserSession(::Ice::Long timeToLiveMilliseconds, ::Ice::Long timeToIdleMilliseconds, const ::std::string& defaultGroup, const ::Ice::Context& __ctx, const ::omero::api::Callback_ISession_createUserSessionPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createUserSession(timeToLiveMilliseconds, timeToIdleMilliseconds, defaultGroup, &__ctx, __del, __cookie);
    }

    ::omero::model::SessionPtr end_createUserSession(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::model::SessionPtr createUserSession(::Ice::Long, ::Ice::Long, const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_createUserSession(::Ice::Long, ::Ice::Long, const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool createUserSession_async(const ::omero::api::AMI_ISession_createUserSessionPtr&, ::Ice::Long, ::Ice::Long, const ::std::string&);
    bool createUserSession_async(const ::omero::api::AMI_ISession_createUserSessionPtr&, ::Ice::Long, ::Ice::Long, const ::std::string&, const ::Ice::Context&);

    ::omero::model::SessionPtr createSessionWithTimeout(const ::omero::sys::PrincipalPtr& p, ::Ice::Long timeToLiveMilliseconds)
    {
        return createSessionWithTimeout(p, timeToLiveMilliseconds, 0);
    }
    ::omero::model::SessionPtr createSessionWithTimeout(const ::omero::sys::PrincipalPtr& p, ::Ice::Long timeToLiveMilliseconds, const ::Ice::Context& __ctx)
    {
        return createSessionWithTimeout(p, timeToLiveMilliseconds, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_createSessionWithTimeout(const ::omero::sys::PrincipalPtr& p, ::Ice::Long timeToLiveMilliseconds, const ::IceInternal::Function<void (const ::omero::model::SessionPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_createSessionWithTimeout(p, timeToLiveMilliseconds, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_createSessionWithTimeout(const ::omero::sys::PrincipalPtr& p, ::Ice::Long timeToLiveMilliseconds, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_createSessionWithTimeout(p, timeToLiveMilliseconds, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_createSessionWithTimeout(const ::omero::sys::PrincipalPtr& p, ::Ice::Long timeToLiveMilliseconds, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::omero::model::SessionPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_createSessionWithTimeout(p, timeToLiveMilliseconds, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_createSessionWithTimeout(const ::omero::sys::PrincipalPtr& p, ::Ice::Long timeToLiveMilliseconds, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_createSessionWithTimeout(p, timeToLiveMilliseconds, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_createSessionWithTimeout(const ::omero::sys::PrincipalPtr& p, ::Ice::Long timeToLiveMilliseconds, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::omero::model::SessionPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::omero::model::SessionPtr&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::api::ISessionPrx __proxy = ::omero::api::ISessionPrx::uncheckedCast(__result->getProxy());
                ::omero::model::SessionPtr __ret;
                try
                {
                    __ret = __proxy->end_createSessionWithTimeout(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::omero::model::SessionPtr&)> _response;
        };
        return begin_createSessionWithTimeout(p, timeToLiveMilliseconds, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_createSessionWithTimeout(const ::omero::sys::PrincipalPtr& p, ::Ice::Long timeToLiveMilliseconds)
    {
        return begin_createSessionWithTimeout(p, timeToLiveMilliseconds, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_createSessionWithTimeout(const ::omero::sys::PrincipalPtr& p, ::Ice::Long timeToLiveMilliseconds, const ::Ice::Context& __ctx)
    {
        return begin_createSessionWithTimeout(p, timeToLiveMilliseconds, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_createSessionWithTimeout(const ::omero::sys::PrincipalPtr& p, ::Ice::Long timeToLiveMilliseconds, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createSessionWithTimeout(p, timeToLiveMilliseconds, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_createSessionWithTimeout(const ::omero::sys::PrincipalPtr& p, ::Ice::Long timeToLiveMilliseconds, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createSessionWithTimeout(p, timeToLiveMilliseconds, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_createSessionWithTimeout(const ::omero::sys::PrincipalPtr& p, ::Ice::Long timeToLiveMilliseconds, const ::omero::api::Callback_ISession_createSessionWithTimeoutPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createSessionWithTimeout(p, timeToLiveMilliseconds, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_createSessionWithTimeout(const ::omero::sys::PrincipalPtr& p, ::Ice::Long timeToLiveMilliseconds, const ::Ice::Context& __ctx, const ::omero::api::Callback_ISession_createSessionWithTimeoutPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createSessionWithTimeout(p, timeToLiveMilliseconds, &__ctx, __del, __cookie);
    }

    ::omero::model::SessionPtr end_createSessionWithTimeout(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::model::SessionPtr createSessionWithTimeout(const ::omero::sys::PrincipalPtr&, ::Ice::Long, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_createSessionWithTimeout(const ::omero::sys::PrincipalPtr&, ::Ice::Long, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool createSessionWithTimeout_async(const ::omero::api::AMI_ISession_createSessionWithTimeoutPtr&, const ::omero::sys::PrincipalPtr&, ::Ice::Long);
    bool createSessionWithTimeout_async(const ::omero::api::AMI_ISession_createSessionWithTimeoutPtr&, const ::omero::sys::PrincipalPtr&, ::Ice::Long, const ::Ice::Context&);

    ::omero::model::SessionPtr createSessionWithTimeouts(const ::omero::sys::PrincipalPtr& p, ::Ice::Long timeToLiveMilliseconds, ::Ice::Long timeToIdleMilliseconds)
    {
        return createSessionWithTimeouts(p, timeToLiveMilliseconds, timeToIdleMilliseconds, 0);
    }
    ::omero::model::SessionPtr createSessionWithTimeouts(const ::omero::sys::PrincipalPtr& p, ::Ice::Long timeToLiveMilliseconds, ::Ice::Long timeToIdleMilliseconds, const ::Ice::Context& __ctx)
    {
        return createSessionWithTimeouts(p, timeToLiveMilliseconds, timeToIdleMilliseconds, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_createSessionWithTimeouts(const ::omero::sys::PrincipalPtr& p, ::Ice::Long timeToLiveMilliseconds, ::Ice::Long timeToIdleMilliseconds, const ::IceInternal::Function<void (const ::omero::model::SessionPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_createSessionWithTimeouts(p, timeToLiveMilliseconds, timeToIdleMilliseconds, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_createSessionWithTimeouts(const ::omero::sys::PrincipalPtr& p, ::Ice::Long timeToLiveMilliseconds, ::Ice::Long timeToIdleMilliseconds, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_createSessionWithTimeouts(p, timeToLiveMilliseconds, timeToIdleMilliseconds, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_createSessionWithTimeouts(const ::omero::sys::PrincipalPtr& p, ::Ice::Long timeToLiveMilliseconds, ::Ice::Long timeToIdleMilliseconds, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::omero::model::SessionPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_createSessionWithTimeouts(p, timeToLiveMilliseconds, timeToIdleMilliseconds, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_createSessionWithTimeouts(const ::omero::sys::PrincipalPtr& p, ::Ice::Long timeToLiveMilliseconds, ::Ice::Long timeToIdleMilliseconds, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_createSessionWithTimeouts(p, timeToLiveMilliseconds, timeToIdleMilliseconds, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_createSessionWithTimeouts(const ::omero::sys::PrincipalPtr& p, ::Ice::Long timeToLiveMilliseconds, ::Ice::Long timeToIdleMilliseconds, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::omero::model::SessionPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::omero::model::SessionPtr&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::api::ISessionPrx __proxy = ::omero::api::ISessionPrx::uncheckedCast(__result->getProxy());
                ::omero::model::SessionPtr __ret;
                try
                {
                    __ret = __proxy->end_createSessionWithTimeouts(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::omero::model::SessionPtr&)> _response;
        };
        return begin_createSessionWithTimeouts(p, timeToLiveMilliseconds, timeToIdleMilliseconds, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_createSessionWithTimeouts(const ::omero::sys::PrincipalPtr& p, ::Ice::Long timeToLiveMilliseconds, ::Ice::Long timeToIdleMilliseconds)
    {
        return begin_createSessionWithTimeouts(p, timeToLiveMilliseconds, timeToIdleMilliseconds, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_createSessionWithTimeouts(const ::omero::sys::PrincipalPtr& p, ::Ice::Long timeToLiveMilliseconds, ::Ice::Long timeToIdleMilliseconds, const ::Ice::Context& __ctx)
    {
        return begin_createSessionWithTimeouts(p, timeToLiveMilliseconds, timeToIdleMilliseconds, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_createSessionWithTimeouts(const ::omero::sys::PrincipalPtr& p, ::Ice::Long timeToLiveMilliseconds, ::Ice::Long timeToIdleMilliseconds, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createSessionWithTimeouts(p, timeToLiveMilliseconds, timeToIdleMilliseconds, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_createSessionWithTimeouts(const ::omero::sys::PrincipalPtr& p, ::Ice::Long timeToLiveMilliseconds, ::Ice::Long timeToIdleMilliseconds, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createSessionWithTimeouts(p, timeToLiveMilliseconds, timeToIdleMilliseconds, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_createSessionWithTimeouts(const ::omero::sys::PrincipalPtr& p, ::Ice::Long timeToLiveMilliseconds, ::Ice::Long timeToIdleMilliseconds, const ::omero::api::Callback_ISession_createSessionWithTimeoutsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createSessionWithTimeouts(p, timeToLiveMilliseconds, timeToIdleMilliseconds, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_createSessionWithTimeouts(const ::omero::sys::PrincipalPtr& p, ::Ice::Long timeToLiveMilliseconds, ::Ice::Long timeToIdleMilliseconds, const ::Ice::Context& __ctx, const ::omero::api::Callback_ISession_createSessionWithTimeoutsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createSessionWithTimeouts(p, timeToLiveMilliseconds, timeToIdleMilliseconds, &__ctx, __del, __cookie);
    }

    ::omero::model::SessionPtr end_createSessionWithTimeouts(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::model::SessionPtr createSessionWithTimeouts(const ::omero::sys::PrincipalPtr&, ::Ice::Long, ::Ice::Long, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_createSessionWithTimeouts(const ::omero::sys::PrincipalPtr&, ::Ice::Long, ::Ice::Long, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool createSessionWithTimeouts_async(const ::omero::api::AMI_ISession_createSessionWithTimeoutsPtr&, const ::omero::sys::PrincipalPtr&, ::Ice::Long, ::Ice::Long);
    bool createSessionWithTimeouts_async(const ::omero::api::AMI_ISession_createSessionWithTimeoutsPtr&, const ::omero::sys::PrincipalPtr&, ::Ice::Long, ::Ice::Long, const ::Ice::Context&);

    ::omero::model::SessionPtr getSession(const ::std::string& sessionUuid)
    {
        return getSession(sessionUuid, 0);
    }
    ::omero::model::SessionPtr getSession(const ::std::string& sessionUuid, const ::Ice::Context& __ctx)
    {
        return getSession(sessionUuid, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_getSession(const ::std::string& sessionUuid, const ::IceInternal::Function<void (const ::omero::model::SessionPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getSession(sessionUuid, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getSession(const ::std::string& sessionUuid, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getSession(sessionUuid, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_getSession(const ::std::string& sessionUuid, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::omero::model::SessionPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getSession(sessionUuid, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getSession(const ::std::string& sessionUuid, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getSession(sessionUuid, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_getSession(const ::std::string& sessionUuid, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::omero::model::SessionPtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::omero::model::SessionPtr&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::api::ISessionPrx __proxy = ::omero::api::ISessionPrx::uncheckedCast(__result->getProxy());
                ::omero::model::SessionPtr __ret;
                try
                {
                    __ret = __proxy->end_getSession(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::omero::model::SessionPtr&)> _response;
        };
        return begin_getSession(sessionUuid, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_getSession(const ::std::string& sessionUuid)
    {
        return begin_getSession(sessionUuid, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getSession(const ::std::string& sessionUuid, const ::Ice::Context& __ctx)
    {
        return begin_getSession(sessionUuid, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getSession(const ::std::string& sessionUuid, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getSession(sessionUuid, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getSession(const ::std::string& sessionUuid, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getSession(sessionUuid, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getSession(const ::std::string& sessionUuid, const ::omero::api::Callback_ISession_getSessionPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getSession(sessionUuid, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getSession(const ::std::string& sessionUuid, const ::Ice::Context& __ctx, const ::omero::api::Callback_ISession_getSessionPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getSession(sessionUuid, &__ctx, __del, __cookie);
    }

    ::omero::model::SessionPtr end_getSession(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::model::SessionPtr getSession(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getSession(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool getSession_async(const ::omero::api::AMI_ISession_getSessionPtr&, const ::std::string&);
    bool getSession_async(const ::omero::api::AMI_ISession_getSessionPtr&, const ::std::string&, const ::Ice::Context&);

    ::Ice::Int getReferenceCount(const ::std::string& sessionUuid)
    {
        return getReferenceCount(sessionUuid, 0);
    }
    ::Ice::Int getReferenceCount(const ::std::string& sessionUuid, const ::Ice::Context& __ctx)
    {
        return getReferenceCount(sessionUuid, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_getReferenceCount(const ::std::string& sessionUuid, const ::IceInternal::Function<void (::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getReferenceCount(sessionUuid, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getReferenceCount(const ::std::string& sessionUuid, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getReferenceCount(sessionUuid, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_getReferenceCount(const ::std::string& sessionUuid, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getReferenceCount(sessionUuid, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getReferenceCount(const ::std::string& sessionUuid, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getReferenceCount(sessionUuid, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_getReferenceCount(const ::std::string& sessionUuid, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (::Ice::Int)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::api::ISessionPrx __proxy = ::omero::api::ISessionPrx::uncheckedCast(__result->getProxy());
                ::Ice::Int __ret;
                try
                {
                    __ret = __proxy->end_getReferenceCount(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (::Ice::Int)> _response;
        };
        return begin_getReferenceCount(sessionUuid, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_getReferenceCount(const ::std::string& sessionUuid)
    {
        return begin_getReferenceCount(sessionUuid, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getReferenceCount(const ::std::string& sessionUuid, const ::Ice::Context& __ctx)
    {
        return begin_getReferenceCount(sessionUuid, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getReferenceCount(const ::std::string& sessionUuid, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getReferenceCount(sessionUuid, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getReferenceCount(const ::std::string& sessionUuid, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getReferenceCount(sessionUuid, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getReferenceCount(const ::std::string& sessionUuid, const ::omero::api::Callback_ISession_getReferenceCountPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getReferenceCount(sessionUuid, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getReferenceCount(const ::std::string& sessionUuid, const ::Ice::Context& __ctx, const ::omero::api::Callback_ISession_getReferenceCountPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getReferenceCount(sessionUuid, &__ctx, __del, __cookie);
    }

    ::Ice::Int end_getReferenceCount(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int getReferenceCount(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getReferenceCount(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool getReferenceCount_async(const ::omero::api::AMI_ISession_getReferenceCountPtr&, const ::std::string&);
    bool getReferenceCount_async(const ::omero::api::AMI_ISession_getReferenceCountPtr&, const ::std::string&, const ::Ice::Context&);

    ::Ice::Int closeSession(const ::omero::model::SessionPtr& sess)
    {
        return closeSession(sess, 0);
    }
    ::Ice::Int closeSession(const ::omero::model::SessionPtr& sess, const ::Ice::Context& __ctx)
    {
        return closeSession(sess, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_closeSession(const ::omero::model::SessionPtr& sess, const ::IceInternal::Function<void (::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_closeSession(sess, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_closeSession(const ::omero::model::SessionPtr& sess, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_closeSession(sess, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_closeSession(const ::omero::model::SessionPtr& sess, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_closeSession(sess, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_closeSession(const ::omero::model::SessionPtr& sess, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_closeSession(sess, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_closeSession(const ::omero::model::SessionPtr& sess, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (::Ice::Int)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::api::ISessionPrx __proxy = ::omero::api::ISessionPrx::uncheckedCast(__result->getProxy());
                ::Ice::Int __ret;
                try
                {
                    __ret = __proxy->end_closeSession(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (::Ice::Int)> _response;
        };
        return begin_closeSession(sess, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_closeSession(const ::omero::model::SessionPtr& sess)
    {
        return begin_closeSession(sess, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_closeSession(const ::omero::model::SessionPtr& sess, const ::Ice::Context& __ctx)
    {
        return begin_closeSession(sess, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_closeSession(const ::omero::model::SessionPtr& sess, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_closeSession(sess, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_closeSession(const ::omero::model::SessionPtr& sess, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_closeSession(sess, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_closeSession(const ::omero::model::SessionPtr& sess, const ::omero::api::Callback_ISession_closeSessionPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_closeSession(sess, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_closeSession(const ::omero::model::SessionPtr& sess, const ::Ice::Context& __ctx, const ::omero::api::Callback_ISession_closeSessionPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_closeSession(sess, &__ctx, __del, __cookie);
    }

    ::Ice::Int end_closeSession(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int closeSession(const ::omero::model::SessionPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_closeSession(const ::omero::model::SessionPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool closeSession_async(const ::omero::api::AMI_ISession_closeSessionPtr&, const ::omero::model::SessionPtr&);
    bool closeSession_async(const ::omero::api::AMI_ISession_closeSessionPtr&, const ::omero::model::SessionPtr&, const ::Ice::Context&);

    ::omero::api::SessionList getMyOpenSessions()
    {
        return getMyOpenSessions(0);
    }
    ::omero::api::SessionList getMyOpenSessions(const ::Ice::Context& __ctx)
    {
        return getMyOpenSessions(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_getMyOpenSessions(const ::IceInternal::Function<void (const ::omero::api::SessionList&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getMyOpenSessions(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getMyOpenSessions(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getMyOpenSessions(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_getMyOpenSessions(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::omero::api::SessionList&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getMyOpenSessions(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getMyOpenSessions(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getMyOpenSessions(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_getMyOpenSessions(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::omero::api::SessionList&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::omero::api::SessionList&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::api::ISessionPrx __proxy = ::omero::api::ISessionPrx::uncheckedCast(__result->getProxy());
                ::omero::api::SessionList __ret;
                try
                {
                    __ret = __proxy->end_getMyOpenSessions(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::omero::api::SessionList&)> _response;
        };
        return begin_getMyOpenSessions(__ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_getMyOpenSessions()
    {
        return begin_getMyOpenSessions(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getMyOpenSessions(const ::Ice::Context& __ctx)
    {
        return begin_getMyOpenSessions(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getMyOpenSessions(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getMyOpenSessions(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getMyOpenSessions(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getMyOpenSessions(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getMyOpenSessions(const ::omero::api::Callback_ISession_getMyOpenSessionsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getMyOpenSessions(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getMyOpenSessions(const ::Ice::Context& __ctx, const ::omero::api::Callback_ISession_getMyOpenSessionsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getMyOpenSessions(&__ctx, __del, __cookie);
    }

    ::omero::api::SessionList end_getMyOpenSessions(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::api::SessionList getMyOpenSessions(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getMyOpenSessions(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool getMyOpenSessions_async(const ::omero::api::AMI_ISession_getMyOpenSessionsPtr&);
    bool getMyOpenSessions_async(const ::omero::api::AMI_ISession_getMyOpenSessionsPtr&, const ::Ice::Context&);

    ::omero::api::SessionList getMyOpenAgentSessions(const ::std::string& agent)
    {
        return getMyOpenAgentSessions(agent, 0);
    }
    ::omero::api::SessionList getMyOpenAgentSessions(const ::std::string& agent, const ::Ice::Context& __ctx)
    {
        return getMyOpenAgentSessions(agent, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_getMyOpenAgentSessions(const ::std::string& agent, const ::IceInternal::Function<void (const ::omero::api::SessionList&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getMyOpenAgentSessions(agent, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getMyOpenAgentSessions(const ::std::string& agent, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getMyOpenAgentSessions(agent, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_getMyOpenAgentSessions(const ::std::string& agent, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::omero::api::SessionList&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getMyOpenAgentSessions(agent, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getMyOpenAgentSessions(const ::std::string& agent, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getMyOpenAgentSessions(agent, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_getMyOpenAgentSessions(const ::std::string& agent, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::omero::api::SessionList&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::omero::api::SessionList&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::api::ISessionPrx __proxy = ::omero::api::ISessionPrx::uncheckedCast(__result->getProxy());
                ::omero::api::SessionList __ret;
                try
                {
                    __ret = __proxy->end_getMyOpenAgentSessions(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::omero::api::SessionList&)> _response;
        };
        return begin_getMyOpenAgentSessions(agent, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_getMyOpenAgentSessions(const ::std::string& agent)
    {
        return begin_getMyOpenAgentSessions(agent, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getMyOpenAgentSessions(const ::std::string& agent, const ::Ice::Context& __ctx)
    {
        return begin_getMyOpenAgentSessions(agent, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getMyOpenAgentSessions(const ::std::string& agent, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getMyOpenAgentSessions(agent, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getMyOpenAgentSessions(const ::std::string& agent, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getMyOpenAgentSessions(agent, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getMyOpenAgentSessions(const ::std::string& agent, const ::omero::api::Callback_ISession_getMyOpenAgentSessionsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getMyOpenAgentSessions(agent, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getMyOpenAgentSessions(const ::std::string& agent, const ::Ice::Context& __ctx, const ::omero::api::Callback_ISession_getMyOpenAgentSessionsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getMyOpenAgentSessions(agent, &__ctx, __del, __cookie);
    }

    ::omero::api::SessionList end_getMyOpenAgentSessions(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::api::SessionList getMyOpenAgentSessions(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getMyOpenAgentSessions(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool getMyOpenAgentSessions_async(const ::omero::api::AMI_ISession_getMyOpenAgentSessionsPtr&, const ::std::string&);
    bool getMyOpenAgentSessions_async(const ::omero::api::AMI_ISession_getMyOpenAgentSessionsPtr&, const ::std::string&, const ::Ice::Context&);

    ::omero::api::SessionList getMyOpenClientSessions()
    {
        return getMyOpenClientSessions(0);
    }
    ::omero::api::SessionList getMyOpenClientSessions(const ::Ice::Context& __ctx)
    {
        return getMyOpenClientSessions(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_getMyOpenClientSessions(const ::IceInternal::Function<void (const ::omero::api::SessionList&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getMyOpenClientSessions(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getMyOpenClientSessions(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getMyOpenClientSessions(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_getMyOpenClientSessions(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::omero::api::SessionList&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getMyOpenClientSessions(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getMyOpenClientSessions(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getMyOpenClientSessions(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_getMyOpenClientSessions(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::omero::api::SessionList&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::omero::api::SessionList&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::api::ISessionPrx __proxy = ::omero::api::ISessionPrx::uncheckedCast(__result->getProxy());
                ::omero::api::SessionList __ret;
                try
                {
                    __ret = __proxy->end_getMyOpenClientSessions(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::omero::api::SessionList&)> _response;
        };
        return begin_getMyOpenClientSessions(__ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_getMyOpenClientSessions()
    {
        return begin_getMyOpenClientSessions(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getMyOpenClientSessions(const ::Ice::Context& __ctx)
    {
        return begin_getMyOpenClientSessions(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getMyOpenClientSessions(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getMyOpenClientSessions(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getMyOpenClientSessions(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getMyOpenClientSessions(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getMyOpenClientSessions(const ::omero::api::Callback_ISession_getMyOpenClientSessionsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getMyOpenClientSessions(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getMyOpenClientSessions(const ::Ice::Context& __ctx, const ::omero::api::Callback_ISession_getMyOpenClientSessionsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getMyOpenClientSessions(&__ctx, __del, __cookie);
    }

    ::omero::api::SessionList end_getMyOpenClientSessions(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::api::SessionList getMyOpenClientSessions(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getMyOpenClientSessions(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool getMyOpenClientSessions_async(const ::omero::api::AMI_ISession_getMyOpenClientSessionsPtr&);
    bool getMyOpenClientSessions_async(const ::omero::api::AMI_ISession_getMyOpenClientSessionsPtr&, const ::Ice::Context&);

    ::omero::RTypePtr getInput(const ::std::string& sess, const ::std::string& key)
    {
        return getInput(sess, key, 0);
    }
    ::omero::RTypePtr getInput(const ::std::string& sess, const ::std::string& key, const ::Ice::Context& __ctx)
    {
        return getInput(sess, key, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_getInput(const ::std::string& sess, const ::std::string& key, const ::IceInternal::Function<void (const ::omero::RTypePtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getInput(sess, key, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getInput(const ::std::string& sess, const ::std::string& key, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getInput(sess, key, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_getInput(const ::std::string& sess, const ::std::string& key, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::omero::RTypePtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getInput(sess, key, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getInput(const ::std::string& sess, const ::std::string& key, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getInput(sess, key, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_getInput(const ::std::string& sess, const ::std::string& key, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::omero::RTypePtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::omero::RTypePtr&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::api::ISessionPrx __proxy = ::omero::api::ISessionPrx::uncheckedCast(__result->getProxy());
                ::omero::RTypePtr __ret;
                try
                {
                    __ret = __proxy->end_getInput(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::omero::RTypePtr&)> _response;
        };
        return begin_getInput(sess, key, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_getInput(const ::std::string& sess, const ::std::string& key)
    {
        return begin_getInput(sess, key, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getInput(const ::std::string& sess, const ::std::string& key, const ::Ice::Context& __ctx)
    {
        return begin_getInput(sess, key, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getInput(const ::std::string& sess, const ::std::string& key, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getInput(sess, key, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getInput(const ::std::string& sess, const ::std::string& key, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getInput(sess, key, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getInput(const ::std::string& sess, const ::std::string& key, const ::omero::api::Callback_ISession_getInputPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getInput(sess, key, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getInput(const ::std::string& sess, const ::std::string& key, const ::Ice::Context& __ctx, const ::omero::api::Callback_ISession_getInputPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getInput(sess, key, &__ctx, __del, __cookie);
    }

    ::omero::RTypePtr end_getInput(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::RTypePtr getInput(const ::std::string&, const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getInput(const ::std::string&, const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool getInput_async(const ::omero::api::AMI_ISession_getInputPtr&, const ::std::string&, const ::std::string&);
    bool getInput_async(const ::omero::api::AMI_ISession_getInputPtr&, const ::std::string&, const ::std::string&, const ::Ice::Context&);

    ::omero::RTypePtr getOutput(const ::std::string& sess, const ::std::string& key)
    {
        return getOutput(sess, key, 0);
    }
    ::omero::RTypePtr getOutput(const ::std::string& sess, const ::std::string& key, const ::Ice::Context& __ctx)
    {
        return getOutput(sess, key, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_getOutput(const ::std::string& sess, const ::std::string& key, const ::IceInternal::Function<void (const ::omero::RTypePtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getOutput(sess, key, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getOutput(const ::std::string& sess, const ::std::string& key, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getOutput(sess, key, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_getOutput(const ::std::string& sess, const ::std::string& key, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::omero::RTypePtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getOutput(sess, key, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getOutput(const ::std::string& sess, const ::std::string& key, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getOutput(sess, key, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_getOutput(const ::std::string& sess, const ::std::string& key, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::omero::RTypePtr&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::omero::RTypePtr&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::api::ISessionPrx __proxy = ::omero::api::ISessionPrx::uncheckedCast(__result->getProxy());
                ::omero::RTypePtr __ret;
                try
                {
                    __ret = __proxy->end_getOutput(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::omero::RTypePtr&)> _response;
        };
        return begin_getOutput(sess, key, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_getOutput(const ::std::string& sess, const ::std::string& key)
    {
        return begin_getOutput(sess, key, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getOutput(const ::std::string& sess, const ::std::string& key, const ::Ice::Context& __ctx)
    {
        return begin_getOutput(sess, key, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getOutput(const ::std::string& sess, const ::std::string& key, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getOutput(sess, key, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getOutput(const ::std::string& sess, const ::std::string& key, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getOutput(sess, key, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getOutput(const ::std::string& sess, const ::std::string& key, const ::omero::api::Callback_ISession_getOutputPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getOutput(sess, key, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getOutput(const ::std::string& sess, const ::std::string& key, const ::Ice::Context& __ctx, const ::omero::api::Callback_ISession_getOutputPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getOutput(sess, key, &__ctx, __del, __cookie);
    }

    ::omero::RTypePtr end_getOutput(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::RTypePtr getOutput(const ::std::string&, const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getOutput(const ::std::string&, const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool getOutput_async(const ::omero::api::AMI_ISession_getOutputPtr&, const ::std::string&, const ::std::string&);
    bool getOutput_async(const ::omero::api::AMI_ISession_getOutputPtr&, const ::std::string&, const ::std::string&, const ::Ice::Context&);

    void setInput(const ::std::string& sess, const ::std::string& key, const ::omero::RTypePtr& value)
    {
        setInput(sess, key, value, 0);
    }
    void setInput(const ::std::string& sess, const ::std::string& key, const ::omero::RTypePtr& value, const ::Ice::Context& __ctx)
    {
        setInput(sess, key, value, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_setInput(const ::std::string& sess, const ::std::string& key, const ::omero::RTypePtr& value, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_setInput(sess, key, value, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_setInput(const ::std::string& sess, const ::std::string& key, const ::omero::RTypePtr& value, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_setInput(sess, key, value, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_setInput(const ::std::string& sess, const ::std::string& key, const ::omero::RTypePtr& value, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_setInput(sess, key, value, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_setInput(const ::std::string& sess, const ::std::string& key, const ::omero::RTypePtr& value, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_setInput(sess, key, value, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_setInput(const ::std::string& sess, const ::std::string& key, const ::omero::RTypePtr& value, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::api::ISessionPrx __proxy = ::omero::api::ISessionPrx::uncheckedCast(__result->getProxy());
                try
                {
                    __proxy->end_setInput(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response();
                }
            }
        
        private:
            
            ::std::function<void ()> _response;
        };
        return begin_setInput(sess, key, value, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_setInput(const ::std::string& sess, const ::std::string& key, const ::omero::RTypePtr& value)
    {
        return begin_setInput(sess, key, value, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setInput(const ::std::string& sess, const ::std::string& key, const ::omero::RTypePtr& value, const ::Ice::Context& __ctx)
    {
        return begin_setInput(sess, key, value, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setInput(const ::std::string& sess, const ::std::string& key, const ::omero::RTypePtr& value, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setInput(sess, key, value, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setInput(const ::std::string& sess, const ::std::string& key, const ::omero::RTypePtr& value, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setInput(sess, key, value, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setInput(const ::std::string& sess, const ::std::string& key, const ::omero::RTypePtr& value, const ::omero::api::Callback_ISession_setInputPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setInput(sess, key, value, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setInput(const ::std::string& sess, const ::std::string& key, const ::omero::RTypePtr& value, const ::Ice::Context& __ctx, const ::omero::api::Callback_ISession_setInputPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setInput(sess, key, value, &__ctx, __del, __cookie);
    }

    void end_setInput(const ::Ice::AsyncResultPtr&);
    
private:

    void setInput(const ::std::string&, const ::std::string&, const ::omero::RTypePtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setInput(const ::std::string&, const ::std::string&, const ::omero::RTypePtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool setInput_async(const ::omero::api::AMI_ISession_setInputPtr&, const ::std::string&, const ::std::string&, const ::omero::RTypePtr&);
    bool setInput_async(const ::omero::api::AMI_ISession_setInputPtr&, const ::std::string&, const ::std::string&, const ::omero::RTypePtr&, const ::Ice::Context&);

    void setOutput(const ::std::string& sess, const ::std::string& key, const ::omero::RTypePtr& value)
    {
        setOutput(sess, key, value, 0);
    }
    void setOutput(const ::std::string& sess, const ::std::string& key, const ::omero::RTypePtr& value, const ::Ice::Context& __ctx)
    {
        setOutput(sess, key, value, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_setOutput(const ::std::string& sess, const ::std::string& key, const ::omero::RTypePtr& value, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_setOutput(sess, key, value, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_setOutput(const ::std::string& sess, const ::std::string& key, const ::omero::RTypePtr& value, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_setOutput(sess, key, value, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_setOutput(const ::std::string& sess, const ::std::string& key, const ::omero::RTypePtr& value, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_setOutput(sess, key, value, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_setOutput(const ::std::string& sess, const ::std::string& key, const ::omero::RTypePtr& value, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_setOutput(sess, key, value, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_setOutput(const ::std::string& sess, const ::std::string& key, const ::omero::RTypePtr& value, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::api::ISessionPrx __proxy = ::omero::api::ISessionPrx::uncheckedCast(__result->getProxy());
                try
                {
                    __proxy->end_setOutput(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response();
                }
            }
        
        private:
            
            ::std::function<void ()> _response;
        };
        return begin_setOutput(sess, key, value, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_setOutput(const ::std::string& sess, const ::std::string& key, const ::omero::RTypePtr& value)
    {
        return begin_setOutput(sess, key, value, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setOutput(const ::std::string& sess, const ::std::string& key, const ::omero::RTypePtr& value, const ::Ice::Context& __ctx)
    {
        return begin_setOutput(sess, key, value, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setOutput(const ::std::string& sess, const ::std::string& key, const ::omero::RTypePtr& value, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setOutput(sess, key, value, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setOutput(const ::std::string& sess, const ::std::string& key, const ::omero::RTypePtr& value, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setOutput(sess, key, value, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setOutput(const ::std::string& sess, const ::std::string& key, const ::omero::RTypePtr& value, const ::omero::api::Callback_ISession_setOutputPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setOutput(sess, key, value, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setOutput(const ::std::string& sess, const ::std::string& key, const ::omero::RTypePtr& value, const ::Ice::Context& __ctx, const ::omero::api::Callback_ISession_setOutputPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setOutput(sess, key, value, &__ctx, __del, __cookie);
    }

    void end_setOutput(const ::Ice::AsyncResultPtr&);
    
private:

    void setOutput(const ::std::string&, const ::std::string&, const ::omero::RTypePtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setOutput(const ::std::string&, const ::std::string&, const ::omero::RTypePtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool setOutput_async(const ::omero::api::AMI_ISession_setOutputPtr&, const ::std::string&, const ::std::string&, const ::omero::RTypePtr&);
    bool setOutput_async(const ::omero::api::AMI_ISession_setOutputPtr&, const ::std::string&, const ::std::string&, const ::omero::RTypePtr&, const ::Ice::Context&);

    ::omero::api::StringSet getInputKeys(const ::std::string& sess)
    {
        return getInputKeys(sess, 0);
    }
    ::omero::api::StringSet getInputKeys(const ::std::string& sess, const ::Ice::Context& __ctx)
    {
        return getInputKeys(sess, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_getInputKeys(const ::std::string& sess, const ::IceInternal::Function<void (const ::omero::api::StringSet&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getInputKeys(sess, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getInputKeys(const ::std::string& sess, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getInputKeys(sess, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_getInputKeys(const ::std::string& sess, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::omero::api::StringSet&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getInputKeys(sess, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getInputKeys(const ::std::string& sess, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getInputKeys(sess, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_getInputKeys(const ::std::string& sess, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::omero::api::StringSet&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::omero::api::StringSet&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::api::ISessionPrx __proxy = ::omero::api::ISessionPrx::uncheckedCast(__result->getProxy());
                ::omero::api::StringSet __ret;
                try
                {
                    __ret = __proxy->end_getInputKeys(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::omero::api::StringSet&)> _response;
        };
        return begin_getInputKeys(sess, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_getInputKeys(const ::std::string& sess)
    {
        return begin_getInputKeys(sess, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getInputKeys(const ::std::string& sess, const ::Ice::Context& __ctx)
    {
        return begin_getInputKeys(sess, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getInputKeys(const ::std::string& sess, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getInputKeys(sess, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getInputKeys(const ::std::string& sess, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getInputKeys(sess, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getInputKeys(const ::std::string& sess, const ::omero::api::Callback_ISession_getInputKeysPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getInputKeys(sess, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getInputKeys(const ::std::string& sess, const ::Ice::Context& __ctx, const ::omero::api::Callback_ISession_getInputKeysPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getInputKeys(sess, &__ctx, __del, __cookie);
    }

    ::omero::api::StringSet end_getInputKeys(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::api::StringSet getInputKeys(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getInputKeys(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool getInputKeys_async(const ::omero::api::AMI_ISession_getInputKeysPtr&, const ::std::string&);
    bool getInputKeys_async(const ::omero::api::AMI_ISession_getInputKeysPtr&, const ::std::string&, const ::Ice::Context&);

    ::omero::api::StringSet getOutputKeys(const ::std::string& sess)
    {
        return getOutputKeys(sess, 0);
    }
    ::omero::api::StringSet getOutputKeys(const ::std::string& sess, const ::Ice::Context& __ctx)
    {
        return getOutputKeys(sess, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_getOutputKeys(const ::std::string& sess, const ::IceInternal::Function<void (const ::omero::api::StringSet&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getOutputKeys(sess, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getOutputKeys(const ::std::string& sess, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getOutputKeys(sess, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_getOutputKeys(const ::std::string& sess, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::omero::api::StringSet&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getOutputKeys(sess, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getOutputKeys(const ::std::string& sess, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getOutputKeys(sess, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_getOutputKeys(const ::std::string& sess, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::omero::api::StringSet&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::omero::api::StringSet&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::api::ISessionPrx __proxy = ::omero::api::ISessionPrx::uncheckedCast(__result->getProxy());
                ::omero::api::StringSet __ret;
                try
                {
                    __ret = __proxy->end_getOutputKeys(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::omero::api::StringSet&)> _response;
        };
        return begin_getOutputKeys(sess, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_getOutputKeys(const ::std::string& sess)
    {
        return begin_getOutputKeys(sess, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getOutputKeys(const ::std::string& sess, const ::Ice::Context& __ctx)
    {
        return begin_getOutputKeys(sess, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getOutputKeys(const ::std::string& sess, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getOutputKeys(sess, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getOutputKeys(const ::std::string& sess, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getOutputKeys(sess, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getOutputKeys(const ::std::string& sess, const ::omero::api::Callback_ISession_getOutputKeysPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getOutputKeys(sess, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getOutputKeys(const ::std::string& sess, const ::Ice::Context& __ctx, const ::omero::api::Callback_ISession_getOutputKeysPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getOutputKeys(sess, &__ctx, __del, __cookie);
    }

    ::omero::api::StringSet end_getOutputKeys(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::api::StringSet getOutputKeys(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getOutputKeys(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool getOutputKeys_async(const ::omero::api::AMI_ISession_getOutputKeysPtr&, const ::std::string&);
    bool getOutputKeys_async(const ::omero::api::AMI_ISession_getOutputKeysPtr&, const ::std::string&, const ::Ice::Context&);

    ::omero::RTypeDict getInputs(const ::std::string& sess)
    {
        return getInputs(sess, 0);
    }
    ::omero::RTypeDict getInputs(const ::std::string& sess, const ::Ice::Context& __ctx)
    {
        return getInputs(sess, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_getInputs(const ::std::string& sess, const ::IceInternal::Function<void (const ::omero::RTypeDict&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getInputs(sess, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getInputs(const ::std::string& sess, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getInputs(sess, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_getInputs(const ::std::string& sess, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::omero::RTypeDict&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getInputs(sess, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getInputs(const ::std::string& sess, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getInputs(sess, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_getInputs(const ::std::string& sess, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::omero::RTypeDict&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::omero::RTypeDict&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::api::ISessionPrx __proxy = ::omero::api::ISessionPrx::uncheckedCast(__result->getProxy());
                ::omero::RTypeDict __ret;
                try
                {
                    __ret = __proxy->end_getInputs(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::omero::RTypeDict&)> _response;
        };
        return begin_getInputs(sess, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_getInputs(const ::std::string& sess)
    {
        return begin_getInputs(sess, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getInputs(const ::std::string& sess, const ::Ice::Context& __ctx)
    {
        return begin_getInputs(sess, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getInputs(const ::std::string& sess, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getInputs(sess, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getInputs(const ::std::string& sess, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getInputs(sess, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getInputs(const ::std::string& sess, const ::omero::api::Callback_ISession_getInputsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getInputs(sess, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getInputs(const ::std::string& sess, const ::Ice::Context& __ctx, const ::omero::api::Callback_ISession_getInputsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getInputs(sess, &__ctx, __del, __cookie);
    }

    ::omero::RTypeDict end_getInputs(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::RTypeDict getInputs(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getInputs(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool getInputs_async(const ::omero::api::AMI_ISession_getInputsPtr&, const ::std::string&);
    bool getInputs_async(const ::omero::api::AMI_ISession_getInputsPtr&, const ::std::string&, const ::Ice::Context&);

    ::omero::RTypeDict getOutputs(const ::std::string& sess)
    {
        return getOutputs(sess, 0);
    }
    ::omero::RTypeDict getOutputs(const ::std::string& sess, const ::Ice::Context& __ctx)
    {
        return getOutputs(sess, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_getOutputs(const ::std::string& sess, const ::IceInternal::Function<void (const ::omero::RTypeDict&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getOutputs(sess, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getOutputs(const ::std::string& sess, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getOutputs(sess, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_getOutputs(const ::std::string& sess, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::omero::RTypeDict&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getOutputs(sess, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getOutputs(const ::std::string& sess, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getOutputs(sess, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_getOutputs(const ::std::string& sess, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::omero::RTypeDict&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::omero::RTypeDict&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::omero::api::ISessionPrx __proxy = ::omero::api::ISessionPrx::uncheckedCast(__result->getProxy());
                ::omero::RTypeDict __ret;
                try
                {
                    __ret = __proxy->end_getOutputs(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::omero::RTypeDict&)> _response;
        };
        return begin_getOutputs(sess, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_getOutputs(const ::std::string& sess)
    {
        return begin_getOutputs(sess, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getOutputs(const ::std::string& sess, const ::Ice::Context& __ctx)
    {
        return begin_getOutputs(sess, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getOutputs(const ::std::string& sess, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getOutputs(sess, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getOutputs(const ::std::string& sess, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getOutputs(sess, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getOutputs(const ::std::string& sess, const ::omero::api::Callback_ISession_getOutputsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getOutputs(sess, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getOutputs(const ::std::string& sess, const ::Ice::Context& __ctx, const ::omero::api::Callback_ISession_getOutputsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getOutputs(sess, &__ctx, __del, __cookie);
    }

    ::omero::RTypeDict end_getOutputs(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::RTypeDict getOutputs(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getOutputs(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool getOutputs_async(const ::omero::api::AMI_ISession_getOutputsPtr&, const ::std::string&);
    bool getOutputs_async(const ::omero::api::AMI_ISession_getOutputsPtr&, const ::std::string&, const ::Ice::Context&);
    
    ::IceInternal::ProxyHandle<ISession> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<ISession*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<ISession> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<ISession*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<ISession> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<ISession*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<ISession> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<ISession*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<ISession> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<ISession*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<ISession> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<ISession*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<ISession> ice_secure(bool __secure) const
    {
        return dynamic_cast<ISession*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<ISession> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<ISession*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<ISession> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<ISession*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<ISession> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<ISession*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<ISession> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<ISession*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<ISession> ice_twoway() const
    {
        return dynamic_cast<ISession*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<ISession> ice_oneway() const
    {
        return dynamic_cast<ISession*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<ISession> ice_batchOneway() const
    {
        return dynamic_cast<ISession*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<ISession> ice_datagram() const
    {
        return dynamic_cast<ISession*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<ISession> ice_batchDatagram() const
    {
        return dynamic_cast<ISession*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<ISession> ice_compress(bool __compress) const
    {
        return dynamic_cast<ISession*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<ISession> ice_timeout(int __timeout) const
    {
        return dynamic_cast<ISession*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<ISession> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<ISession*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<ISession> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<ISession*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

}

}

}

namespace IceDelegate
{

namespace omero
{

namespace api
{

class ISession : virtual public ::IceDelegate::omero::api::ServiceInterface
{
public:

    virtual ::omero::model::SessionPtr createSession(const ::omero::sys::PrincipalPtr&, const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::omero::model::SessionPtr createUserSession(::Ice::Long, ::Ice::Long, const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::omero::model::SessionPtr createSessionWithTimeout(const ::omero::sys::PrincipalPtr&, ::Ice::Long, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::omero::model::SessionPtr createSessionWithTimeouts(const ::omero::sys::PrincipalPtr&, ::Ice::Long, ::Ice::Long, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::omero::model::SessionPtr getSession(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Ice::Int getReferenceCount(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Ice::Int closeSession(const ::omero::model::SessionPtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::omero::api::SessionList getMyOpenSessions(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::omero::api::SessionList getMyOpenAgentSessions(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::omero::api::SessionList getMyOpenClientSessions(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::omero::RTypePtr getInput(const ::std::string&, const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::omero::RTypePtr getOutput(const ::std::string&, const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual void setInput(const ::std::string&, const ::std::string&, const ::omero::RTypePtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual void setOutput(const ::std::string&, const ::std::string&, const ::omero::RTypePtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::omero::api::StringSet getInputKeys(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::omero::api::StringSet getOutputKeys(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::omero::RTypeDict getInputs(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::omero::RTypeDict getOutputs(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;
};

}

}

}

namespace IceDelegateM
{

namespace omero
{

namespace api
{

class ISession : virtual public ::IceDelegate::omero::api::ISession,
                 virtual public ::IceDelegateM::omero::api::ServiceInterface
{
public:

    virtual ::omero::model::SessionPtr createSession(const ::omero::sys::PrincipalPtr&, const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::model::SessionPtr createUserSession(::Ice::Long, ::Ice::Long, const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::model::SessionPtr createSessionWithTimeout(const ::omero::sys::PrincipalPtr&, ::Ice::Long, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::model::SessionPtr createSessionWithTimeouts(const ::omero::sys::PrincipalPtr&, ::Ice::Long, ::Ice::Long, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::model::SessionPtr getSession(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Ice::Int getReferenceCount(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Ice::Int closeSession(const ::omero::model::SessionPtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::api::SessionList getMyOpenSessions(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::api::SessionList getMyOpenAgentSessions(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::api::SessionList getMyOpenClientSessions(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::RTypePtr getInput(const ::std::string&, const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::RTypePtr getOutput(const ::std::string&, const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void setInput(const ::std::string&, const ::std::string&, const ::omero::RTypePtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void setOutput(const ::std::string&, const ::std::string&, const ::omero::RTypePtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::api::StringSet getInputKeys(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::api::StringSet getOutputKeys(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::RTypeDict getInputs(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::RTypeDict getOutputs(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

}

}

}

namespace IceDelegateD
{

namespace omero
{

namespace api
{

class ISession : virtual public ::IceDelegate::omero::api::ISession,
                 virtual public ::IceDelegateD::omero::api::ServiceInterface
{
public:

    virtual ::omero::model::SessionPtr createSession(const ::omero::sys::PrincipalPtr&, const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::model::SessionPtr createUserSession(::Ice::Long, ::Ice::Long, const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::model::SessionPtr createSessionWithTimeout(const ::omero::sys::PrincipalPtr&, ::Ice::Long, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::model::SessionPtr createSessionWithTimeouts(const ::omero::sys::PrincipalPtr&, ::Ice::Long, ::Ice::Long, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::model::SessionPtr getSession(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Ice::Int getReferenceCount(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Ice::Int closeSession(const ::omero::model::SessionPtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::api::SessionList getMyOpenSessions(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::api::SessionList getMyOpenAgentSessions(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::api::SessionList getMyOpenClientSessions(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::RTypePtr getInput(const ::std::string&, const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::RTypePtr getOutput(const ::std::string&, const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void setInput(const ::std::string&, const ::std::string&, const ::omero::RTypePtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void setOutput(const ::std::string&, const ::std::string&, const ::omero::RTypePtr&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::api::StringSet getInputKeys(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::api::StringSet getOutputKeys(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::RTypeDict getInputs(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::omero::RTypeDict getOutputs(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

}

}

}

namespace omero
{

namespace api
{

class ISession : virtual public ::omero::api::ServiceInterface
{
public:

    typedef ISessionPrx ProxyType;
    typedef ISessionPtr PointerType;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void createSession_async(const ::omero::api::AMD_ISession_createSessionPtr&, const ::omero::sys::PrincipalPtr&, const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___createSession(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void createUserSession_async(const ::omero::api::AMD_ISession_createUserSessionPtr&, ::Ice::Long, ::Ice::Long, const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___createUserSession(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void createSessionWithTimeout_async(const ::omero::api::AMD_ISession_createSessionWithTimeoutPtr&, const ::omero::sys::PrincipalPtr&, ::Ice::Long, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___createSessionWithTimeout(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void createSessionWithTimeouts_async(const ::omero::api::AMD_ISession_createSessionWithTimeoutsPtr&, const ::omero::sys::PrincipalPtr&, ::Ice::Long, ::Ice::Long, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___createSessionWithTimeouts(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void getSession_async(const ::omero::api::AMD_ISession_getSessionPtr&, const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getSession(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void getReferenceCount_async(const ::omero::api::AMD_ISession_getReferenceCountPtr&, const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getReferenceCount(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void closeSession_async(const ::omero::api::AMD_ISession_closeSessionPtr&, const ::omero::model::SessionPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___closeSession(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void getMyOpenSessions_async(const ::omero::api::AMD_ISession_getMyOpenSessionsPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getMyOpenSessions(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void getMyOpenAgentSessions_async(const ::omero::api::AMD_ISession_getMyOpenAgentSessionsPtr&, const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getMyOpenAgentSessions(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void getMyOpenClientSessions_async(const ::omero::api::AMD_ISession_getMyOpenClientSessionsPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getMyOpenClientSessions(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void getInput_async(const ::omero::api::AMD_ISession_getInputPtr&, const ::std::string&, const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getInput(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void getOutput_async(const ::omero::api::AMD_ISession_getOutputPtr&, const ::std::string&, const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getOutput(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setInput_async(const ::omero::api::AMD_ISession_setInputPtr&, const ::std::string&, const ::std::string&, const ::omero::RTypePtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setInput(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setOutput_async(const ::omero::api::AMD_ISession_setOutputPtr&, const ::std::string&, const ::std::string&, const ::omero::RTypePtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setOutput(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void getInputKeys_async(const ::omero::api::AMD_ISession_getInputKeysPtr&, const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getInputKeys(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void getOutputKeys_async(const ::omero::api::AMD_ISession_getOutputKeysPtr&, const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getOutputKeys(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void getInputs_async(const ::omero::api::AMD_ISession_getInputsPtr&, const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getInputs(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void getOutputs_async(const ::omero::api::AMD_ISession_getOutputsPtr&, const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getOutputs(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif
};

inline bool operator==(const ISession& l, const ISession& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const ISession& l, const ISession& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

}

}

namespace omero
{

namespace api
{

template<class T>
class CallbackNC_ISession_createSession : public Callback_ISession_createSession_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::model::SessionPtr&);

    CallbackNC_ISession_createSession(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ISessionPrx __proxy = ::omero::api::ISessionPrx::uncheckedCast(__result->getProxy());
        ::omero::model::SessionPtr __ret;
        try
        {
            __ret = __proxy->end_createSession(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_ISession_createSessionPtr
newCallback_ISession_createSession(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::SessionPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ISession_createSession<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ISession_createSessionPtr
newCallback_ISession_createSession(T* instance, void (T::*cb)(const ::omero::model::SessionPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ISession_createSession<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_ISession_createSession : public Callback_ISession_createSession_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::model::SessionPtr&, const CT&);

    Callback_ISession_createSession(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ISessionPrx __proxy = ::omero::api::ISessionPrx::uncheckedCast(__result->getProxy());
        ::omero::model::SessionPtr __ret;
        try
        {
            __ret = __proxy->end_createSession(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ISession_createSessionPtr
newCallback_ISession_createSession(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::SessionPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ISession_createSession<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ISession_createSessionPtr
newCallback_ISession_createSession(T* instance, void (T::*cb)(const ::omero::model::SessionPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ISession_createSession<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_ISession_createUserSession : public Callback_ISession_createUserSession_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::model::SessionPtr&);

    CallbackNC_ISession_createUserSession(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ISessionPrx __proxy = ::omero::api::ISessionPrx::uncheckedCast(__result->getProxy());
        ::omero::model::SessionPtr __ret;
        try
        {
            __ret = __proxy->end_createUserSession(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_ISession_createUserSessionPtr
newCallback_ISession_createUserSession(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::SessionPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ISession_createUserSession<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ISession_createUserSessionPtr
newCallback_ISession_createUserSession(T* instance, void (T::*cb)(const ::omero::model::SessionPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ISession_createUserSession<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_ISession_createUserSession : public Callback_ISession_createUserSession_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::model::SessionPtr&, const CT&);

    Callback_ISession_createUserSession(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ISessionPrx __proxy = ::omero::api::ISessionPrx::uncheckedCast(__result->getProxy());
        ::omero::model::SessionPtr __ret;
        try
        {
            __ret = __proxy->end_createUserSession(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ISession_createUserSessionPtr
newCallback_ISession_createUserSession(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::SessionPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ISession_createUserSession<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ISession_createUserSessionPtr
newCallback_ISession_createUserSession(T* instance, void (T::*cb)(const ::omero::model::SessionPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ISession_createUserSession<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_ISession_createSessionWithTimeout : public Callback_ISession_createSessionWithTimeout_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::model::SessionPtr&);

    CallbackNC_ISession_createSessionWithTimeout(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ISessionPrx __proxy = ::omero::api::ISessionPrx::uncheckedCast(__result->getProxy());
        ::omero::model::SessionPtr __ret;
        try
        {
            __ret = __proxy->end_createSessionWithTimeout(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_ISession_createSessionWithTimeoutPtr
newCallback_ISession_createSessionWithTimeout(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::SessionPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ISession_createSessionWithTimeout<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ISession_createSessionWithTimeoutPtr
newCallback_ISession_createSessionWithTimeout(T* instance, void (T::*cb)(const ::omero::model::SessionPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ISession_createSessionWithTimeout<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_ISession_createSessionWithTimeout : public Callback_ISession_createSessionWithTimeout_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::model::SessionPtr&, const CT&);

    Callback_ISession_createSessionWithTimeout(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ISessionPrx __proxy = ::omero::api::ISessionPrx::uncheckedCast(__result->getProxy());
        ::omero::model::SessionPtr __ret;
        try
        {
            __ret = __proxy->end_createSessionWithTimeout(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ISession_createSessionWithTimeoutPtr
newCallback_ISession_createSessionWithTimeout(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::SessionPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ISession_createSessionWithTimeout<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ISession_createSessionWithTimeoutPtr
newCallback_ISession_createSessionWithTimeout(T* instance, void (T::*cb)(const ::omero::model::SessionPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ISession_createSessionWithTimeout<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_ISession_createSessionWithTimeouts : public Callback_ISession_createSessionWithTimeouts_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::model::SessionPtr&);

    CallbackNC_ISession_createSessionWithTimeouts(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ISessionPrx __proxy = ::omero::api::ISessionPrx::uncheckedCast(__result->getProxy());
        ::omero::model::SessionPtr __ret;
        try
        {
            __ret = __proxy->end_createSessionWithTimeouts(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_ISession_createSessionWithTimeoutsPtr
newCallback_ISession_createSessionWithTimeouts(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::SessionPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ISession_createSessionWithTimeouts<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ISession_createSessionWithTimeoutsPtr
newCallback_ISession_createSessionWithTimeouts(T* instance, void (T::*cb)(const ::omero::model::SessionPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ISession_createSessionWithTimeouts<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_ISession_createSessionWithTimeouts : public Callback_ISession_createSessionWithTimeouts_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::model::SessionPtr&, const CT&);

    Callback_ISession_createSessionWithTimeouts(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ISessionPrx __proxy = ::omero::api::ISessionPrx::uncheckedCast(__result->getProxy());
        ::omero::model::SessionPtr __ret;
        try
        {
            __ret = __proxy->end_createSessionWithTimeouts(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ISession_createSessionWithTimeoutsPtr
newCallback_ISession_createSessionWithTimeouts(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::SessionPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ISession_createSessionWithTimeouts<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ISession_createSessionWithTimeoutsPtr
newCallback_ISession_createSessionWithTimeouts(T* instance, void (T::*cb)(const ::omero::model::SessionPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ISession_createSessionWithTimeouts<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_ISession_getSession : public Callback_ISession_getSession_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::model::SessionPtr&);

    CallbackNC_ISession_getSession(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ISessionPrx __proxy = ::omero::api::ISessionPrx::uncheckedCast(__result->getProxy());
        ::omero::model::SessionPtr __ret;
        try
        {
            __ret = __proxy->end_getSession(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_ISession_getSessionPtr
newCallback_ISession_getSession(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::SessionPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ISession_getSession<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ISession_getSessionPtr
newCallback_ISession_getSession(T* instance, void (T::*cb)(const ::omero::model::SessionPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ISession_getSession<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_ISession_getSession : public Callback_ISession_getSession_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::model::SessionPtr&, const CT&);

    Callback_ISession_getSession(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ISessionPrx __proxy = ::omero::api::ISessionPrx::uncheckedCast(__result->getProxy());
        ::omero::model::SessionPtr __ret;
        try
        {
            __ret = __proxy->end_getSession(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ISession_getSessionPtr
newCallback_ISession_getSession(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::SessionPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ISession_getSession<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ISession_getSessionPtr
newCallback_ISession_getSession(T* instance, void (T::*cb)(const ::omero::model::SessionPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ISession_getSession<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_ISession_getReferenceCount : public Callback_ISession_getReferenceCount_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int);

    CallbackNC_ISession_getReferenceCount(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ISessionPrx __proxy = ::omero::api::ISessionPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_getReferenceCount(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_ISession_getReferenceCountPtr
newCallback_ISession_getReferenceCount(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ISession_getReferenceCount<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ISession_getReferenceCountPtr
newCallback_ISession_getReferenceCount(T* instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ISession_getReferenceCount<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_ISession_getReferenceCount : public Callback_ISession_getReferenceCount_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const CT&);

    Callback_ISession_getReferenceCount(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ISessionPrx __proxy = ::omero::api::ISessionPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_getReferenceCount(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ISession_getReferenceCountPtr
newCallback_ISession_getReferenceCount(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ISession_getReferenceCount<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ISession_getReferenceCountPtr
newCallback_ISession_getReferenceCount(T* instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ISession_getReferenceCount<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_ISession_closeSession : public Callback_ISession_closeSession_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int);

    CallbackNC_ISession_closeSession(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ISessionPrx __proxy = ::omero::api::ISessionPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_closeSession(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_ISession_closeSessionPtr
newCallback_ISession_closeSession(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ISession_closeSession<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ISession_closeSessionPtr
newCallback_ISession_closeSession(T* instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ISession_closeSession<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_ISession_closeSession : public Callback_ISession_closeSession_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const CT&);

    Callback_ISession_closeSession(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ISessionPrx __proxy = ::omero::api::ISessionPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_closeSession(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ISession_closeSessionPtr
newCallback_ISession_closeSession(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ISession_closeSession<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ISession_closeSessionPtr
newCallback_ISession_closeSession(T* instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ISession_closeSession<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_ISession_getMyOpenSessions : public Callback_ISession_getMyOpenSessions_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::api::SessionList&);

    CallbackNC_ISession_getMyOpenSessions(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ISessionPrx __proxy = ::omero::api::ISessionPrx::uncheckedCast(__result->getProxy());
        ::omero::api::SessionList __ret;
        try
        {
            __ret = __proxy->end_getMyOpenSessions(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_ISession_getMyOpenSessionsPtr
newCallback_ISession_getMyOpenSessions(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::SessionList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ISession_getMyOpenSessions<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ISession_getMyOpenSessionsPtr
newCallback_ISession_getMyOpenSessions(T* instance, void (T::*cb)(const ::omero::api::SessionList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ISession_getMyOpenSessions<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_ISession_getMyOpenSessions : public Callback_ISession_getMyOpenSessions_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::api::SessionList&, const CT&);

    Callback_ISession_getMyOpenSessions(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ISessionPrx __proxy = ::omero::api::ISessionPrx::uncheckedCast(__result->getProxy());
        ::omero::api::SessionList __ret;
        try
        {
            __ret = __proxy->end_getMyOpenSessions(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ISession_getMyOpenSessionsPtr
newCallback_ISession_getMyOpenSessions(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::SessionList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ISession_getMyOpenSessions<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ISession_getMyOpenSessionsPtr
newCallback_ISession_getMyOpenSessions(T* instance, void (T::*cb)(const ::omero::api::SessionList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ISession_getMyOpenSessions<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_ISession_getMyOpenAgentSessions : public Callback_ISession_getMyOpenAgentSessions_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::api::SessionList&);

    CallbackNC_ISession_getMyOpenAgentSessions(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ISessionPrx __proxy = ::omero::api::ISessionPrx::uncheckedCast(__result->getProxy());
        ::omero::api::SessionList __ret;
        try
        {
            __ret = __proxy->end_getMyOpenAgentSessions(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_ISession_getMyOpenAgentSessionsPtr
newCallback_ISession_getMyOpenAgentSessions(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::SessionList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ISession_getMyOpenAgentSessions<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ISession_getMyOpenAgentSessionsPtr
newCallback_ISession_getMyOpenAgentSessions(T* instance, void (T::*cb)(const ::omero::api::SessionList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ISession_getMyOpenAgentSessions<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_ISession_getMyOpenAgentSessions : public Callback_ISession_getMyOpenAgentSessions_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::api::SessionList&, const CT&);

    Callback_ISession_getMyOpenAgentSessions(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ISessionPrx __proxy = ::omero::api::ISessionPrx::uncheckedCast(__result->getProxy());
        ::omero::api::SessionList __ret;
        try
        {
            __ret = __proxy->end_getMyOpenAgentSessions(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ISession_getMyOpenAgentSessionsPtr
newCallback_ISession_getMyOpenAgentSessions(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::SessionList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ISession_getMyOpenAgentSessions<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ISession_getMyOpenAgentSessionsPtr
newCallback_ISession_getMyOpenAgentSessions(T* instance, void (T::*cb)(const ::omero::api::SessionList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ISession_getMyOpenAgentSessions<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_ISession_getMyOpenClientSessions : public Callback_ISession_getMyOpenClientSessions_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::api::SessionList&);

    CallbackNC_ISession_getMyOpenClientSessions(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ISessionPrx __proxy = ::omero::api::ISessionPrx::uncheckedCast(__result->getProxy());
        ::omero::api::SessionList __ret;
        try
        {
            __ret = __proxy->end_getMyOpenClientSessions(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_ISession_getMyOpenClientSessionsPtr
newCallback_ISession_getMyOpenClientSessions(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::SessionList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ISession_getMyOpenClientSessions<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ISession_getMyOpenClientSessionsPtr
newCallback_ISession_getMyOpenClientSessions(T* instance, void (T::*cb)(const ::omero::api::SessionList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ISession_getMyOpenClientSessions<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_ISession_getMyOpenClientSessions : public Callback_ISession_getMyOpenClientSessions_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::api::SessionList&, const CT&);

    Callback_ISession_getMyOpenClientSessions(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ISessionPrx __proxy = ::omero::api::ISessionPrx::uncheckedCast(__result->getProxy());
        ::omero::api::SessionList __ret;
        try
        {
            __ret = __proxy->end_getMyOpenClientSessions(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ISession_getMyOpenClientSessionsPtr
newCallback_ISession_getMyOpenClientSessions(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::SessionList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ISession_getMyOpenClientSessions<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ISession_getMyOpenClientSessionsPtr
newCallback_ISession_getMyOpenClientSessions(T* instance, void (T::*cb)(const ::omero::api::SessionList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ISession_getMyOpenClientSessions<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_ISession_getInput : public Callback_ISession_getInput_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::RTypePtr&);

    CallbackNC_ISession_getInput(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ISessionPrx __proxy = ::omero::api::ISessionPrx::uncheckedCast(__result->getProxy());
        ::omero::RTypePtr __ret;
        try
        {
            __ret = __proxy->end_getInput(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_ISession_getInputPtr
newCallback_ISession_getInput(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RTypePtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ISession_getInput<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ISession_getInputPtr
newCallback_ISession_getInput(T* instance, void (T::*cb)(const ::omero::RTypePtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ISession_getInput<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_ISession_getInput : public Callback_ISession_getInput_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::RTypePtr&, const CT&);

    Callback_ISession_getInput(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ISessionPrx __proxy = ::omero::api::ISessionPrx::uncheckedCast(__result->getProxy());
        ::omero::RTypePtr __ret;
        try
        {
            __ret = __proxy->end_getInput(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ISession_getInputPtr
newCallback_ISession_getInput(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RTypePtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ISession_getInput<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ISession_getInputPtr
newCallback_ISession_getInput(T* instance, void (T::*cb)(const ::omero::RTypePtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ISession_getInput<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_ISession_getOutput : public Callback_ISession_getOutput_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::RTypePtr&);

    CallbackNC_ISession_getOutput(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ISessionPrx __proxy = ::omero::api::ISessionPrx::uncheckedCast(__result->getProxy());
        ::omero::RTypePtr __ret;
        try
        {
            __ret = __proxy->end_getOutput(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_ISession_getOutputPtr
newCallback_ISession_getOutput(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RTypePtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ISession_getOutput<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ISession_getOutputPtr
newCallback_ISession_getOutput(T* instance, void (T::*cb)(const ::omero::RTypePtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ISession_getOutput<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_ISession_getOutput : public Callback_ISession_getOutput_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::RTypePtr&, const CT&);

    Callback_ISession_getOutput(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ISessionPrx __proxy = ::omero::api::ISessionPrx::uncheckedCast(__result->getProxy());
        ::omero::RTypePtr __ret;
        try
        {
            __ret = __proxy->end_getOutput(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ISession_getOutputPtr
newCallback_ISession_getOutput(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RTypePtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ISession_getOutput<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ISession_getOutputPtr
newCallback_ISession_getOutput(T* instance, void (T::*cb)(const ::omero::RTypePtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ISession_getOutput<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_ISession_setInput : public Callback_ISession_setInput_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_ISession_setInput(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ISessionPrx __proxy = ::omero::api::ISessionPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_setInput(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
        }
    }

    Response response;
};

template<class T> Callback_ISession_setInputPtr
newCallback_ISession_setInput(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ISession_setInput<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ISession_setInputPtr
newCallback_ISession_setInput(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ISession_setInput<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_ISession_setInputPtr
newCallback_ISession_setInput(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ISession_setInput<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ISession_setInputPtr
newCallback_ISession_setInput(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ISession_setInput<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_ISession_setInput : public Callback_ISession_setInput_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_ISession_setInput(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ISessionPrx __proxy = ::omero::api::ISessionPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_setInput(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ISession_setInputPtr
newCallback_ISession_setInput(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ISession_setInput<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ISession_setInputPtr
newCallback_ISession_setInput(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ISession_setInput<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_ISession_setInputPtr
newCallback_ISession_setInput(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ISession_setInput<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ISession_setInputPtr
newCallback_ISession_setInput(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ISession_setInput<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_ISession_setOutput : public Callback_ISession_setOutput_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_ISession_setOutput(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ISessionPrx __proxy = ::omero::api::ISessionPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_setOutput(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
        }
    }

    Response response;
};

template<class T> Callback_ISession_setOutputPtr
newCallback_ISession_setOutput(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ISession_setOutput<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ISession_setOutputPtr
newCallback_ISession_setOutput(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ISession_setOutput<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_ISession_setOutputPtr
newCallback_ISession_setOutput(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ISession_setOutput<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ISession_setOutputPtr
newCallback_ISession_setOutput(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ISession_setOutput<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_ISession_setOutput : public Callback_ISession_setOutput_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_ISession_setOutput(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ISessionPrx __proxy = ::omero::api::ISessionPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_setOutput(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ISession_setOutputPtr
newCallback_ISession_setOutput(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ISession_setOutput<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ISession_setOutputPtr
newCallback_ISession_setOutput(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ISession_setOutput<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_ISession_setOutputPtr
newCallback_ISession_setOutput(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ISession_setOutput<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ISession_setOutputPtr
newCallback_ISession_setOutput(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ISession_setOutput<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_ISession_getInputKeys : public Callback_ISession_getInputKeys_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::api::StringSet&);

    CallbackNC_ISession_getInputKeys(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ISessionPrx __proxy = ::omero::api::ISessionPrx::uncheckedCast(__result->getProxy());
        ::omero::api::StringSet __ret;
        try
        {
            __ret = __proxy->end_getInputKeys(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_ISession_getInputKeysPtr
newCallback_ISession_getInputKeys(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::StringSet&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ISession_getInputKeys<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ISession_getInputKeysPtr
newCallback_ISession_getInputKeys(T* instance, void (T::*cb)(const ::omero::api::StringSet&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ISession_getInputKeys<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_ISession_getInputKeys : public Callback_ISession_getInputKeys_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::api::StringSet&, const CT&);

    Callback_ISession_getInputKeys(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ISessionPrx __proxy = ::omero::api::ISessionPrx::uncheckedCast(__result->getProxy());
        ::omero::api::StringSet __ret;
        try
        {
            __ret = __proxy->end_getInputKeys(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ISession_getInputKeysPtr
newCallback_ISession_getInputKeys(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::StringSet&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ISession_getInputKeys<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ISession_getInputKeysPtr
newCallback_ISession_getInputKeys(T* instance, void (T::*cb)(const ::omero::api::StringSet&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ISession_getInputKeys<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_ISession_getOutputKeys : public Callback_ISession_getOutputKeys_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::api::StringSet&);

    CallbackNC_ISession_getOutputKeys(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ISessionPrx __proxy = ::omero::api::ISessionPrx::uncheckedCast(__result->getProxy());
        ::omero::api::StringSet __ret;
        try
        {
            __ret = __proxy->end_getOutputKeys(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_ISession_getOutputKeysPtr
newCallback_ISession_getOutputKeys(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::StringSet&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ISession_getOutputKeys<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ISession_getOutputKeysPtr
newCallback_ISession_getOutputKeys(T* instance, void (T::*cb)(const ::omero::api::StringSet&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ISession_getOutputKeys<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_ISession_getOutputKeys : public Callback_ISession_getOutputKeys_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::api::StringSet&, const CT&);

    Callback_ISession_getOutputKeys(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ISessionPrx __proxy = ::omero::api::ISessionPrx::uncheckedCast(__result->getProxy());
        ::omero::api::StringSet __ret;
        try
        {
            __ret = __proxy->end_getOutputKeys(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ISession_getOutputKeysPtr
newCallback_ISession_getOutputKeys(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::StringSet&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ISession_getOutputKeys<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ISession_getOutputKeysPtr
newCallback_ISession_getOutputKeys(T* instance, void (T::*cb)(const ::omero::api::StringSet&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ISession_getOutputKeys<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_ISession_getInputs : public Callback_ISession_getInputs_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::RTypeDict&);

    CallbackNC_ISession_getInputs(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ISessionPrx __proxy = ::omero::api::ISessionPrx::uncheckedCast(__result->getProxy());
        ::omero::RTypeDict __ret;
        try
        {
            __ret = __proxy->end_getInputs(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_ISession_getInputsPtr
newCallback_ISession_getInputs(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RTypeDict&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ISession_getInputs<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ISession_getInputsPtr
newCallback_ISession_getInputs(T* instance, void (T::*cb)(const ::omero::RTypeDict&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ISession_getInputs<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_ISession_getInputs : public Callback_ISession_getInputs_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::RTypeDict&, const CT&);

    Callback_ISession_getInputs(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ISessionPrx __proxy = ::omero::api::ISessionPrx::uncheckedCast(__result->getProxy());
        ::omero::RTypeDict __ret;
        try
        {
            __ret = __proxy->end_getInputs(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ISession_getInputsPtr
newCallback_ISession_getInputs(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RTypeDict&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ISession_getInputs<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ISession_getInputsPtr
newCallback_ISession_getInputs(T* instance, void (T::*cb)(const ::omero::RTypeDict&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ISession_getInputs<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_ISession_getOutputs : public Callback_ISession_getOutputs_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::RTypeDict&);

    CallbackNC_ISession_getOutputs(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ISessionPrx __proxy = ::omero::api::ISessionPrx::uncheckedCast(__result->getProxy());
        ::omero::RTypeDict __ret;
        try
        {
            __ret = __proxy->end_getOutputs(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_ISession_getOutputsPtr
newCallback_ISession_getOutputs(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RTypeDict&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ISession_getOutputs<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ISession_getOutputsPtr
newCallback_ISession_getOutputs(T* instance, void (T::*cb)(const ::omero::RTypeDict&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ISession_getOutputs<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_ISession_getOutputs : public Callback_ISession_getOutputs_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::RTypeDict&, const CT&);

    Callback_ISession_getOutputs(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::ISessionPrx __proxy = ::omero::api::ISessionPrx::uncheckedCast(__result->getProxy());
        ::omero::RTypeDict __ret;
        try
        {
            __ret = __proxy->end_getOutputs(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ISession_getOutputsPtr
newCallback_ISession_getOutputs(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::RTypeDict&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ISession_getOutputs<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ISession_getOutputsPtr
newCallback_ISession_getOutputs(T* instance, void (T::*cb)(const ::omero::RTypeDict&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ISession_getOutputs<T, CT>(instance, cb, excb, sentcb);
}

}

}

#endif
